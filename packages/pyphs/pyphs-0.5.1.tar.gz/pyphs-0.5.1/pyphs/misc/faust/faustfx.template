// This Faust code has been automatically generated by PyPHS
// https://pyphs.github.io/pyphs/
// It is associated with the PyPHS core "${label}"

// Inputs: $in
// Outputs: $out
// Ctrl parameters: $pars

// ----------------------------------------------------------
// Stereo input to stereo output
// Constant inputs are defined here
//

process = (_*gainIn, _*gainIn) :> ${inputs} : recursion <: (_*gainOut, _*gainOut);

// ----------------------------------------------------------
// Imports

import("stdfaust.lib");

// ----------------------------------------------------------
// Parameters

// Constant Inputs
${constInputs}

// Constant Parameters
${constPars}

// Sample Rate

${fs} = ma.SR;

// ----------------------------------------------------------
// Sliders for I/O gains

gainInExp = hslider("Gain IN", 0., -1, 1., 0.001);
gainIn = pow(10, gainInExp);

gainOutExp = hslider("Gain OUT", 0., -1, 1., 0.001);
gainOut = pow(10, gainOutExp);

// ----------------------------------------------------------
// Sliders for ctrl parameters
${sliders}

// ----------------------------------------------------------
// Pass processes
${pass}

// ----------------------------------------------------------
// Terminate processes
${stop}

// ----------------------------------------------------------
// Pass and terminate processes for arguments

args = x, w, x, o, u;
argsT = xT, wT, xT, oT, uT;

// Pass and terminate processes for that part of
// arguments that is constant over an iteration

c = x, o, u;
cT = xT, oT, uT;

// ----------------------------------------------------------
// Shortcuts

v2vl = v :(vl, vnlT);
v2vnl = v :(vlT, vnl);
vlvnl2v = (vl, vnl) <: ((xl, wlT, vnlT), (vlT, xnl, wnlT), (xlT, wl, vnlT), (vlT, xnlT, wnl));

// ----------------------------------------------------------
// State update
// Takes args, updates x <- x + dx, and return args

udx = args <: (x, w, cT), ((x, wT, x, oT, uT) :> x), (xT, wT, xT, o, uT);

// ----------------------------------------------------------
// Linear update udvl(dx, w, x, u, p, o)
// Takes args, returns vl
${udvl}

// ----------------------------------------------------------
// Nonlinear update udvl(dx, w, x, u, p, o)
// Takes args, returns vnl
${udvnl}

// ----------------------------------------------------------
// Outputs
// Takes args, returns y
${y}

// ----------------------------------------------------------
// Linear iteration:
// Takes args, update linears vl, returns args

iterationL = args <: (udvl, (vlT, vnl, c)) : (vlvnl2v, c) : args;

// ----------------------------------------------------------
// Nonlinear iteration:
// Takes args, update nonlinears vnl, returns args

iterationNL = args <: ((vl, vnlT, cT), udvnl, (vT, c)) : (vlvnl2v, c) : args;

// ----------------------------------------------------------
// Main Iteration:

iteration = ${udNL} ${udL} ${udXY};

// ----------------------------------------------------------
// Recursion to keep memory of args

recursion = ${recursion};
