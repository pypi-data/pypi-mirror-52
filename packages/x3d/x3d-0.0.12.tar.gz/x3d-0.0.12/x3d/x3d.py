###############################################

# X3D Package for Python x3d.py

# generator:  X3duomToX3dPythonPackage.xslt
# X3DUOM:     X3dUnifiedObjectModel-4.0.xml
# Python X3D: https://www.web3d.org/x3d/stylesheets/python/python.html
"""
The x3d.py Python X3D Package supports programmers with Python interfaces and objects for standards-based X3D programming, all as open source.

This work is part of the X3D Python Scene Access Interface Library (X3DPSAIL).
"""

_DEBUG = True       # options True False

###############################################

# Utility Functions

def metaDiagnostics(self, headElement=None):
    """
    Utility function to return any meta info, hint, warning, error, TODO values in this model
    """
    if  headElement is None:
        headElement = self
    if  isinstance(headElement, X3D):
        headElement = headElement.head
    # print ('type(headElement)=' + str(type(headElement))) # diagnostic
    if  isinstance(headElement, head):
        result = "meta "
        for each in headElement.children:
            if isinstance(each, meta) and each.name in ('info', 'hint', 'warning', 'error', 'TODO'):
                result += each.name.strip() + ': ' + each.content.strip()
                if  result.endswith('.') or result.endswith(','):
                    result += ' '
                else:
                    result += ', '
        if  result.strip() != "meta":
            return result.rstrip(', ').strip()
    return ''

###############################################

# Field Validation Functions

# Type-specific functions to check for valid values, throw exception if illegal value is found

def fixBoolean(value, default=None):
    """
    Utility function to convert boolean to corresponding Python value
    """
    # if _DEBUG: print('fixBoolean(value=' + str(value) + ', default=' + str(default) + ')')
    if  value is None:
        return default
    if isinstance(value, list) and len(value) == 1:
        # if _DEBUG: print('fixBoolean downcasting by resetting singleton list value=' + str(value) + ' as value=' + str(value[0]))
        value = value[0]
    elif isinstance(value, SFBool):
        return value.value # dereference
    elif isinstance(value, MFBool) and len(value) == 1:
        return value.value[0] # dereference
    if value in ('true', 'True'):
        return True
    if value in ('false', 'False'):
        return False
    if isinstance(value, bool):
        return value
    if isinstance(value, list):
        index = 0
        result = value
        for each in value:
#           print('each=' + str(each)) # debug
            if  each in ('true', 'True'):
                result[index] = True
            elif each in ('false', 'False'):
                result[index] = False
            while isinstance(each, list) and len(each) == 1:
                # if _DEBUG: print('fixBoolean downcasting by extracting singleton list value[' + str(index) + ']=' + str(each) + ' as each[0]=' + str(each[0]))
                result[index] = each[0]
            if not isinstance(result[index], bool):
                print(flush=True)
                raise TypeError('fixBoolean(value=' + str(value) + ') MFBool value[' + str(index) + ']=' + str(each) + ', result[' + str(index) + ']=' + result[index] + ' with type=' + str(type(value)) + ' is not a valid Python bool expression')
            index += 1
        # if _DEBUG: print('...fixBoolean result=' + str(result)) # if _DEBUG: 
        return result
    print(flush=True)
    raise TypeError('fixBoolean(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python bool')

def isPositive(value):
    """
    Utility function to confirm positive value(s) greater than or equal to zero
    """
    if isinstance(value, (list, tuple)):
        for each in value:
            if each <= 0:
                return False
        return True
    if isinstance(value, (int, float)):
        return value > 0

def assertPositive(fieldName, value):
    """
    Utility function to raise AssertionError if not isPositive(value)
    """
    # if _DEBUG: print('* debug: assertPositive(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isPositive(value), fieldName + '=' + str(value) + ' fails assertPositive requirements: value(s) greater than or equal to zero'

def isNonNegative(value):
    """
    Utility function to confirm nonnegative value(s) greater than or equal to zero
    """
    if isinstance(value, (list, tuple)):
        # if _DEBUG: print('isNonNegative: ', value);
        for each in value:
            if each < 0:
                return False
        return True
    if isinstance(value, (int, float)):
        return value >= 0

def assertNonNegative(fieldName, value):
    """
    Utility function to raise AssertionError if not isNonNegative(value)
    """
    # if _DEBUG: print('* debug: assertNonNegative(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isNonNegative(value), fieldName + '=' + str(value) + ' fails assertNonNegative requirements: value(s) greater than or equal to zero'

def isZeroToOne(value):
    """
    Utility function to confirm value(s) in range [0..1]
    """
    # if True or _DEBUG: print('* debug: isZeroToOne(' + str(value) + ')');
    if isinstance(value, (list, tuple)):
        for each in value:
            if isinstance(each, list) or isinstance(each, tuple):
                for another in each:
                    if another < 0 or another > 1:
                        return False
            elif each < 0 or each > 1:
                return False
        return True
    if isinstance(value, (int, float)):
        return value >= 0 and value <= 1

def assertZeroToOne(fieldName, value):
    """
    Utility function to raise AssertionError if not isZeroToOne(value)
    """
    # if _DEBUG: print('* debug: assertZeroToOne(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isZeroToOne(value), fieldName + '=' + str(value) + ' fails assertZeroToOne requirements: value(s) in range [0..1]'

def isLessThanEquals(value, maximum):
    """
    Utility function to confirm value(s) less than or equal to maximum
    """
    # if True or _DEBUG: print('* debug: isLessThanEquals(' + str(value) + ')');
    if isinstance(value, (list, tuple)):
        for each in value:
            if each > maximum:
                return False
        return True
    if isinstance(value, (int, float)):
        return value <= maximum

def assertLessThanEquals(fieldName, value, maximum):
    """
    Utility function to raise AssertionError if not isLessThanEquals(value)
    """
    # if _DEBUG: print('* debug: assertLessThanEquals(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isLessThanEquals(value, maximum), fieldName + '=' + str(value) + ' fails assertLessThanEquals maximum=' + str(maximum)

def isLessThan(value, maximum):
    """
    Utility function to confirm value(s) less than maximum
    """
    # if True or _DEBUG: print('* debug: isLessThan(' + str(value) + ')');
    if isinstance(value, (list, tuple)):
        for each in value:
            if each >= maximum:
                return False
        return True
    if isinstance(value, (int, float)):
        return value < maximum

def assertLessThan(fieldName, value, maximum):
    """
    Utility function to raise AssertionError if not isLessThan(value)
    """
    # if _DEBUG: print('* debug: assertLessThan(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isLessThan(value, maximum), fieldName + '=' + str(value) + ' fails assertLessThan maximum=' + str(maximum)

######
def isGreaterThanEquals(value, minimum):
    """
    Utility function to confirm value(s) less than or equal to minimum
    """
    # if True or _DEBUG: print('* debug: isGreaterThanEquals(' + str(value) + ')');
    if isinstance(value, (list, tuple)):
        for each in value:
            if each < minimum:
                return False
        return True
    if isinstance(value, (int, float)):
        return value >= minimum

def assertGreaterThanEquals(fieldName, value, minimum):
    """
    Utility function to raise AssertionError if not isGreaterThanEquals(value)
    """
    # if _DEBUG: print('* debug: assertGreaterThanEquals(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isGreaterThanEquals(value, minimum), fieldName + '=' + str(value) + ' fails assertGreaterThanEquals minimum=' + str(minimum)

def isGreaterThan(value, minimum):
    """
    Utility function to confirm value(s) less than minimum
    """
    # if True or _DEBUG: print('* debug: isGreaterThan(' + str(value) + ')');
    if isinstance(value, (list, tuple)):
        for each in value:
            if each <= minimum:
                return False
        return True
    if isinstance(value, (int, float)):
        return value > minimum

def assertGreaterThan(fieldName, value, minimum):
    """
    Utility function to raise AssertionError if not isGreaterThan(value)
    """
    # if _DEBUG: print('* debug: assertGreaterThan(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isGreaterThan(value, minimum), fieldName + '=' + str(value) + ' fails assertGreaterThan minimum=' + str(minimum)

def isBoundingBox(value):
    """
    Utility function to confirm legal X3D bounding box value of (-1 -1 -1) or nonnegative triple
    """
    if value is None:
        return None
    # if True or _DEBUG: print('* debug: isBoundingBox(' + str(value) + ')', 'isinstance(value, tuple)=' + str(isinstance(value, tuple)), 'len(value)=' + str(len(value)));
    if isinstance(value, (list, tuple)):
        if len(value) != 3:
            return False
        if value[0] == -1 and value[1] == -1 and value[2] == -1:
            return True
        return isNonNegative(value)

def assertBoundingBox(fieldName, value):
    """
    Utility function to raise AssertionError if not isBoundingBox(value)
    """
    # if True or _DEBUG: print('* debug: assertBoundingBox(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isBoundingBox(value), fieldName + '=' + str(value) + ' fails assertBoundingBox requirements: must be (-1, -1, -1) or non-negative 3-tuple'

def isValidSFBool(value):
    """
    Utility function to determine type validity of a SFBool value
    """
    if isinstance(value, _X3DField):
        # print('SFBool type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFBool)=' + str(isinstance(value, SFBool)))
        if not isinstance(value, SFBool) and not isinstance(value, MFBool):
            return False # type mismatch!
    if isinstance(value, SFBool):
        value = value.value # dereference value from base type
    if isinstance(value, MFBool) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, bool):
        return False
    return True

def assertValidSFBool(value):
    """
    Utility function to assert type validity of a SFBool value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFBool) and not isinstance(value, MFBool):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFBool')
    if isinstance(value, SFBool):
        value = value.value # dereference value from this base type
    if isinstance(value, MFBool) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, bool):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid bool value (True or False) for SFBool')
    if not isValidSFBool(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python bool value (True or False) for SFBool')
    return True

def isValidMFBool(value):
    """
    Utility function to determine type validity of a MFBool value
    """
    if isinstance(value, _X3DField):
        # print('MFBool type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFBool)=' + str(isinstance(value, MFBool)))
        if not isinstance(value, SFBool) and not isinstance(value, MFBool):
            return False # type mismatch!
    if isinstance(value, MFBool):
        value = value.value # dereference value from base type
    if isinstance(value, SFBool):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFBool):
            each = each.value # dereference
        if not isinstance(each, bool):
            return False
    return True

def assertValidMFBool(value):
    """
    Utility function to assert type validity of a MFBool value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFBool) and not isinstance(value, MFBool):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFBool')
    if isinstance(value, MFBool):
        value = value.value # dereference value from this base type
    if isinstance(value, SFBool):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFBool')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFBool):
            each = each.value # dereference
        if not isinstance(each, bool):
            print(flush=True)
            raise AssertionError('MFBool list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid bool')
    if not isValidMFBool(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFBool')
    return True

def isValidSFColor(value):
    """
    Utility function to determine type validity of a SFColor value
    """
    if isinstance(value, _X3DField):
        # print('SFColor type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFColor)=' + str(isinstance(value, SFColor)))
        if not isinstance(value, SFColor) and not isinstance(value, MFColor):
            return False # type mismatch!
    if isinstance(value, SFColor):
        value = value.value # dereference value from base type
    if isinstance(value, MFColor) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFColor):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
        if (each < 0) or (each > 1):
            return False
    if tupleCount != 3:
        return False
    if not isZeroToOne(value):
        return False
    return True

def assertValidSFColor(value):
    """
    Utility function to assert type validity of a SFColor value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFColor) and not isinstance(value, MFColor):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFColor')
    if isinstance(value, SFColor):
        value = value.value # dereference value from this base type
    if isinstance(value, MFColor) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFColor')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFColor):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('SFColor list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
        if (each < 0) or (each > 1):
            print(flush=True)
            raise AssertionError('SFColor' + str(value) + ' has value ' + str(each) + ' with type=' + str(type(value)) + ' is  out of range [0..1] and is not a valid SFColor')
    if tupleCount != 3:
        print(flush=True)
        raise AssertionError('SFColor ' + str(value) + ' has ' + str(tupleCount) + ' elements instead of 3')
    assertZeroToOne('SFColor', value)
    if not isValidSFColor(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFColor')
    return True

def isValidMFColor(value):
    """
    Utility function to determine type validity of a MFColor value
    """
    if isinstance(value, _X3DField):
        # print('MFColor type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFColor)=' + str(isinstance(value, MFColor)))
        if not isinstance(value, SFColor) and not isinstance(value, MFColor):
            return False # type mismatch!
    if isinstance(value, MFColor):
        value = value.value # dereference value from base type
    if isinstance(value, SFColor):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            return False
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
            if (element < 0) or (element > 1):
                return False
    if not isZeroToOne(value):
        return False
    return True

def assertValidMFColor(value):
    """
    Utility function to assert type validity of a MFColor value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFColor) and not isinstance(value, MFColor):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFColor')
    if isinstance(value, MFColor):
        value = value.value # dereference value from this base type
    if isinstance(value, SFColor):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFColor')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            print(flush=True)
            raise AssertionError('MFColor element #' + str(_index) + ' with value ' + str(each) + ' is not a valid tuple')
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                print(flush=True)
                raise AssertionError('MFColor element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ' that is not a valid float')
            if (element < 0) or (element > 1):
                print(flush=True)
                raise AssertionError('MFColor' + str(value) + ' has value ' + str(element) + ' with type=' + str(type(value)) + ' out of range [0..1] and is not a valid MFColor')
    assertZeroToOne('MFColor', value)
    if not isValidMFColor(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFColor')
    return True

def isValidSFColorRGBA(value):
    """
    Utility function to determine type validity of a SFColorRGBA value
    """
    if isinstance(value, _X3DField):
        # print('SFColorRGBA type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFColorRGBA)=' + str(isinstance(value, SFColorRGBA)))
        if not isinstance(value, SFColorRGBA) and not isinstance(value, MFColorRGBA):
            return False # type mismatch!
    if isinstance(value, SFColorRGBA):
        value = value.value # dereference value from base type
    if isinstance(value, MFColorRGBA) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFColorRGBA):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
        if (each < 0) or (each > 1):
            return False
    if tupleCount != 4:
        return False
    if not isZeroToOne(value):
        return False
    return True

def assertValidSFColorRGBA(value):
    """
    Utility function to assert type validity of a SFColorRGBA value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFColorRGBA) and not isinstance(value, MFColorRGBA):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFColorRGBA')
    if isinstance(value, SFColorRGBA):
        value = value.value # dereference value from this base type
    if isinstance(value, MFColorRGBA) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFColorRGBA')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFColorRGBA):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('SFColorRGBA list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
        if (each < 0) or (each > 1):
            print(flush=True)
            raise AssertionError('SFColorRGBA' + str(value) + ' has value ' + str(each) + ' with type=' + str(type(value)) + ' is  out of range [0..1] and is not a valid SFColorRGBA')
    if tupleCount != 4:
        print(flush=True)
        raise AssertionError('SFColorRGBA ' + str(value) + ' has ' + str(tupleCount) + ' elements instead of 4')
    assertZeroToOne('SFColorRGBA', value)
    if not isValidSFColorRGBA(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFColorRGBA')
    return True

def isValidMFColorRGBA(value):
    """
    Utility function to determine type validity of a MFColorRGBA value
    """
    if isinstance(value, _X3DField):
        # print('MFColorRGBA type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFColorRGBA)=' + str(isinstance(value, MFColorRGBA)))
        if not isinstance(value, SFColorRGBA) and not isinstance(value, MFColorRGBA):
            return False # type mismatch!
    if isinstance(value, MFColorRGBA):
        value = value.value # dereference value from base type
    if isinstance(value, SFColorRGBA):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            return False
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
            if (element < 0) or (element > 1):
                return False
    if not isZeroToOne(value):
        return False
    return True

def assertValidMFColorRGBA(value):
    """
    Utility function to assert type validity of a MFColorRGBA value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFColorRGBA) and not isinstance(value, MFColorRGBA):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFColorRGBA')
    if isinstance(value, MFColorRGBA):
        value = value.value # dereference value from this base type
    if isinstance(value, SFColorRGBA):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFColorRGBA')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            print(flush=True)
            raise AssertionError('MFColorRGBA element #' + str(_index) + ' with value ' + str(each) + ' is not a valid tuple')
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                print(flush=True)
                raise AssertionError('MFColorRGBA element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ' that is not a valid float')
            if (element < 0) or (element > 1):
                print(flush=True)
                raise AssertionError('MFColorRGBA' + str(value) + ' has value ' + str(element) + ' with type=' + str(type(value)) + ' out of range [0..1] and is not a valid MFColorRGBA')
    assertZeroToOne('MFColorRGBA', value)
    if not isValidMFColorRGBA(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFColorRGBA')
    return True

def isValidSFDouble(value):
    """
    Utility function to determine type validity of a SFDouble value
    """
    if isinstance(value, _X3DField):
        # print('SFDouble type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFDouble)=' + str(isinstance(value, SFDouble)))
        if not isinstance(value, SFDouble) and not isinstance(value, MFDouble):
            return False # type mismatch!
    if isinstance(value, SFDouble):
        value = value.value # dereference value from base type
    if isinstance(value, MFDouble) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, float) and not isinstance(value, int):
        return False
    return True

def assertValidSFDouble(value):
    """
    Utility function to assert type validity of a SFDouble value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFDouble) and not isinstance(value, MFDouble):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFDouble')
    if isinstance(value, SFDouble):
        value = value.value # dereference value from this base type
    if isinstance(value, MFDouble) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, float) and not isinstance(value, int):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid float value for SFDouble')
    if not isValidSFDouble(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python float value for SFDouble')
    return True

def isValidMFDouble(value):
    """
    Utility function to determine type validity of a MFDouble value
    """
    if isinstance(value, _X3DField):
        # print('MFDouble type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFDouble)=' + str(isinstance(value, MFDouble)))
        if not isinstance(value, SFDouble) and not isinstance(value, MFDouble):
            return False # type mismatch!
    if isinstance(value, MFDouble):
        value = value.value # dereference value from base type
    if isinstance(value, SFDouble):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFDouble):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    return True

def assertValidMFDouble(value):
    """
    Utility function to assert type validity of a MFDouble value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFDouble) and not isinstance(value, MFDouble):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFDouble')
    if isinstance(value, MFDouble):
        value = value.value # dereference value from this base type
    if isinstance(value, SFDouble):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFDouble')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFDouble):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('MFDouble list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if not isValidMFDouble(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFDouble')
    return True

def isValidSFFloat(value):
    """
    Utility function to determine type validity of a SFFloat value
    """
    if isinstance(value, _X3DField):
        # print('SFFloat type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFFloat)=' + str(isinstance(value, SFFloat)))
        if not isinstance(value, SFFloat) and not isinstance(value, MFFloat):
            return False # type mismatch!
    if isinstance(value, SFFloat):
        value = value.value # dereference value from base type
    if isinstance(value, MFFloat) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, float) and not isinstance(value, int):
        return False
    return True

def assertValidSFFloat(value):
    """
    Utility function to assert type validity of a SFFloat value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFFloat) and not isinstance(value, MFFloat):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFFloat')
    if isinstance(value, SFFloat):
        value = value.value # dereference value from this base type
    if isinstance(value, MFFloat) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, float) and not isinstance(value, int):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid float value for SFFloat')
    if not isValidSFFloat(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python float value for SFFloat')
    return True

def isValidMFFloat(value):
    """
    Utility function to determine type validity of a MFFloat value
    """
    if isinstance(value, _X3DField):
        # print('MFFloat type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFFloat)=' + str(isinstance(value, MFFloat)))
        if not isinstance(value, SFFloat) and not isinstance(value, MFFloat):
            return False # type mismatch!
    if isinstance(value, MFFloat):
        value = value.value # dereference value from base type
    if isinstance(value, SFFloat):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFFloat):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    return True

def assertValidMFFloat(value):
    """
    Utility function to assert type validity of a MFFloat value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFFloat) and not isinstance(value, MFFloat):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFFloat')
    if isinstance(value, MFFloat):
        value = value.value # dereference value from this base type
    if isinstance(value, SFFloat):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFFloat')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFFloat):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('MFFloat list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if not isValidMFFloat(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFFloat')
    return True

def isValidSFImage(value):
    """
    Utility function to determine type validity of a SFImage value
    """
    if isinstance(value, _X3DField):
        # print('SFImage type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFImage)=' + str(isinstance(value, SFImage)))
        if not isinstance(value, SFImage) and not isinstance(value, MFImage):
            return False # type mismatch!
    if isinstance(value, SFImage):
        value = value.value # dereference value from base type
    if isinstance(value, MFImage) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, float) and not isinstance(value, int):
        return False
    return True

def assertValidSFImage(value):
    """
    Utility function to assert type validity of a SFImage value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFImage) and not isinstance(value, MFImage):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFImage')
    if isinstance(value, SFImage):
        value = value.value # dereference value from this base type
    if isinstance(value, MFImage) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, float) and not isinstance(value, int):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid float value for SFImage')
    if not isValidSFImage(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python float value for SFImage')
    return True

def isValidMFImage(value):
    """
    Utility function to determine type validity of a MFImage value
    """
    if isinstance(value, _X3DField):
        # print('MFImage type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFImage)=' + str(isinstance(value, MFImage)))
        if not isinstance(value, SFImage) and not isinstance(value, MFImage):
            return False # type mismatch!
    if isinstance(value, MFImage):
        value = value.value # dereference value from base type
    if isinstance(value, SFImage):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFImage):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    return True

def assertValidMFImage(value):
    """
    Utility function to assert type validity of a MFImage value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFImage) and not isinstance(value, MFImage):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFImage')
    if isinstance(value, MFImage):
        value = value.value # dereference value from this base type
    if isinstance(value, SFImage):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFImage')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFImage):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('MFImage list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if not isValidMFImage(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFImage')
    return True

def isValidSFInt32(value):
    """
    Utility function to determine type validity of a SFInt32 value
    """
    if isinstance(value, _X3DField):
        # print('SFInt32 type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFInt32)=' + str(isinstance(value, SFInt32)))
        if not isinstance(value, SFInt32) and not isinstance(value, MFInt32):
            return False # type mismatch!
    if isinstance(value, SFInt32):
        value = value.value # dereference value from base type
    if isinstance(value, MFInt32) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, int):
        return False
    return True

def assertValidSFInt32(value):
    """
    Utility function to assert type validity of a SFInt32 value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFInt32) and not isinstance(value, MFInt32):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFInt32')
    if isinstance(value, SFInt32):
        value = value.value # dereference value from this base type
    if isinstance(value, MFInt32) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, int):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid int value for SFInt32')
    if not isValidSFInt32(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python int value for SFInt32')
    return True

def isValidMFInt32(value):
    """
    Utility function to determine type validity of a MFInt32 value
    """
    if isinstance(value, _X3DField):
        # print('MFInt32 type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFInt32)=' + str(isinstance(value, MFInt32)))
        if not isinstance(value, SFInt32) and not isinstance(value, MFInt32):
            return False # type mismatch!
    if isinstance(value, MFInt32):
        value = value.value # dereference value from base type
    if isinstance(value, SFInt32):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFInt32):
            each = each.value # dereference
        if not isinstance(each, int):
            return False
    return True

def assertValidMFInt32(value):
    """
    Utility function to assert type validity of a MFInt32 value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFInt32) and not isinstance(value, MFInt32):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFInt32')
    if isinstance(value, MFInt32):
        value = value.value # dereference value from this base type
    if isinstance(value, SFInt32):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFInt32')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFInt32):
            each = each.value # dereference
        if not isinstance(each, int):
            print(flush=True)
            raise AssertionError('MFInt32 list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid int')
    if not isValidMFInt32(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFInt32')
    return True

def isValidSFMatrix3d(value):
    """
    Utility function to determine type validity of a SFMatrix3d value
    """
    if isinstance(value, _X3DField):
        # print('SFMatrix3d type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFMatrix3d)=' + str(isinstance(value, SFMatrix3d)))
        if not isinstance(value, SFMatrix3d) and not isinstance(value, MFMatrix3d):
            return False # type mismatch!
    if isinstance(value, SFMatrix3d):
        value = value.value # dereference value from base type
    if isinstance(value, MFMatrix3d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix3d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 9:
        return False
    return True

def assertValidSFMatrix3d(value):
    """
    Utility function to assert type validity of a SFMatrix3d value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix3d) and not isinstance(value, MFMatrix3d):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFMatrix3d')
    if isinstance(value, SFMatrix3d):
        value = value.value # dereference value from this base type
    if isinstance(value, MFMatrix3d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFMatrix3d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix3d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('SFMatrix3d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 9:
        print(flush=True)
        raise AssertionError('SFMatrix3d ' + str(value) + ' has ' + str(tupleCount) + ' elements instead of 9')
    if not isValidSFMatrix3d(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFMatrix3d')
    return True

def isValidMFMatrix3d(value):
    """
    Utility function to determine type validity of a MFMatrix3d value
    """
    if isinstance(value, _X3DField):
        # print('MFMatrix3d type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFMatrix3d)=' + str(isinstance(value, MFMatrix3d)))
        if not isinstance(value, SFMatrix3d) and not isinstance(value, MFMatrix3d):
            return False # type mismatch!
    if isinstance(value, MFMatrix3d):
        value = value.value # dereference value from base type
    if isinstance(value, SFMatrix3d):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            return False
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFMatrix3d(value):
    """
    Utility function to assert type validity of a MFMatrix3d value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix3d) and not isinstance(value, MFMatrix3d):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFMatrix3d')
    if isinstance(value, MFMatrix3d):
        value = value.value # dereference value from this base type
    if isinstance(value, SFMatrix3d):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFMatrix3d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            print(flush=True)
            raise AssertionError('MFMatrix3d element #' + str(_index) + ' with value ' + str(each) + ' is not a valid tuple')
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                print(flush=True)
                raise AssertionError('MFMatrix3d element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ' that is not a valid float')
    if not isValidMFMatrix3d(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFMatrix3d')
    return True

def isValidSFMatrix3f(value):
    """
    Utility function to determine type validity of a SFMatrix3f value
    """
    if isinstance(value, _X3DField):
        # print('SFMatrix3f type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFMatrix3f)=' + str(isinstance(value, SFMatrix3f)))
        if not isinstance(value, SFMatrix3f) and not isinstance(value, MFMatrix3f):
            return False # type mismatch!
    if isinstance(value, SFMatrix3f):
        value = value.value # dereference value from base type
    if isinstance(value, MFMatrix3f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix3f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 9:
        return False
    return True

def assertValidSFMatrix3f(value):
    """
    Utility function to assert type validity of a SFMatrix3f value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix3f) and not isinstance(value, MFMatrix3f):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFMatrix3f')
    if isinstance(value, SFMatrix3f):
        value = value.value # dereference value from this base type
    if isinstance(value, MFMatrix3f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFMatrix3f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix3f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('SFMatrix3f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 9:
        print(flush=True)
        raise AssertionError('SFMatrix3f ' + str(value) + ' has ' + str(tupleCount) + ' elements instead of 9')
    if not isValidSFMatrix3f(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFMatrix3f')
    return True

def isValidMFMatrix3f(value):
    """
    Utility function to determine type validity of a MFMatrix3f value
    """
    if isinstance(value, _X3DField):
        # print('MFMatrix3f type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFMatrix3f)=' + str(isinstance(value, MFMatrix3f)))
        if not isinstance(value, SFMatrix3f) and not isinstance(value, MFMatrix3f):
            return False # type mismatch!
    if isinstance(value, MFMatrix3f):
        value = value.value # dereference value from base type
    if isinstance(value, SFMatrix3f):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            return False
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFMatrix3f(value):
    """
    Utility function to assert type validity of a MFMatrix3f value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix3f) and not isinstance(value, MFMatrix3f):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFMatrix3f')
    if isinstance(value, MFMatrix3f):
        value = value.value # dereference value from this base type
    if isinstance(value, SFMatrix3f):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFMatrix3f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            print(flush=True)
            raise AssertionError('MFMatrix3f element #' + str(_index) + ' with value ' + str(each) + ' is not a valid tuple')
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                print(flush=True)
                raise AssertionError('MFMatrix3f element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ' that is not a valid float')
    if not isValidMFMatrix3f(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFMatrix3f')
    return True

def isValidSFMatrix4d(value):
    """
    Utility function to determine type validity of a SFMatrix4d value
    """
    if isinstance(value, _X3DField):
        # print('SFMatrix4d type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFMatrix4d)=' + str(isinstance(value, SFMatrix4d)))
        if not isinstance(value, SFMatrix4d) and not isinstance(value, MFMatrix4d):
            return False # type mismatch!
    if isinstance(value, SFMatrix4d):
        value = value.value # dereference value from base type
    if isinstance(value, MFMatrix4d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix4d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 16:
        return False
    return True

def assertValidSFMatrix4d(value):
    """
    Utility function to assert type validity of a SFMatrix4d value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix4d) and not isinstance(value, MFMatrix4d):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFMatrix4d')
    if isinstance(value, SFMatrix4d):
        value = value.value # dereference value from this base type
    if isinstance(value, MFMatrix4d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFMatrix4d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix4d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('SFMatrix4d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 16:
        print(flush=True)
        raise AssertionError('SFMatrix4d ' + str(value) + ' has ' + str(tupleCount) + ' elements instead of 16')
    if not isValidSFMatrix4d(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFMatrix4d')
    return True

def isValidMFMatrix4d(value):
    """
    Utility function to determine type validity of a MFMatrix4d value
    """
    if isinstance(value, _X3DField):
        # print('MFMatrix4d type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFMatrix4d)=' + str(isinstance(value, MFMatrix4d)))
        if not isinstance(value, SFMatrix4d) and not isinstance(value, MFMatrix4d):
            return False # type mismatch!
    if isinstance(value, MFMatrix4d):
        value = value.value # dereference value from base type
    if isinstance(value, SFMatrix4d):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            return False
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFMatrix4d(value):
    """
    Utility function to assert type validity of a MFMatrix4d value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix4d) and not isinstance(value, MFMatrix4d):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFMatrix4d')
    if isinstance(value, MFMatrix4d):
        value = value.value # dereference value from this base type
    if isinstance(value, SFMatrix4d):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFMatrix4d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            print(flush=True)
            raise AssertionError('MFMatrix4d element #' + str(_index) + ' with value ' + str(each) + ' is not a valid tuple')
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                print(flush=True)
                raise AssertionError('MFMatrix4d element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ' that is not a valid float')
    if not isValidMFMatrix4d(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFMatrix4d')
    return True

def isValidSFMatrix4f(value):
    """
    Utility function to determine type validity of a SFMatrix4f value
    """
    if isinstance(value, _X3DField):
        # print('SFMatrix4f type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFMatrix4f)=' + str(isinstance(value, SFMatrix4f)))
        if not isinstance(value, SFMatrix4f) and not isinstance(value, MFMatrix4f):
            return False # type mismatch!
    if isinstance(value, SFMatrix4f):
        value = value.value # dereference value from base type
    if isinstance(value, MFMatrix4f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix4f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 16:
        return False
    return True

def assertValidSFMatrix4f(value):
    """
    Utility function to assert type validity of a SFMatrix4f value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix4f) and not isinstance(value, MFMatrix4f):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFMatrix4f')
    if isinstance(value, SFMatrix4f):
        value = value.value # dereference value from this base type
    if isinstance(value, MFMatrix4f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFMatrix4f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix4f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('SFMatrix4f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 16:
        print(flush=True)
        raise AssertionError('SFMatrix4f ' + str(value) + ' has ' + str(tupleCount) + ' elements instead of 16')
    if not isValidSFMatrix4f(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFMatrix4f')
    return True

def isValidMFMatrix4f(value):
    """
    Utility function to determine type validity of a MFMatrix4f value
    """
    if isinstance(value, _X3DField):
        # print('MFMatrix4f type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFMatrix4f)=' + str(isinstance(value, MFMatrix4f)))
        if not isinstance(value, SFMatrix4f) and not isinstance(value, MFMatrix4f):
            return False # type mismatch!
    if isinstance(value, MFMatrix4f):
        value = value.value # dereference value from base type
    if isinstance(value, SFMatrix4f):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            return False
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFMatrix4f(value):
    """
    Utility function to assert type validity of a MFMatrix4f value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix4f) and not isinstance(value, MFMatrix4f):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFMatrix4f')
    if isinstance(value, MFMatrix4f):
        value = value.value # dereference value from this base type
    if isinstance(value, SFMatrix4f):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFMatrix4f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            print(flush=True)
            raise AssertionError('MFMatrix4f element #' + str(_index) + ' with value ' + str(each) + ' is not a valid tuple')
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                print(flush=True)
                raise AssertionError('MFMatrix4f element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ' that is not a valid float')
    if not isValidMFMatrix4f(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFMatrix4f')
    return True

def isValidSFNode(value):
    """
    Utility function to determine type validity of a SFNode value
    """
    if isinstance(value, _X3DField):
        # print('SFNode type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFNode)=' + str(isinstance(value, SFNode)))
        if not isinstance(value, SFNode) and not isinstance(value, MFNode):
            return False # type mismatch!
    if isinstance(value, SFNode):
        value = value.value # dereference value from base type
    if isinstance(value, MFNode) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, object):
        return False
    return True

def assertValidSFNode(value):
    """
    Utility function to assert type validity of a SFNode value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFNode) and not isinstance(value, MFNode):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFNode')
    if isinstance(value, SFNode):
        value = value.value # dereference value from this base type
    if isinstance(value, MFNode) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, object):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid object value for SFNode')
    if not isValidSFNode(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python object value for SFNode')
    return True

def isValidMFNode(value):
    """
    Utility function to determine type validity of a MFNode value
    """
    if isinstance(value, _X3DField):
        # print('MFNode type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFNode)=' + str(isinstance(value, MFNode)))
        if not isinstance(value, SFNode) and not isinstance(value, MFNode):
            return False # type mismatch!
    if isinstance(value, MFNode):
        value = value.value # dereference value from base type
    if isinstance(value, SFNode):
        value = [value.value] # dereference value from this SF type, convert to list 1
    for each in value:
        if not isinstance(each, (_X3DNode, _X3DStatement)):
            return False
    return True

def assertValidMFNode(value):
    """
    Utility function to assert type validity of a MFNode value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFNode) and not isinstance(value, MFNode):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFNode')
    if isinstance(value, MFNode):
        value = value.value # dereference value from this base type
    if isinstance(value, SFNode):
        value = [value.value] # dereference value from this SF type, convert to list 2
    for each in value:
        if not isinstance(each, _X3DNode) and not isinstance(each, _X3DStatement):
            print(flush=True)
            raise AssertionError(str(value) + ' element ' + str(each) + ' is not a valid _X3DNode or _X3DStatement for MFNode')
    if not isValidMFNode(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid _X3DNode or _X3DStatement for MFNode')
    return True

def isValidSFRotation(value):
    """
    Utility function to determine type validity of a SFRotation value
    """
    if isinstance(value, _X3DField):
        # print('SFRotation type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFRotation)=' + str(isinstance(value, SFRotation)))
        if not isinstance(value, SFRotation) and not isinstance(value, MFRotation):
            return False # type mismatch!
    if isinstance(value, SFRotation):
        value = value.value # dereference value from base type
    if isinstance(value, MFRotation) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFRotation):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 4:
        return False
    return True

def assertValidSFRotation(value):
    """
    Utility function to assert type validity of a SFRotation value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFRotation) and not isinstance(value, MFRotation):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFRotation')
    if isinstance(value, SFRotation):
        value = value.value # dereference value from this base type
    if isinstance(value, MFRotation) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFRotation')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFRotation):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('SFRotation list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 4:
        print(flush=True)
        raise AssertionError('SFRotation ' + str(value) + ' has ' + str(tupleCount) + ' elements instead of 4')
    if not isValidSFRotation(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFRotation')
    return True

def isValidMFRotation(value):
    """
    Utility function to determine type validity of a MFRotation value
    """
    if isinstance(value, _X3DField):
        # print('MFRotation type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFRotation)=' + str(isinstance(value, MFRotation)))
        if not isinstance(value, SFRotation) and not isinstance(value, MFRotation):
            return False # type mismatch!
    if isinstance(value, MFRotation):
        value = value.value # dereference value from base type
    if isinstance(value, SFRotation):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            return False
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFRotation(value):
    """
    Utility function to assert type validity of a MFRotation value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFRotation) and not isinstance(value, MFRotation):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFRotation')
    if isinstance(value, MFRotation):
        value = value.value # dereference value from this base type
    if isinstance(value, SFRotation):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFRotation')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            print(flush=True)
            raise AssertionError('MFRotation element #' + str(_index) + ' with value ' + str(each) + ' is not a valid tuple')
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                print(flush=True)
                raise AssertionError('MFRotation element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ' that is not a valid float')
    if not isValidMFRotation(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFRotation')
    return True

def isValidSFString(value):
    """
    Utility function to determine type validity of a SFString value
    """
    if isinstance(value, _X3DField):
        # print('SFString type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFString)=' + str(isinstance(value, SFString)))
        if not isinstance(value, SFString) and not isinstance(value, MFString):
            return False # type mismatch!
    if isinstance(value, SFString):
        value = value.value # dereference value from base type
    if isinstance(value, MFString) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, str):
        return False
    return True

def assertValidSFString(value):
    """
    Utility function to assert type validity of a SFString value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFString) and not isinstance(value, MFString):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFString')
    if isinstance(value, SFString):
        value = value.value # dereference value from this base type
    if isinstance(value, MFString) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, str):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid str value for SFString')
    if not isValidSFString(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python str value for SFString')
    return True

def isValidMFString(value):
    """
    Utility function to determine type validity of a MFString value
    """
    if isinstance(value, _X3DField):
        # print('MFString type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFString)=' + str(isinstance(value, MFString)))
        if not isinstance(value, SFString) and not isinstance(value, MFString):
            return False # type mismatch!
    if isinstance(value, MFString):
        value = value.value # dereference value from base type
    if isinstance(value, SFString):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFString):
            each = each.value # dereference
        if not isinstance(each, str):
            return False
    return True

def assertValidMFString(value):
    """
    Utility function to assert type validity of a MFString value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFString) and not isinstance(value, MFString):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFString')
    if isinstance(value, MFString):
        value = value.value # dereference value from this base type
    if isinstance(value, SFString):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFString')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFString):
            each = each.value # dereference
        if not isinstance(each, str):
            print(flush=True)
            raise AssertionError('MFString list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid str')
    if not isValidMFString(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFString')
    return True

def isValidSFTime(value):
    """
    Utility function to determine type validity of a SFTime value
    """
    if isinstance(value, _X3DField):
        # print('SFTime type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFTime)=' + str(isinstance(value, SFTime)))
        if not isinstance(value, SFTime) and not isinstance(value, MFTime):
            return False # type mismatch!
    if isinstance(value, SFTime):
        value = value.value # dereference value from base type
    if isinstance(value, MFTime) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, ):
        return False
    return True

def assertValidSFTime(value):
    """
    Utility function to assert type validity of a SFTime value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFTime) and not isinstance(value, MFTime):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFTime')
    if isinstance(value, SFTime):
        value = value.value # dereference value from this base type
    if isinstance(value, MFTime) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, ):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid  value for SFTime')
    if not isValidSFTime(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python  value for SFTime')
    return True

def isValidMFTime(value):
    """
    Utility function to determine type validity of a MFTime value
    """
    if isinstance(value, _X3DField):
        # print('MFTime type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFTime)=' + str(isinstance(value, MFTime)))
        if not isinstance(value, SFTime) and not isinstance(value, MFTime):
            return False # type mismatch!
    if isinstance(value, MFTime):
        value = value.value # dereference value from base type
    if isinstance(value, SFTime):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFTime):
            each = each.value # dereference
        if not isinstance(each, ):
            return False
    return True

def assertValidMFTime(value):
    """
    Utility function to assert type validity of a MFTime value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFTime) and not isinstance(value, MFTime):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFTime')
    if isinstance(value, MFTime):
        value = value.value # dereference value from this base type
    if isinstance(value, SFTime):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFTime')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFTime):
            each = each.value # dereference
        if not isinstance(each, ):
            print(flush=True)
            raise AssertionError('MFTime list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid ')
    if not isValidMFTime(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFTime')
    return True

def isValidSFVec2d(value):
    """
    Utility function to determine type validity of a SFVec2d value
    """
    if isinstance(value, _X3DField):
        # print('SFVec2d type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFVec2d)=' + str(isinstance(value, SFVec2d)))
        if not isinstance(value, SFVec2d) and not isinstance(value, MFVec2d):
            return False # type mismatch!
    if isinstance(value, SFVec2d):
        value = value.value # dereference value from base type
    if isinstance(value, MFVec2d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec2d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 2:
        return False
    return True

def assertValidSFVec2d(value):
    """
    Utility function to assert type validity of a SFVec2d value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFVec2d) and not isinstance(value, MFVec2d):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFVec2d')
    if isinstance(value, SFVec2d):
        value = value.value # dereference value from this base type
    if isinstance(value, MFVec2d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFVec2d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec2d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('SFVec2d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 2:
        print(flush=True)
        raise AssertionError('SFVec2d ' + str(value) + ' has ' + str(tupleCount) + ' elements instead of 2')
    if not isValidSFVec2d(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFVec2d')
    return True

def isValidMFVec2d(value):
    """
    Utility function to determine type validity of a MFVec2d value
    """
    if isinstance(value, _X3DField):
        # print('MFVec2d type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFVec2d)=' + str(isinstance(value, MFVec2d)))
        if not isinstance(value, SFVec2d) and not isinstance(value, MFVec2d):
            return False # type mismatch!
    if isinstance(value, MFVec2d):
        value = value.value # dereference value from base type
    if isinstance(value, SFVec2d):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            return False
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFVec2d(value):
    """
    Utility function to assert type validity of a MFVec2d value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFVec2d) and not isinstance(value, MFVec2d):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFVec2d')
    if isinstance(value, MFVec2d):
        value = value.value # dereference value from this base type
    if isinstance(value, SFVec2d):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFVec2d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            print(flush=True)
            raise AssertionError('MFVec2d element #' + str(_index) + ' with value ' + str(each) + ' is not a valid tuple')
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                print(flush=True)
                raise AssertionError('MFVec2d element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ' that is not a valid float')
    if not isValidMFVec2d(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFVec2d')
    return True

def isValidSFVec2f(value):
    """
    Utility function to determine type validity of a SFVec2f value
    """
    if isinstance(value, _X3DField):
        # print('SFVec2f type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFVec2f)=' + str(isinstance(value, SFVec2f)))
        if not isinstance(value, SFVec2f) and not isinstance(value, MFVec2f):
            return False # type mismatch!
    if isinstance(value, SFVec2f):
        value = value.value # dereference value from base type
    if isinstance(value, MFVec2f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec2f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 2:
        return False
    return True

def assertValidSFVec2f(value):
    """
    Utility function to assert type validity of a SFVec2f value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFVec2f) and not isinstance(value, MFVec2f):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFVec2f')
    if isinstance(value, SFVec2f):
        value = value.value # dereference value from this base type
    if isinstance(value, MFVec2f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFVec2f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec2f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('SFVec2f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 2:
        print(flush=True)
        raise AssertionError('SFVec2f ' + str(value) + ' has ' + str(tupleCount) + ' elements instead of 2')
    if not isValidSFVec2f(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFVec2f')
    return True

def isValidMFVec2f(value):
    """
    Utility function to determine type validity of a MFVec2f value
    """
    if isinstance(value, _X3DField):
        # print('MFVec2f type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFVec2f)=' + str(isinstance(value, MFVec2f)))
        if not isinstance(value, SFVec2f) and not isinstance(value, MFVec2f):
            return False # type mismatch!
    if isinstance(value, MFVec2f):
        value = value.value # dereference value from base type
    if isinstance(value, SFVec2f):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            return False
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFVec2f(value):
    """
    Utility function to assert type validity of a MFVec2f value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFVec2f) and not isinstance(value, MFVec2f):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFVec2f')
    if isinstance(value, MFVec2f):
        value = value.value # dereference value from this base type
    if isinstance(value, SFVec2f):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFVec2f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            print(flush=True)
            raise AssertionError('MFVec2f element #' + str(_index) + ' with value ' + str(each) + ' is not a valid tuple')
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                print(flush=True)
                raise AssertionError('MFVec2f element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ' that is not a valid float')
    if not isValidMFVec2f(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFVec2f')
    return True

def isValidSFVec3d(value):
    """
    Utility function to determine type validity of a SFVec3d value
    """
    if isinstance(value, _X3DField):
        # print('SFVec3d type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFVec3d)=' + str(isinstance(value, SFVec3d)))
        if not isinstance(value, SFVec3d) and not isinstance(value, MFVec3d):
            return False # type mismatch!
    if isinstance(value, SFVec3d):
        value = value.value # dereference value from base type
    if isinstance(value, MFVec3d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec3d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 3:
        return False
    return True

def assertValidSFVec3d(value):
    """
    Utility function to assert type validity of a SFVec3d value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFVec3d) and not isinstance(value, MFVec3d):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFVec3d')
    if isinstance(value, SFVec3d):
        value = value.value # dereference value from this base type
    if isinstance(value, MFVec3d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFVec3d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec3d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('SFVec3d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 3:
        print(flush=True)
        raise AssertionError('SFVec3d ' + str(value) + ' has ' + str(tupleCount) + ' elements instead of 3')
    if not isValidSFVec3d(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFVec3d')
    return True

def isValidMFVec3d(value):
    """
    Utility function to determine type validity of a MFVec3d value
    """
    if isinstance(value, _X3DField):
        # print('MFVec3d type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFVec3d)=' + str(isinstance(value, MFVec3d)))
        if not isinstance(value, SFVec3d) and not isinstance(value, MFVec3d):
            return False # type mismatch!
    if isinstance(value, MFVec3d):
        value = value.value # dereference value from base type
    if isinstance(value, SFVec3d):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            return False
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFVec3d(value):
    """
    Utility function to assert type validity of a MFVec3d value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFVec3d) and not isinstance(value, MFVec3d):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFVec3d')
    if isinstance(value, MFVec3d):
        value = value.value # dereference value from this base type
    if isinstance(value, SFVec3d):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFVec3d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            print(flush=True)
            raise AssertionError('MFVec3d element #' + str(_index) + ' with value ' + str(each) + ' is not a valid tuple')
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                print(flush=True)
                raise AssertionError('MFVec3d element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ' that is not a valid float')
    if not isValidMFVec3d(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFVec3d')
    return True

def isValidSFVec3f(value):
    """
    Utility function to determine type validity of a SFVec3f value
    """
    if isinstance(value, _X3DField):
        # print('SFVec3f type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFVec3f)=' + str(isinstance(value, SFVec3f)))
        if not isinstance(value, SFVec3f) and not isinstance(value, MFVec3f):
            return False # type mismatch!
    if isinstance(value, SFVec3f):
        value = value.value # dereference value from base type
    if isinstance(value, MFVec3f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec3f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 3:
        return False
    return True

def assertValidSFVec3f(value):
    """
    Utility function to assert type validity of a SFVec3f value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFVec3f) and not isinstance(value, MFVec3f):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFVec3f')
    if isinstance(value, SFVec3f):
        value = value.value # dereference value from this base type
    if isinstance(value, MFVec3f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFVec3f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec3f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('SFVec3f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 3:
        print(flush=True)
        raise AssertionError('SFVec3f ' + str(value) + ' has ' + str(tupleCount) + ' elements instead of 3')
    if not isValidSFVec3f(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFVec3f')
    return True

def isValidMFVec3f(value):
    """
    Utility function to determine type validity of a MFVec3f value
    """
    if isinstance(value, _X3DField):
        # print('MFVec3f type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFVec3f)=' + str(isinstance(value, MFVec3f)))
        if not isinstance(value, SFVec3f) and not isinstance(value, MFVec3f):
            return False # type mismatch!
    if isinstance(value, MFVec3f):
        value = value.value # dereference value from base type
    if isinstance(value, SFVec3f):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            return False
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFVec3f(value):
    """
    Utility function to assert type validity of a MFVec3f value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFVec3f) and not isinstance(value, MFVec3f):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFVec3f')
    if isinstance(value, MFVec3f):
        value = value.value # dereference value from this base type
    if isinstance(value, SFVec3f):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFVec3f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            print(flush=True)
            raise AssertionError('MFVec3f element #' + str(_index) + ' with value ' + str(each) + ' is not a valid tuple')
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                print(flush=True)
                raise AssertionError('MFVec3f element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ' that is not a valid float')
    if not isValidMFVec3f(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFVec3f')
    return True

def isValidSFVec4d(value):
    """
    Utility function to determine type validity of a SFVec4d value
    """
    if isinstance(value, _X3DField):
        # print('SFVec4d type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFVec4d)=' + str(isinstance(value, SFVec4d)))
        if not isinstance(value, SFVec4d) and not isinstance(value, MFVec4d):
            return False # type mismatch!
    if isinstance(value, SFVec4d):
        value = value.value # dereference value from base type
    if isinstance(value, MFVec4d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec4d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 4:
        return False
    return True

def assertValidSFVec4d(value):
    """
    Utility function to assert type validity of a SFVec4d value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFVec4d) and not isinstance(value, MFVec4d):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFVec4d')
    if isinstance(value, SFVec4d):
        value = value.value # dereference value from this base type
    if isinstance(value, MFVec4d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFVec4d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec4d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('SFVec4d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 4:
        print(flush=True)
        raise AssertionError('SFVec4d ' + str(value) + ' has ' + str(tupleCount) + ' elements instead of 4')
    if not isValidSFVec4d(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFVec4d')
    return True

def isValidMFVec4d(value):
    """
    Utility function to determine type validity of a MFVec4d value
    """
    if isinstance(value, _X3DField):
        # print('MFVec4d type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFVec4d)=' + str(isinstance(value, MFVec4d)))
        if not isinstance(value, SFVec4d) and not isinstance(value, MFVec4d):
            return False # type mismatch!
    if isinstance(value, MFVec4d):
        value = value.value # dereference value from base type
    if isinstance(value, SFVec4d):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            return False
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFVec4d(value):
    """
    Utility function to assert type validity of a MFVec4d value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFVec4d) and not isinstance(value, MFVec4d):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFVec4d')
    if isinstance(value, MFVec4d):
        value = value.value # dereference value from this base type
    if isinstance(value, SFVec4d):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFVec4d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            print(flush=True)
            raise AssertionError('MFVec4d element #' + str(_index) + ' with value ' + str(each) + ' is not a valid tuple')
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                print(flush=True)
                raise AssertionError('MFVec4d element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ' that is not a valid float')
    if not isValidMFVec4d(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFVec4d')
    return True

def isValidSFVec4f(value):
    """
    Utility function to determine type validity of a SFVec4f value
    """
    if isinstance(value, _X3DField):
        # print('SFVec4f type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, SFVec4f)=' + str(isinstance(value, SFVec4f)))
        if not isinstance(value, SFVec4f) and not isinstance(value, MFVec4f):
            return False # type mismatch!
    if isinstance(value, SFVec4f):
        value = value.value # dereference value from base type
    if isinstance(value, MFVec4f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec4f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 4:
        return False
    return True

def assertValidSFVec4f(value):
    """
    Utility function to assert type validity of a SFVec4f value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFVec4f) and not isinstance(value, MFVec4f):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a SFVec4f')
    if isinstance(value, SFVec4f):
        value = value.value # dereference value from this base type
    if isinstance(value, MFVec4f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFVec4f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec4f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            print(flush=True)
            raise AssertionError('SFVec4f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 4:
        print(flush=True)
        raise AssertionError('SFVec4f ' + str(value) + ' has ' + str(tupleCount) + ' elements instead of 4')
    if not isValidSFVec4f(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python tuple for SFVec4f')
    return True

def isValidMFVec4f(value):
    """
    Utility function to determine type validity of a MFVec4f value
    """
    if isinstance(value, _X3DField):
        # print('MFVec4f type mismatch diagnostic: value=' + str(value) + ' has type=' + str(type(value)) + ', isinstance(value, MFVec4f)=' + str(isinstance(value, MFVec4f)))
        if not isinstance(value, SFVec4f) and not isinstance(value, MFVec4f):
            return False # type mismatch!
    if isinstance(value, MFVec4f):
        value = value.value # dereference value from base type
    if isinstance(value, SFVec4f):
        value = [value.value] # dereference value from this SF type, convert to list 1
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            return False
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFVec4f(value):
    """
    Utility function to assert type validity of a MFVec4f value, otherwise raise AssertionError with diagnostic message
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)))
    if isinstance(value, _X3DField) and not isinstance(value, SFVec4f) and not isinstance(value, MFVec4f):
        print(flush=True)
        raise TypeError(str(value) + ' has type ' + str(type(value)) + ' and is not a MFVec4f')
    if isinstance(value, MFVec4f):
        value = value.value # dereference value from this base type
    if isinstance(value, SFVec4f):
        value = [value.value] # dereference value from this SF type, convert to list 2
    if not isinstance(value, list):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFVec4f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    _index = 0
    for each in value:
        if not isinstance(each, tuple):
            print(flush=True)
            raise AssertionError('MFVec4f element #' + str(_index) + ' with value ' + str(each) + ' is not a valid tuple')
        _index += 1
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                print(flush=True)
                raise AssertionError('MFVec4f element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ' that is not a valid float')
    if not isValidMFVec4f(value):
        print(flush=True)
        raise AssertionError(str(value) + ' is not a valid Python list for MFVec4f')
    return True

###############################################

class _X3DField(object):
    """
    All X3D fields implement _X3DField abstract type.
    """
    value = None
    NAME = '_X3DField'
    SPECIFICATION_URL = 'https://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/fieldsDef.html'
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FieldTypesTable'
    @property # getter - - - - - - - - - -
    def value(self):
        """ provide value of this field type """
        return self.__value
    def __repl__(self):
        # if _DEBUG: print('* debug: type(self.value)=' + str(type(self.value)))
        if  isinstance(self.value, list): # avoid TypeError if value is not iterable
            # isinstance(self.value, MFNode): not working, what got passed in was not an MFNode object apparently
            result = '['
            for each in self.value:
                result += str(each) + ', '
                # if _DEBUG: print('* _X3DField debug: str(each)=' + str(each))
            return result.rstrip(', ') + ']'
        return str(self.value)
    def __str__(self):
        return self.__repl__()

def isX3DField(value):
    """
    Determine whether object is an instance of _X3DField.
    """
    return isinstance(value, _X3DField)

# Access Types

class AccessType(_X3DField):
    """
    accessType determines whether a field corresponds to event input, event output, or persistent state information. Events are strictly typed values with a corresponding timestamp. ROUTE connections must match accessType between source field and target field.

    initializeOnly: can be initialized, but cannot send or receive events. This is usually the case for fields that are considered too computationally expensive to change at run time.
    inputOutput: can be initialized, and can also send or receive events during run-time operations.
    inputOnly: cannot be initialized or included in a scene file, but can receive input event values via a ROUTE during run-time operations.
    outputOnly: cannot be initialized or included in a scene file, but can send output event values via a ROUTE during run-time operations.
    """
    SPECIFICATION_URL = 'https://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/concepts.html#FieldSemantics'
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#accessType'
    # string constants listing each allowed accessType
    initializeOnly = 'initializeOnly'
    inputOutput = 'inputOutput'
    inputOnly = 'inputOnly'
    outputOnly = 'outputOnly'


# Field Types

class FieldType(_X3DField):
    """
    The X3D Architecture specification of field types classify the possible values for a field.
    Each field in each node (i.e. each XML attribute) has a strictly defined data type.
    Multiple data types are provided for boolean, integer, floating-point and string values.
    X3D is a strongly typed language, meaning that all data must strictly conform to these data types in order for a scene to be correct.
    """
    SPECIFICATION_URL = 'https://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/fieldsDef.html'
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type'
    # string constants listing each allowed type
    SFBool = 'SFBool'
    MFBool = 'MFBool'
    SFColor = 'SFColor'
    MFColor = 'MFColor'
    SFColorRGBA = 'SFColorRGBA'
    MFColorRGBA = 'MFColorRGBA'
    SFDouble = 'SFDouble'
    MFDouble = 'MFDouble'
    SFFloat = 'SFFloat'
    MFFloat = 'MFFloat'
    SFImage = 'SFImage'
    MFImage = 'MFImage'
    SFInt32 = 'SFInt32'
    MFInt32 = 'MFInt32'
    SFMatrix3d = 'SFMatrix3d'
    MFMatrix3d = 'MFMatrix3d'
    SFMatrix3f = 'SFMatrix3f'
    MFMatrix3f = 'MFMatrix3f'
    SFMatrix4d = 'SFMatrix4d'
    MFMatrix4d = 'MFMatrix4d'
    SFMatrix4f = 'SFMatrix4f'
    MFMatrix4f = 'MFMatrix4f'
    SFNode = 'SFNode'
    MFNode = 'MFNode'
    SFRotation = 'SFRotation'
    MFRotation = 'MFRotation'
    SFString = 'SFString'
    MFString = 'MFString'
    SFTime = 'SFTime'
    MFTime = 'MFTime'
    SFVec2d = 'SFVec2d'
    MFVec2d = 'MFVec2d'
    SFVec2f = 'SFVec2f'
    MFVec2f = 'MFVec2f'
    SFVec3d = 'SFVec3d'
    MFVec3d = 'MFVec3d'
    SFVec3f = 'SFVec3f'
    MFVec3f = 'MFVec3f'
    SFVec4d = 'SFVec4d'
    MFVec4d = 'MFVec4d'
    SFVec4f = 'SFVec4f'
    MFVec4f = 'MFVec4f'

class SFBool(_X3DField):
    """
    SFBool is a logical type with possible values (True|False).
    """
    NAME = 'SFBool'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFBool'
    DEFAULT_VALUE = True
    REGEX_XML = r'\s*(true|false)\s*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        value = fixBoolean(value, default=self.DEFAULT_VALUE)
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFBool(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFBool(_X3DField):
    """
    MFBool is an array of Boolean values.
    """
    NAME = 'MFBool'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFBool'
    DEFAULT_VALUE = list()
    REGEX_XML = r'\s*((true|false)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        value = fixBoolean(value, default=self.DEFAULT_VALUE)
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFBool(value):
            value = [value]
        assertValidMFBool(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFBool(value):
                if isinstance(value, SFBool):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFBool(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFBool):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFBool(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFColor(_X3DField):
    """
    The SFColor field specifies one RGB (red-green-blue) color triple.
    """
    NAME = 'SFColor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFColor'
    DEFAULT_VALUE = (0, 0, 0)
    REGEX_XML = r'(\s)*(([+]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)(\s)+){2}([+]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)(\s)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFColor(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFColor(_X3DField):
    """
    MFColor specifies zero or more SFColor RGB triples.
    """
    NAME = 'MFColor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFColor'
    DEFAULT_VALUE = list()
    REGEX_XML = r'(\s)*((([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)(\s)+){2}([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFColor(value):
            value = [value]
        assertValidMFColor(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFColor(value):
                if isinstance(value, SFColor):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFColor(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFColor):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFColor(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFColorRGBA(_X3DField):
    """
    The SFColorRGBA field specifies one RGBA (red-green-blue-alpha) color 4-tuple.
    """
    NAME = 'SFColorRGBA'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFColorRGBA'
    DEFAULT_VALUE = (0, 0, 0, 0)
    REGEX_XML = r'(\s)*(([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)(\s)+){3}([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)(\s)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFColorRGBA(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFColorRGBA(_X3DField):
    """
    MFColorRGBA specifies zero or more SFColorRGBA 4-tuples.
    """
    NAME = 'MFColorRGBA'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFColorRGBA'
    DEFAULT_VALUE = list()
    REGEX_XML = r'(\s)*((([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)(\s)+){3}([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFColorRGBA(value):
            value = [value]
        assertValidMFColorRGBA(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFColorRGBA(value):
                if isinstance(value, SFColorRGBA):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFColorRGBA(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFColorRGBA):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFColorRGBA(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFDouble(_X3DField):
    """
    SFDouble is a double-precision floating-point type.
    """
    NAME = 'SFDouble'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFDouble'
    DEFAULT_VALUE = 0.0
    REGEX_XML = r'(\s)*([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)(\s)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFDouble(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFDouble(_X3DField):
    """
    MFDouble is an array of Double values, meaning a double-precision floating-point array type.
    """
    NAME = 'MFDouble'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFDouble'
    DEFAULT_VALUE = list()
    REGEX_XML = r'(\s)*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFDouble(value):
            value = [value]
        assertValidMFDouble(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFDouble(value):
                if isinstance(value, SFDouble):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFDouble(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFDouble):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFDouble(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFFloat(_X3DField):
    """
    SFFloat is a single-precision floating-point type.
    """
    NAME = 'SFFloat'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFFloat'
    DEFAULT_VALUE = 0.0
    REGEX_XML = r'(\s)*([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)(\s)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFFloat(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFFloat(_X3DField):
    """
    MFFloat is an array of SFFloat values, meaning a single-precision floating-point array type.
    """
    NAME = 'MFFloat'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFFloat'
    DEFAULT_VALUE = list()
    REGEX_XML = r'(\s)*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFFloat(value):
            value = [value]
        assertValidMFFloat(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFFloat(value):
                if isinstance(value, SFFloat):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFFloat(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFFloat):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFFloat(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFImage(_X3DField):
    """
    The SFImage field specifies a single uncompressed 2-dimensional pixel image.
    """
    NAME = 'SFImage'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFImage'
    DEFAULT_VALUE = [0, 0, 0]
    REGEX_XML = r'\s*([+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?\s+){2}[+]?[0-4](\s+(0x[0-9a-fA-F]{1,16}|[+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?))*\s*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFImage(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFImage(_X3DField):
    """
    MFImage is an array of SFImage values.
    """
    NAME = 'MFImage'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFImage'
    DEFAULT_VALUE = list()
    REGEX_XML = r'\s*(([+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?\s+){2}[+]?[0-4](\s+(0x[0-9a-fA-F]{1,16}|[+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?))*\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFImage(value):
            value = [value]
        assertValidMFImage(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFImage(value):
                if isinstance(value, SFImage):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFImage(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFImage):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFImage(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFInt32(_X3DField):
    """
    An SFInt32 field specifies one 32-bit signed integer.
    """
    NAME = 'SFInt32'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFInt32'
    DEFAULT_VALUE = 0
    REGEX_XML = r'(\s)*[+-]?(0|[1-9][0-9]*)([Ee][+-]?[0-9]+)?(\s)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFInt32(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFInt32(_X3DField):
    """
    An MFInt32 field defines an array of 32-bit signed integers.
    """
    NAME = 'MFInt32'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFInt32'
    DEFAULT_VALUE = list()
    REGEX_XML = r'(\s)*([+-]?(0|[1-9][0-9]*)([Ee][+-]?[0-9]+)?\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFInt32(value):
            value = [value]
        assertValidMFInt32(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFInt32(value):
                if isinstance(value, SFInt32):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFInt32(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFInt32):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFInt32(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFMatrix3d(_X3DField):
    """
    SFMatrix3d specifies a 3x3 matrix of double-precision floating point numbers, organized in row-major fashion.
    """
    NAME = 'SFMatrix3d'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix3d'
    DEFAULT_VALUE = (1, 0, 0, 0, 1, 0, 0, 0, 1)
    REGEX_XML = r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFMatrix3d(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFMatrix3d(_X3DField):
    """
    MFMatrix3d specifies zero or more 3x3 matrices of double-precision floating point numbers, organized in row-major fashion.
    """
    NAME = 'MFMatrix3d'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix3d'
    DEFAULT_VALUE = list()
    REGEX_XML = r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFMatrix3d(value):
            value = [value]
        assertValidMFMatrix3d(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFMatrix3d(value):
                if isinstance(value, SFMatrix3d):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFMatrix3d(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFMatrix3d):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFMatrix3d(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFMatrix3f(_X3DField):
    """
    SFMatrix3f specifies a 3x3 matrix of single-precision floating point numbers, organized in row-major fashion.
    """
    NAME = 'SFMatrix3f'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix3f'
    DEFAULT_VALUE = (1, 0, 0, 0, 1, 0, 0, 0, 1)
    REGEX_XML = r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFMatrix3f(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFMatrix3f(_X3DField):
    """
    MFMatrix3f specifies zero or more 3x3 matrices of single-precision floating point numbers, organized in row-major fashion.
    """
    NAME = 'MFMatrix3f'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix3f'
    DEFAULT_VALUE = list()
    REGEX_XML = r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFMatrix3f(value):
            value = [value]
        assertValidMFMatrix3f(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFMatrix3f(value):
                if isinstance(value, SFMatrix3f):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFMatrix3f(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFMatrix3f):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFMatrix3f(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFMatrix4d(_X3DField):
    """
    SFMatrix4d specifies a 4x4 matrix of double-precision floating point numbers, organized in row-major fashion.
    """
    NAME = 'SFMatrix4d'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix4d'
    DEFAULT_VALUE = (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
    REGEX_XML = r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFMatrix4d(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFMatrix4d(_X3DField):
    """
    MFMatrix4d specifies zero or more 4x4 matrices of double-precision floating point numbers, organized in row-major fashion.
    """
    NAME = 'MFMatrix4d'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix4d'
    DEFAULT_VALUE = list()
    REGEX_XML = r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFMatrix4d(value):
            value = [value]
        assertValidMFMatrix4d(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFMatrix4d(value):
                if isinstance(value, SFMatrix4d):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFMatrix4d(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFMatrix4d):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFMatrix4d(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFMatrix4f(_X3DField):
    """
    SFMatrix4f specifies a 4x4 matrix of single-precision floating point numbers, organized in row-major fashion.
    """
    NAME = 'SFMatrix4f'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix4f'
    DEFAULT_VALUE = (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
    REGEX_XML = r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFMatrix4f(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFMatrix4f(_X3DField):
    """
    MFMatrix4f specifies zero or more 4x4 matrices of single-precision floating point numbers, organized in row-major fashion.
    """
    NAME = 'MFMatrix4f'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix4f'
    DEFAULT_VALUE = list()
    REGEX_XML = r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFMatrix4f(value):
            value = [value]
        assertValidMFMatrix4f(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFMatrix4f(value):
                if isinstance(value, SFMatrix4f):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFMatrix4f(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFMatrix4f):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFMatrix4f(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFNode(_X3DField):
    """
    The SFNode field specifies an X3D node; the default empty value of an uninitialized SFNode field is sometimes described as NULL.
    """
    NAME = 'SFNode'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFNode'
    DEFAULT_VALUE = None
    FIELD_DECLARATIONS = [('value', 'None', FieldType.SFNode, AccessType.inputOutput)]
    REGEX_XML = r'' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFNode(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFNode(_X3DField):
    """
    The MFNode field specifies zero or more nodes; the default value of an MFNode field is the empty list.
    """
    NAME = 'MFNode'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFNode'
    DEFAULT_VALUE = list()
    FIELD_DECLARATIONS = [('value', None, FieldType.MFNode, AccessType.inputOutput)]
    REGEX_XML = r'' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFNode(value):
            value = [value]
        assertValidMFNode(value)
        self.__value = value
    def __repl__(self):
        result = '['
        for each in self.__value:
            result += str(each) + ', '
        return result.rstrip(', ') + ']'
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFNode(value):
                if isinstance(value, SFNode):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFNode(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFNode):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFNode(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFRotation(_X3DField):
    """
    SFRotation is an axis-angle 4-tuple, indicating X-Y-Z direction axis plus angle orientation about that axis.
    """
    NAME = 'SFRotation'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFRotation'
    DEFAULT_VALUE = (0, 0, 1, 0)
    REGEX_XML = r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFRotation(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFRotation(_X3DField):
    """
    MFRotation is an array of SFRotation values.
    """
    NAME = 'MFRotation'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFRotation'
    DEFAULT_VALUE = list()
    REGEX_XML = r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFRotation(value):
            value = [value]
        assertValidMFRotation(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFRotation(value):
                if isinstance(value, SFRotation):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFRotation(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFRotation):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFRotation(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFString(_X3DField):
    """
    SFString defines a single string encoded with the UTF-8 universal character set.
    """
    NAME = 'SFString'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFString'
    DEFAULT_VALUE = ''
    REGEX_XML = r'(\s|\S)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFString(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFString(_X3DField):
    """
    MFString is an array of SFString values, each "quoted" and separated by whitespace.
    """
    NAME = 'MFString'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFString'
    DEFAULT_VALUE = list()
    REGEX_XML = r'(\s|\S)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFString(value):
            value = [value]
        assertValidMFString(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFString(value):
                if isinstance(value, SFString):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFString(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFString):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFString(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFTime(_X3DField):
    """
    The SFTime field specifies a single time value.
    """
    NAME = 'SFTime'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFTime'
    DEFAULT_VALUE = -1.0
    REGEX_XML = r'(\s)*([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)(\s)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFTime(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFTime(_X3DField):
    """
    MFTime is an array of SFTime values.
    """
    NAME = 'MFTime'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFTime'
    DEFAULT_VALUE = list()
    REGEX_XML = r'(\s)*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFTime(value):
            value = [value]
        assertValidMFTime(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFTime(value):
                if isinstance(value, SFTime):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFTime(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFTime):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFTime(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFVec2d(_X3DField):
    """
    SFVec2d is a 2-tuple pair of SFDouble values.
    """
    NAME = 'SFVec2d'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec2d'
    DEFAULT_VALUE = (0.0, 0.0)
    REGEX_XML = r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFVec2d(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFVec2d(_X3DField):
    """
    MFVec2d is an array of SFVec2d values.
    """
    NAME = 'MFVec2d'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec2d'
    DEFAULT_VALUE = list()
    REGEX_XML = r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFVec2d(value):
            value = [value]
        assertValidMFVec2d(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFVec2d(value):
                if isinstance(value, SFVec2d):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFVec2d(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFVec2d):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFVec2d(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFVec2f(_X3DField):
    """
    SFVec2f is a 2-tuple pair of SFFloat values.
    """
    NAME = 'SFVec2f'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec2f'
    DEFAULT_VALUE = (0.0, 0.0)
    REGEX_XML = r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFVec2f(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFVec2f(_X3DField):
    """
    MFVec2f is an array of SFVec2f values.
    """
    NAME = 'MFVec2f'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec2f'
    DEFAULT_VALUE = list()
    REGEX_XML = r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFVec2f(value):
            value = [value]
        assertValidMFVec2f(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFVec2f(value):
                if isinstance(value, SFVec2f):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFVec2f(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFVec2f):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFVec2f(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFVec3d(_X3DField):
    """
    SFVec3d is a 3-tuple triplet of SFDouble values.
    """
    NAME = 'SFVec3d'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec3d'
    DEFAULT_VALUE = (0.0, 0.0, 0.0)
    REGEX_XML = r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFVec3d(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFVec3d(_X3DField):
    """
    MFVec3d is an array of SFVec3d values.
    """
    NAME = 'MFVec3d'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec3d'
    DEFAULT_VALUE = list()
    REGEX_XML = r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFVec3d(value):
            value = [value]
        assertValidMFVec3d(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFVec3d(value):
                if isinstance(value, SFVec3d):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFVec3d(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFVec3d):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFVec3d(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFVec3f(_X3DField):
    """
    SFVec3f is a 3-tuple triplet of SFFloat values.
    """
    NAME = 'SFVec3f'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec3f'
    DEFAULT_VALUE = (0.0, 0.0, 0.0)
    REGEX_XML = r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFVec3f(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFVec3f(_X3DField):
    """
    MFVec3f is an array of SFVec3f values.
    """
    NAME = 'MFVec3f'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec3f'
    DEFAULT_VALUE = list()
    REGEX_XML = r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFVec3f(value):
            value = [value]
        assertValidMFVec3f(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFVec3f(value):
                if isinstance(value, SFVec3f):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFVec3f(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFVec3f):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFVec3f(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFVec4d(_X3DField):
    """
    SFVec4d is a 4-tuple set of double-precision floating-point values, specifying a 3D homogeneous vector.
    """
    NAME = 'SFVec4d'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec4d'
    DEFAULT_VALUE = (0.0, 0.0, 0.0, 0.0)
    REGEX_XML = r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFVec4d(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFVec4d(_X3DField):
    """
    MFVec4d is zero or more SFVec4d values.
    """
    NAME = 'MFVec4d'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec4d'
    DEFAULT_VALUE = list()
    REGEX_XML = r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFVec4d(value):
            value = [value]
        assertValidMFVec4d(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFVec4d(value):
                if isinstance(value, SFVec4d):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFVec4d(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFVec4d):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFVec4d(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

class SFVec4f(_X3DField):
    """
    SFVec4f is a 4-tuple set of single-precision floating-point values, specifying a 3D homogeneous vector.
    """
    NAME = 'SFVec4f'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec4f'
    DEFAULT_VALUE = (0.0, 0.0, 0.0, 0.0)
    REGEX_XML = r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif isinstance(value, list) and len(value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value) + " as str(value.value)")
            value = value.value # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFVec4f(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0

class MFVec4f(_X3DField):
    """
    MFVec4f is zero or more SFVec4f values.
    """
    NAME = 'MFVec4f'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec4f'
    DEFAULT_VALUE = list()
    REGEX_XML = r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        elif not isinstance(value, list) and isValidSFVec4f(value):
            value = [value]
        assertValidMFVec4f(value)
        self.__value = value
    def append(self, value=None):
        """ add to existing value, first ensuring that a correctly typed value is applied """
        if  not value is None:
            if isValidSFVec4f(value):
                if isinstance(value, SFVec4f):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFVec4f(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFVec4f):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFVec4f(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)

###############################################

# Abstract Node Types

# Note that these package-internal class names are preceded by an underscore _ character since X3D authors are not expected to use them

class _X3DNode(object):
    """
    All instantiable nodes implement X3DNode, which corresponds to SFNode in the X3D specification.
    """
    NAME = '_X3DNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF="", USE="", class_="", metadata=None, IS=None):
        self.DEF = DEF
        self.USE = USE
        self.class_ = class_
        self.IS = IS
        self.metadata = metadata
        # if _DEBUG: print('... in X3DNode __init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
    @property # getter - - - - - - - - - -
    def DEF(self):
        """ unique ID name for this node, referenceable by other nodes """
        return self.__DEF
    @DEF.setter
    def DEF(self, DEF=None):
        if  DEF is None:
            DEF = SFString.DEFAULT_VALUE
        assertValidSFString(DEF)
        self.__DEF = str(DEF)
        if self.__DEF:
            self.__USE = None # DEF and USE are mutually exclusive
    @property # getter - - - - - - - - - -
    def USE(self):
        """  reuse an already DEF-ed node ID, excluding all child nodes and all other attributes """
        return self.__USE
    @USE.setter
    def USE(self, USE=None):
        if  USE is None:
            USE = SFString.DEFAULT_VALUE
        assertValidSFString(USE)
        self.__USE = str(USE)
        if self.__USE:
            self.__DEF = None # DEF and USE are mutually exclusive
    @property # getter - - - - - - - - - -
    def class_(self):
        """ space-separated list of classes, reserved for use by CSS cascading stylesheets """
        return self.__class_
    @class_.setter
    def class_(self, class_=None):
        if  class_ is None:
            class_ = SFString.DEFAULT_VALUE
        assertValidSFString(class_)
        self.__class_ = class_
    @property # getter - - - - - - - - - -
    def IS(self):
        """ The IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields. """
        return self.__IS
    @IS.setter
    def IS(self, IS=None):
        if  IS is None:
            IS = SFNode.DEFAULT_VALUE
        assertValidSFNode(IS)
        if not isinstance(IS, object):
            print(flush=True)
            raise TypeError(str(IS) + ' does not have a valid node type object')
        self.__IS = IS
    @property # getter - - - - - - - - - -
    def metadata(self):
        """ can contain a single MetadataBoolean, MetadataInteger, MetadataFloat, MetadataDouble, MetadataString or MetadataSet node. """
        return self.__metadata
    @metadata.setter
    def metadata(self, metadata=None):
        if  metadata is None:
            metadata = SFNode.DEFAULT_VALUE
        assertValidSFNode(metadata)
        if not isinstance(metadata, object):
            print(flush=True)
            raise TypeError(str(metadata) + ' does not have a valid node type object')
        self.__metadata = metadata
    def __repl__(self):
        result = self.NAME + '('
        # TODO put DEF first, matching canonical form
        for each in self.FIELD_DECLARATIONS:
            # if _DEBUG: print(self.NAME + ' for each in self.FIELD_DECLARATIONS: each=' + str(each))
            name = each[0]
            default = each[1]
            type_ = each[2]
            accessType = each[3]
            value = getattr(self, name)
            # if _DEBUG: print('gettattr(self, ' + str(name) + ') value="' + str(value) + '" for FIELD_DECLARATIONS ' + str(each) + ')')
            if value != default:
                # consider whether indentation is useful; probably not
                # print ("\n\t")
                if  isinstance(value, list): # avoid TypeError if value is not iterable
                    result += str(name) + '=['
                    for each in value:
                        result += str(each) + ', '
                        # if _DEBUG: print('* X3DNode debug: str(each)=' + str(each))
                    result = result.rstrip(', ')
                    result += '],'
                elif isinstance(value, str) and "'" in value:
                    result += str(name) + '=' + '"' + str(value) + '"' + ','
                elif isinstance(value, str) and value != default:
                    result += str(name) + '=' + "'" + str(value) + "'" + ','
                elif value != default:
                    result += str(name) + '='       + str(value)       + ','
                # elif _DEBUG:
                #   result += str(name) + '=' + "'" + str(value) + "'" + ','
        return result.strip().rstrip(',').rstrip(', ') + ')'
    def __str__(self):
        return self.__repl__().strip() # X3DNode

class _X3DChildNode(_X3DNode):
    """
    A node that implements X3DChildNode is one of the legal children for a X3DGroupingNode parent.
    """
    NAME = '_X3DChildNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DChildNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTimeDependentNode(_X3DChildNode):
    """
    Base type from which all time-dependent nodes are derived.
    """
    NAME = '_X3DTimeDependentNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTimeDependentNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DGeometryNode(_X3DNode):
    """
    Geometry nodes produce renderable geometry and are contained by a Shape node.
    """
    NAME = '_X3DGeometryNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DGeometryNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DParametricGeometryNode(_X3DGeometryNode):
    """
    Base type for all geometry node types that are created parametrically and use control points to describe the final shape of the surface.
    """
    NAME = '_X3DParametricGeometryNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DParametricGeometryNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DAppearanceChildNode(_X3DNode):
    """
    Nodes of this type can be used as child nodes for Appearance.
    """
    NAME = '_X3DAppearanceChildNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DAppearanceChildNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTextureNode(_X3DAppearanceChildNode):
    """
    Base type for all nodes which specify sources for texture images.
    """
    NAME = '_X3DTextureNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTextureNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSensorNode(_X3DChildNode):
    """
    Base type for all sensors.
    """
    NAME = '_X3DSensorNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DPointingDeviceSensorNode(_X3DSensorNode):
    """
    Base type for all pointing device sensors.
    """
    NAME = '_X3DPointingDeviceSensorNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DPointingDeviceSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DVolumeRenderStyleNode(_X3DNode):
    """
    The X3DVolumeRenderStyleNode abstract node type is the base type for all node types that specify a specific visual rendering style to be used when rendering volume data.
    """
    NAME = '_X3DVolumeRenderStyleNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DVolumeRenderStyleNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DGeometricPropertyNode(_X3DNode):
    """
    Base type for all geometric property node types.
    """
    NAME = '_X3DGeometricPropertyNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DGeometricPropertyNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DFollowerNode(_X3DChildNode):
    """
    X3DFollowerNode is the abstract base class for all nodes in the Followers component.
    """
    NAME = '_X3DFollowerNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DFollowerNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DBindableNode(_X3DChildNode):
    """
    Bindable nodes implement the binding stack, so that only one of each node type is active at a given time.
    """
    NAME = '_X3DBindableNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DBindableNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DAppearanceNode(_X3DNode):
    """
    Base type for all Appearance nodes.
    """
    NAME = '_X3DAppearanceNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DAppearanceNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DBackgroundNode(_X3DBindableNode):
    """
    Abstract type from which all backgrounds inherit, also defining a background binding stack.
    """
    NAME = '_X3DBackgroundNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DBackgroundNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DChaserNode(_X3DFollowerNode):
    """
    The X3DChaserNode abstract node type calculates the output on value_changed as a finite impulse response (FIR) based on the events received on set_destination field.
    """
    NAME = '_X3DChaserNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DChaserNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DColorNode(_X3DGeometricPropertyNode):
    """
    Base type for color specifications in X3D.
    """
    NAME = '_X3DColorNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DColorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DComposableVolumeRenderStyleNode(_X3DVolumeRenderStyleNode):
    """
    The X3DComposableVolumeRenderStyleNode abstract node type is the base type for all node types that allow rendering styles to be sequentially composed together to form a single renderable output.
    """
    NAME = '_X3DComposableVolumeRenderStyleNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DComposableVolumeRenderStyleNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DComposedGeometryNode(_X3DGeometryNode):
    """
    Composed geometry nodes produce renderable geometry, can contain Color Coordinate Normal TextureCoordinate, and are contained by a Shape node.
    """
    NAME = '_X3DComposedGeometryNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DComposedGeometryNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DCoordinateNode(_X3DGeometricPropertyNode):
    """
    Base type for all coordinate node types in X3D.
    """
    NAME = '_X3DCoordinateNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DCoordinateNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DDamperNode(_X3DFollowerNode):
    """
    The X3DDamperNode abstract node type creates an IIR response that approaches the destination value according to the shape of the e-function only asymptotically but very quickly.
    """
    NAME = '_X3DDamperNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DDamperNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DDragSensorNode(_X3DPointingDeviceSensorNode):
    """
    Base type for all drag-style pointing device sensors.
    """
    NAME = '_X3DDragSensorNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DDragSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DEnvironmentalSensorNode(_X3DSensorNode):
    """
    Base type for the environmental sensor nodes ProximitySensor, TransformSensor and VisibilitySensor.
    """
    NAME = '_X3DEnvironmentalSensorNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DEnvironmentalSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DEnvironmentTextureNode(_X3DTextureNode):
    """
    Base type for all nodes that specify cubic environment map sources for texture images.
    """
    NAME = '_X3DEnvironmentTextureNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DEnvironmentTextureNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DFontStyleNode(_X3DNode):
    """
    Base type for all font style nodes.
    """
    NAME = '_X3DFontStyleNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DFontStyleNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DGroupingNode(_X3DChildNode):
    """
    Grouping nodes can contain other nodes as children, thus making up the backbone of a scene graph.
    """
    NAME = '_X3DGroupingNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DGroupingNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DInfoNode(_X3DChildNode):
    """
    Base type for all nodes that contain only information without visual semantics.
    """
    NAME = '_X3DInfoNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DInfoNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DInterpolatorNode(_X3DChildNode):
    """
    Interpolator nodes are designed for linear keyframed animation. Interpolators are driven by an input key ranging [0..1] and produce corresponding piecewise-linear output functions.
    """
    NAME = '_X3DInterpolatorNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DInterpolatorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DKeyDeviceSensorNode(_X3DSensorNode):
    """
    Base type for all sensor node types that operate using key devices.
    """
    NAME = '_X3DKeyDeviceSensorNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DKeyDeviceSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DLayerNode(_X3DNode):
    """
    The X3DLayerNode abstract node type is the base node type for layer nodes.
    """
    NAME = '_X3DLayerNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DLayerNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DLayoutNode(_X3DChildNode):
    """
    X3DLayoutNode is the base node type for layout nodes.
    """
    NAME = '_X3DLayoutNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DLayoutNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DLightNode(_X3DChildNode):
    """
    Light nodes provide illumination for rendering geometry in the scene. Implementing nodes must include a global field with type SFBool and accessType inputOutput.
    """
    NAME = '_X3DLightNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DLightNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DMaterialNode(_X3DAppearanceChildNode):
    """
    Base type for all Material nodes.
    """
    NAME = '_X3DMaterialNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DMaterialNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DNBodyCollidableNode(_X3DChildNode):
    """
    The X3DNBodyCollidableNode abstract node type represents objects that act as the interface between the rigid body physics, collision geometry proxy, and renderable objects in the scene graph hierarchy.
    """
    NAME = '_X3DNBodyCollidableNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DNBodyCollidableNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DNBodyCollisionSpaceNode(_X3DNode):
    """
    The X3DNBodyCollisionSpaceNode abstract node type represents objects that act as a self-contained spatial collection of objects that can interact through collision detection routines.
    """
    NAME = '_X3DNBodyCollisionSpaceNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DNBodyCollisionSpaceNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DNetworkSensorNode(_X3DSensorNode):
    """
    Base typefor all sensors that generate events based on network activity.
    """
    NAME = '_X3DNetworkSensorNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DNetworkSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DNormalNode(_X3DGeometricPropertyNode):
    """
    Base type for all normal node types in X3D.
    """
    NAME = '_X3DNormalNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DNormalNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DNurbsControlCurveNode(_X3DNode):
    """
    Base type for all nodes that provide control curve information in 2D space.
    """
    NAME = '_X3DNurbsControlCurveNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DNurbsControlCurveNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DNurbsSurfaceGeometryNode(_X3DParametricGeometryNode):
    """
    Abstract geometry type for all types of NURBS surfaces.
    """
    NAME = '_X3DNurbsSurfaceGeometryNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DNurbsSurfaceGeometryNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DParticleEmitterNode(_X3DNode):
    """
    The X3DParticleEmitterNode abstract type represents any node that is an emitter of particles.
    """
    NAME = '_X3DParticleEmitterNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DParticleEmitterNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DParticlePhysicsModelNode(_X3DNode):
    """
    The X3DParticlePhysicsModelNode abstract type represents any node that applies a form of constraints on the particles after they have been generated.
    """
    NAME = '_X3DParticlePhysicsModelNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DParticlePhysicsModelNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DPickSensorNode(_X3DSensorNode):
    """
    The X3DPickSensorNode abstract node type is the base node type that represents the lowest common denominator of picking capabilities.
    """
    NAME = '_X3DPickSensorNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DPickSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DProductStructureChildNode(_X3DChildNode):
    """
    Base type marking nodes that are valid product structure children for the CADGeometry component.
    """
    NAME = '_X3DProductStructureChildNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DProductStructureChildNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DPrototypeInstance(_X3DNode):
    """
    Base type for all prototype instances. Note that direct children nodes are disallowed, instead let fieldValue with type SFNode/MFNode contain them. Current practice is that, if desired, prototype authors must explicitly add the metadata SFNode field in the ProtoInterface.
    """
    NAME = '_X3DPrototypeInstance'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DPrototypeInstance __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DRigidJointNode(_X3DNode):
    """
    The X3DRigidJointNode abstract node type is the base type for all joint types.
    """
    NAME = '_X3DRigidJointNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DRigidJointNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DScriptNode(_X3DChildNode):
    """
    Base type for scripting nodes (but not shader nodes).
    """
    NAME = '_X3DScriptNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DScriptNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSequencerNode(_X3DChildNode):
    """
    Base type from which all Sequencers are derived.
    """
    NAME = '_X3DSequencerNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSequencerNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DShaderNode(_X3DAppearanceChildNode):
    """
    Base type for all nodes that specify a programmable shader.
    """
    NAME = '_X3DShaderNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DShaderNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DShapeNode(_X3DChildNode):
    """
    Base type for all Shape nodes.
    """
    NAME = '_X3DShapeNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DShapeNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSoundNode(_X3DChildNode):
    """
    Base type for all sound nodes.
    """
    NAME = '_X3DSoundNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSoundNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSoundSourceNode(_X3DTimeDependentNode):
    """
    Nodes implementing X3DSoundSourceNode are allowed as children of Sound node.
    """
    NAME = '_X3DSoundSourceNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSoundSourceNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTexture2DNode(_X3DTextureNode):
    """
    Base type for all nodes which specify 2D sources for texture images.
    """
    NAME = '_X3DTexture2DNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTexture2DNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTexture3DNode(_X3DTextureNode):
    """
    Base type for all nodes that specify 3D sources for texture images.
    """
    NAME = '_X3DTexture3DNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTexture3DNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTextureCoordinateNode(_X3DGeometricPropertyNode):
    """
    Base type for all nodes which specify texture coordinates.
    """
    NAME = '_X3DTextureCoordinateNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTextureCoordinateNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTextureTransformNode(_X3DAppearanceChildNode):
    """
    Base type for all nodes which specify a transformation of texture coordinates.
    """
    NAME = '_X3DTextureTransformNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTextureTransformNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTouchSensorNode(_X3DPointingDeviceSensorNode):
    """
    Base type for all touch-style pointing device sensors.
    """
    NAME = '_X3DTouchSensorNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTouchSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTriggerNode(_X3DChildNode):
    """
    Base type from which all trigger nodes are derived.
    """
    NAME = '_X3DTriggerNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTriggerNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DVertexAttributeNode(_X3DGeometricPropertyNode):
    """
    Base type for all nodes that specify per-vertex attribute information to the shader.
    """
    NAME = '_X3DVertexAttributeNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DVertexAttributeNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DViewpointNode(_X3DBindableNode):
    """
    Node type X3DViewpointNode defines a specific location in the local coordinate system from which the user may view the scene, and also defines a viewpoint binding stack.
    """
    NAME = '_X3DViewpointNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DViewpointNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DViewportNode(_X3DGroupingNode):
    """
    The X3DViewportNode abstract node type is the base node type for viewport nodes.
    """
    NAME = '_X3DViewportNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DViewportNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DVolumeDataNode(_X3DChildNode):
    """
    The X3DVolumeDataNode abstract node type is the base type for all node types that describe volumetric data to be rendered.
    """
    NAME = '_X3DVolumeDataNode'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DVolumeDataNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

###############################################

# Abstract Object Types

# Note that these package-internal class names are preceded by an underscore _ character since X3D authors are not expected to use them

class _X3DBoundedObject(_X3DNode):
    """
    X3DBoundedObject indicates that bounding box values can be provided (or computed) to encompass this node and any children.
    """
    NAME = '_X3DBoundedObject'
    SPECIFICATION_URL = ''

class _X3DFogObject(_X3DNode):
    """
    Abstract type describing a node that influences the lighting equation through the use of fog semantics.
    """
    NAME = '_X3DFogObject'
    SPECIFICATION_URL = ''

class _X3DMetadataObject(_X3DNode):
    """
    Each node inheriting the X3DMetadataObject interface contains a single array of strictly typed values: MFBool, MFInt32, MFFloat, MFDouble, MFString, or MFNode, the latter having children that are all Metadata nodes.
    """
    NAME = '_X3DMetadataObject'
    SPECIFICATION_URL = ''
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractObjectType X3DMetadataObject __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DPickableObject(_X3DNode):
    """
    The X3DPickableObject abstract object type marks a node as being capable of having customized picking performed on its contents or children.
    """
    NAME = '_X3DPickableObject'
    SPECIFICATION_URL = ''

class _X3DProgrammableShaderObject(_X3DNode):
    """
    Base type for all nodes that specify arbitrary fields for interfacing with per-object attribute values.
    """
    NAME = '_X3DProgrammableShaderObject'
    SPECIFICATION_URL = ''

class _X3DUrlObject(_X3DNode):
    """
    X3DUrlObject indicates that a node has content loaded from a Uniform Resource Locator (URL) and can be tracked via a LoadSensor. Such child nodes have containerField='watchList' to indicate their relationship to the parent LoadSensor node.
    """
    NAME = '_X3DUrlObject'
    SPECIFICATION_URL = ''

###############################################

# Statements

class _X3DStatement(object):
    """
    All X3D statements implement _X3DStatement abstract type.
    """
    NAME = '_X3DStatement'
    SPECIFICATION_URL = 'https://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/components/core.html#AbstractX3DStructure'
    def __repl__(self):
        result = self.NAME + '('
        # if _DEBUG: print(self.NAME + ' self.FIELD_DECLARATIONS: ' + str(self.FIELD_DECLARATIONS))
        for each in self.FIELD_DECLARATIONS:
            # if _DEBUG: print(self.NAME + ' for each in self.FIELD_DECLARATIONS: each=' + str(each))
            name = each[0]
            default = each[1]
            type_ = each[2]
            accessType = each[3]
            value = getattr(self, name)
            # if _DEBUG: print('gettattr(self, ' + str(name) + ') value="' + str(value) + '" for FIELD_DECLARATIONS ' + str(each) + ')')
            if value != default:
                if  isinstance(value, list): # avoid TypeError if value is not iterable
                    result += str(name) + '=['
                    for next in value:
                        result += str(next) + ', '
                        # if _DEBUG: print('* _X3DStatement debug: str(next)=' + str(next))
                    result = result.rstrip(', ')
                    result += '],'
                elif isinstance(value, str) and "'" in value:
                    result += str(name) + '=' + '"' + str(value) + '"' + ','
                elif isinstance(value, str) and value != default:
                    result += str(name) + '=' + "'" + str(value) + "'" + ','
                elif value != default:
                    result += str(name) + '='       + str(value)       + ','
                # elif _DEBUG:
                #   result += str(name) + '=' + "'" + str(value) + "'" + ','
        return result.strip().rstrip(',').rstrip(', ') + ')'
    def __str__(self):
        return self.__repl__().strip() # _X3DStatement

def isX3DStatement(value):
    return isinstance(value, _X3DStatement)

class Comment(_X3DStatement):
    """
    X3D statement containing zero or more comment strings.
    """
    NAME = 'Comment'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html'
    DEFAULT_VALUE = list()
    REGEX_XML = r'(\s|\S)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        """ value setter ensures that a correctly typed value is provided """
        if  value is None:
            value = self.DEFAULT_VALUE
        assertValidMFString(value)
        self.__value = value

def isComment(value):
    return isinstance(value, _X3DComment)

class component(_X3DStatement):
    """
    Functional summary: each added component statement indicates needed scene functionality support above the given X3D profile.
    """
    NAME = 'component'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#component'
    FIELD_DECLARATIONS = [('level', 1, FieldType.SFInt32, AccessType.inputOutput),
                          ('name', '', FieldType.SFString, AccessType.inputOutput)]
    def __init__(self,
                 level=1,
                 name=''):
        self.level = level
        self.name = name
    @property # getter - - - - - - - - - -
    def level(self):
        return self.__level
    @level.setter
    def level(self, level=None):
        if  level is None:
            level = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(level)
        assertGreaterThanEquals('level', level, 1)
        assertLessThanEquals('level', level, 5)
        self.__level = level
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function component.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<component'
        if self.level != 1:
            result += " level='" + self.level + "'"
        if self.name:
            result += " name='" + self.name + "'" + '>' + '\n'
        result += indent + '</component>' + '\n'
#       print('XML serialization complete.')
        return result

class connect(_X3DStatement):
    """
    Functional summary: connect statements define event-routing connections between node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields.
    """
    NAME = 'connect'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#connect'
    FIELD_DECLARATIONS = [('nodeField', '', FieldType.SFString, AccessType.inputOutput),
                          ('protoField', '', FieldType.SFString, AccessType.inputOutput)]
    def __init__(self,
                 nodeField='',
                 protoField=''):
        self.nodeField = nodeField
        self.protoField = protoField
    @property # getter - - - - - - - - - -
    def nodeField(self):
        return self.__nodeField
    @nodeField.setter
    def nodeField(self, nodeField=None):
        if  nodeField is None:
            nodeField = SFString.DEFAULT_VALUE
        assertValidSFString(nodeField)
        self.__nodeField = nodeField
    @property # getter - - - - - - - - - -
    def protoField(self):
        return self.__protoField
    @protoField.setter
    def protoField(self, protoField=None):
        if  protoField is None:
            protoField = SFString.DEFAULT_VALUE
        assertValidSFString(protoField)
        self.__protoField = protoField
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function connect.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<connect'
        if self.nodeField:
            result += " nodeField='" + self.nodeField + "'"
        if self.protoField:
            result += " protoField='" + self.protoField + "'" + '>' + '\n'
        result += indent + '</connect>' + '\n'
#       print('XML serialization complete.')
        return result

class EXPORT(_X3DStatement):
    """
    Functional summary: EXPORT exposes a local node for ROUTE passing of event values when the current Scene is included via Inline by a parent external world. These connections allow event values to be exchanged via ROUTE statements between a parent model and a child Inline model.
    """
    NAME = 'EXPORT'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#EXPORT'
    FIELD_DECLARATIONS = [('AS', '', FieldType.SFString, AccessType.inputOutput),
                          ('localDEF', '', FieldType.SFString, AccessType.inputOutput)]
    def __init__(self,
                 AS='',
                 localDEF=''):
        self.AS = AS
        self.localDEF = localDEF
    @property # getter - - - - - - - - - -
    def AS(self):
        return self.__AS
    @AS.setter
    def AS(self, AS=None):
        if  AS is None:
            AS = SFString.DEFAULT_VALUE
        assertValidSFString(AS)
        self.__AS = AS
    @property # getter - - - - - - - - - -
    def localDEF(self):
        return self.__localDEF
    @localDEF.setter
    def localDEF(self, localDEF=None):
        if  localDEF is None:
            localDEF = SFString.DEFAULT_VALUE
        assertValidSFString(localDEF)
        self.__localDEF = localDEF
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function EXPORT.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<EXPORT'
        if self.AS:
            result += " AS='" + self.AS + "'"
        if self.localDEF:
            result += " localDEF='" + self.localDEF + "'" + '>' + '\n'
        result += indent + '</EXPORT>' + '\n'
#       print('XML serialization complete.')
        return result

class ExternProtoDeclare(_X3DStatement):
    """
    ExternProtoDeclare refers to a ProtoDeclare node declaration provided in another file. ExternProtoDeclare interfaces are defined by field statements (and without IS/connect statements).
    """
    NAME = 'ExternProtoDeclare'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ExternProtoDeclare'
    FIELD_DECLARATIONS = [('appinfo', '', FieldType.SFString, AccessType.inputOutput),
                          ('documentation', '', FieldType.SFString, AccessType.inputOutput),
                          ('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('field', list(), FieldType.MFNode, AccessType.inputOutput)]
    def __init__(self,
                 appinfo='',
                 documentation='',
                 name='',
                 url=list(),
                 field=list()):
        self.appinfo = appinfo
        self.documentation = documentation
        self.name = name
        self.url = url
        self.field = field
    @property # getter - - - - - - - - - -
    def appinfo(self):
        return self.__appinfo
    @appinfo.setter
    def appinfo(self, appinfo=None):
        if  appinfo is None:
            appinfo = SFString.DEFAULT_VALUE
        assertValidSFString(appinfo)
        self.__appinfo = appinfo
    @property # getter - - - - - - - - - -
    def documentation(self):
        return self.__documentation
    @documentation.setter
    def documentation(self, documentation=None):
        if  documentation is None:
            documentation = SFString.DEFAULT_VALUE
        assertValidSFString(documentation)
        self.__documentation = documentation
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def field(self):
        return self.__field
    @field.setter
    def field(self, field=None):
        if  field is None:
            field = MFNode.DEFAULT_VALUE
        assertValidMFNode(field)
        self.__field = field
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ExternProtoDeclare.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ExternProtoDeclare'
        if self.appinfo:
            result += " appinfo='" + self.appinfo + "'"
        if self.documentation:
            result += " documentation='" + self.documentation + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.field: # walk each child node, if any
            result += indent
            for each in self.field:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ExternProtoDeclare>' + '\n'
#       print('XML serialization complete.')
        return result

class field(_X3DStatement):
    """
    Functional summary: a field statement defines an interface attribute or node. Each field statement can contain either attribute-value or node content.
    """
    NAME = 'field'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#field'
    FIELD_DECLARATIONS = [('accessType', '', FieldType.SFString, AccessType.inputOutput),
                          ('appinfo', '', FieldType.SFString, AccessType.inputOutput),
                          ('documentation', '', FieldType.SFString, AccessType.inputOutput),
                          ('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('type', '', FieldType.SFString, AccessType.inputOutput),
                          ('value', '', FieldType.SFString, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput)]
    def __init__(self,
                 accessType='',
                 appinfo='',
                 documentation='',
                 name='',
                 type='',
                 value='',
                 children=list()):
        self.accessType = accessType
        self.appinfo = appinfo
        self.documentation = documentation
        self.name = name
        self.type = type
        self.value = value
        self.children = children
    @property # getter - - - - - - - - - -
    def accessType(self):
        return self.__accessType
    @accessType.setter
    def accessType(self, accessType=None):
        if  accessType is None:
            accessType = SFString.DEFAULT_VALUE
        assertValidSFString(accessType)
        self.__accessType = accessType
    @property # getter - - - - - - - - - -
    def appinfo(self):
        return self.__appinfo
    @appinfo.setter
    def appinfo(self, appinfo=None):
        if  appinfo is None:
            appinfo = SFString.DEFAULT_VALUE
        assertValidSFString(appinfo)
        self.__appinfo = appinfo
    @property # getter - - - - - - - - - -
    def documentation(self):
        return self.__documentation
    @documentation.setter
    def documentation(self, documentation=None):
        if  documentation is None:
            documentation = SFString.DEFAULT_VALUE
        assertValidSFString(documentation)
        self.__documentation = documentation
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def type(self):
        return self.__type
    @type.setter
    def type(self, type=None):
        if  type is None:
            type = SFString.DEFAULT_VALUE
        assertValidSFString(type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        if  value is None:
            value = SFString.DEFAULT_VALUE
        assertValidSFString(value)
        self.__value = value
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function field.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<field'
        if self.accessType:
            result += " accessType='" + self.accessType + "'"
        if self.appinfo:
            result += " appinfo='" + self.appinfo + "'"
        if self.documentation:
            result += " documentation='" + self.documentation + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.type:
            result += " type='" + self.type + "'"
        if self.value:
            result += " value='" + self.value + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</field>' + '\n'
#       print('XML serialization complete.')
        return result

class fieldValue(_X3DStatement):
    """
    Functional summary: a fieldValue statement re-initializes the default value of a field in a ProtoInstance. Each fieldValue statement can contain either attribute-value or node content.
    """
    NAME = 'fieldValue'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#fieldValue'
    FIELD_DECLARATIONS = [('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('value', '', FieldType.SFString, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput)]
    def __init__(self,
                 name='',
                 value='',
                 children=list()):
        self.name = name
        self.value = value
        self.children = children
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        if  value is None:
            value = SFString.DEFAULT_VALUE
        assertValidSFString(value)
        self.__value = value
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function fieldValue.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<fieldValue'
        if self.name:
            result += " name='" + self.name + "'"
        if self.value:
            result += " value='" + self.value + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</fieldValue>' + '\n'
#       print('XML serialization complete.')
        return result

class head(_X3DStatement):
    """
    Functional summary: each X3D scene includes a head statement that can contain component, unit and meta statements.
    """
    NAME = 'head'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#head'
    FIELD_DECLARATIONS = [('children', None, FieldType.MFNode, AccessType.inputOutput)]
    def __init__(self, children=None):
        self.children = children
    @property # getter - - - - - - - - - -
    def children(self):
        """ contains component, unit and meta statements """
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function head.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<head' + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</head>' + '\n'
#       print('XML serialization complete.')
        return result

class IMPORT(_X3DStatement):
    """
    Functional summary: IMPORT provides ROUTE access to a node that has a corresponding EXPORT statement within an Inline scene. These connections allow event values to be exchanged via ROUTE statements between a parent model and a child Inline model.
    """
    NAME = 'IMPORT'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IMPORT'
    FIELD_DECLARATIONS = [('AS', '', FieldType.SFString, AccessType.inputOutput),
                          ('importedDEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('inlineDEF', '', FieldType.SFString, AccessType.inputOutput)]
    def __init__(self,
                 AS='',
                 importedDEF='',
                 inlineDEF=''):
        self.AS = AS
        self.importedDEF = importedDEF
        self.inlineDEF = inlineDEF
    @property # getter - - - - - - - - - -
    def AS(self):
        return self.__AS
    @AS.setter
    def AS(self, AS=None):
        if  AS is None:
            AS = SFString.DEFAULT_VALUE
        assertValidSFString(AS)
        self.__AS = AS
    @property # getter - - - - - - - - - -
    def importedDEF(self):
        return self.__importedDEF
    @importedDEF.setter
    def importedDEF(self, importedDEF=None):
        if  importedDEF is None:
            importedDEF = SFString.DEFAULT_VALUE
        assertValidSFString(importedDEF)
        self.__importedDEF = importedDEF
    @property # getter - - - - - - - - - -
    def inlineDEF(self):
        return self.__inlineDEF
    @inlineDEF.setter
    def inlineDEF(self, inlineDEF=None):
        if  inlineDEF is None:
            inlineDEF = SFString.DEFAULT_VALUE
        assertValidSFString(inlineDEF)
        self.__inlineDEF = inlineDEF
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function IMPORT.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<IMPORT'
        if self.AS:
            result += " AS='" + self.AS + "'"
        if self.importedDEF:
            result += " importedDEF='" + self.importedDEF + "'"
        if self.inlineDEF:
            result += " inlineDEF='" + self.inlineDEF + "'" + '>' + '\n'
        result += indent + '</IMPORT>' + '\n'
#       print('XML serialization complete.')
        return result

class IS(_X3DStatement):
    """
    Functional summary: the IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields. IS/connect statements can be added if the parent node is within a ProtoBody and connect statements define correspondences between prototype fields and built-in node fields.
    """
    NAME = 'IS'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IS'
    FIELD_DECLARATIONS = [('connect', list(), FieldType.MFNode, AccessType.inputOutput)]
    def __init__(self,
                 connect=list()):
        self.connect = connect
    @property # getter - - - - - - - - - -
    def connect(self):
        return self.__connect
    @connect.setter
    def connect(self, connect=None):
        if  connect is None:
            connect = MFNode.DEFAULT_VALUE
        assertValidMFNode(connect)
        self.__connect = connect
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function IS.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<IS' + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.connect: # walk each child node, if any
            result += indent
            for each in self.connect:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</IS>' + '\n'
#       print('XML serialization complete.')
        return result

class meta(_X3DStatement):
    """
    Functional summary: the meta statement provides metadata information about a scene, where name and content attributes provide attribute=value metadata pairs.
    """
    NAME = 'meta'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#meta'
    FIELD_DECLARATIONS = [('content', '', FieldType.SFString, AccessType.inputOutput),
                          ('dir', '', FieldType.SFString, AccessType.inputOutput),
                          ('httpequiv', '', FieldType.SFString, AccessType.inputOutput),
                          ('lang', '', FieldType.SFString, AccessType.inputOutput),
                          ('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('scheme', '', FieldType.SFString, AccessType.inputOutput)]
    def __init__(self,
                 content='',
                 dir='',
                 httpequiv='',
                 lang='',
                 name='',
                 scheme=''):
        self.content = content
        self.dir = dir
        self.httpequiv = httpequiv
        self.lang = lang
        self.name = name
        self.scheme = scheme
    @property # getter - - - - - - - - - -
    def content(self):
        return self.__content
    @content.setter
    def content(self, content=None):
        if  content is None:
            content = SFString.DEFAULT_VALUE
        assertValidSFString(content)
        self.__content = content
    @property # getter - - - - - - - - - -
    def dir(self):
        return self.__dir
    @dir.setter
    def dir(self, dir=None):
        if  dir is None:
            dir = SFString.DEFAULT_VALUE
        assertValidSFString(dir)
        self.__dir = dir
    @property # getter - - - - - - - - - -
    def httpequiv(self):
        return self.__httpequiv
    @httpequiv.setter
    def httpequiv(self, httpequiv=None):
        if  httpequiv is None:
            httpequiv = SFString.DEFAULT_VALUE
        assertValidSFString(httpequiv)
        self.__httpequiv = httpequiv
    @property # getter - - - - - - - - - -
    def lang(self):
        return self.__lang
    @lang.setter
    def lang(self, lang=None):
        if  lang is None:
            lang = SFString.DEFAULT_VALUE
        assertValidSFString(lang)
        self.__lang = lang
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def scheme(self):
        return self.__scheme
    @scheme.setter
    def scheme(self, scheme=None):
        if  scheme is None:
            scheme = SFString.DEFAULT_VALUE
        assertValidSFString(scheme)
        self.__scheme = scheme
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function meta.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<meta'
        if self.content:
            result += " content='" + self.content + "'"
        if self.dir:
            result += " dir='" + self.dir + "'"
        if self.httpequiv:
            result += " httpequiv='" + self.httpequiv + "'"
        if self.lang:
            result += " lang='" + self.lang + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.scheme:
            result += " scheme='" + self.scheme + "'" + '>' + '\n'
        result += indent + '</meta>' + '\n'
#       print('XML serialization complete.')
        return result

class ProtoBody(_X3DStatement):
    """
    ProtoBody contains the definition nodes for new Prototype nodes.
    """
    NAME = 'ProtoBody'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoBody'
    FIELD_DECLARATIONS = [('children', list(), FieldType.MFNode, AccessType.inputOutput)]
    def __init__(self,
                 children=list()):
        self.children = children
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ProtoBody.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ProtoBody' + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ProtoBody>' + '\n'
#       print('XML serialization complete.')
        return result

class ProtoDeclare(_X3DStatement):
    """
    ProtoDeclare defines new Prototype nodes. Nested ProtoDeclares and ProtoInstances are allowed by the specification.
    """
    NAME = 'ProtoDeclare'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoDeclare'
    FIELD_DECLARATIONS = [('appinfo', '', FieldType.SFString, AccessType.inputOutput),
                          ('documentation', '', FieldType.SFString, AccessType.inputOutput),
                          ('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('ProtoBody', None, FieldType.SFNode, AccessType.inputOutput),
                          ('ProtoInterface', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 appinfo='',
                 documentation='',
                 name='',
                 ProtoBody=None,
                 ProtoInterface=None):
        self.appinfo = appinfo
        self.documentation = documentation
        self.name = name
        self.ProtoBody = ProtoBody
        self.ProtoInterface = ProtoInterface
    @property # getter - - - - - - - - - -
    def appinfo(self):
        return self.__appinfo
    @appinfo.setter
    def appinfo(self, appinfo=None):
        if  appinfo is None:
            appinfo = SFString.DEFAULT_VALUE
        assertValidSFString(appinfo)
        self.__appinfo = appinfo
    @property # getter - - - - - - - - - -
    def documentation(self):
        return self.__documentation
    @documentation.setter
    def documentation(self, documentation=None):
        if  documentation is None:
            documentation = SFString.DEFAULT_VALUE
        assertValidSFString(documentation)
        self.__documentation = documentation
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def ProtoBody(self):
        return self.__ProtoBody
    @ProtoBody.setter
    def ProtoBody(self, ProtoBody=None):
        if  ProtoBody is None:
            ProtoBody = SFNode.DEFAULT_VALUE
        assertValidSFNode(ProtoBody)
        if not isinstance(ProtoBody, object):
            print(flush=True)
            raise TypeError(str(ProtoBody) + ' does not have a valid node type object')
        self.__ProtoBody = ProtoBody
    @property # getter - - - - - - - - - -
    def ProtoInterface(self):
        return self.__ProtoInterface
    @ProtoInterface.setter
    def ProtoInterface(self, ProtoInterface=None):
        if  ProtoInterface is None:
            ProtoInterface = SFNode.DEFAULT_VALUE
        assertValidSFNode(ProtoInterface)
        if not isinstance(ProtoInterface, object):
            print(flush=True)
            raise TypeError(str(ProtoInterface) + ' does not have a valid node type object')
        self.__ProtoInterface = ProtoInterface
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ProtoDeclare.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ProtoDeclare'
        if self.appinfo:
            result += " appinfo='" + self.appinfo + "'"
        if self.documentation:
            result += " documentation='" + self.documentation + "'"
        if self.name:
            result += " name='" + self.name + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.ProtoBody: # walk each child node, if any
            result += indent
            for each in self.ProtoBody:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.ProtoInterface: # walk each child node, if any
            result += indent
            for each in self.ProtoInterface:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ProtoDeclare>' + '\n'
#       print('XML serialization complete.')
        return result

class ProtoInterface(_X3DStatement):
    """
    ProtoInterface defines fields for new Prototype nodes.
    """
    NAME = 'ProtoInterface'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoInterface'
    FIELD_DECLARATIONS = [('field', list(), FieldType.MFNode, AccessType.inputOutput)]
    def __init__(self,
                 field=list()):
        self.field = field
    @property # getter - - - - - - - - - -
    def field(self):
        return self.__field
    @field.setter
    def field(self, field=None):
        if  field is None:
            field = MFNode.DEFAULT_VALUE
        assertValidMFNode(field)
        self.__field = field
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ProtoInterface.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ProtoInterface' + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.field: # walk each child node, if any
            result += indent
            for each in self.field:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ProtoInterface>' + '\n'
#       print('XML serialization complete.')
        return result

class ROUTE(_X3DStatement):
    """
    ROUTE connects output fields of event-producing nodes to input fields of event-consuming nodes.
    """
    NAME = 'ROUTE'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ROUTE'
    FIELD_DECLARATIONS = [('fromField', '', FieldType.SFString, AccessType.inputOutput),
                          ('fromNode', '', FieldType.SFString, AccessType.inputOutput),
                          ('toField', '', FieldType.SFString, AccessType.inputOutput),
                          ('toNode', '', FieldType.SFString, AccessType.inputOutput)]
    def __init__(self,
                 fromField='',
                 fromNode='',
                 toField='',
                 toNode=''):
        self.fromField = fromField
        self.fromNode = fromNode
        self.toField = toField
        self.toNode = toNode
    @property # getter - - - - - - - - - -
    def fromField(self):
        return self.__fromField
    @fromField.setter
    def fromField(self, fromField=None):
        if  fromField is None:
            fromField = SFString.DEFAULT_VALUE
        assertValidSFString(fromField)
        self.__fromField = fromField
    @property # getter - - - - - - - - - -
    def fromNode(self):
        return self.__fromNode
    @fromNode.setter
    def fromNode(self, fromNode=None):
        if  fromNode is None:
            fromNode = SFString.DEFAULT_VALUE
        assertValidSFString(fromNode)
        self.__fromNode = fromNode
    @property # getter - - - - - - - - - -
    def toField(self):
        return self.__toField
    @toField.setter
    def toField(self, toField=None):
        if  toField is None:
            toField = SFString.DEFAULT_VALUE
        assertValidSFString(toField)
        self.__toField = toField
    @property # getter - - - - - - - - - -
    def toNode(self):
        return self.__toNode
    @toNode.setter
    def toNode(self, toNode=None):
        if  toNode is None:
            toNode = SFString.DEFAULT_VALUE
        assertValidSFString(toNode)
        self.__toNode = toNode
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ROUTE.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ROUTE'
        if self.fromField:
            result += " fromField='" + self.fromField + "'"
        if self.fromNode:
            result += " fromNode='" + self.fromNode + "'"
        if self.toField:
            result += " toField='" + self.toField + "'"
        if self.toNode:
            result += " toNode='" + self.toNode + "'" + '>' + '\n'
        result += indent + '</ROUTE>' + '\n'
#       print('XML serialization complete.')
        return result

class Scene(_X3DStatement):
    """
    Scene is the implicit root node of the X3D scene graph.
    """
    NAME = 'Scene'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Scene'
    FIELD_DECLARATIONS = [('children', list(), FieldType.MFNode, AccessType.inputOutput)]
    def __init__(self,
                 children=list()):
        self.children = children
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Scene.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Scene' + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Scene>' + '\n'
#       print('XML serialization complete.')
        return result

class unit(_X3DStatement):
    """
    Functional summary: unit statement defines data-conversion factors for typed values defined in a scene.
    """
    NAME = 'unit'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#unit'
    FIELD_DECLARATIONS = [('category', '', FieldType.SFString, AccessType.initializeOnly),
                          ('conversionFactor', 1.0, FieldType.SFDouble, AccessType.inputOutput),
                          ('name', '', FieldType.SFString, AccessType.inputOutput)]
    def __init__(self,
                 category='',
                 conversionFactor=1.0,
                 name=''):
        self.category = category
        self.conversionFactor = conversionFactor
        self.name = name
    @property # getter - - - - - - - - - -
    def category(self):
        return self.__category
    @category.setter
    def category(self, category=None):
        if  category is None:
            category = SFString.DEFAULT_VALUE
        assertValidSFString(category)
        self.__category = category
    @property # getter - - - - - - - - - -
    def conversionFactor(self):
        return self.__conversionFactor
    @conversionFactor.setter
    def conversionFactor(self, conversionFactor=None):
        if  conversionFactor is None:
            conversionFactor = SFDouble.DEFAULT_VALUE
        assertValidSFDouble(conversionFactor)
        assertPositive('conversionFactor', conversionFactor)
        self.__conversionFactor = conversionFactor
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function unit.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<unit'
        if self.category:
            result += " category='" + self.category + "'"
        if self.conversionFactor != 1.0:
            result += " conversionFactor='" + self.conversionFactor + "'"
        if self.name:
            result += " name='" + self.name + "'" + '>' + '\n'
        result += indent + '</unit>' + '\n'
#       print('XML serialization complete.')
        return result

class X3D(_X3DNode):
    """
    X3D is the root node for an Extensible 3D (X3D) Graphics model.
    """
    NAME = 'X3D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#X3D'
    XML_HEADER = '<?xml version="1.0" encoding="UTF-8"?>'
    XML_DOCTYPE_X3D_3_0 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.0//EN" "http://www.web3d.org/specifications/x3d-3.0.dtd">'
    XML_DOCTYPE_X3D_3_1 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.1//EN" "http://www.web3d.org/specifications/x3d-3.1.dtd">'
    XML_DOCTYPE_X3D_3_2 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.2//EN" "http://www.web3d.org/specifications/x3d-3.2.dtd">'
    XML_DOCTYPE_X3D_3_3 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.3//EN" "http://www.web3d.org/specifications/x3d-3.3.dtd">'
    XML_DOCTYPE_X3D_4_0 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 4.0//EN" "http://www.web3d.org/specifications/x3d-4.0.dtd">'
    X3D_XML_SCHEMA_ATTRIBUTES_3_0 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.0.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_3_1 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.1.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_3_2 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.2.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_3_3 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.3.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_4_0 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-4.0.xsd'"
    FIELD_DECLARATIONS = [('profile', 'Immersive', FieldType.SFString, AccessType.inputOutput),
                          ('version', '3.3', FieldType.SFString, AccessType.inputOutput),
                          ('head', None, FieldType.SFNode, AccessType.inputOutput),
                          ('Scene', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 profile='Immersive',
                 version='3.3',
                 head=None,
                 Scene=None):
        self.profile = profile
        self.version = version
        self.head = head
        self.Scene = Scene
    @property # getter - - - - - - - - - -
    def profile(self):
        return self.__profile
    @profile.setter
    def profile(self, profile=None):
        if  profile is None:
            profile = SFString.DEFAULT_VALUE
        assertValidSFString(profile)
        self.__profile = profile
    @property # getter - - - - - - - - - -
    def version(self):
        return self.__version
    @version.setter
    def version(self, version=None):
        if  version is None:
            version = SFString.DEFAULT_VALUE
        assertValidSFString(version)
        self.__version = version
    @property # getter - - - - - - - - - -
    def head(self):
        return self.__head
    @head.setter
    def head(self, head=None):
        if  head is None:
            head = SFNode.DEFAULT_VALUE
        assertValidSFNode(head)
        if not isinstance(head, object):
            print(flush=True)
            raise TypeError(str(head) + ' does not have a valid node type object')
        self.__head = head
    @property # getter - - - - - - - - - -
    def Scene(self):
        return self.__Scene
    @Scene.setter
    def Scene(self, Scene=None):
        if  Scene is None:
            Scene = SFNode.DEFAULT_VALUE
        assertValidSFNode(Scene)
        if not isinstance(Scene, object):
            print(flush=True)
            raise TypeError(str(Scene) + ' does not have a valid node type object')
        self.__Scene = Scene
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function X3D.toXML(indentLevel=' + str(indentLevel) + '), indent="' + indent + '"' + '\n'
        result += indent + self.XML_HEADER + '\n'
        if self.version == '3.0':
            result += indent + self.XML_DOCTYPE_X3D_3_0 + '\n'
        elif self.version == '3.1':
            result += indent + self.XML_DOCTYPE_X3D_3_1 + '\n'
        elif self.version == '3.2':
            result += indent + self.XML_DOCTYPE_X3D_3_2 + '\n'
        elif self.version == '3.3':
            result += indent + self.XML_DOCTYPE_X3D_3_3 + '\n'
        elif self.version == '4.0':
            result += indent + self.XML_DOCTYPE_X3D_4_0 + '\n'
        elif self.version == '4.1':
            result += indent + self.XML_DOCTYPE_X3D_4_1 + '\n'
        result += indent + "<X3D profile='" + self.profile +"' version='" + self.version +"' "
        if self.version == '3.0':
            result += self.X3D_XML_SCHEMA_ATTRIBUTES_3_0
        elif self.version == '3.1':
            result += self.X3D_XML_SCHEMA_ATTRIBUTES_3_1
        elif self.version == '3.2':
            result += self.X3D_XML_SCHEMA_ATTRIBUTES_3_2
        elif self.version == '3.3':
            result += self.X3D_XML_SCHEMA_ATTRIBUTES_3_3
        elif self.version == '4.0':
            result += self.X3D_XML_SCHEMA_ATTRIBUTES_4_0
        elif self.version == '4.1':
            result += self.X3D_XML_SCHEMA_ATTRIBUTES_4_1
        result += '>' + '\n'
        if self.head:
            result += self.head.toXML(indentLevel=indentLevel+1)
        if self.Scene:
            result += self.Scene.toXML(indentLevel=indentLevel+1)
        result += '</X3D>' + '\n'
#       print('XML serialization complete.')
        return result

###############################################

# Concrete Nodes

def isX3DNode(value):
    return isinstance(value, _X3DNode)

class Anchor(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'Anchor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Anchor'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('parameter', list(), FieldType.MFString, AccessType.inputOutput),
                          ('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 description='',
                 parameter=list(),
                 url=list(),
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Anchor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.description = description
        self.parameter = parameter
        self.url = url
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def parameter(self):
        return self.__parameter
    @parameter.setter
    def parameter(self, parameter=None):
        if  parameter is None:
            parameter = MFString.DEFAULT_VALUE
        assertValidMFString(parameter)
        self.__parameter = parameter
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Anchor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Anchor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.parameter != list():
            result += " parameter='" + self.parameter + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Anchor>' + '\n'
#       print('XML serialization complete.')
        return result

class Appearance(_X3DAppearanceNode):
    """
    X3D element
    """
    NAME = 'Appearance'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Appearance'
    FIELD_DECLARATIONS = [('fillProperties', None, FieldType.SFNode, AccessType.inputOutput),
                          ('lineProperties', None, FieldType.SFNode, AccessType.inputOutput),
                          ('material', None, FieldType.SFNode, AccessType.inputOutput),
                          ('pointProperties', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texture', None, FieldType.SFNode, AccessType.inputOutput),
                          ('textureTransform', None, FieldType.SFNode, AccessType.inputOutput),
                          ('shaders', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 fillProperties=None,
                 lineProperties=None,
                 material=None,
                 pointProperties=None,
                 texture=None,
                 textureTransform=None,
                 shaders=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Appearance __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.fillProperties = fillProperties
        self.lineProperties = lineProperties
        self.material = material
        self.pointProperties = pointProperties
        self.texture = texture
        self.textureTransform = textureTransform
        self.shaders = shaders
    @property # getter - - - - - - - - - -
    def fillProperties(self):
        return self.__fillProperties
    @fillProperties.setter
    def fillProperties(self, fillProperties=None):
        if  fillProperties is None:
            fillProperties = SFNode.DEFAULT_VALUE
        assertValidSFNode(fillProperties)
        if not isinstance(fillProperties, object):
            print(flush=True)
            raise TypeError(str(fillProperties) + ' does not have a valid node type object')
        self.__fillProperties = fillProperties
    @property # getter - - - - - - - - - -
    def lineProperties(self):
        return self.__lineProperties
    @lineProperties.setter
    def lineProperties(self, lineProperties=None):
        if  lineProperties is None:
            lineProperties = SFNode.DEFAULT_VALUE
        assertValidSFNode(lineProperties)
        if not isinstance(lineProperties, object):
            print(flush=True)
            raise TypeError(str(lineProperties) + ' does not have a valid node type object')
        self.__lineProperties = lineProperties
    @property # getter - - - - - - - - - -
    def material(self):
        return self.__material
    @material.setter
    def material(self, material=None):
        if  material is None:
            material = SFNode.DEFAULT_VALUE
        assertValidSFNode(material)
        if not isinstance(material, object):
            print(flush=True)
            raise TypeError(str(material) + ' does not have a valid node type object')
        self.__material = material
    @property # getter - - - - - - - - - -
    def pointProperties(self):
        return self.__pointProperties
    @pointProperties.setter
    def pointProperties(self, pointProperties=None):
        if  pointProperties is None:
            pointProperties = SFNode.DEFAULT_VALUE
        assertValidSFNode(pointProperties)
        if not isinstance(pointProperties, object):
            print(flush=True)
            raise TypeError(str(pointProperties) + ' does not have a valid node type object')
        self.__pointProperties = pointProperties
    @property # getter - - - - - - - - - -
    def texture(self):
        return self.__texture
    @texture.setter
    def texture(self, texture=None):
        if  texture is None:
            texture = SFNode.DEFAULT_VALUE
        assertValidSFNode(texture)
        if not isinstance(texture, object):
            print(flush=True)
            raise TypeError(str(texture) + ' does not have a valid node type object')
        self.__texture = texture
    @property # getter - - - - - - - - - -
    def textureTransform(self):
        return self.__textureTransform
    @textureTransform.setter
    def textureTransform(self, textureTransform=None):
        if  textureTransform is None:
            textureTransform = SFNode.DEFAULT_VALUE
        assertValidSFNode(textureTransform)
        if not isinstance(textureTransform, object):
            print(flush=True)
            raise TypeError(str(textureTransform) + ' does not have a valid node type object')
        self.__textureTransform = textureTransform
    @property # getter - - - - - - - - - -
    def shaders(self):
        return self.__shaders
    @shaders.setter
    def shaders(self, shaders=None):
        if  shaders is None:
            shaders = MFNode.DEFAULT_VALUE
        assertValidMFNode(shaders)
        self.__shaders = shaders
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Appearance.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Appearance'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fillProperties: # walk each child node, if any
            result += indent
            for each in self.fillProperties:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.lineProperties: # walk each child node, if any
            result += indent
            for each in self.lineProperties:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.material: # walk each child node, if any
            result += indent
            for each in self.material:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.pointProperties: # walk each child node, if any
            result += indent
            for each in self.pointProperties:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texture: # walk each child node, if any
            result += indent
            for each in self.texture:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.textureTransform: # walk each child node, if any
            result += indent
            for each in self.textureTransform:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.shaders: # walk each child node, if any
            result += indent
            for each in self.shaders:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Appearance>' + '\n'
#       print('XML serialization complete.')
        return result

class Arc2D(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'Arc2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Arc2D'
    FIELD_DECLARATIONS = [('endAngle', 1.570796, FieldType.SFFloat, AccessType.initializeOnly),
                          ('radius', 1, FieldType.SFFloat, AccessType.initializeOnly),
                          ('startAngle', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 endAngle=1.570796,
                 radius=1,
                 startAngle=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Arc2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.endAngle = endAngle
        self.radius = radius
        self.startAngle = startAngle
    @property # getter - - - - - - - - - -
    def endAngle(self):
        return self.__endAngle
    @endAngle.setter
    def endAngle(self, endAngle=None):
        if  endAngle is None:
            endAngle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(endAngle)
        assertGreaterThan('endAngle', endAngle, -6.2832)
        assertLessThan('endAngle', endAngle, 6.2832)
        self.__endAngle = endAngle
    @property # getter - - - - - - - - - -
    def radius(self):
        return self.__radius
    @radius.setter
    def radius(self, radius=None):
        if  radius is None:
            radius = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def startAngle(self):
        return self.__startAngle
    @startAngle.setter
    def startAngle(self, startAngle=None):
        if  startAngle is None:
            startAngle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(startAngle)
        assertGreaterThan('startAngle', startAngle, -6.2832)
        assertLessThan('startAngle', startAngle, 6.2832)
        self.__startAngle = startAngle
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Arc2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Arc2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.endAngle != 1.570796:
            result += " endAngle='" + self.endAngle + "'"
        if self.radius != 1:
            result += " radius='" + self.radius + "'"
        if self.startAngle != 0:
            result += " startAngle='" + self.startAngle + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Arc2D>' + '\n'
#       print('XML serialization complete.')
        return result

class ArcClose2D(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'ArcClose2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ArcClose2D'
    FIELD_DECLARATIONS = [('closureType', 'PIE', FieldType.SFString, AccessType.initializeOnly),
                          ('endAngle', 1.570796, FieldType.SFFloat, AccessType.initializeOnly),
                          ('radius', 1, FieldType.SFFloat, AccessType.initializeOnly),
                          ('solid', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('startAngle', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 closureType='PIE',
                 endAngle=1.570796,
                 radius=1,
                 solid=False,
                 startAngle=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ArcClose2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.closureType = closureType
        self.endAngle = endAngle
        self.radius = radius
        self.solid = solid
        self.startAngle = startAngle
    @property # getter - - - - - - - - - -
    def closureType(self):
        return self.__closureType
    @closureType.setter
    def closureType(self, closureType=None):
        if  closureType is None:
            closureType = SFString.DEFAULT_VALUE
        assertValidSFString(closureType)
        self.__closureType = closureType
    @property # getter - - - - - - - - - -
    def endAngle(self):
        return self.__endAngle
    @endAngle.setter
    def endAngle(self, endAngle=None):
        if  endAngle is None:
            endAngle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(endAngle)
        assertGreaterThan('endAngle', endAngle, -6.2832)
        assertLessThan('endAngle', endAngle, 6.2832)
        self.__endAngle = endAngle
    @property # getter - - - - - - - - - -
    def radius(self):
        return self.__radius
    @radius.setter
    def radius(self, radius=None):
        if  radius is None:
            radius = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def startAngle(self):
        return self.__startAngle
    @startAngle.setter
    def startAngle(self, startAngle=None):
        if  startAngle is None:
            startAngle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(startAngle)
        assertGreaterThan('startAngle', startAngle, -6.2832)
        assertLessThan('startAngle', startAngle, 6.2832)
        self.__startAngle = startAngle
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ArcClose2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ArcClose2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.closureType != 'PIE':
            result += " closureType='" + self.closureType + "'"
        if self.endAngle != 1.570796:
            result += " endAngle='" + self.endAngle + "'"
        if self.radius != 1:
            result += " radius='" + self.radius + "'"
        if self.solid != False:
            result += " solid='" + self.solid + "'"
        if self.startAngle != 0:
            result += " startAngle='" + self.startAngle + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ArcClose2D>' + '\n'
#       print('XML serialization complete.')
        return result

class AudioClip(_X3DSoundSourceNode):
    """
    X3D element
    """
    NAME = 'AudioClip'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#AudioClip'
    FIELD_DECLARATIONS = [('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('loop', False, FieldType.SFBool, AccessType.inputOutput),
                          ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('pitch', 1.0, FieldType.SFFloat, AccessType.inputOutput),
                          ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('startTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 description='',
                 loop=False,
                 pauseTime=0,
                 pitch=1.0,
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 url=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode AudioClip __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.loop = loop
        self.pauseTime = pauseTime
        self.pitch = pitch
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.url = url
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def loop(self):
        return self.__loop
    @loop.setter
    def loop(self, loop=None):
        if  loop is None:
            loop = SFBool.DEFAULT_VALUE
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime=None):
        if  pauseTime is None:
            pauseTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def pitch(self):
        return self.__pitch
    @pitch.setter
    def pitch(self, pitch=None):
        if  pitch is None:
            pitch = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(pitch)
        assertPositive('pitch', pitch)
        self.__pitch = pitch
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime=None):
        if  resumeTime is None:
            resumeTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime=None):
        if  startTime is None:
            startTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime=None):
        if  stopTime is None:
            stopTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function AudioClip.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<AudioClip'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.loop != False:
            result += " loop='" + self.loop + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + self.pauseTime + "'"
        if self.pitch != 1.0:
            result += " pitch='" + self.pitch + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + self.resumeTime + "'"
        if self.startTime != 0:
            result += " startTime='" + self.startTime + "'"
        if self.stopTime != 0:
            result += " stopTime='" + self.stopTime + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</AudioClip>' + '\n'
#       print('XML serialization complete.')
        return result

class Background(_X3DBackgroundNode):
    """
    X3D element
    """
    NAME = 'Background'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Background'
    FIELD_DECLARATIONS = [('backUrl', list(), FieldType.MFString, AccessType.inputOutput),
                          ('bottomUrl', list(), FieldType.MFString, AccessType.inputOutput),
                          ('frontUrl', list(), FieldType.MFString, AccessType.inputOutput),
                          ('groundAngle', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('groundColor', list(), FieldType.MFColor, AccessType.inputOutput),
                          ('leftUrl', list(), FieldType.MFString, AccessType.inputOutput),
                          ('rightUrl', list(), FieldType.MFString, AccessType.inputOutput),
                          ('skyAngle', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('skyColor', [0, 0, 0], FieldType.MFColor, AccessType.inputOutput),
                          ('topUrl', list(), FieldType.MFString, AccessType.inputOutput),
                          ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 backUrl=list(),
                 bottomUrl=list(),
                 frontUrl=list(),
                 groundAngle=list(),
                 groundColor=list(),
                 leftUrl=list(),
                 rightUrl=list(),
                 skyAngle=list(),
                 skyColor=[0, 0, 0],
                 topUrl=list(),
                 transparency=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Background __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.backUrl = backUrl
        self.bottomUrl = bottomUrl
        self.frontUrl = frontUrl
        self.groundAngle = groundAngle
        self.groundColor = groundColor
        self.leftUrl = leftUrl
        self.rightUrl = rightUrl
        self.skyAngle = skyAngle
        self.skyColor = skyColor
        self.topUrl = topUrl
        self.transparency = transparency
    @property # getter - - - - - - - - - -
    def backUrl(self):
        return self.__backUrl
    @backUrl.setter
    def backUrl(self, backUrl=None):
        if  backUrl is None:
            backUrl = MFString.DEFAULT_VALUE
        assertValidMFString(backUrl)
        self.__backUrl = backUrl
    @property # getter - - - - - - - - - -
    def bottomUrl(self):
        return self.__bottomUrl
    @bottomUrl.setter
    def bottomUrl(self, bottomUrl=None):
        if  bottomUrl is None:
            bottomUrl = MFString.DEFAULT_VALUE
        assertValidMFString(bottomUrl)
        self.__bottomUrl = bottomUrl
    @property # getter - - - - - - - - - -
    def frontUrl(self):
        return self.__frontUrl
    @frontUrl.setter
    def frontUrl(self, frontUrl=None):
        if  frontUrl is None:
            frontUrl = MFString.DEFAULT_VALUE
        assertValidMFString(frontUrl)
        self.__frontUrl = frontUrl
    @property # getter - - - - - - - - - -
    def groundAngle(self):
        return self.__groundAngle
    @groundAngle.setter
    def groundAngle(self, groundAngle=None):
        if  groundAngle is None:
            groundAngle = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(groundAngle)
        assertGreaterThanEquals('groundAngle', groundAngle, 0)
        assertLessThanEquals('groundAngle', groundAngle, 1.5708)
        self.__groundAngle = groundAngle
    @property # getter - - - - - - - - - -
    def groundColor(self):
        return self.__groundColor
    @groundColor.setter
    def groundColor(self, groundColor=None):
        if  groundColor is None:
            groundColor = MFColor.DEFAULT_VALUE
        assertValidMFColor(groundColor)
        assertZeroToOne('groundColor', groundColor)
        self.__groundColor = groundColor
    @property # getter - - - - - - - - - -
    def leftUrl(self):
        return self.__leftUrl
    @leftUrl.setter
    def leftUrl(self, leftUrl=None):
        if  leftUrl is None:
            leftUrl = MFString.DEFAULT_VALUE
        assertValidMFString(leftUrl)
        self.__leftUrl = leftUrl
    @property # getter - - - - - - - - - -
    def rightUrl(self):
        return self.__rightUrl
    @rightUrl.setter
    def rightUrl(self, rightUrl=None):
        if  rightUrl is None:
            rightUrl = MFString.DEFAULT_VALUE
        assertValidMFString(rightUrl)
        self.__rightUrl = rightUrl
    @property # getter - - - - - - - - - -
    def skyAngle(self):
        return self.__skyAngle
    @skyAngle.setter
    def skyAngle(self, skyAngle=None):
        if  skyAngle is None:
            skyAngle = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(skyAngle)
        assertGreaterThanEquals('skyAngle', skyAngle, 0)
        assertLessThanEquals('skyAngle', skyAngle, 3.1416)
        self.__skyAngle = skyAngle
    @property # getter - - - - - - - - - -
    def skyColor(self):
        return self.__skyColor
    @skyColor.setter
    def skyColor(self, skyColor=None):
        if  skyColor is None:
            skyColor = MFColor.DEFAULT_VALUE
        assertValidMFColor(skyColor)
        assertZeroToOne('skyColor', skyColor)
        self.__skyColor = skyColor
    @property # getter - - - - - - - - - -
    def topUrl(self):
        return self.__topUrl
    @topUrl.setter
    def topUrl(self, topUrl=None):
        if  topUrl is None:
            topUrl = MFString.DEFAULT_VALUE
        assertValidMFString(topUrl)
        self.__topUrl = topUrl
    @property # getter - - - - - - - - - -
    def transparency(self):
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency=None):
        if  transparency is None:
            transparency = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Background.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Background'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.backUrl != list():
            result += " backUrl='" + self.backUrl + "'"
        if self.bottomUrl != list():
            result += " bottomUrl='" + self.bottomUrl + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.frontUrl != list():
            result += " frontUrl='" + self.frontUrl + "'"
        if self.groundAngle != list():
            result += " groundAngle='" + self.groundAngle + "'"
        if self.groundColor != list():
            result += " groundColor='" + self.groundColor + "'"
        if self.leftUrl != list():
            result += " leftUrl='" + self.leftUrl + "'"
        if self.rightUrl != list():
            result += " rightUrl='" + self.rightUrl + "'"
        if self.skyAngle != list():
            result += " skyAngle='" + self.skyAngle + "'"
        if self.skyColor != [0, 0, 0]:
            result += " skyColor='" + self.skyColor + "'"
        if self.topUrl != list():
            result += " topUrl='" + self.topUrl + "'"
        if self.transparency != 0:
            result += " transparency='" + self.transparency + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Background>' + '\n'
#       print('XML serialization complete.')
        return result

class BallJoint(_X3DRigidJointNode):
    """
    BallJoint represents an unconstrained joint between two bodies that pivot about a common anchor point.
    """
    NAME = 'BallJoint'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BallJoint'
    FIELD_DECLARATIONS = [('anchorPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput),
                          ('body1', None, FieldType.SFNode, AccessType.inputOutput),
                          ('body2', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 anchorPoint=(0, 0, 0),
                 forceOutput=["NONE"],
                 body1=None,
                 body2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BallJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.anchorPoint = anchorPoint
        self.forceOutput = forceOutput
        self.body1 = body1
        self.body2 = body2
    @property # getter - - - - - - - - - -
    def anchorPoint(self):
        return self.__anchorPoint
    @anchorPoint.setter
    def anchorPoint(self, anchorPoint=None):
        if  anchorPoint is None:
            anchorPoint = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(anchorPoint)
        self.__anchorPoint = anchorPoint
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput=None):
        if  forceOutput is None:
            forceOutput = MFString.DEFAULT_VALUE
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1=None):
        if  body1 is None:
            body1 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            print(flush=True)
            raise TypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2=None):
        if  body2 is None:
            body2 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            print(flush=True)
            raise TypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function BallJoint.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<BallJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.anchorPoint != (0, 0, 0):
            result += " anchorPoint='" + self.anchorPoint + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.forceOutput != ["NONE"]:
            result += " forceOutput='" + self.forceOutput + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body1: # walk each child node, if any
            result += indent
            for each in self.body1:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body2: # walk each child node, if any
            result += indent
            for each in self.body2:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</BallJoint>' + '\n'
#       print('XML serialization complete.')
        return result

class Billboard(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'Billboard'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Billboard'
    FIELD_DECLARATIONS = [('axisOfRotation', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 axisOfRotation=(0, 1, 0),
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Billboard __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.axisOfRotation = axisOfRotation
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.children = children
    @property # getter - - - - - - - - - -
    def axisOfRotation(self):
        return self.__axisOfRotation
    @axisOfRotation.setter
    def axisOfRotation(self, axisOfRotation=None):
        if  axisOfRotation is None:
            axisOfRotation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(axisOfRotation)
        self.__axisOfRotation = axisOfRotation
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Billboard.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Billboard'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.axisOfRotation != (0, 1, 0):
            result += " axisOfRotation='" + self.axisOfRotation + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Billboard>' + '\n'
#       print('XML serialization complete.')
        return result

class BlendedVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    X3D element
    """
    NAME = 'BlendedVolumeStyle'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BlendedVolumeStyle'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('weightConstant1', 0.5, FieldType.SFFloat, AccessType.inputOutput),
                          ('weightConstant2', 0.5, FieldType.SFFloat, AccessType.inputOutput),
                          ('weightFunction1', 'CONSTANT', FieldType.SFString, AccessType.inputOutput),
                          ('weightFunction2', 'CONSTANT', FieldType.SFString, AccessType.inputOutput),
                          ('renderStyle', None, FieldType.SFNode, AccessType.inputOutput),
                          ('voxels', None, FieldType.SFNode, AccessType.inputOutput),
                          ('weightTransferFunction1', None, FieldType.SFNode, AccessType.inputOutput),
                          ('weightTransferFunction2', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 weightConstant1=0.5,
                 weightConstant2=0.5,
                 weightFunction1='CONSTANT',
                 weightFunction2='CONSTANT',
                 renderStyle=None,
                 voxels=None,
                 weightTransferFunction1=None,
                 weightTransferFunction2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BlendedVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.weightConstant1 = weightConstant1
        self.weightConstant2 = weightConstant2
        self.weightFunction1 = weightFunction1
        self.weightFunction2 = weightFunction2
        self.renderStyle = renderStyle
        self.voxels = voxels
        self.weightTransferFunction1 = weightTransferFunction1
        self.weightTransferFunction2 = weightTransferFunction2
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def weightConstant1(self):
        return self.__weightConstant1
    @weightConstant1.setter
    def weightConstant1(self, weightConstant1=None):
        if  weightConstant1 is None:
            weightConstant1 = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(weightConstant1)
        assertZeroToOne('weightConstant1', weightConstant1)
        self.__weightConstant1 = weightConstant1
    @property # getter - - - - - - - - - -
    def weightConstant2(self):
        return self.__weightConstant2
    @weightConstant2.setter
    def weightConstant2(self, weightConstant2=None):
        if  weightConstant2 is None:
            weightConstant2 = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(weightConstant2)
        assertZeroToOne('weightConstant2', weightConstant2)
        self.__weightConstant2 = weightConstant2
    @property # getter - - - - - - - - - -
    def weightFunction1(self):
        return self.__weightFunction1
    @weightFunction1.setter
    def weightFunction1(self, weightFunction1=None):
        if  weightFunction1 is None:
            weightFunction1 = SFString.DEFAULT_VALUE
        assertValidSFString(weightFunction1)
        self.__weightFunction1 = weightFunction1
    @property # getter - - - - - - - - - -
    def weightFunction2(self):
        return self.__weightFunction2
    @weightFunction2.setter
    def weightFunction2(self, weightFunction2=None):
        if  weightFunction2 is None:
            weightFunction2 = SFString.DEFAULT_VALUE
        assertValidSFString(weightFunction2)
        self.__weightFunction2 = weightFunction2
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle=None):
        if  renderStyle is None:
            renderStyle = SFNode.DEFAULT_VALUE
        assertValidSFNode(renderStyle)
        if not isinstance(renderStyle, object):
            print(flush=True)
            raise TypeError(str(renderStyle) + ' does not have a valid node type object')
        self.__renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def voxels(self):
        return self.__voxels
    @voxels.setter
    def voxels(self, voxels=None):
        if  voxels is None:
            voxels = SFNode.DEFAULT_VALUE
        assertValidSFNode(voxels)
        if not isinstance(voxels, object):
            print(flush=True)
            raise TypeError(str(voxels) + ' does not have a valid node type object')
        self.__voxels = voxels
    @property # getter - - - - - - - - - -
    def weightTransferFunction1(self):
        return self.__weightTransferFunction1
    @weightTransferFunction1.setter
    def weightTransferFunction1(self, weightTransferFunction1=None):
        if  weightTransferFunction1 is None:
            weightTransferFunction1 = SFNode.DEFAULT_VALUE
        assertValidSFNode(weightTransferFunction1)
        if not isinstance(weightTransferFunction1, object):
            print(flush=True)
            raise TypeError(str(weightTransferFunction1) + ' does not have a valid node type object')
        self.__weightTransferFunction1 = weightTransferFunction1
    @property # getter - - - - - - - - - -
    def weightTransferFunction2(self):
        return self.__weightTransferFunction2
    @weightTransferFunction2.setter
    def weightTransferFunction2(self, weightTransferFunction2=None):
        if  weightTransferFunction2 is None:
            weightTransferFunction2 = SFNode.DEFAULT_VALUE
        assertValidSFNode(weightTransferFunction2)
        if not isinstance(weightTransferFunction2, object):
            print(flush=True)
            raise TypeError(str(weightTransferFunction2) + ' does not have a valid node type object')
        self.__weightTransferFunction2 = weightTransferFunction2
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function BlendedVolumeStyle.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<BlendedVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.weightConstant1 != 0.5:
            result += " weightConstant1='" + self.weightConstant1 + "'"
        if self.weightConstant2 != 0.5:
            result += " weightConstant2='" + self.weightConstant2 + "'"
        if self.weightFunction1 != 'CONSTANT':
            result += " weightFunction1='" + self.weightFunction1 + "'"
        if self.weightFunction2 != 'CONSTANT':
            result += " weightFunction2='" + self.weightFunction2 + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.renderStyle: # walk each child node, if any
            result += indent
            for each in self.renderStyle:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.voxels: # walk each child node, if any
            result += indent
            for each in self.voxels:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.weightTransferFunction1: # walk each child node, if any
            result += indent
            for each in self.weightTransferFunction1:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.weightTransferFunction2: # walk each child node, if any
            result += indent
            for each in self.weightTransferFunction2:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</BlendedVolumeStyle>' + '\n'
#       print('XML serialization complete.')
        return result

class BooleanFilter(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'BooleanFilter'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BooleanFilter'
    FIELD_DECLARATIONS = [('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BooleanFilter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function BooleanFilter.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<BooleanFilter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</BooleanFilter>' + '\n'
#       print('XML serialization complete.')
        return result

class BooleanSequencer(_X3DSequencerNode):
    """
    X3D element
    """
    NAME = 'BooleanSequencer'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BooleanSequencer'
    FIELD_DECLARATIONS = [('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BooleanSequencer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFBool.DEFAULT_VALUE
        assertValidMFBool(keyValue)
        self.__keyValue = keyValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function BooleanSequencer.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<BooleanSequencer'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</BooleanSequencer>' + '\n'
#       print('XML serialization complete.')
        return result

class BooleanToggle(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'BooleanToggle'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BooleanToggle'
    FIELD_DECLARATIONS = [('toggle', False, FieldType.SFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 toggle=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BooleanToggle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.toggle = toggle
    @property # getter - - - - - - - - - -
    def toggle(self):
        return self.__toggle
    @toggle.setter
    def toggle(self, toggle=None):
        if  toggle is None:
            toggle = SFBool.DEFAULT_VALUE
        assertValidSFBool(toggle)
        self.__toggle = toggle
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function BooleanToggle.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<BooleanToggle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.toggle != False:
            result += " toggle='" + self.toggle + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</BooleanToggle>' + '\n'
#       print('XML serialization complete.')
        return result

class BooleanTrigger(_X3DTriggerNode):
    """
    X3D element
    """
    NAME = 'BooleanTrigger'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BooleanTrigger'
    FIELD_DECLARATIONS = [('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BooleanTrigger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function BooleanTrigger.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<BooleanTrigger'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</BooleanTrigger>' + '\n'
#       print('XML serialization complete.')
        return result

class BoundaryEnhancementVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    X3D element
    """
    NAME = 'BoundaryEnhancementVolumeStyle'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BoundaryEnhancementVolumeStyle'
    FIELD_DECLARATIONS = [('boundaryOpacity', 0.9, FieldType.SFFloat, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('opacityFactor', 2, FieldType.SFFloat, AccessType.inputOutput),
                          ('retainedOpacity', 0.2, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 boundaryOpacity=0.9,
                 enabled=True,
                 opacityFactor=2,
                 retainedOpacity=0.2,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BoundaryEnhancementVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.boundaryOpacity = boundaryOpacity
        self.enabled = enabled
        self.opacityFactor = opacityFactor
        self.retainedOpacity = retainedOpacity
    @property # getter - - - - - - - - - -
    def boundaryOpacity(self):
        return self.__boundaryOpacity
    @boundaryOpacity.setter
    def boundaryOpacity(self, boundaryOpacity=None):
        if  boundaryOpacity is None:
            boundaryOpacity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(boundaryOpacity)
        assertZeroToOne('boundaryOpacity', boundaryOpacity)
        self.__boundaryOpacity = boundaryOpacity
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def opacityFactor(self):
        return self.__opacityFactor
    @opacityFactor.setter
    def opacityFactor(self, opacityFactor=None):
        if  opacityFactor is None:
            opacityFactor = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(opacityFactor)
        assertNonNegative('opacityFactor', opacityFactor)
        self.__opacityFactor = opacityFactor
    @property # getter - - - - - - - - - -
    def retainedOpacity(self):
        return self.__retainedOpacity
    @retainedOpacity.setter
    def retainedOpacity(self, retainedOpacity=None):
        if  retainedOpacity is None:
            retainedOpacity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(retainedOpacity)
        assertZeroToOne('retainedOpacity', retainedOpacity)
        self.__retainedOpacity = retainedOpacity
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function BoundaryEnhancementVolumeStyle.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<BoundaryEnhancementVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.boundaryOpacity != 0.9:
            result += " boundaryOpacity='" + self.boundaryOpacity + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.opacityFactor != 2:
            result += " opacityFactor='" + self.opacityFactor + "'"
        if self.retainedOpacity != 0.2:
            result += " retainedOpacity='" + self.retainedOpacity + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</BoundaryEnhancementVolumeStyle>' + '\n'
#       print('XML serialization complete.')
        return result

class BoundedPhysicsModel(_X3DParticlePhysicsModelNode):
    """
    X3D element
    """
    NAME = 'BoundedPhysicsModel'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BoundedPhysicsModel'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('geometry', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 geometry=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BoundedPhysicsModel __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.geometry = geometry
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def geometry(self):
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry=None):
        if  geometry is None:
            geometry = SFNode.DEFAULT_VALUE
        assertValidSFNode(geometry)
        if not isinstance(geometry, object):
            print(flush=True)
            raise TypeError(str(geometry) + ' does not have a valid node type object')
        self.__geometry = geometry
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function BoundedPhysicsModel.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<BoundedPhysicsModel'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geometry: # walk each child node, if any
            result += indent
            for each in self.geometry:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</BoundedPhysicsModel>' + '\n'
#       print('XML serialization complete.')
        return result

class Box(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'Box'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Box'
    FIELD_DECLARATIONS = [('size', (2, 2, 2), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 size=(2, 2, 2),
                 solid=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Box __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.size = size
        self.solid = solid
    @property # getter - - - - - - - - - -
    def size(self):
        return self.__size
    @size.setter
    def size(self, size=None):
        if  size is None:
            size = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Box.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Box'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.size != (2, 2, 2):
            result += " size='" + self.size + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Box>' + '\n'
#       print('XML serialization complete.')
        return result

class CADAssembly(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'CADAssembly'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CADAssembly'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 name='',
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CADAssembly __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.name = name
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CADAssembly.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CADAssembly'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CADAssembly>' + '\n'
#       print('XML serialization complete.')
        return result

class CADFace(_X3DProductStructureChildNode):
    """
    X3D element
    """
    NAME = 'CADFace'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CADFace'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('shape', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 name='',
                 shape=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CADFace __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.name = name
        self.shape = shape
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def shape(self):
        return self.__shape
    @shape.setter
    def shape(self, shape=None):
        if  shape is None:
            shape = SFNode.DEFAULT_VALUE
        assertValidSFNode(shape)
        if not isinstance(shape, object):
            print(flush=True)
            raise TypeError(str(shape) + ' does not have a valid node type object')
        self.__shape = shape
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CADFace.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CADFace'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.shape: # walk each child node, if any
            result += indent
            for each in self.shape:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CADFace>' + '\n'
#       print('XML serialization complete.')
        return result

class CADLayer(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'CADLayer'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CADLayer'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('visible', list(), FieldType.MFBool, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 name='',
                 visible=list(),
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CADLayer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.name = name
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def visible(self):
        return self.__visible
    @visible.setter
    def visible(self, visible=None):
        if  visible is None:
            visible = MFBool.DEFAULT_VALUE
        assertValidMFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CADLayer.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CADLayer'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.visible != list():
            result += " visible='" + self.visible + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CADLayer>' + '\n'
#       print('XML serialization complete.')
        return result

class CADPart(_X3DProductStructureChildNode):
    """
    X3D element
    """
    NAME = 'CADPart'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CADPart'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 name='',
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 translation=(0, 0, 0),
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CADPart __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.center = center
        self.name = name
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.translation = translation
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def rotation(self):
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation=None):
        if  rotation is None:
            rotation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        return self.__scale
    @scale.setter
    def scale(self, scale=None):
        if  scale is None:
            scale = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation=None):
        if  scaleOrientation is None:
            scaleOrientation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def translation(self):
        return self.__translation
    @translation.setter
    def translation(self, translation=None):
        if  translation is None:
            translation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CADPart.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CADPart'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + self.rotation + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + self.scale + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + self.scaleOrientation + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + self.translation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CADPart>' + '\n'
#       print('XML serialization complete.')
        return result

class CartoonVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    X3D element
    """
    NAME = 'CartoonVolumeStyle'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CartoonVolumeStyle'
    FIELD_DECLARATIONS = [('colorSteps', 4, FieldType.SFInt32, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('orthogonalColor', (1, 1, 1, 1), FieldType.SFColorRGBA, AccessType.inputOutput),
                          ('parallelColor', (0, 0, 0, 1), FieldType.SFColorRGBA, AccessType.inputOutput),
                          ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 colorSteps=4,
                 enabled=True,
                 orthogonalColor=(1, 1, 1, 1),
                 parallelColor=(0, 0, 0, 1),
                 surfaceNormals=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CartoonVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.colorSteps = colorSteps
        self.enabled = enabled
        self.orthogonalColor = orthogonalColor
        self.parallelColor = parallelColor
        self.surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def colorSteps(self):
        return self.__colorSteps
    @colorSteps.setter
    def colorSteps(self, colorSteps=None):
        if  colorSteps is None:
            colorSteps = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(colorSteps)
        assertGreaterThanEquals('colorSteps', colorSteps, 1)
        assertLessThanEquals('colorSteps', colorSteps, 64)
        self.__colorSteps = colorSteps
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def orthogonalColor(self):
        return self.__orthogonalColor
    @orthogonalColor.setter
    def orthogonalColor(self, orthogonalColor=None):
        if  orthogonalColor is None:
            orthogonalColor = SFColorRGBA.DEFAULT_VALUE
        assertValidSFColorRGBA(orthogonalColor)
        assertZeroToOne('orthogonalColor', orthogonalColor)
        self.__orthogonalColor = orthogonalColor
    @property # getter - - - - - - - - - -
    def parallelColor(self):
        return self.__parallelColor
    @parallelColor.setter
    def parallelColor(self, parallelColor=None):
        if  parallelColor is None:
            parallelColor = SFColorRGBA.DEFAULT_VALUE
        assertValidSFColorRGBA(parallelColor)
        assertZeroToOne('parallelColor', parallelColor)
        self.__parallelColor = parallelColor
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals=None):
        if  surfaceNormals is None:
            surfaceNormals = SFNode.DEFAULT_VALUE
        assertValidSFNode(surfaceNormals)
        if not isinstance(surfaceNormals, object):
            print(flush=True)
            raise TypeError(str(surfaceNormals) + ' does not have a valid node type object')
        self.__surfaceNormals = surfaceNormals
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CartoonVolumeStyle.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CartoonVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorSteps != 4:
            result += " colorSteps='" + self.colorSteps + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.orthogonalColor != (1, 1, 1, 1):
            result += " orthogonalColor='" + self.orthogonalColor + "'"
        if self.parallelColor != (0, 0, 0, 1):
            result += " parallelColor='" + self.parallelColor + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.surfaceNormals: # walk each child node, if any
            result += indent
            for each in self.surfaceNormals:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CartoonVolumeStyle>' + '\n'
#       print('XML serialization complete.')
        return result

class Circle2D(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'Circle2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Circle2D'
    FIELD_DECLARATIONS = [('radius', 1, FieldType.SFFloat, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 radius=1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Circle2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.radius = radius
    @property # getter - - - - - - - - - -
    def radius(self):
        return self.__radius
    @radius.setter
    def radius(self, radius=None):
        if  radius is None:
            radius = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Circle2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Circle2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.radius != 1:
            result += " radius='" + self.radius + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Circle2D>' + '\n'
#       print('XML serialization complete.')
        return result

class ClipPlane(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'ClipPlane'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ClipPlane'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('plane', (0, 1, 0, 0), FieldType.SFVec4f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 plane=(0, 1, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ClipPlane __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.plane = plane
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def plane(self):
        return self.__plane
    @plane.setter
    def plane(self, plane=None):
        if  plane is None:
            plane = SFVec4f.DEFAULT_VALUE
        assertValidSFVec4f(plane)
        assertGreaterThanEquals('plane', plane, -1)
        assertLessThanEquals('plane', plane, 1)
        self.__plane = plane
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ClipPlane.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ClipPlane'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.plane != (0, 1, 0, 0):
            result += " plane='" + self.plane + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ClipPlane>' + '\n'
#       print('XML serialization complete.')
        return result

class CollidableOffset(_X3DNBodyCollidableNode):
    """
    CollidableOffset repositions geometry relative to center of owning body.
    """
    NAME = 'CollidableOffset'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollidableOffset'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('collidable', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 enabled=True,
                 rotation=(0, 0, 1, 0),
                 translation=(0, 0, 0),
                 collidable=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CollidableOffset __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.enabled = enabled
        self.rotation = rotation
        self.translation = translation
        self.collidable = collidable
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def rotation(self):
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation=None):
        if  rotation is None:
            rotation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def translation(self):
        return self.__translation
    @translation.setter
    def translation(self, translation=None):
        if  translation is None:
            translation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def collidable(self):
        return self.__collidable
    @collidable.setter
    def collidable(self, collidable=None):
        if  collidable is None:
            collidable = SFNode.DEFAULT_VALUE
        assertValidSFNode(collidable)
        if not isinstance(collidable, object):
            print(flush=True)
            raise TypeError(str(collidable) + ' does not have a valid node type object')
        self.__collidable = collidable
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CollidableOffset.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CollidableOffset'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + self.rotation + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + self.translation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.collidable: # walk each child node, if any
            result += indent
            for each in self.collidable:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CollidableOffset>' + '\n'
#       print('XML serialization complete.')
        return result

class CollidableShape(_X3DNBodyCollidableNode):
    """
    CollidableShape connects the collision detection system, the rigid body model, and the renderable scene graph.
    """
    NAME = 'CollidableShape'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollidableShape'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('shape', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 enabled=True,
                 rotation=(0, 0, 1, 0),
                 translation=(0, 0, 0),
                 shape=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CollidableShape __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.enabled = enabled
        self.rotation = rotation
        self.translation = translation
        self.shape = shape
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def rotation(self):
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation=None):
        if  rotation is None:
            rotation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def translation(self):
        return self.__translation
    @translation.setter
    def translation(self, translation=None):
        if  translation is None:
            translation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def shape(self):
        return self.__shape
    @shape.setter
    def shape(self, shape=None):
        if  shape is None:
            shape = SFNode.DEFAULT_VALUE
        assertValidSFNode(shape)
        if not isinstance(shape, object):
            print(flush=True)
            raise TypeError(str(shape) + ' does not have a valid node type object')
        self.__shape = shape
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CollidableShape.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CollidableShape'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + self.rotation + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + self.translation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.shape: # walk each child node, if any
            result += indent
            for each in self.shape:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CollidableShape>' + '\n'
#       print('XML serialization complete.')
        return result

class Collision(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'Collision'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Collision'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('proxy', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 enabled=True,
                 proxy=None,
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Collision __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.enabled = enabled
        self.proxy = proxy
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def proxy(self):
        return self.__proxy
    @proxy.setter
    def proxy(self, proxy=None):
        if  proxy is None:
            proxy = SFNode.DEFAULT_VALUE
        assertValidSFNode(proxy)
        if not isinstance(proxy, object):
            print(flush=True)
            raise TypeError(str(proxy) + ' does not have a valid node type object')
        self.__proxy = proxy
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Collision.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Collision'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.proxy: # walk each child node, if any
            result += indent
            for each in self.proxy:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Collision>' + '\n'
#       print('XML serialization complete.')
        return result

class CollisionCollection(_X3DNode):
    """
    CollisionCollection holds a collection of objects that can be managed as a single entity for resolution of inter-object collisions.
    """
    NAME = 'CollisionCollection'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollisionCollection'
    FIELD_DECLARATIONS = [('appliedParameters', ["BOUNCE"], FieldType.MFString, AccessType.inputOutput),
                          ('bounce', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('frictionCoefficients', (0, 0), FieldType.SFVec2f, AccessType.inputOutput),
                          ('minBounceSpeed', 0.1, FieldType.SFFloat, AccessType.inputOutput),
                          ('slipFactors', (0, 0), FieldType.SFVec2f, AccessType.inputOutput),
                          ('softnessConstantForceMix', 0.0001, FieldType.SFFloat, AccessType.inputOutput),
                          ('softnessErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput),
                          ('surfaceSpeed', (0, 0), FieldType.SFVec2f, AccessType.inputOutput),
                          ('collidables', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 appliedParameters=["BOUNCE"],
                 bounce=0,
                 enabled=True,
                 frictionCoefficients=(0, 0),
                 minBounceSpeed=0.1,
                 slipFactors=(0, 0),
                 softnessConstantForceMix=0.0001,
                 softnessErrorCorrection=0.8,
                 surfaceSpeed=(0, 0),
                 collidables=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CollisionCollection __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.appliedParameters = appliedParameters
        self.bounce = bounce
        self.enabled = enabled
        self.frictionCoefficients = frictionCoefficients
        self.minBounceSpeed = minBounceSpeed
        self.slipFactors = slipFactors
        self.softnessConstantForceMix = softnessConstantForceMix
        self.softnessErrorCorrection = softnessErrorCorrection
        self.surfaceSpeed = surfaceSpeed
        self.collidables = collidables
    @property # getter - - - - - - - - - -
    def appliedParameters(self):
        return self.__appliedParameters
    @appliedParameters.setter
    def appliedParameters(self, appliedParameters=None):
        if  appliedParameters is None:
            appliedParameters = MFString.DEFAULT_VALUE
        assertValidMFString(appliedParameters)
        self.__appliedParameters = appliedParameters
    @property # getter - - - - - - - - - -
    def bounce(self):
        return self.__bounce
    @bounce.setter
    def bounce(self, bounce=None):
        if  bounce is None:
            bounce = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(bounce)
        assertZeroToOne('bounce', bounce)
        self.__bounce = bounce
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def frictionCoefficients(self):
        return self.__frictionCoefficients
    @frictionCoefficients.setter
    def frictionCoefficients(self, frictionCoefficients=None):
        if  frictionCoefficients is None:
            frictionCoefficients = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(frictionCoefficients)
        assertNonNegative('frictionCoefficients', frictionCoefficients)
        self.__frictionCoefficients = frictionCoefficients
    @property # getter - - - - - - - - - -
    def minBounceSpeed(self):
        return self.__minBounceSpeed
    @minBounceSpeed.setter
    def minBounceSpeed(self, minBounceSpeed=None):
        if  minBounceSpeed is None:
            minBounceSpeed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(minBounceSpeed)
        assertNonNegative('minBounceSpeed', minBounceSpeed)
        self.__minBounceSpeed = minBounceSpeed
    @property # getter - - - - - - - - - -
    def slipFactors(self):
        return self.__slipFactors
    @slipFactors.setter
    def slipFactors(self, slipFactors=None):
        if  slipFactors is None:
            slipFactors = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(slipFactors)
        self.__slipFactors = slipFactors
    @property # getter - - - - - - - - - -
    def softnessConstantForceMix(self):
        return self.__softnessConstantForceMix
    @softnessConstantForceMix.setter
    def softnessConstantForceMix(self, softnessConstantForceMix=None):
        if  softnessConstantForceMix is None:
            softnessConstantForceMix = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(softnessConstantForceMix)
        assertZeroToOne('softnessConstantForceMix', softnessConstantForceMix)
        self.__softnessConstantForceMix = softnessConstantForceMix
    @property # getter - - - - - - - - - -
    def softnessErrorCorrection(self):
        return self.__softnessErrorCorrection
    @softnessErrorCorrection.setter
    def softnessErrorCorrection(self, softnessErrorCorrection=None):
        if  softnessErrorCorrection is None:
            softnessErrorCorrection = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(softnessErrorCorrection)
        assertZeroToOne('softnessErrorCorrection', softnessErrorCorrection)
        self.__softnessErrorCorrection = softnessErrorCorrection
    @property # getter - - - - - - - - - -
    def surfaceSpeed(self):
        return self.__surfaceSpeed
    @surfaceSpeed.setter
    def surfaceSpeed(self, surfaceSpeed=None):
        if  surfaceSpeed is None:
            surfaceSpeed = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(surfaceSpeed)
        self.__surfaceSpeed = surfaceSpeed
    @property # getter - - - - - - - - - -
    def collidables(self):
        return self.__collidables
    @collidables.setter
    def collidables(self, collidables=None):
        if  collidables is None:
            collidables = MFNode.DEFAULT_VALUE
        assertValidMFNode(collidables)
        self.__collidables = collidables
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CollisionCollection.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CollisionCollection'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.appliedParameters != ["BOUNCE"]:
            result += " appliedParameters='" + self.appliedParameters + "'"
        if self.bounce != 0:
            result += " bounce='" + self.bounce + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.frictionCoefficients != (0, 0):
            result += " frictionCoefficients='" + self.frictionCoefficients + "'"
        if self.minBounceSpeed != 0.1:
            result += " minBounceSpeed='" + self.minBounceSpeed + "'"
        if self.slipFactors != (0, 0):
            result += " slipFactors='" + self.slipFactors + "'"
        if self.softnessConstantForceMix != 0.0001:
            result += " softnessConstantForceMix='" + self.softnessConstantForceMix + "'"
        if self.softnessErrorCorrection != 0.8:
            result += " softnessErrorCorrection='" + self.softnessErrorCorrection + "'"
        if self.surfaceSpeed != (0, 0):
            result += " surfaceSpeed='" + self.surfaceSpeed + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.collidables: # walk each child node, if any
            result += indent
            for each in self.collidables:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CollisionCollection>' + '\n'
#       print('XML serialization complete.')
        return result

class CollisionSensor(_X3DSensorNode):
    """
    CollisionSensor generates collision-detection events.
    """
    NAME = 'CollisionSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollisionSensor'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('collider', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 collider=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CollisionSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.collider = collider
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def collider(self):
        return self.__collider
    @collider.setter
    def collider(self, collider=None):
        if  collider is None:
            collider = SFNode.DEFAULT_VALUE
        assertValidSFNode(collider)
        if not isinstance(collider, object):
            print(flush=True)
            raise TypeError(str(collider) + ' does not have a valid node type object')
        self.__collider = collider
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CollisionSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CollisionSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.collider: # walk each child node, if any
            result += indent
            for each in self.collider:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CollisionSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class CollisionSpace(_X3DNBodyCollisionSpaceNode):
    """
    CollisionSpace holds collection of objects considered together for resolution of inter-object collisions.
    """
    NAME = 'CollisionSpace'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollisionSpace'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('useGeometry', False, FieldType.SFBool, AccessType.inputOutput),
                          ('collidables', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 enabled=True,
                 useGeometry=False,
                 collidables=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CollisionSpace __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.enabled = enabled
        self.useGeometry = useGeometry
        self.collidables = collidables
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def useGeometry(self):
        return self.__useGeometry
    @useGeometry.setter
    def useGeometry(self, useGeometry=None):
        if  useGeometry is None:
            useGeometry = SFBool.DEFAULT_VALUE
        assertValidSFBool(useGeometry)
        self.__useGeometry = useGeometry
    @property # getter - - - - - - - - - -
    def collidables(self):
        return self.__collidables
    @collidables.setter
    def collidables(self, collidables=None):
        if  collidables is None:
            collidables = MFNode.DEFAULT_VALUE
        assertValidMFNode(collidables)
        self.__collidables = collidables
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CollisionSpace.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CollisionSpace'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.useGeometry != False:
            result += " useGeometry='" + self.useGeometry + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.collidables: # walk each child node, if any
            result += indent
            for each in self.collidables:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CollisionSpace>' + '\n'
#       print('XML serialization complete.')
        return result

class Color(_X3DColorNode):
    """
    X3D element
    """
    NAME = 'Color'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Color'
    FIELD_DECLARATIONS = [('color', list(), FieldType.MFColor, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 color=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Color __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.color = color
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = MFColor.DEFAULT_VALUE
        assertValidMFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Color.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Color'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != list():
            result += " color='" + self.color + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Color>' + '\n'
#       print('XML serialization complete.')
        return result

class ColorChaser(_X3DChaserNode):
    """
    X3D element
    """
    NAME = 'ColorChaser'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ColorChaser'
    FIELD_DECLARATIONS = [('duration', 1, FieldType.SFTime, AccessType.initializeOnly),
                          ('initialDestination', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.initializeOnly),
                          ('initialValue', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 duration=1,
                 initialDestination=(0.8, 0.8, 0.8),
                 initialValue=(0.8, 0.8, 0.8),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ColorChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        return self.__duration
    @duration.setter
    def duration(self, duration=None):
        if  duration is None:
            duration = SFTime.DEFAULT_VALUE
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = SFColor.DEFAULT_VALUE
        assertValidSFColor(initialDestination)
        assertZeroToOne('initialDestination', initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = SFColor.DEFAULT_VALUE
        assertValidSFColor(initialValue)
        assertZeroToOne('initialValue', initialValue)
        self.__initialValue = initialValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ColorChaser.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ColorChaser'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + self.duration + "'"
        if self.initialDestination != (0.8, 0.8, 0.8):
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != (0.8, 0.8, 0.8):
            result += " initialValue='" + self.initialValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ColorChaser>' + '\n'
#       print('XML serialization complete.')
        return result

class ColorDamper(_X3DDamperNode):
    """
    X3D element
    """
    NAME = 'ColorDamper'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ColorDamper'
    FIELD_DECLARATIONS = [('initialDestination', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.initializeOnly),
                          ('initialValue', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.initializeOnly),
                          ('order', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput),
                          ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 initialDestination=(0.8, 0.8, 0.8),
                 initialValue=(0.8, 0.8, 0.8),
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ColorDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = SFColor.DEFAULT_VALUE
        assertValidSFColor(initialDestination)
        assertZeroToOne('initialDestination', initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = SFColor.DEFAULT_VALUE
        assertValidSFColor(initialValue)
        assertZeroToOne('initialValue', initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        return self.__order
    @order.setter
    def order(self, order=None):
        if  order is None:
            order = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        return self.__tau
    @tau.setter
    def tau(self, tau=None):
        if  tau is None:
            tau = SFTime.DEFAULT_VALUE
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance=None):
        if  tolerance is None:
            tolerance = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ColorDamper.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ColorDamper'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != (0.8, 0.8, 0.8):
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != (0.8, 0.8, 0.8):
            result += " initialValue='" + self.initialValue + "'"
        if self.order != 3:
            result += " order='" + self.order + "'"
        if self.tau != 0.3:
            result += " tau='" + self.tau + "'"
        if self.tolerance != -1:
            result += " tolerance='" + self.tolerance + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ColorDamper>' + '\n'
#       print('XML serialization complete.')
        return result

class ColorInterpolator(_X3DInterpolatorNode):
    """
    X3D element
    """
    NAME = 'ColorInterpolator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ColorInterpolator'
    FIELD_DECLARATIONS = [('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFColor, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ColorInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFColor.DEFAULT_VALUE
        assertValidMFColor(keyValue)
        assertZeroToOne('keyValue', keyValue)
        self.__keyValue = keyValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ColorInterpolator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ColorInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ColorInterpolator>' + '\n'
#       print('XML serialization complete.')
        return result

class ColorRGBA(_X3DColorNode):
    """
    X3D element
    """
    NAME = 'ColorRGBA'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ColorRGBA'
    FIELD_DECLARATIONS = [('color', list(), FieldType.MFColorRGBA, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 color=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ColorRGBA __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.color = color
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = MFColorRGBA.DEFAULT_VALUE
        assertValidMFColorRGBA(color)
        assertZeroToOne('color', color)
        self.__color = color
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ColorRGBA.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ColorRGBA'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != list():
            result += " color='" + self.color + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ColorRGBA>' + '\n'
#       print('XML serialization complete.')
        return result

class ComposedCubeMapTexture(_X3DEnvironmentTextureNode):
    """
    X3D element
    """
    NAME = 'ComposedCubeMapTexture'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ComposedCubeMapTexture'
    FIELD_DECLARATIONS = [('back', None, FieldType.SFNode, AccessType.inputOutput),
                          ('bottom', None, FieldType.SFNode, AccessType.inputOutput),
                          ('front', None, FieldType.SFNode, AccessType.inputOutput),
                          ('left', None, FieldType.SFNode, AccessType.inputOutput),
                          ('right', None, FieldType.SFNode, AccessType.inputOutput),
                          ('top', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 back=None,
                 bottom=None,
                 front=None,
                 left=None,
                 right=None,
                 top=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ComposedCubeMapTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.back = back
        self.bottom = bottom
        self.front = front
        self.left = left
        self.right = right
        self.top = top
    @property # getter - - - - - - - - - -
    def back(self):
        return self.__back
    @back.setter
    def back(self, back=None):
        if  back is None:
            back = SFNode.DEFAULT_VALUE
        assertValidSFNode(back)
        if not isinstance(back, object):
            print(flush=True)
            raise TypeError(str(back) + ' does not have a valid node type object')
        self.__back = back
    @property # getter - - - - - - - - - -
    def bottom(self):
        return self.__bottom
    @bottom.setter
    def bottom(self, bottom=None):
        if  bottom is None:
            bottom = SFNode.DEFAULT_VALUE
        assertValidSFNode(bottom)
        if not isinstance(bottom, object):
            print(flush=True)
            raise TypeError(str(bottom) + ' does not have a valid node type object')
        self.__bottom = bottom
    @property # getter - - - - - - - - - -
    def front(self):
        return self.__front
    @front.setter
    def front(self, front=None):
        if  front is None:
            front = SFNode.DEFAULT_VALUE
        assertValidSFNode(front)
        if not isinstance(front, object):
            print(flush=True)
            raise TypeError(str(front) + ' does not have a valid node type object')
        self.__front = front
    @property # getter - - - - - - - - - -
    def left(self):
        return self.__left
    @left.setter
    def left(self, left=None):
        if  left is None:
            left = SFNode.DEFAULT_VALUE
        assertValidSFNode(left)
        if not isinstance(left, object):
            print(flush=True)
            raise TypeError(str(left) + ' does not have a valid node type object')
        self.__left = left
    @property # getter - - - - - - - - - -
    def right(self):
        return self.__right
    @right.setter
    def right(self, right=None):
        if  right is None:
            right = SFNode.DEFAULT_VALUE
        assertValidSFNode(right)
        if not isinstance(right, object):
            print(flush=True)
            raise TypeError(str(right) + ' does not have a valid node type object')
        self.__right = right
    @property # getter - - - - - - - - - -
    def top(self):
        return self.__top
    @top.setter
    def top(self, top=None):
        if  top is None:
            top = SFNode.DEFAULT_VALUE
        assertValidSFNode(top)
        if not isinstance(top, object):
            print(flush=True)
            raise TypeError(str(top) + ' does not have a valid node type object')
        self.__top = top
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ComposedCubeMapTexture.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ComposedCubeMapTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.back: # walk each child node, if any
            result += indent
            for each in self.back:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.bottom: # walk each child node, if any
            result += indent
            for each in self.bottom:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.front: # walk each child node, if any
            result += indent
            for each in self.front:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.left: # walk each child node, if any
            result += indent
            for each in self.left:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.right: # walk each child node, if any
            result += indent
            for each in self.right:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.top: # walk each child node, if any
            result += indent
            for each in self.top:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ComposedCubeMapTexture>' + '\n'
#       print('XML serialization complete.')
        return result

class ComposedShader(_X3DShaderNode):
    """
    ComposedShader can contain field declarations, but no CDATA section of plain-text source code, since programs are composed from child ShaderPart nodes.
    """
    NAME = 'ComposedShader'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ComposedShader'
    FIELD_DECLARATIONS = [('language', '', FieldType.SFString, AccessType.initializeOnly),
                          ('field', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('parts', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 language='',
                 field=list(),
                 parts=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ComposedShader __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.language = language
        self.field = field
        self.parts = parts
    @property # getter - - - - - - - - - -
    def language(self):
        return self.__language
    @language.setter
    def language(self, language=None):
        if  language is None:
            language = SFString.DEFAULT_VALUE
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def field(self):
        return self.__field
    @field.setter
    def field(self, field=None):
        if  field is None:
            field = MFNode.DEFAULT_VALUE
        assertValidMFNode(field)
        self.__field = field
    @property # getter - - - - - - - - - -
    def parts(self):
        return self.__parts
    @parts.setter
    def parts(self, parts=None):
        if  parts is None:
            parts = MFNode.DEFAULT_VALUE
        assertValidMFNode(parts)
        self.__parts = parts
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ComposedShader.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ComposedShader'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.language:
            result += " language='" + self.language + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.field: # walk each child node, if any
            result += indent
            for each in self.field:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.parts: # walk each child node, if any
            result += indent
            for each in self.parts:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ComposedShader>' + '\n'
#       print('XML serialization complete.')
        return result

class ComposedTexture3D(_X3DTexture3DNode):
    """
    X3D element
    """
    NAME = 'ComposedTexture3D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ComposedTexture3D'
    FIELD_DECLARATIONS = [('repeatR', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('repeatS', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('repeatT', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('texture', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 repeatR=False,
                 repeatS=False,
                 repeatT=False,
                 textureProperties=None,
                 texture=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ComposedTexture3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.repeatR = repeatR
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.textureProperties = textureProperties
        self.texture = texture
    @property # getter - - - - - - - - - -
    def repeatR(self):
        return self.__repeatR
    @repeatR.setter
    def repeatR(self, repeatR=None):
        if  repeatR is None:
            repeatR = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatR)
        self.__repeatR = repeatR
    @property # getter - - - - - - - - - -
    def repeatS(self):
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS=None):
        if  repeatS is None:
            repeatS = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT=None):
        if  repeatT is None:
            repeatT = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties=None):
        if  textureProperties is None:
            textureProperties = SFNode.DEFAULT_VALUE
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            print(flush=True)
            raise TypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def texture(self):
        return self.__texture
    @texture.setter
    def texture(self, texture=None):
        if  texture is None:
            texture = MFNode.DEFAULT_VALUE
        assertValidMFNode(texture)
        self.__texture = texture
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ComposedTexture3D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ComposedTexture3D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.repeatR != False:
            result += " repeatR='" + self.repeatR + "'"
        if self.repeatS != False:
            result += " repeatS='" + self.repeatS + "'"
        if self.repeatT != False:
            result += " repeatT='" + self.repeatT + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.textureProperties: # walk each child node, if any
            result += indent
            for each in self.textureProperties:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texture: # walk each child node, if any
            result += indent
            for each in self.texture:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ComposedTexture3D>' + '\n'
#       print('XML serialization complete.')
        return result

class ComposedVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    X3D element
    """
    NAME = 'ComposedVolumeStyle'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ComposedVolumeStyle'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('renderStyle', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 renderStyle=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ComposedVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle=None):
        if  renderStyle is None:
            renderStyle = MFNode.DEFAULT_VALUE
        assertValidMFNode(renderStyle)
        self.__renderStyle = renderStyle
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ComposedVolumeStyle.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ComposedVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.renderStyle: # walk each child node, if any
            result += indent
            for each in self.renderStyle:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ComposedVolumeStyle>' + '\n'
#       print('XML serialization complete.')
        return result

class Cone(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'Cone'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Cone'
    FIELD_DECLARATIONS = [('bottom', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('bottomRadius', 1, FieldType.SFFloat, AccessType.initializeOnly),
                          ('height', 2, FieldType.SFFloat, AccessType.initializeOnly),
                          ('side', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bottom=True,
                 bottomRadius=1,
                 height=2,
                 side=True,
                 solid=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Cone __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bottom = bottom
        self.bottomRadius = bottomRadius
        self.height = height
        self.side = side
        self.solid = solid
    @property # getter - - - - - - - - - -
    def bottom(self):
        return self.__bottom
    @bottom.setter
    def bottom(self, bottom=None):
        if  bottom is None:
            bottom = SFBool.DEFAULT_VALUE
        assertValidSFBool(bottom)
        self.__bottom = bottom
    @property # getter - - - - - - - - - -
    def bottomRadius(self):
        return self.__bottomRadius
    @bottomRadius.setter
    def bottomRadius(self, bottomRadius=None):
        if  bottomRadius is None:
            bottomRadius = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(bottomRadius)
        assertPositive('bottomRadius', bottomRadius)
        self.__bottomRadius = bottomRadius
    @property # getter - - - - - - - - - -
    def height(self):
        return self.__height
    @height.setter
    def height(self, height=None):
        if  height is None:
            height = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(height)
        assertPositive('height', height)
        self.__height = height
    @property # getter - - - - - - - - - -
    def side(self):
        return self.__side
    @side.setter
    def side(self, side=None):
        if  side is None:
            side = SFBool.DEFAULT_VALUE
        assertValidSFBool(side)
        self.__side = side
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Cone.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Cone'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bottom != True:
            result += " bottom='" + self.bottom + "'"
        if self.bottomRadius != 1:
            result += " bottomRadius='" + self.bottomRadius + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.height != 2:
            result += " height='" + self.height + "'"
        if self.side != True:
            result += " side='" + self.side + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Cone>' + '\n'
#       print('XML serialization complete.')
        return result

class ConeEmitter(_X3DParticleEmitterNode):
    """
    X3D element
    """
    NAME = 'ConeEmitter'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ConeEmitter'
    FIELD_DECLARATIONS = [('angle', 0.7854, FieldType.SFFloat, AccessType.inputOutput),
                          ('direction', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('mass', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('speed', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('surfaceArea', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 angle=0.7854,
                 direction=(0, 1, 0),
                 mass=0,
                 position=(0, 0, 0),
                 speed=0,
                 surfaceArea=0,
                 variation=0.25,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ConeEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.angle = angle
        self.direction = direction
        self.mass = mass
        self.position = position
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
    @property # getter - - - - - - - - - -
    def angle(self):
        return self.__angle
    @angle.setter
    def angle(self, angle=None):
        if  angle is None:
            angle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(angle)
        assertGreaterThanEquals('angle', angle, 0)
        assertLessThanEquals('angle', angle, 3.1416)
        self.__angle = angle
    @property # getter - - - - - - - - - -
    def direction(self):
        return self.__direction
    @direction.setter
    def direction(self, direction=None):
        if  direction is None:
            direction = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(direction)
        assertGreaterThanEquals('direction', direction, -1)
        assertLessThanEquals('direction', direction, 1)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def mass(self):
        return self.__mass
    @mass.setter
    def mass(self, mass=None):
        if  mass is None:
            mass = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def position(self):
        return self.__position
    @position.setter
    def position(self, position=None):
        if  position is None:
            position = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def speed(self):
        return self.__speed
    @speed.setter
    def speed(self, speed=None):
        if  speed is None:
            speed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea=None):
        if  surfaceArea is None:
            surfaceArea = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        return self.__variation
    @variation.setter
    def variation(self, variation=None):
        if  variation is None:
            variation = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ConeEmitter.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ConeEmitter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.angle != 0.7854:
            result += " angle='" + self.angle + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.direction != (0, 1, 0):
            result += " direction='" + self.direction + "'"
        if self.mass != 0:
            result += " mass='" + self.mass + "'"
        if self.position != (0, 0, 0):
            result += " position='" + self.position + "'"
        if self.speed != 0:
            result += " speed='" + self.speed + "'"
        if self.surfaceArea != 0:
            result += " surfaceArea='" + self.surfaceArea + "'"
        if self.variation != 0.25:
            result += " variation='" + self.variation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ConeEmitter>' + '\n'
#       print('XML serialization complete.')
        return result

class Contact(_X3DNode):
    """
    Contact nodes are produced as output events when two collidable objects or spaces make contact.
    """
    NAME = 'Contact'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Contact'
    FIELD_DECLARATIONS = [('appliedParameters', ["BOUNCE"], FieldType.MFString, AccessType.inputOutput),
                          ('bounce', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('contactNormal', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('depth', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('frictionCoefficients', (0, 0), FieldType.SFVec2f, AccessType.inputOutput),
                          ('frictionDirection', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('minBounceSpeed', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('slipCoefficients', (0, 0), FieldType.SFVec2f, AccessType.inputOutput),
                          ('softnessConstantForceMix', 0.0001, FieldType.SFFloat, AccessType.inputOutput),
                          ('softnessErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput),
                          ('surfaceSpeed', (0, 0), FieldType.SFVec2f, AccessType.inputOutput),
                          ('body1', None, FieldType.SFNode, AccessType.inputOutput),
                          ('body2', None, FieldType.SFNode, AccessType.inputOutput),
                          ('geometry1', None, FieldType.SFNode, AccessType.inputOutput),
                          ('geometry2', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 appliedParameters=["BOUNCE"],
                 bounce=0,
                 contactNormal=(0, 1, 0),
                 depth=0,
                 frictionCoefficients=(0, 0),
                 frictionDirection=(0, 1, 0),
                 minBounceSpeed=0,
                 position=(0, 0, 0),
                 slipCoefficients=(0, 0),
                 softnessConstantForceMix=0.0001,
                 softnessErrorCorrection=0.8,
                 surfaceSpeed=(0, 0),
                 body1=None,
                 body2=None,
                 geometry1=None,
                 geometry2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Contact __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.appliedParameters = appliedParameters
        self.bounce = bounce
        self.contactNormal = contactNormal
        self.depth = depth
        self.frictionCoefficients = frictionCoefficients
        self.frictionDirection = frictionDirection
        self.minBounceSpeed = minBounceSpeed
        self.position = position
        self.slipCoefficients = slipCoefficients
        self.softnessConstantForceMix = softnessConstantForceMix
        self.softnessErrorCorrection = softnessErrorCorrection
        self.surfaceSpeed = surfaceSpeed
        self.body1 = body1
        self.body2 = body2
        self.geometry1 = geometry1
        self.geometry2 = geometry2
    @property # getter - - - - - - - - - -
    def appliedParameters(self):
        return self.__appliedParameters
    @appliedParameters.setter
    def appliedParameters(self, appliedParameters=None):
        if  appliedParameters is None:
            appliedParameters = MFString.DEFAULT_VALUE
        assertValidMFString(appliedParameters)
        self.__appliedParameters = appliedParameters
    @property # getter - - - - - - - - - -
    def bounce(self):
        return self.__bounce
    @bounce.setter
    def bounce(self, bounce=None):
        if  bounce is None:
            bounce = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(bounce)
        assertZeroToOne('bounce', bounce)
        self.__bounce = bounce
    @property # getter - - - - - - - - - -
    def contactNormal(self):
        return self.__contactNormal
    @contactNormal.setter
    def contactNormal(self, contactNormal=None):
        if  contactNormal is None:
            contactNormal = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(contactNormal)
        self.__contactNormal = contactNormal
    @property # getter - - - - - - - - - -
    def depth(self):
        return self.__depth
    @depth.setter
    def depth(self, depth=None):
        if  depth is None:
            depth = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(depth)
        self.__depth = depth
    @property # getter - - - - - - - - - -
    def frictionCoefficients(self):
        return self.__frictionCoefficients
    @frictionCoefficients.setter
    def frictionCoefficients(self, frictionCoefficients=None):
        if  frictionCoefficients is None:
            frictionCoefficients = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(frictionCoefficients)
        assertNonNegative('frictionCoefficients', frictionCoefficients)
        self.__frictionCoefficients = frictionCoefficients
    @property # getter - - - - - - - - - -
    def frictionDirection(self):
        return self.__frictionDirection
    @frictionDirection.setter
    def frictionDirection(self, frictionDirection=None):
        if  frictionDirection is None:
            frictionDirection = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(frictionDirection)
        self.__frictionDirection = frictionDirection
    @property # getter - - - - - - - - - -
    def minBounceSpeed(self):
        return self.__minBounceSpeed
    @minBounceSpeed.setter
    def minBounceSpeed(self, minBounceSpeed=None):
        if  minBounceSpeed is None:
            minBounceSpeed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(minBounceSpeed)
        assertNonNegative('minBounceSpeed', minBounceSpeed)
        self.__minBounceSpeed = minBounceSpeed
    @property # getter - - - - - - - - - -
    def position(self):
        return self.__position
    @position.setter
    def position(self, position=None):
        if  position is None:
            position = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def slipCoefficients(self):
        return self.__slipCoefficients
    @slipCoefficients.setter
    def slipCoefficients(self, slipCoefficients=None):
        if  slipCoefficients is None:
            slipCoefficients = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(slipCoefficients)
        self.__slipCoefficients = slipCoefficients
    @property # getter - - - - - - - - - -
    def softnessConstantForceMix(self):
        return self.__softnessConstantForceMix
    @softnessConstantForceMix.setter
    def softnessConstantForceMix(self, softnessConstantForceMix=None):
        if  softnessConstantForceMix is None:
            softnessConstantForceMix = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(softnessConstantForceMix)
        assertZeroToOne('softnessConstantForceMix', softnessConstantForceMix)
        self.__softnessConstantForceMix = softnessConstantForceMix
    @property # getter - - - - - - - - - -
    def softnessErrorCorrection(self):
        return self.__softnessErrorCorrection
    @softnessErrorCorrection.setter
    def softnessErrorCorrection(self, softnessErrorCorrection=None):
        if  softnessErrorCorrection is None:
            softnessErrorCorrection = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(softnessErrorCorrection)
        assertZeroToOne('softnessErrorCorrection', softnessErrorCorrection)
        self.__softnessErrorCorrection = softnessErrorCorrection
    @property # getter - - - - - - - - - -
    def surfaceSpeed(self):
        return self.__surfaceSpeed
    @surfaceSpeed.setter
    def surfaceSpeed(self, surfaceSpeed=None):
        if  surfaceSpeed is None:
            surfaceSpeed = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(surfaceSpeed)
        self.__surfaceSpeed = surfaceSpeed
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1=None):
        if  body1 is None:
            body1 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            print(flush=True)
            raise TypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2=None):
        if  body2 is None:
            body2 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            print(flush=True)
            raise TypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    @property # getter - - - - - - - - - -
    def geometry1(self):
        return self.__geometry1
    @geometry1.setter
    def geometry1(self, geometry1=None):
        if  geometry1 is None:
            geometry1 = SFNode.DEFAULT_VALUE
        assertValidSFNode(geometry1)
        if not isinstance(geometry1, object):
            print(flush=True)
            raise TypeError(str(geometry1) + ' does not have a valid node type object')
        self.__geometry1 = geometry1
    @property # getter - - - - - - - - - -
    def geometry2(self):
        return self.__geometry2
    @geometry2.setter
    def geometry2(self, geometry2=None):
        if  geometry2 is None:
            geometry2 = SFNode.DEFAULT_VALUE
        assertValidSFNode(geometry2)
        if not isinstance(geometry2, object):
            print(flush=True)
            raise TypeError(str(geometry2) + ' does not have a valid node type object')
        self.__geometry2 = geometry2
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Contact.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Contact'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.appliedParameters != ["BOUNCE"]:
            result += " appliedParameters='" + self.appliedParameters + "'"
        if self.bounce != 0:
            result += " bounce='" + self.bounce + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.contactNormal != (0, 1, 0):
            result += " contactNormal='" + self.contactNormal + "'"
        if self.depth != 0:
            result += " depth='" + self.depth + "'"
        if self.frictionCoefficients != (0, 0):
            result += " frictionCoefficients='" + self.frictionCoefficients + "'"
        if self.frictionDirection != (0, 1, 0):
            result += " frictionDirection='" + self.frictionDirection + "'"
        if self.minBounceSpeed != 0:
            result += " minBounceSpeed='" + self.minBounceSpeed + "'"
        if self.position != (0, 0, 0):
            result += " position='" + self.position + "'"
        if self.slipCoefficients != (0, 0):
            result += " slipCoefficients='" + self.slipCoefficients + "'"
        if self.softnessConstantForceMix != 0.0001:
            result += " softnessConstantForceMix='" + self.softnessConstantForceMix + "'"
        if self.softnessErrorCorrection != 0.8:
            result += " softnessErrorCorrection='" + self.softnessErrorCorrection + "'"
        if self.surfaceSpeed != (0, 0):
            result += " surfaceSpeed='" + self.surfaceSpeed + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body1: # walk each child node, if any
            result += indent
            for each in self.body1:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body2: # walk each child node, if any
            result += indent
            for each in self.body2:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geometry1: # walk each child node, if any
            result += indent
            for each in self.geometry1:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geometry2: # walk each child node, if any
            result += indent
            for each in self.geometry2:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Contact>' + '\n'
#       print('XML serialization complete.')
        return result

class Contour2D(_X3DNode):
    """
    X3D element
    """
    NAME = 'Contour2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Contour2D'
    FIELD_DECLARATIONS = [('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Contour2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.children = children
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Contour2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Contour2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Contour2D>' + '\n'
#       print('XML serialization complete.')
        return result

class ContourPolyline2D(_X3DNurbsControlCurveNode):
    """
    X3D element
    """
    NAME = 'ContourPolyline2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ContourPolyline2D'
    FIELD_DECLARATIONS = [('controlPoint', list(), FieldType.MFVec2d, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 controlPoint=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ContourPolyline2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint=None):
        if  controlPoint is None:
            controlPoint = MFVec2d.DEFAULT_VALUE
        assertValidMFVec2d(controlPoint)
        self.__controlPoint = controlPoint
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ContourPolyline2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ContourPolyline2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.controlPoint != list():
            result += " controlPoint='" + self.controlPoint + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ContourPolyline2D>' + '\n'
#       print('XML serialization complete.')
        return result

class Coordinate(_X3DCoordinateNode):
    """
    X3D element
    """
    NAME = 'Coordinate'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Coordinate'
    FIELD_DECLARATIONS = [('point', list(), FieldType.MFVec3f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 point=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Coordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.point = point
    @property # getter - - - - - - - - - -
    def point(self):
        return self.__point
    @point.setter
    def point(self, point=None):
        if  point is None:
            point = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(point)
        self.__point = point
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Coordinate.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Coordinate'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.point != list():
            result += " point='" + self.point + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Coordinate>' + '\n'
#       print('XML serialization complete.')
        return result

class CoordinateChaser(_X3DChaserNode):
    """
    X3D element
    """
    NAME = 'CoordinateChaser'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateChaser'
    FIELD_DECLARATIONS = [('duration', 1, FieldType.SFTime, AccessType.initializeOnly),
                          ('initialDestination', [0, 0, 0], FieldType.MFVec3f, AccessType.initializeOnly),
                          ('initialValue', [0, 0, 0], FieldType.MFVec3f, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 duration=1,
                 initialDestination=[0, 0, 0],
                 initialValue=[0, 0, 0],
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CoordinateChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        return self.__duration
    @duration.setter
    def duration(self, duration=None):
        if  duration is None:
            duration = SFTime.DEFAULT_VALUE
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(initialValue)
        self.__initialValue = initialValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CoordinateChaser.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CoordinateChaser'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + self.duration + "'"
        if self.initialDestination != [0, 0, 0]:
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != [0, 0, 0]:
            result += " initialValue='" + self.initialValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CoordinateChaser>' + '\n'
#       print('XML serialization complete.')
        return result

class CoordinateDamper(_X3DDamperNode):
    """
    X3D element
    """
    NAME = 'CoordinateDamper'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateDamper'
    FIELD_DECLARATIONS = [('initialDestination', [0, 0, 0], FieldType.MFVec3f, AccessType.initializeOnly),
                          ('initialValue', [0, 0, 0], FieldType.MFVec3f, AccessType.initializeOnly),
                          ('order', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput),
                          ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 initialDestination=[0, 0, 0],
                 initialValue=[0, 0, 0],
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CoordinateDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        return self.__order
    @order.setter
    def order(self, order=None):
        if  order is None:
            order = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        return self.__tau
    @tau.setter
    def tau(self, tau=None):
        if  tau is None:
            tau = SFTime.DEFAULT_VALUE
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance=None):
        if  tolerance is None:
            tolerance = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CoordinateDamper.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CoordinateDamper'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != [0, 0, 0]:
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != [0, 0, 0]:
            result += " initialValue='" + self.initialValue + "'"
        if self.order != 3:
            result += " order='" + self.order + "'"
        if self.tau != 0.3:
            result += " tau='" + self.tau + "'"
        if self.tolerance != -1:
            result += " tolerance='" + self.tolerance + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CoordinateDamper>' + '\n'
#       print('XML serialization complete.')
        return result

class CoordinateDouble(_X3DCoordinateNode):
    """
    X3D element
    """
    NAME = 'CoordinateDouble'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateDouble'
    FIELD_DECLARATIONS = [('point', list(), FieldType.MFVec3d, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 point=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CoordinateDouble __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.point = point
    @property # getter - - - - - - - - - -
    def point(self):
        return self.__point
    @point.setter
    def point(self, point=None):
        if  point is None:
            point = MFVec3d.DEFAULT_VALUE
        assertValidMFVec3d(point)
        self.__point = point
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CoordinateDouble.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CoordinateDouble'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.point != list():
            result += " point='" + self.point + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CoordinateDouble>' + '\n'
#       print('XML serialization complete.')
        return result

class CoordinateInterpolator(_X3DInterpolatorNode):
    """
    X3D element
    """
    NAME = 'CoordinateInterpolator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateInterpolator'
    FIELD_DECLARATIONS = [('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFVec3f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CoordinateInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(keyValue)
        self.__keyValue = keyValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CoordinateInterpolator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CoordinateInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CoordinateInterpolator>' + '\n'
#       print('XML serialization complete.')
        return result

class CoordinateInterpolator2D(_X3DInterpolatorNode):
    """
    X3D element
    """
    NAME = 'CoordinateInterpolator2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateInterpolator2D'
    FIELD_DECLARATIONS = [('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFVec2f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CoordinateInterpolator2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(keyValue)
        self.__keyValue = keyValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CoordinateInterpolator2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CoordinateInterpolator2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CoordinateInterpolator2D>' + '\n'
#       print('XML serialization complete.')
        return result

class Cylinder(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'Cylinder'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Cylinder'
    FIELD_DECLARATIONS = [('bottom', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('height', 2, FieldType.SFFloat, AccessType.initializeOnly),
                          ('radius', 1, FieldType.SFFloat, AccessType.initializeOnly),
                          ('side', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('top', True, FieldType.SFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bottom=True,
                 height=2,
                 radius=1,
                 side=True,
                 solid=True,
                 top=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Cylinder __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bottom = bottom
        self.height = height
        self.radius = radius
        self.side = side
        self.solid = solid
        self.top = top
    @property # getter - - - - - - - - - -
    def bottom(self):
        return self.__bottom
    @bottom.setter
    def bottom(self, bottom=None):
        if  bottom is None:
            bottom = SFBool.DEFAULT_VALUE
        assertValidSFBool(bottom)
        self.__bottom = bottom
    @property # getter - - - - - - - - - -
    def height(self):
        return self.__height
    @height.setter
    def height(self, height=None):
        if  height is None:
            height = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(height)
        assertPositive('height', height)
        self.__height = height
    @property # getter - - - - - - - - - -
    def radius(self):
        return self.__radius
    @radius.setter
    def radius(self, radius=None):
        if  radius is None:
            radius = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def side(self):
        return self.__side
    @side.setter
    def side(self, side=None):
        if  side is None:
            side = SFBool.DEFAULT_VALUE
        assertValidSFBool(side)
        self.__side = side
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def top(self):
        return self.__top
    @top.setter
    def top(self, top=None):
        if  top is None:
            top = SFBool.DEFAULT_VALUE
        assertValidSFBool(top)
        self.__top = top
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Cylinder.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Cylinder'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bottom != True:
            result += " bottom='" + self.bottom + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.height != 2:
            result += " height='" + self.height + "'"
        if self.radius != 1:
            result += " radius='" + self.radius + "'"
        if self.side != True:
            result += " side='" + self.side + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'"
        if self.top != True:
            result += " top='" + self.top + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Cylinder>' + '\n'
#       print('XML serialization complete.')
        return result

class CylinderSensor(_X3DDragSensorNode):
    """
    X3D element
    """
    NAME = 'CylinderSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CylinderSensor'
    FIELD_DECLARATIONS = [('autoOffset', True, FieldType.SFBool, AccessType.inputOutput),
                          ('axisRotation', (0, 1, 0, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('diskAngle', 0.26179167, FieldType.SFFloat, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('maxAngle', -1, FieldType.SFFloat, AccessType.inputOutput),
                          ('minAngle', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('offset', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 autoOffset=True,
                 axisRotation=(0, 1, 0, 0),
                 description='',
                 diskAngle=0.26179167,
                 enabled=True,
                 maxAngle=-1,
                 minAngle=0,
                 offset=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CylinderSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.autoOffset = autoOffset
        self.axisRotation = axisRotation
        self.description = description
        self.diskAngle = diskAngle
        self.enabled = enabled
        self.maxAngle = maxAngle
        self.minAngle = minAngle
        self.offset = offset
    @property # getter - - - - - - - - - -
    def autoOffset(self):
        return self.__autoOffset
    @autoOffset.setter
    def autoOffset(self, autoOffset=None):
        if  autoOffset is None:
            autoOffset = SFBool.DEFAULT_VALUE
        assertValidSFBool(autoOffset)
        self.__autoOffset = autoOffset
    @property # getter - - - - - - - - - -
    def axisRotation(self):
        return self.__axisRotation
    @axisRotation.setter
    def axisRotation(self, axisRotation=None):
        if  axisRotation is None:
            axisRotation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(axisRotation)
        self.__axisRotation = axisRotation
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def diskAngle(self):
        return self.__diskAngle
    @diskAngle.setter
    def diskAngle(self, diskAngle=None):
        if  diskAngle is None:
            diskAngle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(diskAngle)
        assertGreaterThanEquals('diskAngle', diskAngle, 0)
        assertLessThanEquals('diskAngle', diskAngle, 1.5708)
        self.__diskAngle = diskAngle
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def maxAngle(self):
        return self.__maxAngle
    @maxAngle.setter
    def maxAngle(self, maxAngle=None):
        if  maxAngle is None:
            maxAngle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(maxAngle)
        assertGreaterThan('maxAngle', maxAngle, -6.2832)
        assertLessThan('maxAngle', maxAngle, 6.2832)
        self.__maxAngle = maxAngle
    @property # getter - - - - - - - - - -
    def minAngle(self):
        return self.__minAngle
    @minAngle.setter
    def minAngle(self, minAngle=None):
        if  minAngle is None:
            minAngle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(minAngle)
        assertGreaterThan('minAngle', minAngle, -6.2832)
        assertLessThan('minAngle', minAngle, 6.2832)
        self.__minAngle = minAngle
    @property # getter - - - - - - - - - -
    def offset(self):
        return self.__offset
    @offset.setter
    def offset(self, offset=None):
        if  offset is None:
            offset = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(offset)
        self.__offset = offset
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function CylinderSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<CylinderSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.autoOffset != True:
            result += " autoOffset='" + self.autoOffset + "'"
        if self.axisRotation != (0, 1, 0, 0):
            result += " axisRotation='" + self.axisRotation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.diskAngle != 0.26179167:
            result += " diskAngle='" + self.diskAngle + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.maxAngle != -1:
            result += " maxAngle='" + self.maxAngle + "'"
        if self.minAngle != 0:
            result += " minAngle='" + self.minAngle + "'"
        if self.offset != 0:
            result += " offset='" + self.offset + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</CylinderSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class DirectionalLight(_X3DLightNode):
    """
    DirectionalLight might not be scoped by parent Group or Transform at levels 1 or 2.
    """
    NAME = 'DirectionalLight'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DirectionalLight'
    FIELD_DECLARATIONS = [('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput),
                          ('direction', (0, 0, -1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('global_', False, FieldType.SFBool, AccessType.inputOutput),
                          ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('on', True, FieldType.SFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ambientIntensity=0,
                 color=(1, 1, 1),
                 direction=(0, 0, -1),
                 global_=False,
                 intensity=1,
                 on=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode DirectionalLight __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.color = color
        self.direction = direction
        self.global_ = global_
        self.intensity = intensity
        self.on = on
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity=None):
        if  ambientIntensity is None:
            ambientIntensity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFColor.DEFAULT_VALUE
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def direction(self):
        return self.__direction
    @direction.setter
    def direction(self, direction=None):
        if  direction is None:
            direction = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def global_(self):
        return self.__global_
    @global_.setter
    def global_(self, global_=None):
        if  global_ is None:
            global_ = SFBool.DEFAULT_VALUE
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity=None):
        if  intensity is None:
            intensity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(intensity)
        assertZeroToOne('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def on(self):
        return self.__on
    @on.setter
    def on(self, on=None):
        if  on is None:
            on = SFBool.DEFAULT_VALUE
        assertValidSFBool(on)
        self.__on = on
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function DirectionalLight.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<DirectionalLight'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ambientIntensity != 0:
            result += " ambientIntensity='" + self.ambientIntensity + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + self.color + "'"
        if self.direction != (0, 0, -1):
            result += " direction='" + self.direction + "'"
        if self.global_ != False:
            result += " global_='" + self.global_ + "'"
        if self.intensity != 1:
            result += " intensity='" + self.intensity + "'"
        if self.on != True:
            result += " on='" + self.on + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</DirectionalLight>' + '\n'
#       print('XML serialization complete.')
        return result

class DISEntityManager(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'DISEntityManager'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DISEntityManager'
    FIELD_DECLARATIONS = [('address', 'localhost', FieldType.SFString, AccessType.inputOutput),
                          ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('port', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('mapping', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 address='localhost',
                 applicationID=0,
                 port=0,
                 siteID=0,
                 mapping=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode DISEntityManager __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.applicationID = applicationID
        self.port = port
        self.siteID = siteID
        self.mapping = mapping
    @property # getter - - - - - - - - - -
    def address(self):
        return self.__address
    @address.setter
    def address(self, address=None):
        if  address is None:
            address = SFString.DEFAULT_VALUE
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def applicationID(self):
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID=None):
        if  applicationID is None:
            applicationID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def port(self):
        return self.__port
    @port.setter
    def port(self, port=None):
        if  port is None:
            port = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def siteID(self):
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID=None):
        if  siteID is None:
            siteID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def mapping(self):
        return self.__mapping
    @mapping.setter
    def mapping(self, mapping=None):
        if  mapping is None:
            mapping = MFNode.DEFAULT_VALUE
        assertValidMFNode(mapping)
        self.__mapping = mapping
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function DISEntityManager.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<DISEntityManager'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.address != 'localhost':
            result += " address='" + self.address + "'"
        if self.applicationID != 0:
            result += " applicationID='" + self.applicationID + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.port != 0:
            result += " port='" + self.port + "'"
        if self.siteID != 0:
            result += " siteID='" + self.siteID + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.mapping: # walk each child node, if any
            result += indent
            for each in self.mapping:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</DISEntityManager>' + '\n'
#       print('XML serialization complete.')
        return result

class DISEntityTypeMapping(_X3DInfoNode):
    """
    X3D element
    """
    NAME = 'DISEntityTypeMapping'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DISEntityTypeMapping'
    FIELD_DECLARATIONS = [('category', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('country', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('domain', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('extra', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('kind', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('specific', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('subcategory', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 category=0,
                 country=0,
                 domain=0,
                 extra=0,
                 kind=0,
                 specific=0,
                 subcategory=0,
                 url=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode DISEntityTypeMapping __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.category = category
        self.country = country
        self.domain = domain
        self.extra = extra
        self.kind = kind
        self.specific = specific
        self.subcategory = subcategory
        self.url = url
    @property # getter - - - - - - - - - -
    def category(self):
        return self.__category
    @category.setter
    def category(self, category=None):
        if  category is None:
            category = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(category)
        assertGreaterThanEquals('category', category, 0)
        assertLessThanEquals('category', category, 255)
        self.__category = category
    @property # getter - - - - - - - - - -
    def country(self):
        return self.__country
    @country.setter
    def country(self, country=None):
        if  country is None:
            country = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(country)
        assertGreaterThanEquals('country', country, 0)
        assertLessThanEquals('country', country, 65535)
        self.__country = country
    @property # getter - - - - - - - - - -
    def domain(self):
        return self.__domain
    @domain.setter
    def domain(self, domain=None):
        if  domain is None:
            domain = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(domain)
        assertGreaterThanEquals('domain', domain, 0)
        assertLessThanEquals('domain', domain, 255)
        self.__domain = domain
    @property # getter - - - - - - - - - -
    def extra(self):
        return self.__extra
    @extra.setter
    def extra(self, extra=None):
        if  extra is None:
            extra = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(extra)
        assertGreaterThanEquals('extra', extra, 0)
        assertLessThanEquals('extra', extra, 255)
        self.__extra = extra
    @property # getter - - - - - - - - - -
    def kind(self):
        return self.__kind
    @kind.setter
    def kind(self, kind=None):
        if  kind is None:
            kind = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(kind)
        assertGreaterThanEquals('kind', kind, 0)
        assertLessThanEquals('kind', kind, 255)
        self.__kind = kind
    @property # getter - - - - - - - - - -
    def specific(self):
        return self.__specific
    @specific.setter
    def specific(self, specific=None):
        if  specific is None:
            specific = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(specific)
        assertGreaterThanEquals('specific', specific, 0)
        assertLessThanEquals('specific', specific, 255)
        self.__specific = specific
    @property # getter - - - - - - - - - -
    def subcategory(self):
        return self.__subcategory
    @subcategory.setter
    def subcategory(self, subcategory=None):
        if  subcategory is None:
            subcategory = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(subcategory)
        assertGreaterThanEquals('subcategory', subcategory, 0)
        assertLessThanEquals('subcategory', subcategory, 255)
        self.__subcategory = subcategory
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function DISEntityTypeMapping.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<DISEntityTypeMapping'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.category != 0:
            result += " category='" + self.category + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.country != 0:
            result += " country='" + self.country + "'"
        if self.domain != 0:
            result += " domain='" + self.domain + "'"
        if self.extra != 0:
            result += " extra='" + self.extra + "'"
        if self.kind != 0:
            result += " kind='" + self.kind + "'"
        if self.specific != 0:
            result += " specific='" + self.specific + "'"
        if self.subcategory != 0:
            result += " subcategory='" + self.subcategory + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</DISEntityTypeMapping>' + '\n'
#       print('XML serialization complete.')
        return result

class Disk2D(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'Disk2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Disk2D'
    FIELD_DECLARATIONS = [('innerRadius', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('outerRadius', 1, FieldType.SFFloat, AccessType.initializeOnly),
                          ('solid', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 innerRadius=0,
                 outerRadius=1,
                 solid=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Disk2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.innerRadius = innerRadius
        self.outerRadius = outerRadius
        self.solid = solid
    @property # getter - - - - - - - - - -
    def innerRadius(self):
        return self.__innerRadius
    @innerRadius.setter
    def innerRadius(self, innerRadius=None):
        if  innerRadius is None:
            innerRadius = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(innerRadius)
        assertNonNegative('innerRadius', innerRadius)
        self.__innerRadius = innerRadius
    @property # getter - - - - - - - - - -
    def outerRadius(self):
        return self.__outerRadius
    @outerRadius.setter
    def outerRadius(self, outerRadius=None):
        if  outerRadius is None:
            outerRadius = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(outerRadius)
        assertPositive('outerRadius', outerRadius)
        self.__outerRadius = outerRadius
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Disk2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Disk2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.innerRadius != 0:
            result += " innerRadius='" + self.innerRadius + "'"
        if self.outerRadius != 1:
            result += " outerRadius='" + self.outerRadius + "'"
        if self.solid != False:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Disk2D>' + '\n'
#       print('XML serialization complete.')
        return result

class DoubleAxisHingeJoint(_X3DRigidJointNode):
    """
    DoubleAxisHingeJoint has two independent axes located around a common anchor point.
    """
    NAME = 'DoubleAxisHingeJoint'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DoubleAxisHingeJoint'
    FIELD_DECLARATIONS = [('anchorPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('axis1', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('axis2', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('desiredAngularVelocity1', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('desiredAngularVelocity2', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput),
                          ('maxAngle1', 3.141592653, FieldType.SFFloat, AccessType.inputOutput),
                          ('maxTorque1', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('maxTorque2', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('minAngle1', -3.141592653, FieldType.SFFloat, AccessType.inputOutput),
                          ('stop1Bounce', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('stop1ConstantForceMix', 0.001, FieldType.SFFloat, AccessType.inputOutput),
                          ('stop1ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput),
                          ('suspensionErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput),
                          ('suspensionForce', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('body1', None, FieldType.SFNode, AccessType.inputOutput),
                          ('body2', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 anchorPoint=(0, 0, 0),
                 axis1=(0, 0, 0),
                 axis2=(0, 0, 0),
                 desiredAngularVelocity1=0,
                 desiredAngularVelocity2=0,
                 forceOutput=["NONE"],
                 maxAngle1=3.141592653,
                 maxTorque1=0,
                 maxTorque2=0,
                 minAngle1=-3.141592653,
                 stop1Bounce=0,
                 stop1ConstantForceMix=0.001,
                 stop1ErrorCorrection=0.8,
                 suspensionErrorCorrection=0.8,
                 suspensionForce=0,
                 body1=None,
                 body2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode DoubleAxisHingeJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.anchorPoint = anchorPoint
        self.axis1 = axis1
        self.axis2 = axis2
        self.desiredAngularVelocity1 = desiredAngularVelocity1
        self.desiredAngularVelocity2 = desiredAngularVelocity2
        self.forceOutput = forceOutput
        self.maxAngle1 = maxAngle1
        self.maxTorque1 = maxTorque1
        self.maxTorque2 = maxTorque2
        self.minAngle1 = minAngle1
        self.stop1Bounce = stop1Bounce
        self.stop1ConstantForceMix = stop1ConstantForceMix
        self.stop1ErrorCorrection = stop1ErrorCorrection
        self.suspensionErrorCorrection = suspensionErrorCorrection
        self.suspensionForce = suspensionForce
        self.body1 = body1
        self.body2 = body2
    @property # getter - - - - - - - - - -
    def anchorPoint(self):
        return self.__anchorPoint
    @anchorPoint.setter
    def anchorPoint(self, anchorPoint=None):
        if  anchorPoint is None:
            anchorPoint = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(anchorPoint)
        self.__anchorPoint = anchorPoint
    @property # getter - - - - - - - - - -
    def axis1(self):
        return self.__axis1
    @axis1.setter
    def axis1(self, axis1=None):
        if  axis1 is None:
            axis1 = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(axis1)
        self.__axis1 = axis1
    @property # getter - - - - - - - - - -
    def axis2(self):
        return self.__axis2
    @axis2.setter
    def axis2(self, axis2=None):
        if  axis2 is None:
            axis2 = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(axis2)
        self.__axis2 = axis2
    @property # getter - - - - - - - - - -
    def desiredAngularVelocity1(self):
        return self.__desiredAngularVelocity1
    @desiredAngularVelocity1.setter
    def desiredAngularVelocity1(self, desiredAngularVelocity1=None):
        if  desiredAngularVelocity1 is None:
            desiredAngularVelocity1 = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(desiredAngularVelocity1)
        self.__desiredAngularVelocity1 = desiredAngularVelocity1
    @property # getter - - - - - - - - - -
    def desiredAngularVelocity2(self):
        return self.__desiredAngularVelocity2
    @desiredAngularVelocity2.setter
    def desiredAngularVelocity2(self, desiredAngularVelocity2=None):
        if  desiredAngularVelocity2 is None:
            desiredAngularVelocity2 = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(desiredAngularVelocity2)
        self.__desiredAngularVelocity2 = desiredAngularVelocity2
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput=None):
        if  forceOutput is None:
            forceOutput = MFString.DEFAULT_VALUE
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def maxAngle1(self):
        return self.__maxAngle1
    @maxAngle1.setter
    def maxAngle1(self, maxAngle1=None):
        if  maxAngle1 is None:
            maxAngle1 = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(maxAngle1)
        self.__maxAngle1 = maxAngle1
    @property # getter - - - - - - - - - -
    def maxTorque1(self):
        return self.__maxTorque1
    @maxTorque1.setter
    def maxTorque1(self, maxTorque1=None):
        if  maxTorque1 is None:
            maxTorque1 = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(maxTorque1)
        self.__maxTorque1 = maxTorque1
    @property # getter - - - - - - - - - -
    def maxTorque2(self):
        return self.__maxTorque2
    @maxTorque2.setter
    def maxTorque2(self, maxTorque2=None):
        if  maxTorque2 is None:
            maxTorque2 = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(maxTorque2)
        self.__maxTorque2 = maxTorque2
    @property # getter - - - - - - - - - -
    def minAngle1(self):
        return self.__minAngle1
    @minAngle1.setter
    def minAngle1(self, minAngle1=None):
        if  minAngle1 is None:
            minAngle1 = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(minAngle1)
        self.__minAngle1 = minAngle1
    @property # getter - - - - - - - - - -
    def stop1Bounce(self):
        return self.__stop1Bounce
    @stop1Bounce.setter
    def stop1Bounce(self, stop1Bounce=None):
        if  stop1Bounce is None:
            stop1Bounce = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stop1Bounce)
        self.__stop1Bounce = stop1Bounce
    @property # getter - - - - - - - - - -
    def stop1ConstantForceMix(self):
        return self.__stop1ConstantForceMix
    @stop1ConstantForceMix.setter
    def stop1ConstantForceMix(self, stop1ConstantForceMix=None):
        if  stop1ConstantForceMix is None:
            stop1ConstantForceMix = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stop1ConstantForceMix)
        self.__stop1ConstantForceMix = stop1ConstantForceMix
    @property # getter - - - - - - - - - -
    def stop1ErrorCorrection(self):
        return self.__stop1ErrorCorrection
    @stop1ErrorCorrection.setter
    def stop1ErrorCorrection(self, stop1ErrorCorrection=None):
        if  stop1ErrorCorrection is None:
            stop1ErrorCorrection = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stop1ErrorCorrection)
        self.__stop1ErrorCorrection = stop1ErrorCorrection
    @property # getter - - - - - - - - - -
    def suspensionErrorCorrection(self):
        return self.__suspensionErrorCorrection
    @suspensionErrorCorrection.setter
    def suspensionErrorCorrection(self, suspensionErrorCorrection=None):
        if  suspensionErrorCorrection is None:
            suspensionErrorCorrection = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(suspensionErrorCorrection)
        self.__suspensionErrorCorrection = suspensionErrorCorrection
    @property # getter - - - - - - - - - -
    def suspensionForce(self):
        return self.__suspensionForce
    @suspensionForce.setter
    def suspensionForce(self, suspensionForce=None):
        if  suspensionForce is None:
            suspensionForce = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(suspensionForce)
        self.__suspensionForce = suspensionForce
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1=None):
        if  body1 is None:
            body1 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            print(flush=True)
            raise TypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2=None):
        if  body2 is None:
            body2 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            print(flush=True)
            raise TypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function DoubleAxisHingeJoint.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<DoubleAxisHingeJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.anchorPoint != (0, 0, 0):
            result += " anchorPoint='" + self.anchorPoint + "'"
        if self.axis1 != (0, 0, 0):
            result += " axis1='" + self.axis1 + "'"
        if self.axis2 != (0, 0, 0):
            result += " axis2='" + self.axis2 + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.desiredAngularVelocity1 != 0:
            result += " desiredAngularVelocity1='" + self.desiredAngularVelocity1 + "'"
        if self.desiredAngularVelocity2 != 0:
            result += " desiredAngularVelocity2='" + self.desiredAngularVelocity2 + "'"
        if self.forceOutput != ["NONE"]:
            result += " forceOutput='" + self.forceOutput + "'"
        if self.maxAngle1 != 3.141592653:
            result += " maxAngle1='" + self.maxAngle1 + "'"
        if self.maxTorque1 != 0:
            result += " maxTorque1='" + self.maxTorque1 + "'"
        if self.maxTorque2 != 0:
            result += " maxTorque2='" + self.maxTorque2 + "'"
        if self.minAngle1 != -3.141592653:
            result += " minAngle1='" + self.minAngle1 + "'"
        if self.stop1Bounce != 0:
            result += " stop1Bounce='" + self.stop1Bounce + "'"
        if self.stop1ConstantForceMix != 0.001:
            result += " stop1ConstantForceMix='" + self.stop1ConstantForceMix + "'"
        if self.stop1ErrorCorrection != 0.8:
            result += " stop1ErrorCorrection='" + self.stop1ErrorCorrection + "'"
        if self.suspensionErrorCorrection != 0.8:
            result += " suspensionErrorCorrection='" + self.suspensionErrorCorrection + "'"
        if self.suspensionForce != 0:
            result += " suspensionForce='" + self.suspensionForce + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body1: # walk each child node, if any
            result += indent
            for each in self.body1:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body2: # walk each child node, if any
            result += indent
            for each in self.body2:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</DoubleAxisHingeJoint>' + '\n'
#       print('XML serialization complete.')
        return result

class EaseInEaseOut(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'EaseInEaseOut'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#EaseInEaseOut'
    FIELD_DECLARATIONS = [('easeInEaseOut', list(), FieldType.MFVec2f, AccessType.inputOutput),
                          ('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 easeInEaseOut=list(),
                 key=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode EaseInEaseOut __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.easeInEaseOut = easeInEaseOut
        self.key = key
    @property # getter - - - - - - - - - -
    def easeInEaseOut(self):
        return self.__easeInEaseOut
    @easeInEaseOut.setter
    def easeInEaseOut(self, easeInEaseOut=None):
        if  easeInEaseOut is None:
            easeInEaseOut = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(easeInEaseOut)
        self.__easeInEaseOut = easeInEaseOut
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function EaseInEaseOut.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<EaseInEaseOut'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.easeInEaseOut != list():
            result += " easeInEaseOut='" + self.easeInEaseOut + "'"
        if self.key != list():
            result += " key='" + self.key + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</EaseInEaseOut>' + '\n'
#       print('XML serialization complete.')
        return result

class EdgeEnhancementVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    X3D element
    """
    NAME = 'EdgeEnhancementVolumeStyle'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#EdgeEnhancementVolumeStyle'
    FIELD_DECLARATIONS = [('edgeColor', (0, 0, 0, 1), FieldType.SFColorRGBA, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('gradientThreshold', 0.4, FieldType.SFFloat, AccessType.inputOutput),
                          ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 edgeColor=(0, 0, 0, 1),
                 enabled=True,
                 gradientThreshold=0.4,
                 surfaceNormals=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode EdgeEnhancementVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.edgeColor = edgeColor
        self.enabled = enabled
        self.gradientThreshold = gradientThreshold
        self.surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def edgeColor(self):
        return self.__edgeColor
    @edgeColor.setter
    def edgeColor(self, edgeColor=None):
        if  edgeColor is None:
            edgeColor = SFColorRGBA.DEFAULT_VALUE
        assertValidSFColorRGBA(edgeColor)
        assertZeroToOne('edgeColor', edgeColor)
        self.__edgeColor = edgeColor
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gradientThreshold(self):
        return self.__gradientThreshold
    @gradientThreshold.setter
    def gradientThreshold(self, gradientThreshold=None):
        if  gradientThreshold is None:
            gradientThreshold = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(gradientThreshold)
        assertGreaterThanEquals('gradientThreshold', gradientThreshold, 0)
        assertLessThanEquals('gradientThreshold', gradientThreshold, 3.1416)
        self.__gradientThreshold = gradientThreshold
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals=None):
        if  surfaceNormals is None:
            surfaceNormals = SFNode.DEFAULT_VALUE
        assertValidSFNode(surfaceNormals)
        if not isinstance(surfaceNormals, object):
            print(flush=True)
            raise TypeError(str(surfaceNormals) + ' does not have a valid node type object')
        self.__surfaceNormals = surfaceNormals
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function EdgeEnhancementVolumeStyle.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<EdgeEnhancementVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.edgeColor != (0, 0, 0, 1):
            result += " edgeColor='" + self.edgeColor + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.gradientThreshold != 0.4:
            result += " gradientThreshold='" + self.gradientThreshold + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.surfaceNormals: # walk each child node, if any
            result += indent
            for each in self.surfaceNormals:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</EdgeEnhancementVolumeStyle>' + '\n'
#       print('XML serialization complete.')
        return result

class ElevationGrid(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'ElevationGrid'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ElevationGrid'
    FIELD_DECLARATIONS = [('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('creaseAngle', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('height', [0, 0, 0, 0], FieldType.MFFloat, AccessType.initializeOnly),
                          ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('xDimension', 2, FieldType.SFInt32, AccessType.initializeOnly),
                          ('xSpacing', 1.0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('zDimension', 2, FieldType.SFInt32, AccessType.initializeOnly),
                          ('zSpacing', 1.0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('normal', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('attrib', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 creaseAngle=0,
                 height=[0, 0, 0, 0],
                 normalPerVertex=True,
                 solid=True,
                 xDimension=2,
                 xSpacing=1.0,
                 zDimension=2,
                 zSpacing=1.0,
                 color=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ElevationGrid __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.creaseAngle = creaseAngle
        self.height = height
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.xDimension = xDimension
        self.xSpacing = xSpacing
        self.zDimension = zDimension
        self.zSpacing = zSpacing
        self.color = color
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex=None):
        if  colorPerVertex is None:
            colorPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def creaseAngle(self):
        return self.__creaseAngle
    @creaseAngle.setter
    def creaseAngle(self, creaseAngle=None):
        if  creaseAngle is None:
            creaseAngle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(creaseAngle)
        assertNonNegative('creaseAngle', creaseAngle)
        self.__creaseAngle = creaseAngle
    @property # getter - - - - - - - - - -
    def height(self):
        return self.__height
    @height.setter
    def height(self, height=None):
        if  height is None:
            height = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(height)
        self.__height = height
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex=None):
        if  normalPerVertex is None:
            normalPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def xDimension(self):
        return self.__xDimension
    @xDimension.setter
    def xDimension(self, xDimension=None):
        if  xDimension is None:
            xDimension = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(xDimension)
        assertNonNegative('xDimension', xDimension)
        self.__xDimension = xDimension
    @property # getter - - - - - - - - - -
    def xSpacing(self):
        return self.__xSpacing
    @xSpacing.setter
    def xSpacing(self, xSpacing=None):
        if  xSpacing is None:
            xSpacing = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(xSpacing)
        assertPositive('xSpacing', xSpacing)
        self.__xSpacing = xSpacing
    @property # getter - - - - - - - - - -
    def zDimension(self):
        return self.__zDimension
    @zDimension.setter
    def zDimension(self, zDimension=None):
        if  zDimension is None:
            zDimension = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(zDimension)
        assertNonNegative('zDimension', zDimension)
        self.__zDimension = zDimension
    @property # getter - - - - - - - - - -
    def zSpacing(self):
        return self.__zSpacing
    @zSpacing.setter
    def zSpacing(self, zSpacing=None):
        if  zSpacing is None:
            zSpacing = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(zSpacing)
        assertPositive('zSpacing', zSpacing)
        self.__zSpacing = zSpacing
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord=None):
        if  fogCoord is None:
            fogCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            print(flush=True)
            raise TypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal=None):
        if  normal is None:
            normal = SFNode.DEFAULT_VALUE
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            print(flush=True)
            raise TypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            print(flush=True)
            raise TypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib=None):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ElevationGrid.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ElevationGrid'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorPerVertex != True:
            result += " colorPerVertex='" + self.colorPerVertex + "'"
        if self.creaseAngle != 0:
            result += " creaseAngle='" + self.creaseAngle + "'"
        if self.height != [0, 0, 0, 0]:
            result += " height='" + self.height + "'"
        if self.normalPerVertex != True:
            result += " normalPerVertex='" + self.normalPerVertex + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'"
        if self.xDimension != 2:
            result += " xDimension='" + self.xDimension + "'"
        if self.xSpacing != 1.0:
            result += " xSpacing='" + self.xSpacing + "'"
        if self.zDimension != 2:
            result += " zDimension='" + self.zDimension + "'"
        if self.zSpacing != 1.0:
            result += " zSpacing='" + self.zSpacing + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fogCoord: # walk each child node, if any
            result += indent
            for each in self.fogCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.normal: # walk each child node, if any
            result += indent
            for each in self.normal:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.attrib: # walk each child node, if any
            result += indent
            for each in self.attrib:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ElevationGrid>' + '\n'
#       print('XML serialization complete.')
        return result

class EspduTransform(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'EspduTransform'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#EspduTransform'
    FIELD_DECLARATIONS = [('address', 'localhost', FieldType.SFString, AccessType.inputOutput),
                          ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('articulationParameterArray', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('articulationParameterChangeIndicatorArray', list(), FieldType.MFInt32, AccessType.inputOutput),
                          ('articulationParameterCount', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('articulationParameterDesignatorArray', list(), FieldType.MFInt32, AccessType.inputOutput),
                          ('articulationParameterIdPartAttachedToArray', list(), FieldType.MFInt32, AccessType.inputOutput),
                          ('articulationParameterTypeArray', list(), FieldType.MFInt32, AccessType.inputOutput),
                          ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('collisionType', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('deadReckoning', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('detonationLocation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('detonationRelativeLocation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('detonationResult', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('entityCategory', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('entityCountry', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('entityDomain', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('entityExtra', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('entityID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('entityKind', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('entitySpecific', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('entitySubcategory', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('eventApplicationID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('eventEntityID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('eventNumber', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('eventSiteID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('fired1', False, FieldType.SFBool, AccessType.inputOutput),
                          ('fired2', False, FieldType.SFBool, AccessType.inputOutput),
                          ('fireMissionIndex', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('firingRange', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('firingRate', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('forceID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('fuse', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput),
                          ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('linearAcceleration', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('linearVelocity', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('marking', '', FieldType.SFString, AccessType.inputOutput),
                          ('multicastRelayHost', '', FieldType.SFString, AccessType.inputOutput),
                          ('multicastRelayPort', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('munitionApplicationID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('munitionEndPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('munitionEntityID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('munitionQuantity', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('munitionSiteID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('munitionStartPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('networkMode', 'standAlone', FieldType.SFString, AccessType.inputOutput),
                          ('port', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('readInterval', 0.1, FieldType.SFTime, AccessType.inputOutput),
                          ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('rtpHeaderExpected', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('warhead', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('writeInterval', 1.0, FieldType.SFTime, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 address='localhost',
                 applicationID=0,
                 articulationParameterArray=list(),
                 articulationParameterChangeIndicatorArray=list(),
                 articulationParameterCount=0,
                 articulationParameterDesignatorArray=list(),
                 articulationParameterIdPartAttachedToArray=list(),
                 articulationParameterTypeArray=list(),
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 collisionType=0,
                 deadReckoning=0,
                 detonationLocation=(0, 0, 0),
                 detonationRelativeLocation=(0, 0, 0),
                 detonationResult=0,
                 enabled=True,
                 entityCategory=0,
                 entityCountry=0,
                 entityDomain=0,
                 entityExtra=0,
                 entityID=0,
                 entityKind=0,
                 entitySpecific=0,
                 entitySubcategory=0,
                 eventApplicationID=0,
                 eventEntityID=0,
                 eventNumber=0,
                 eventSiteID=0,
                 fired1=False,
                 fired2=False,
                 fireMissionIndex=0,
                 firingRange=0,
                 firingRate=0,
                 forceID=0,
                 fuse=0,
                 geoCoords=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 linearAcceleration=(0, 0, 0),
                 linearVelocity=(0, 0, 0),
                 marking='',
                 multicastRelayHost='',
                 multicastRelayPort=0,
                 munitionApplicationID=0,
                 munitionEndPoint=(0, 0, 0),
                 munitionEntityID=0,
                 munitionQuantity=0,
                 munitionSiteID=0,
                 munitionStartPoint=(0, 0, 0),
                 networkMode='standAlone',
                 port=0,
                 readInterval=0.1,
                 rotation=(0, 0, 1, 0),
                 rtpHeaderExpected=False,
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 siteID=0,
                 translation=(0, 0, 0),
                 warhead=0,
                 writeInterval=1.0,
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode EspduTransform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.applicationID = applicationID
        self.articulationParameterArray = articulationParameterArray
        self.articulationParameterChangeIndicatorArray = articulationParameterChangeIndicatorArray
        self.articulationParameterCount = articulationParameterCount
        self.articulationParameterDesignatorArray = articulationParameterDesignatorArray
        self.articulationParameterIdPartAttachedToArray = articulationParameterIdPartAttachedToArray
        self.articulationParameterTypeArray = articulationParameterTypeArray
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.center = center
        self.collisionType = collisionType
        self.deadReckoning = deadReckoning
        self.detonationLocation = detonationLocation
        self.detonationRelativeLocation = detonationRelativeLocation
        self.detonationResult = detonationResult
        self.enabled = enabled
        self.entityCategory = entityCategory
        self.entityCountry = entityCountry
        self.entityDomain = entityDomain
        self.entityExtra = entityExtra
        self.entityID = entityID
        self.entityKind = entityKind
        self.entitySpecific = entitySpecific
        self.entitySubcategory = entitySubcategory
        self.eventApplicationID = eventApplicationID
        self.eventEntityID = eventEntityID
        self.eventNumber = eventNumber
        self.eventSiteID = eventSiteID
        self.fired1 = fired1
        self.fired2 = fired2
        self.fireMissionIndex = fireMissionIndex
        self.firingRange = firingRange
        self.firingRate = firingRate
        self.forceID = forceID
        self.fuse = fuse
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.linearAcceleration = linearAcceleration
        self.linearVelocity = linearVelocity
        self.marking = marking
        self.multicastRelayHost = multicastRelayHost
        self.multicastRelayPort = multicastRelayPort
        self.munitionApplicationID = munitionApplicationID
        self.munitionEndPoint = munitionEndPoint
        self.munitionEntityID = munitionEntityID
        self.munitionQuantity = munitionQuantity
        self.munitionSiteID = munitionSiteID
        self.munitionStartPoint = munitionStartPoint
        self.networkMode = networkMode
        self.port = port
        self.readInterval = readInterval
        self.rotation = rotation
        self.rtpHeaderExpected = rtpHeaderExpected
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.siteID = siteID
        self.translation = translation
        self.warhead = warhead
        self.writeInterval = writeInterval
        self.children = children
    @property # getter - - - - - - - - - -
    def address(self):
        return self.__address
    @address.setter
    def address(self, address=None):
        if  address is None:
            address = SFString.DEFAULT_VALUE
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def applicationID(self):
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID=None):
        if  applicationID is None:
            applicationID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def articulationParameterArray(self):
        return self.__articulationParameterArray
    @articulationParameterArray.setter
    def articulationParameterArray(self, articulationParameterArray=None):
        if  articulationParameterArray is None:
            articulationParameterArray = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(articulationParameterArray)
        self.__articulationParameterArray = articulationParameterArray
    @property # getter - - - - - - - - - -
    def articulationParameterChangeIndicatorArray(self):
        return self.__articulationParameterChangeIndicatorArray
    @articulationParameterChangeIndicatorArray.setter
    def articulationParameterChangeIndicatorArray(self, articulationParameterChangeIndicatorArray=None):
        if  articulationParameterChangeIndicatorArray is None:
            articulationParameterChangeIndicatorArray = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(articulationParameterChangeIndicatorArray)
        self.__articulationParameterChangeIndicatorArray = articulationParameterChangeIndicatorArray
    @property # getter - - - - - - - - - -
    def articulationParameterCount(self):
        return self.__articulationParameterCount
    @articulationParameterCount.setter
    def articulationParameterCount(self, articulationParameterCount=None):
        if  articulationParameterCount is None:
            articulationParameterCount = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(articulationParameterCount)
        self.__articulationParameterCount = articulationParameterCount
    @property # getter - - - - - - - - - -
    def articulationParameterDesignatorArray(self):
        return self.__articulationParameterDesignatorArray
    @articulationParameterDesignatorArray.setter
    def articulationParameterDesignatorArray(self, articulationParameterDesignatorArray=None):
        if  articulationParameterDesignatorArray is None:
            articulationParameterDesignatorArray = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(articulationParameterDesignatorArray)
        self.__articulationParameterDesignatorArray = articulationParameterDesignatorArray
    @property # getter - - - - - - - - - -
    def articulationParameterIdPartAttachedToArray(self):
        return self.__articulationParameterIdPartAttachedToArray
    @articulationParameterIdPartAttachedToArray.setter
    def articulationParameterIdPartAttachedToArray(self, articulationParameterIdPartAttachedToArray=None):
        if  articulationParameterIdPartAttachedToArray is None:
            articulationParameterIdPartAttachedToArray = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(articulationParameterIdPartAttachedToArray)
        self.__articulationParameterIdPartAttachedToArray = articulationParameterIdPartAttachedToArray
    @property # getter - - - - - - - - - -
    def articulationParameterTypeArray(self):
        return self.__articulationParameterTypeArray
    @articulationParameterTypeArray.setter
    def articulationParameterTypeArray(self, articulationParameterTypeArray=None):
        if  articulationParameterTypeArray is None:
            articulationParameterTypeArray = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(articulationParameterTypeArray)
        self.__articulationParameterTypeArray = articulationParameterTypeArray
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def collisionType(self):
        return self.__collisionType
    @collisionType.setter
    def collisionType(self, collisionType=None):
        if  collisionType is None:
            collisionType = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(collisionType)
        self.__collisionType = collisionType
    @property # getter - - - - - - - - - -
    def deadReckoning(self):
        return self.__deadReckoning
    @deadReckoning.setter
    def deadReckoning(self, deadReckoning=None):
        if  deadReckoning is None:
            deadReckoning = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(deadReckoning)
        self.__deadReckoning = deadReckoning
    @property # getter - - - - - - - - - -
    def detonationLocation(self):
        return self.__detonationLocation
    @detonationLocation.setter
    def detonationLocation(self, detonationLocation=None):
        if  detonationLocation is None:
            detonationLocation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(detonationLocation)
        self.__detonationLocation = detonationLocation
    @property # getter - - - - - - - - - -
    def detonationRelativeLocation(self):
        return self.__detonationRelativeLocation
    @detonationRelativeLocation.setter
    def detonationRelativeLocation(self, detonationRelativeLocation=None):
        if  detonationRelativeLocation is None:
            detonationRelativeLocation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(detonationRelativeLocation)
        self.__detonationRelativeLocation = detonationRelativeLocation
    @property # getter - - - - - - - - - -
    def detonationResult(self):
        return self.__detonationResult
    @detonationResult.setter
    def detonationResult(self, detonationResult=None):
        if  detonationResult is None:
            detonationResult = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(detonationResult)
        self.__detonationResult = detonationResult
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def entityCategory(self):
        return self.__entityCategory
    @entityCategory.setter
    def entityCategory(self, entityCategory=None):
        if  entityCategory is None:
            entityCategory = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(entityCategory)
        self.__entityCategory = entityCategory
    @property # getter - - - - - - - - - -
    def entityCountry(self):
        return self.__entityCountry
    @entityCountry.setter
    def entityCountry(self, entityCountry=None):
        if  entityCountry is None:
            entityCountry = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(entityCountry)
        self.__entityCountry = entityCountry
    @property # getter - - - - - - - - - -
    def entityDomain(self):
        return self.__entityDomain
    @entityDomain.setter
    def entityDomain(self, entityDomain=None):
        if  entityDomain is None:
            entityDomain = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(entityDomain)
        self.__entityDomain = entityDomain
    @property # getter - - - - - - - - - -
    def entityExtra(self):
        return self.__entityExtra
    @entityExtra.setter
    def entityExtra(self, entityExtra=None):
        if  entityExtra is None:
            entityExtra = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(entityExtra)
        self.__entityExtra = entityExtra
    @property # getter - - - - - - - - - -
    def entityID(self):
        return self.__entityID
    @entityID.setter
    def entityID(self, entityID=None):
        if  entityID is None:
            entityID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(entityID)
        self.__entityID = entityID
    @property # getter - - - - - - - - - -
    def entityKind(self):
        return self.__entityKind
    @entityKind.setter
    def entityKind(self, entityKind=None):
        if  entityKind is None:
            entityKind = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(entityKind)
        self.__entityKind = entityKind
    @property # getter - - - - - - - - - -
    def entitySpecific(self):
        return self.__entitySpecific
    @entitySpecific.setter
    def entitySpecific(self, entitySpecific=None):
        if  entitySpecific is None:
            entitySpecific = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(entitySpecific)
        self.__entitySpecific = entitySpecific
    @property # getter - - - - - - - - - -
    def entitySubcategory(self):
        return self.__entitySubcategory
    @entitySubcategory.setter
    def entitySubcategory(self, entitySubcategory=None):
        if  entitySubcategory is None:
            entitySubcategory = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(entitySubcategory)
        self.__entitySubcategory = entitySubcategory
    @property # getter - - - - - - - - - -
    def eventApplicationID(self):
        return self.__eventApplicationID
    @eventApplicationID.setter
    def eventApplicationID(self, eventApplicationID=None):
        if  eventApplicationID is None:
            eventApplicationID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(eventApplicationID)
        self.__eventApplicationID = eventApplicationID
    @property # getter - - - - - - - - - -
    def eventEntityID(self):
        return self.__eventEntityID
    @eventEntityID.setter
    def eventEntityID(self, eventEntityID=None):
        if  eventEntityID is None:
            eventEntityID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(eventEntityID)
        self.__eventEntityID = eventEntityID
    @property # getter - - - - - - - - - -
    def eventNumber(self):
        return self.__eventNumber
    @eventNumber.setter
    def eventNumber(self, eventNumber=None):
        if  eventNumber is None:
            eventNumber = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(eventNumber)
        self.__eventNumber = eventNumber
    @property # getter - - - - - - - - - -
    def eventSiteID(self):
        return self.__eventSiteID
    @eventSiteID.setter
    def eventSiteID(self, eventSiteID=None):
        if  eventSiteID is None:
            eventSiteID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(eventSiteID)
        self.__eventSiteID = eventSiteID
    @property # getter - - - - - - - - - -
    def fired1(self):
        return self.__fired1
    @fired1.setter
    def fired1(self, fired1=None):
        if  fired1 is None:
            fired1 = SFBool.DEFAULT_VALUE
        assertValidSFBool(fired1)
        self.__fired1 = fired1
    @property # getter - - - - - - - - - -
    def fired2(self):
        return self.__fired2
    @fired2.setter
    def fired2(self, fired2=None):
        if  fired2 is None:
            fired2 = SFBool.DEFAULT_VALUE
        assertValidSFBool(fired2)
        self.__fired2 = fired2
    @property # getter - - - - - - - - - -
    def fireMissionIndex(self):
        return self.__fireMissionIndex
    @fireMissionIndex.setter
    def fireMissionIndex(self, fireMissionIndex=None):
        if  fireMissionIndex is None:
            fireMissionIndex = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(fireMissionIndex)
        self.__fireMissionIndex = fireMissionIndex
    @property # getter - - - - - - - - - -
    def firingRange(self):
        return self.__firingRange
    @firingRange.setter
    def firingRange(self, firingRange=None):
        if  firingRange is None:
            firingRange = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(firingRange)
        self.__firingRange = firingRange
    @property # getter - - - - - - - - - -
    def firingRate(self):
        return self.__firingRate
    @firingRate.setter
    def firingRate(self, firingRate=None):
        if  firingRate is None:
            firingRate = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(firingRate)
        self.__firingRate = firingRate
    @property # getter - - - - - - - - - -
    def forceID(self):
        return self.__forceID
    @forceID.setter
    def forceID(self, forceID=None):
        if  forceID is None:
            forceID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(forceID)
        self.__forceID = forceID
    @property # getter - - - - - - - - - -
    def fuse(self):
        return self.__fuse
    @fuse.setter
    def fuse(self, fuse=None):
        if  fuse is None:
            fuse = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(fuse)
        self.__fuse = fuse
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords=None):
        if  geoCoords is None:
            geoCoords = SFVec3d.DEFAULT_VALUE
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def linearAcceleration(self):
        return self.__linearAcceleration
    @linearAcceleration.setter
    def linearAcceleration(self, linearAcceleration=None):
        if  linearAcceleration is None:
            linearAcceleration = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(linearAcceleration)
        self.__linearAcceleration = linearAcceleration
    @property # getter - - - - - - - - - -
    def linearVelocity(self):
        return self.__linearVelocity
    @linearVelocity.setter
    def linearVelocity(self, linearVelocity=None):
        if  linearVelocity is None:
            linearVelocity = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(linearVelocity)
        self.__linearVelocity = linearVelocity
    @property # getter - - - - - - - - - -
    def marking(self):
        return self.__marking
    @marking.setter
    def marking(self, marking=None):
        if  marking is None:
            marking = SFString.DEFAULT_VALUE
        assertValidSFString(marking)
        self.__marking = marking
    @property # getter - - - - - - - - - -
    def multicastRelayHost(self):
        return self.__multicastRelayHost
    @multicastRelayHost.setter
    def multicastRelayHost(self, multicastRelayHost=None):
        if  multicastRelayHost is None:
            multicastRelayHost = SFString.DEFAULT_VALUE
        assertValidSFString(multicastRelayHost)
        self.__multicastRelayHost = multicastRelayHost
    @property # getter - - - - - - - - - -
    def multicastRelayPort(self):
        return self.__multicastRelayPort
    @multicastRelayPort.setter
    def multicastRelayPort(self, multicastRelayPort=None):
        if  multicastRelayPort is None:
            multicastRelayPort = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(multicastRelayPort)
        self.__multicastRelayPort = multicastRelayPort
    @property # getter - - - - - - - - - -
    def munitionApplicationID(self):
        return self.__munitionApplicationID
    @munitionApplicationID.setter
    def munitionApplicationID(self, munitionApplicationID=None):
        if  munitionApplicationID is None:
            munitionApplicationID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(munitionApplicationID)
        self.__munitionApplicationID = munitionApplicationID
    @property # getter - - - - - - - - - -
    def munitionEndPoint(self):
        return self.__munitionEndPoint
    @munitionEndPoint.setter
    def munitionEndPoint(self, munitionEndPoint=None):
        if  munitionEndPoint is None:
            munitionEndPoint = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(munitionEndPoint)
        self.__munitionEndPoint = munitionEndPoint
    @property # getter - - - - - - - - - -
    def munitionEntityID(self):
        return self.__munitionEntityID
    @munitionEntityID.setter
    def munitionEntityID(self, munitionEntityID=None):
        if  munitionEntityID is None:
            munitionEntityID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(munitionEntityID)
        self.__munitionEntityID = munitionEntityID
    @property # getter - - - - - - - - - -
    def munitionQuantity(self):
        return self.__munitionQuantity
    @munitionQuantity.setter
    def munitionQuantity(self, munitionQuantity=None):
        if  munitionQuantity is None:
            munitionQuantity = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(munitionQuantity)
        self.__munitionQuantity = munitionQuantity
    @property # getter - - - - - - - - - -
    def munitionSiteID(self):
        return self.__munitionSiteID
    @munitionSiteID.setter
    def munitionSiteID(self, munitionSiteID=None):
        if  munitionSiteID is None:
            munitionSiteID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(munitionSiteID)
        self.__munitionSiteID = munitionSiteID
    @property # getter - - - - - - - - - -
    def munitionStartPoint(self):
        return self.__munitionStartPoint
    @munitionStartPoint.setter
    def munitionStartPoint(self, munitionStartPoint=None):
        if  munitionStartPoint is None:
            munitionStartPoint = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(munitionStartPoint)
        self.__munitionStartPoint = munitionStartPoint
    @property # getter - - - - - - - - - -
    def networkMode(self):
        return self.__networkMode
    @networkMode.setter
    def networkMode(self, networkMode=None):
        if  networkMode is None:
            networkMode = SFString.DEFAULT_VALUE
        assertValidSFString(networkMode)
        self.__networkMode = networkMode
    @property # getter - - - - - - - - - -
    def port(self):
        return self.__port
    @port.setter
    def port(self, port=None):
        if  port is None:
            port = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def readInterval(self):
        return self.__readInterval
    @readInterval.setter
    def readInterval(self, readInterval=None):
        if  readInterval is None:
            readInterval = SFTime.DEFAULT_VALUE
        assertValidSFTime(readInterval)
        assertNonNegative('readInterval', readInterval)
        self.__readInterval = readInterval
    @property # getter - - - - - - - - - -
    def rotation(self):
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation=None):
        if  rotation is None:
            rotation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def rtpHeaderExpected(self):
        return self.__rtpHeaderExpected
    @rtpHeaderExpected.setter
    def rtpHeaderExpected(self, rtpHeaderExpected=None):
        if  rtpHeaderExpected is None:
            rtpHeaderExpected = SFBool.DEFAULT_VALUE
        assertValidSFBool(rtpHeaderExpected)
        self.__rtpHeaderExpected = rtpHeaderExpected
    @property # getter - - - - - - - - - -
    def scale(self):
        return self.__scale
    @scale.setter
    def scale(self, scale=None):
        if  scale is None:
            scale = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation=None):
        if  scaleOrientation is None:
            scaleOrientation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def siteID(self):
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID=None):
        if  siteID is None:
            siteID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def translation(self):
        return self.__translation
    @translation.setter
    def translation(self, translation=None):
        if  translation is None:
            translation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def warhead(self):
        return self.__warhead
    @warhead.setter
    def warhead(self, warhead=None):
        if  warhead is None:
            warhead = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(warhead)
        self.__warhead = warhead
    @property # getter - - - - - - - - - -
    def writeInterval(self):
        return self.__writeInterval
    @writeInterval.setter
    def writeInterval(self, writeInterval=None):
        if  writeInterval is None:
            writeInterval = SFTime.DEFAULT_VALUE
        assertValidSFTime(writeInterval)
        assertNonNegative('writeInterval', writeInterval)
        self.__writeInterval = writeInterval
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function EspduTransform.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<EspduTransform'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.address != 'localhost':
            result += " address='" + self.address + "'"
        if self.applicationID != 0:
            result += " applicationID='" + self.applicationID + "'"
        if self.articulationParameterArray != list():
            result += " articulationParameterArray='" + self.articulationParameterArray + "'"
        if self.articulationParameterChangeIndicatorArray != list():
            result += " articulationParameterChangeIndicatorArray='" + self.articulationParameterChangeIndicatorArray + "'"
        if self.articulationParameterCount != 0:
            result += " articulationParameterCount='" + self.articulationParameterCount + "'"
        if self.articulationParameterDesignatorArray != list():
            result += " articulationParameterDesignatorArray='" + self.articulationParameterDesignatorArray + "'"
        if self.articulationParameterIdPartAttachedToArray != list():
            result += " articulationParameterIdPartAttachedToArray='" + self.articulationParameterIdPartAttachedToArray + "'"
        if self.articulationParameterTypeArray != list():
            result += " articulationParameterTypeArray='" + self.articulationParameterTypeArray + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.collisionType != 0:
            result += " collisionType='" + self.collisionType + "'"
        if self.deadReckoning != 0:
            result += " deadReckoning='" + self.deadReckoning + "'"
        if self.detonationLocation != (0, 0, 0):
            result += " detonationLocation='" + self.detonationLocation + "'"
        if self.detonationRelativeLocation != (0, 0, 0):
            result += " detonationRelativeLocation='" + self.detonationRelativeLocation + "'"
        if self.detonationResult != 0:
            result += " detonationResult='" + self.detonationResult + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.entityCategory != 0:
            result += " entityCategory='" + self.entityCategory + "'"
        if self.entityCountry != 0:
            result += " entityCountry='" + self.entityCountry + "'"
        if self.entityDomain != 0:
            result += " entityDomain='" + self.entityDomain + "'"
        if self.entityExtra != 0:
            result += " entityExtra='" + self.entityExtra + "'"
        if self.entityID != 0:
            result += " entityID='" + self.entityID + "'"
        if self.entityKind != 0:
            result += " entityKind='" + self.entityKind + "'"
        if self.entitySpecific != 0:
            result += " entitySpecific='" + self.entitySpecific + "'"
        if self.entitySubcategory != 0:
            result += " entitySubcategory='" + self.entitySubcategory + "'"
        if self.eventApplicationID != 0:
            result += " eventApplicationID='" + self.eventApplicationID + "'"
        if self.eventEntityID != 0:
            result += " eventEntityID='" + self.eventEntityID + "'"
        if self.eventNumber != 0:
            result += " eventNumber='" + self.eventNumber + "'"
        if self.eventSiteID != 0:
            result += " eventSiteID='" + self.eventSiteID + "'"
        if self.fireMissionIndex != 0:
            result += " fireMissionIndex='" + self.fireMissionIndex + "'"
        if self.fired1 != False:
            result += " fired1='" + self.fired1 + "'"
        if self.fired2 != False:
            result += " fired2='" + self.fired2 + "'"
        if self.firingRange != 0:
            result += " firingRange='" + self.firingRange + "'"
        if self.firingRate != 0:
            result += " firingRate='" + self.firingRate + "'"
        if self.forceID != 0:
            result += " forceID='" + self.forceID + "'"
        if self.fuse != 0:
            result += " fuse='" + self.fuse + "'"
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords='" + self.geoCoords + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'"
        if self.linearAcceleration != (0, 0, 0):
            result += " linearAcceleration='" + self.linearAcceleration + "'"
        if self.linearVelocity != (0, 0, 0):
            result += " linearVelocity='" + self.linearVelocity + "'"
        if self.marking:
            result += " marking='" + self.marking + "'"
        if self.multicastRelayHost:
            result += " multicastRelayHost='" + self.multicastRelayHost + "'"
        if self.multicastRelayPort != 0:
            result += " multicastRelayPort='" + self.multicastRelayPort + "'"
        if self.munitionApplicationID != 0:
            result += " munitionApplicationID='" + self.munitionApplicationID + "'"
        if self.munitionEndPoint != (0, 0, 0):
            result += " munitionEndPoint='" + self.munitionEndPoint + "'"
        if self.munitionEntityID != 0:
            result += " munitionEntityID='" + self.munitionEntityID + "'"
        if self.munitionQuantity != 0:
            result += " munitionQuantity='" + self.munitionQuantity + "'"
        if self.munitionSiteID != 0:
            result += " munitionSiteID='" + self.munitionSiteID + "'"
        if self.munitionStartPoint != (0, 0, 0):
            result += " munitionStartPoint='" + self.munitionStartPoint + "'"
        if self.networkMode != 'standAlone':
            result += " networkMode='" + self.networkMode + "'"
        if self.port != 0:
            result += " port='" + self.port + "'"
        if self.readInterval != 0.1:
            result += " readInterval='" + self.readInterval + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + self.rotation + "'"
        if self.rtpHeaderExpected != False:
            result += " rtpHeaderExpected='" + self.rtpHeaderExpected + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + self.scale + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + self.scaleOrientation + "'"
        if self.siteID != 0:
            result += " siteID='" + self.siteID + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + self.translation + "'"
        if self.warhead != 0:
            result += " warhead='" + self.warhead + "'"
        if self.writeInterval != 1.0:
            result += " writeInterval='" + self.writeInterval + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</EspduTransform>' + '\n'
#       print('XML serialization complete.')
        return result

class ExplosionEmitter(_X3DParticleEmitterNode):
    """
    X3D element
    """
    NAME = 'ExplosionEmitter'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ExplosionEmitter'
    FIELD_DECLARATIONS = [('mass', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('speed', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('surfaceArea', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 mass=0,
                 position=(0, 0, 0),
                 speed=0,
                 surfaceArea=0,
                 variation=0.25,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ExplosionEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.mass = mass
        self.position = position
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
    @property # getter - - - - - - - - - -
    def mass(self):
        return self.__mass
    @mass.setter
    def mass(self, mass=None):
        if  mass is None:
            mass = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def position(self):
        return self.__position
    @position.setter
    def position(self, position=None):
        if  position is None:
            position = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def speed(self):
        return self.__speed
    @speed.setter
    def speed(self, speed=None):
        if  speed is None:
            speed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea=None):
        if  surfaceArea is None:
            surfaceArea = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        return self.__variation
    @variation.setter
    def variation(self, variation=None):
        if  variation is None:
            variation = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ExplosionEmitter.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ExplosionEmitter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.mass != 0:
            result += " mass='" + self.mass + "'"
        if self.position != (0, 0, 0):
            result += " position='" + self.position + "'"
        if self.speed != 0:
            result += " speed='" + self.speed + "'"
        if self.surfaceArea != 0:
            result += " surfaceArea='" + self.surfaceArea + "'"
        if self.variation != 0.25:
            result += " variation='" + self.variation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ExplosionEmitter>' + '\n'
#       print('XML serialization complete.')
        return result

class Extrusion(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'Extrusion'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Extrusion'
    FIELD_DECLARATIONS = [('beginCap', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('convex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('creaseAngle', 0.0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('crossSection', [1, 1, 1, -1, -1, -1, -1, 1, 1, 1], FieldType.MFVec2f, AccessType.initializeOnly),
                          ('endCap', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('orientation', [0, 0, 1, 0], FieldType.MFRotation, AccessType.inputOutput),
                          ('scale', [1, 1], FieldType.MFVec2f, AccessType.inputOutput),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('spine', [0, 0, 0, 0, 1, 0], FieldType.MFVec3f, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 beginCap=True,
                 ccw=True,
                 convex=True,
                 creaseAngle=0.0,
                 crossSection=[1, 1, 1, -1, -1, -1, -1, 1, 1, 1],
                 endCap=True,
                 orientation=[0, 0, 1, 0],
                 scale=[1, 1],
                 solid=True,
                 spine=[0, 0, 0, 0, 1, 0],
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Extrusion __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.beginCap = beginCap
        self.ccw = ccw
        self.convex = convex
        self.creaseAngle = creaseAngle
        self.crossSection = crossSection
        self.endCap = endCap
        self.orientation = orientation
        self.scale = scale
        self.solid = solid
        self.spine = spine
    @property # getter - - - - - - - - - -
    def beginCap(self):
        return self.__beginCap
    @beginCap.setter
    def beginCap(self, beginCap=None):
        if  beginCap is None:
            beginCap = SFBool.DEFAULT_VALUE
        assertValidSFBool(beginCap)
        self.__beginCap = beginCap
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def convex(self):
        return self.__convex
    @convex.setter
    def convex(self, convex=None):
        if  convex is None:
            convex = SFBool.DEFAULT_VALUE
        assertValidSFBool(convex)
        self.__convex = convex
    @property # getter - - - - - - - - - -
    def creaseAngle(self):
        return self.__creaseAngle
    @creaseAngle.setter
    def creaseAngle(self, creaseAngle=None):
        if  creaseAngle is None:
            creaseAngle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(creaseAngle)
        assertNonNegative('creaseAngle', creaseAngle)
        self.__creaseAngle = creaseAngle
    @property # getter - - - - - - - - - -
    def crossSection(self):
        return self.__crossSection
    @crossSection.setter
    def crossSection(self, crossSection=None):
        if  crossSection is None:
            crossSection = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(crossSection)
        self.__crossSection = crossSection
    @property # getter - - - - - - - - - -
    def endCap(self):
        return self.__endCap
    @endCap.setter
    def endCap(self, endCap=None):
        if  endCap is None:
            endCap = SFBool.DEFAULT_VALUE
        assertValidSFBool(endCap)
        self.__endCap = endCap
    @property # getter - - - - - - - - - -
    def orientation(self):
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation=None):
        if  orientation is None:
            orientation = MFRotation.DEFAULT_VALUE
        assertValidMFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def scale(self):
        return self.__scale
    @scale.setter
    def scale(self, scale=None):
        if  scale is None:
            scale = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def spine(self):
        return self.__spine
    @spine.setter
    def spine(self, spine=None):
        if  spine is None:
            spine = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(spine)
        self.__spine = spine
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Extrusion.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Extrusion'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.beginCap != True:
            result += " beginCap='" + self.beginCap + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.convex != True:
            result += " convex='" + self.convex + "'"
        if self.creaseAngle != 0.0:
            result += " creaseAngle='" + self.creaseAngle + "'"
        if self.crossSection != [1, 1, 1, -1, -1, -1, -1, 1, 1, 1]:
            result += " crossSection='" + self.crossSection + "'"
        if self.endCap != True:
            result += " endCap='" + self.endCap + "'"
        if self.orientation != [0, 0, 1, 0]:
            result += " orientation='" + self.orientation + "'"
        if self.scale != [1, 1]:
            result += " scale='" + self.scale + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'"
        if self.spine != [0, 0, 0, 0, 1, 0]:
            result += " spine='" + self.spine + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Extrusion>' + '\n'
#       print('XML serialization complete.')
        return result

class FillProperties(_X3DAppearanceChildNode):
    """
    X3D element
    """
    NAME = 'FillProperties'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FillProperties'
    FIELD_DECLARATIONS = [('filled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('hatchColor', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput),
                          ('hatched', True, FieldType.SFBool, AccessType.inputOutput),
                          ('hatchStyle', 1, FieldType.SFInt32, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 filled=True,
                 hatchColor=(1, 1, 1),
                 hatched=True,
                 hatchStyle=1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode FillProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.filled = filled
        self.hatchColor = hatchColor
        self.hatched = hatched
        self.hatchStyle = hatchStyle
    @property # getter - - - - - - - - - -
    def filled(self):
        return self.__filled
    @filled.setter
    def filled(self, filled=None):
        if  filled is None:
            filled = SFBool.DEFAULT_VALUE
        assertValidSFBool(filled)
        self.__filled = filled
    @property # getter - - - - - - - - - -
    def hatchColor(self):
        return self.__hatchColor
    @hatchColor.setter
    def hatchColor(self, hatchColor=None):
        if  hatchColor is None:
            hatchColor = SFColor.DEFAULT_VALUE
        assertValidSFColor(hatchColor)
        assertZeroToOne('hatchColor', hatchColor)
        self.__hatchColor = hatchColor
    @property # getter - - - - - - - - - -
    def hatched(self):
        return self.__hatched
    @hatched.setter
    def hatched(self, hatched=None):
        if  hatched is None:
            hatched = SFBool.DEFAULT_VALUE
        assertValidSFBool(hatched)
        self.__hatched = hatched
    @property # getter - - - - - - - - - -
    def hatchStyle(self):
        return self.__hatchStyle
    @hatchStyle.setter
    def hatchStyle(self, hatchStyle=None):
        if  hatchStyle is None:
            hatchStyle = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(hatchStyle)
        self.__hatchStyle = hatchStyle
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function FillProperties.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<FillProperties'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.filled != True:
            result += " filled='" + self.filled + "'"
        if self.hatchColor != (1, 1, 1):
            result += " hatchColor='" + self.hatchColor + "'"
        if self.hatchStyle != 1:
            result += " hatchStyle='" + self.hatchStyle + "'"
        if self.hatched != True:
            result += " hatched='" + self.hatched + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</FillProperties>' + '\n'
#       print('XML serialization complete.')
        return result

class FloatVertexAttribute(_X3DVertexAttributeNode):
    """
    X3D element
    """
    NAME = 'FloatVertexAttribute'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FloatVertexAttribute'
    FIELD_DECLARATIONS = [('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('numComponents', 4, FieldType.SFInt32, AccessType.initializeOnly),
                          ('value', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 name='',
                 numComponents=4,
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode FloatVertexAttribute __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.numComponents = numComponents
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def numComponents(self):
        return self.__numComponents
    @numComponents.setter
    def numComponents(self, numComponents=None):
        if  numComponents is None:
            numComponents = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(numComponents)
        assertGreaterThanEquals('numComponents', numComponents, 1)
        assertLessThanEquals('numComponents', numComponents, 4)
        self.__numComponents = numComponents
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        if  value is None:
            value = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(value)
        self.__value = value
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function FloatVertexAttribute.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<FloatVertexAttribute'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.numComponents != 4:
            result += " numComponents='" + self.numComponents + "'"
        if self.value != list():
            result += " value='" + self.value + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</FloatVertexAttribute>' + '\n'
#       print('XML serialization complete.')
        return result

class Fog(_X3DBindableNode):
    """
    X3D element
    """
    NAME = 'Fog'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Fog'
    FIELD_DECLARATIONS = [('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput),
                          ('fogType', 'LINEAR', FieldType.SFString, AccessType.inputOutput),
                          ('visibilityRange', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 color=(1, 1, 1),
                 fogType='LINEAR',
                 visibilityRange=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Fog __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.color = color
        self.fogType = fogType
        self.visibilityRange = visibilityRange
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFColor.DEFAULT_VALUE
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def fogType(self):
        return self.__fogType
    @fogType.setter
    def fogType(self, fogType=None):
        if  fogType is None:
            fogType = SFString.DEFAULT_VALUE
        assertValidSFString(fogType)
        self.__fogType = fogType
    @property # getter - - - - - - - - - -
    def visibilityRange(self):
        return self.__visibilityRange
    @visibilityRange.setter
    def visibilityRange(self, visibilityRange=None):
        if  visibilityRange is None:
            visibilityRange = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(visibilityRange)
        assertNonNegative('visibilityRange', visibilityRange)
        self.__visibilityRange = visibilityRange
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Fog.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Fog'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + self.color + "'"
        if self.fogType != 'LINEAR':
            result += " fogType='" + self.fogType + "'"
        if self.visibilityRange != 0:
            result += " visibilityRange='" + self.visibilityRange + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Fog>' + '\n'
#       print('XML serialization complete.')
        return result

class FogCoordinate(_X3DGeometricPropertyNode):
    """
    X3D element
    """
    NAME = 'FogCoordinate'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FogCoordinate'
    FIELD_DECLARATIONS = [('depth', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 depth=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode FogCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.depth = depth
    @property # getter - - - - - - - - - -
    def depth(self):
        return self.__depth
    @depth.setter
    def depth(self, depth=None):
        if  depth is None:
            depth = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(depth)
        assertZeroToOne('depth', depth)
        self.__depth = depth
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function FogCoordinate.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<FogCoordinate'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.depth != list():
            result += " depth='" + self.depth + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</FogCoordinate>' + '\n'
#       print('XML serialization complete.')
        return result

class FontStyle(_X3DFontStyleNode):
    """
    X3D element
    """
    NAME = 'FontStyle'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FontStyle'
    FIELD_DECLARATIONS = [('family', ["SERIF"], FieldType.MFString, AccessType.initializeOnly),
                          ('horizontal', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('justify', ["BEGIN"], FieldType.MFString, AccessType.initializeOnly),
                          ('language', '', FieldType.SFString, AccessType.initializeOnly),
                          ('leftToRight', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('size', 1.0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('spacing', 1.0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('style', 'PLAIN', FieldType.SFString, AccessType.initializeOnly),
                          ('topToBottom', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 family=["SERIF"],
                 horizontal=True,
                 justify=["BEGIN"],
                 language='',
                 leftToRight=True,
                 size=1.0,
                 spacing=1.0,
                 style='PLAIN',
                 topToBottom=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode FontStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.family = family
        self.horizontal = horizontal
        self.justify = justify
        self.language = language
        self.leftToRight = leftToRight
        self.size = size
        self.spacing = spacing
        self.style = style
        self.topToBottom = topToBottom
    @property # getter - - - - - - - - - -
    def family(self):
        return self.__family
    @family.setter
    def family(self, family=None):
        if  family is None:
            family = MFString.DEFAULT_VALUE
        assertValidMFString(family)
        self.__family = family
    @property # getter - - - - - - - - - -
    def horizontal(self):
        return self.__horizontal
    @horizontal.setter
    def horizontal(self, horizontal=None):
        if  horizontal is None:
            horizontal = SFBool.DEFAULT_VALUE
        assertValidSFBool(horizontal)
        self.__horizontal = horizontal
    @property # getter - - - - - - - - - -
    def justify(self):
        return self.__justify
    @justify.setter
    def justify(self, justify=None):
        if  justify is None:
            justify = MFString.DEFAULT_VALUE
        assertValidMFString(justify)
        self.__justify = justify
    @property # getter - - - - - - - - - -
    def language(self):
        return self.__language
    @language.setter
    def language(self, language=None):
        if  language is None:
            language = SFString.DEFAULT_VALUE
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def leftToRight(self):
        return self.__leftToRight
    @leftToRight.setter
    def leftToRight(self, leftToRight=None):
        if  leftToRight is None:
            leftToRight = SFBool.DEFAULT_VALUE
        assertValidSFBool(leftToRight)
        self.__leftToRight = leftToRight
    @property # getter - - - - - - - - - -
    def size(self):
        return self.__size
    @size.setter
    def size(self, size=None):
        if  size is None:
            size = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(size)
        assertPositive('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def spacing(self):
        return self.__spacing
    @spacing.setter
    def spacing(self, spacing=None):
        if  spacing is None:
            spacing = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(spacing)
        assertNonNegative('spacing', spacing)
        self.__spacing = spacing
    @property # getter - - - - - - - - - -
    def style(self):
        return self.__style
    @style.setter
    def style(self, style=None):
        if  style is None:
            style = SFString.DEFAULT_VALUE
        assertValidSFString(style)
        self.__style = style
    @property # getter - - - - - - - - - -
    def topToBottom(self):
        return self.__topToBottom
    @topToBottom.setter
    def topToBottom(self, topToBottom=None):
        if  topToBottom is None:
            topToBottom = SFBool.DEFAULT_VALUE
        assertValidSFBool(topToBottom)
        self.__topToBottom = topToBottom
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function FontStyle.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<FontStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.family != ["SERIF"]:
            result += " family='" + self.family + "'"
        if self.horizontal != True:
            result += " horizontal='" + self.horizontal + "'"
        if self.justify != ["BEGIN"]:
            result += " justify='" + self.justify + "'"
        if self.language:
            result += " language='" + self.language + "'"
        if self.leftToRight != True:
            result += " leftToRight='" + self.leftToRight + "'"
        if self.size != 1.0:
            result += " size='" + self.size + "'"
        if self.spacing != 1.0:
            result += " spacing='" + self.spacing + "'"
        if self.style != 'PLAIN':
            result += " style='" + self.style + "'"
        if self.topToBottom != True:
            result += " topToBottom='" + self.topToBottom + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</FontStyle>' + '\n'
#       print('XML serialization complete.')
        return result

class ForcePhysicsModel(_X3DParticlePhysicsModelNode):
    """
    X3D element
    """
    NAME = 'ForcePhysicsModel'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ForcePhysicsModel'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('force', (0, -9.8, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 force=(0, -9.8, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ForcePhysicsModel __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.force = force
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def force(self):
        return self.__force
    @force.setter
    def force(self, force=None):
        if  force is None:
            force = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(force)
        self.__force = force
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ForcePhysicsModel.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ForcePhysicsModel'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.force != (0, -9.8, 0):
            result += " force='" + self.force + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ForcePhysicsModel>' + '\n'
#       print('XML serialization complete.')
        return result

class GeneratedCubeMapTexture(_X3DEnvironmentTextureNode):
    """
    X3D element
    """
    NAME = 'GeneratedCubeMapTexture'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeneratedCubeMapTexture'
    FIELD_DECLARATIONS = [('size', 128, FieldType.SFInt32, AccessType.initializeOnly),
                          ('update', 'NONE', FieldType.SFString, AccessType.inputOutput),
                          ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 size=128,
                 update='NONE',
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeneratedCubeMapTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.size = size
        self.update = update
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def size(self):
        return self.__size
    @size.setter
    def size(self, size=None):
        if  size is None:
            size = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(size)
        assertPositive('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def update(self):
        return self.__update
    @update.setter
    def update(self, update=None):
        if  update is None:
            update = SFString.DEFAULT_VALUE
        assertValidSFString(update)
        self.__update = update
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties=None):
        if  textureProperties is None:
            textureProperties = SFNode.DEFAULT_VALUE
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            print(flush=True)
            raise TypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function GeneratedCubeMapTexture.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<GeneratedCubeMapTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.size != 128:
            result += " size='" + self.size + "'"
        if self.update != 'NONE':
            result += " update='" + self.update + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.textureProperties: # walk each child node, if any
            result += indent
            for each in self.textureProperties:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</GeneratedCubeMapTexture>' + '\n'
#       print('XML serialization complete.')
        return result

class GeoCoordinate(_X3DCoordinateNode):
    """
    X3D element
    """
    NAME = 'GeoCoordinate'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoCoordinate'
    FIELD_DECLARATIONS = [('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('point', list(), FieldType.MFVec3d, AccessType.inputOutput),
                          ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 geoSystem=["GD", "WE"],
                 point=list(),
                 geoOrigin=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.geoSystem = geoSystem
        self.point = point
        self.geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def point(self):
        return self.__point
    @point.setter
    def point(self, point=None):
        if  point is None:
            point = MFVec3d.DEFAULT_VALUE
        assertValidMFVec3d(point)
        self.__point = point
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin=None):
        if  geoOrigin is None:
            geoOrigin = SFNode.DEFAULT_VALUE
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            print(flush=True)
            raise TypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function GeoCoordinate.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<GeoCoordinate'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'"
        if self.point != list():
            result += " point='" + self.point + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geoOrigin: # walk each child node, if any
            result += indent
            for each in self.geoOrigin:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</GeoCoordinate>' + '\n'
#       print('XML serialization complete.')
        return result

class GeoElevationGrid(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'GeoElevationGrid'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoElevationGrid'
    FIELD_DECLARATIONS = [('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('creaseAngle', 0, FieldType.SFDouble, AccessType.initializeOnly),
                          ('geoGridOrigin', (0, 0, 0), FieldType.SFVec3d, AccessType.initializeOnly),
                          ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('height', [0, 0, 0, 0], FieldType.MFDouble, AccessType.initializeOnly),
                          ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('xDimension', 2, FieldType.SFInt32, AccessType.initializeOnly),
                          ('xSpacing', 1.0, FieldType.SFDouble, AccessType.initializeOnly),
                          ('yScale', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('zDimension', 2, FieldType.SFInt32, AccessType.initializeOnly),
                          ('zSpacing', 1.0, FieldType.SFDouble, AccessType.initializeOnly),
                          ('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('normal', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 creaseAngle=0,
                 geoGridOrigin=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 height=[0, 0, 0, 0],
                 normalPerVertex=True,
                 solid=True,
                 xDimension=2,
                 xSpacing=1.0,
                 yScale=1,
                 zDimension=2,
                 zSpacing=1.0,
                 color=None,
                 geoOrigin=None,
                 normal=None,
                 texCoord=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoElevationGrid __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.creaseAngle = creaseAngle
        self.geoGridOrigin = geoGridOrigin
        self.geoSystem = geoSystem
        self.height = height
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.xDimension = xDimension
        self.xSpacing = xSpacing
        self.yScale = yScale
        self.zDimension = zDimension
        self.zSpacing = zSpacing
        self.color = color
        self.geoOrigin = geoOrigin
        self.normal = normal
        self.texCoord = texCoord
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex=None):
        if  colorPerVertex is None:
            colorPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def creaseAngle(self):
        return self.__creaseAngle
    @creaseAngle.setter
    def creaseAngle(self, creaseAngle=None):
        if  creaseAngle is None:
            creaseAngle = SFDouble.DEFAULT_VALUE
        assertValidSFDouble(creaseAngle)
        assertNonNegative('creaseAngle', creaseAngle)
        self.__creaseAngle = creaseAngle
    @property # getter - - - - - - - - - -
    def geoGridOrigin(self):
        return self.__geoGridOrigin
    @geoGridOrigin.setter
    def geoGridOrigin(self, geoGridOrigin=None):
        if  geoGridOrigin is None:
            geoGridOrigin = SFVec3d.DEFAULT_VALUE
        assertValidSFVec3d(geoGridOrigin)
        self.__geoGridOrigin = geoGridOrigin
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def height(self):
        return self.__height
    @height.setter
    def height(self, height=None):
        if  height is None:
            height = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(height)
        self.__height = height
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex=None):
        if  normalPerVertex is None:
            normalPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def xDimension(self):
        return self.__xDimension
    @xDimension.setter
    def xDimension(self, xDimension=None):
        if  xDimension is None:
            xDimension = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(xDimension)
        assertNonNegative('xDimension', xDimension)
        self.__xDimension = xDimension
    @property # getter - - - - - - - - - -
    def xSpacing(self):
        return self.__xSpacing
    @xSpacing.setter
    def xSpacing(self, xSpacing=None):
        if  xSpacing is None:
            xSpacing = SFDouble.DEFAULT_VALUE
        assertValidSFDouble(xSpacing)
        assertPositive('xSpacing', xSpacing)
        self.__xSpacing = xSpacing
    @property # getter - - - - - - - - - -
    def yScale(self):
        return self.__yScale
    @yScale.setter
    def yScale(self, yScale=None):
        if  yScale is None:
            yScale = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(yScale)
        assertNonNegative('yScale', yScale)
        self.__yScale = yScale
    @property # getter - - - - - - - - - -
    def zDimension(self):
        return self.__zDimension
    @zDimension.setter
    def zDimension(self, zDimension=None):
        if  zDimension is None:
            zDimension = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(zDimension)
        assertNonNegative('zDimension', zDimension)
        self.__zDimension = zDimension
    @property # getter - - - - - - - - - -
    def zSpacing(self):
        return self.__zSpacing
    @zSpacing.setter
    def zSpacing(self, zSpacing=None):
        if  zSpacing is None:
            zSpacing = SFDouble.DEFAULT_VALUE
        assertValidSFDouble(zSpacing)
        assertPositive('zSpacing', zSpacing)
        self.__zSpacing = zSpacing
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin=None):
        if  geoOrigin is None:
            geoOrigin = SFNode.DEFAULT_VALUE
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            print(flush=True)
            raise TypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal=None):
        if  normal is None:
            normal = SFNode.DEFAULT_VALUE
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            print(flush=True)
            raise TypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            print(flush=True)
            raise TypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function GeoElevationGrid.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<GeoElevationGrid'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorPerVertex != True:
            result += " colorPerVertex='" + self.colorPerVertex + "'"
        if self.creaseAngle != 0:
            result += " creaseAngle='" + self.creaseAngle + "'"
        if self.geoGridOrigin != (0, 0, 0):
            result += " geoGridOrigin='" + self.geoGridOrigin + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'"
        if self.height != [0, 0, 0, 0]:
            result += " height='" + self.height + "'"
        if self.normalPerVertex != True:
            result += " normalPerVertex='" + self.normalPerVertex + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'"
        if self.xDimension != 2:
            result += " xDimension='" + self.xDimension + "'"
        if self.xSpacing != 1.0:
            result += " xSpacing='" + self.xSpacing + "'"
        if self.yScale != 1:
            result += " yScale='" + self.yScale + "'"
        if self.zDimension != 2:
            result += " zDimension='" + self.zDimension + "'"
        if self.zSpacing != 1.0:
            result += " zSpacing='" + self.zSpacing + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geoOrigin: # walk each child node, if any
            result += indent
            for each in self.geoOrigin:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.normal: # walk each child node, if any
            result += indent
            for each in self.normal:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</GeoElevationGrid>' + '\n'
#       print('XML serialization complete.')
        return result

class GeoLocation(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'GeoLocation'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoLocation'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput),
                          ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 geoCoords=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 geoOrigin=None,
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoLocation __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.geoOrigin = geoOrigin
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords=None):
        if  geoCoords is None:
            geoCoords = SFVec3d.DEFAULT_VALUE
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin=None):
        if  geoOrigin is None:
            geoOrigin = SFNode.DEFAULT_VALUE
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            print(flush=True)
            raise TypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function GeoLocation.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<GeoLocation'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords='" + self.geoCoords + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geoOrigin: # walk each child node, if any
            result += indent
            for each in self.geoOrigin:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</GeoLocation>' + '\n'
#       print('XML serialization complete.')
        return result

class GeoLOD(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'GeoLOD'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoLOD'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('center', (0, 0, 0), FieldType.SFVec3d, AccessType.initializeOnly),
                          ('child1Url', list(), FieldType.MFString, AccessType.initializeOnly),
                          ('child2Url', list(), FieldType.MFString, AccessType.initializeOnly),
                          ('child3Url', list(), FieldType.MFString, AccessType.initializeOnly),
                          ('child4Url', list(), FieldType.MFString, AccessType.initializeOnly),
                          ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('range', 10, FieldType.SFFloat, AccessType.initializeOnly),
                          ('rootUrl', list(), FieldType.MFString, AccessType.initializeOnly),
                          ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('rootNode', list(), FieldType.MFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 child1Url=list(),
                 child2Url=list(),
                 child3Url=list(),
                 child4Url=list(),
                 geoSystem=["GD", "WE"],
                 range=10,
                 rootUrl=list(),
                 geoOrigin=None,
                 rootNode=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoLOD __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.center = center
        self.child1Url = child1Url
        self.child2Url = child2Url
        self.child3Url = child3Url
        self.child4Url = child4Url
        self.geoSystem = geoSystem
        self.range = range
        self.rootUrl = rootUrl
        self.geoOrigin = geoOrigin
        self.rootNode = rootNode
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3d.DEFAULT_VALUE
        assertValidSFVec3d(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def child1Url(self):
        return self.__child1Url
    @child1Url.setter
    def child1Url(self, child1Url=None):
        if  child1Url is None:
            child1Url = MFString.DEFAULT_VALUE
        assertValidMFString(child1Url)
        self.__child1Url = child1Url
    @property # getter - - - - - - - - - -
    def child2Url(self):
        return self.__child2Url
    @child2Url.setter
    def child2Url(self, child2Url=None):
        if  child2Url is None:
            child2Url = MFString.DEFAULT_VALUE
        assertValidMFString(child2Url)
        self.__child2Url = child2Url
    @property # getter - - - - - - - - - -
    def child3Url(self):
        return self.__child3Url
    @child3Url.setter
    def child3Url(self, child3Url=None):
        if  child3Url is None:
            child3Url = MFString.DEFAULT_VALUE
        assertValidMFString(child3Url)
        self.__child3Url = child3Url
    @property # getter - - - - - - - - - -
    def child4Url(self):
        return self.__child4Url
    @child4Url.setter
    def child4Url(self, child4Url=None):
        if  child4Url is None:
            child4Url = MFString.DEFAULT_VALUE
        assertValidMFString(child4Url)
        self.__child4Url = child4Url
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def range(self):
        return self.__range
    @range.setter
    def range(self, range=None):
        if  range is None:
            range = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(range)
        assertNonNegative('range', range)
        self.__range = range
    @property # getter - - - - - - - - - -
    def rootUrl(self):
        return self.__rootUrl
    @rootUrl.setter
    def rootUrl(self, rootUrl=None):
        if  rootUrl is None:
            rootUrl = MFString.DEFAULT_VALUE
        assertValidMFString(rootUrl)
        self.__rootUrl = rootUrl
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin=None):
        if  geoOrigin is None:
            geoOrigin = SFNode.DEFAULT_VALUE
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            print(flush=True)
            raise TypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def rootNode(self):
        return self.__rootNode
    @rootNode.setter
    def rootNode(self, rootNode=None):
        if  rootNode is None:
            rootNode = MFNode.DEFAULT_VALUE
        assertValidMFNode(rootNode)
        self.__rootNode = rootNode
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function GeoLOD.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<GeoLOD'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.child1Url != list():
            result += " child1Url='" + self.child1Url + "'"
        if self.child2Url != list():
            result += " child2Url='" + self.child2Url + "'"
        if self.child3Url != list():
            result += " child3Url='" + self.child3Url + "'"
        if self.child4Url != list():
            result += " child4Url='" + self.child4Url + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'"
        if self.range != 10:
            result += " range='" + self.range + "'"
        if self.rootUrl != list():
            result += " rootUrl='" + self.rootUrl + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geoOrigin: # walk each child node, if any
            result += indent
            for each in self.geoOrigin:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.rootNode: # walk each child node, if any
            result += indent
            for each in self.rootNode:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</GeoLOD>' + '\n'
#       print('XML serialization complete.')
        return result

class GeoMetadata(_X3DInfoNode):
    """
    X3D element
    """
    NAME = 'GeoMetadata'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoMetadata'
    FIELD_DECLARATIONS = [('summary', list(), FieldType.MFString, AccessType.inputOutput),
                          ('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('data', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 summary=list(),
                 url=list(),
                 data=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoMetadata __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.summary = summary
        self.url = url
        self.data = data
    @property # getter - - - - - - - - - -
    def summary(self):
        return self.__summary
    @summary.setter
    def summary(self, summary=None):
        if  summary is None:
            summary = MFString.DEFAULT_VALUE
        assertValidMFString(summary)
        self.__summary = summary
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def data(self):
        return self.__data
    @data.setter
    def data(self, data=None):
        if  data is None:
            data = MFNode.DEFAULT_VALUE
        assertValidMFNode(data)
        self.__data = data
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function GeoMetadata.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<GeoMetadata'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.summary != list():
            result += " summary='" + self.summary + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.data: # walk each child node, if any
            result += indent
            for each in self.data:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</GeoMetadata>' + '\n'
#       print('XML serialization complete.')
        return result

class GeoOrigin(_X3DNode):
    """
    GeoOrigin is deprecated and discouraged (but nevertheless allowed) in X3D v3.3. GeoOrigin is likely to be restored in X3D v4.0 for special use on devices with limited floating-point resolution.
    """
    NAME = 'GeoOrigin'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoOrigin'
    FIELD_DECLARATIONS = [('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput),
                          ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('rotateYUp', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 geoCoords=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 rotateYUp=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoOrigin __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.rotateYUp = rotateYUp
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords=None):
        if  geoCoords is None:
            geoCoords = SFVec3d.DEFAULT_VALUE
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def rotateYUp(self):
        return self.__rotateYUp
    @rotateYUp.setter
    def rotateYUp(self, rotateYUp=None):
        if  rotateYUp is None:
            rotateYUp = SFBool.DEFAULT_VALUE
        assertValidSFBool(rotateYUp)
        self.__rotateYUp = rotateYUp
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function GeoOrigin.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<GeoOrigin'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords='" + self.geoCoords + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'"
        if self.rotateYUp != False:
            result += " rotateYUp='" + self.rotateYUp + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</GeoOrigin>' + '\n'
#       print('XML serialization complete.')
        return result

class GeoPositionInterpolator(_X3DInterpolatorNode):
    """
    X3D element
    """
    NAME = 'GeoPositionInterpolator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoPositionInterpolator'
    FIELD_DECLARATIONS = [('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFVec3d, AccessType.inputOutput),
                          ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 geoSystem=["GD", "WE"],
                 key=list(),
                 keyValue=list(),
                 geoOrigin=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoPositionInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.geoSystem = geoSystem
        self.key = key
        self.keyValue = keyValue
        self.geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFVec3d.DEFAULT_VALUE
        assertValidMFVec3d(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin=None):
        if  geoOrigin is None:
            geoOrigin = SFNode.DEFAULT_VALUE
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            print(flush=True)
            raise TypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function GeoPositionInterpolator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<GeoPositionInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geoOrigin: # walk each child node, if any
            result += indent
            for each in self.geoOrigin:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</GeoPositionInterpolator>' + '\n'
#       print('XML serialization complete.')
        return result

class GeoProximitySensor(_X3DEnvironmentalSensorNode):
    """
    X3D element
    """
    NAME = 'GeoProximitySensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoProximitySensor'
    FIELD_DECLARATIONS = [('center', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('geoCenter', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput),
                          ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 center=(0, 0, 0),
                 enabled=True,
                 geoCenter=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 size=(0, 0, 0),
                 geoOrigin=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoProximitySensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.enabled = enabled
        self.geoCenter = geoCenter
        self.geoSystem = geoSystem
        self.size = size
        self.geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3d.DEFAULT_VALUE
        assertValidSFVec3d(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def geoCenter(self):
        return self.__geoCenter
    @geoCenter.setter
    def geoCenter(self, geoCenter=None):
        if  geoCenter is None:
            geoCenter = SFVec3d.DEFAULT_VALUE
        assertValidSFVec3d(geoCenter)
        self.__geoCenter = geoCenter
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def size(self):
        return self.__size
    @size.setter
    def size(self, size=None):
        if  size is None:
            size = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(size)
        assertNonNegative('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin=None):
        if  geoOrigin is None:
            geoOrigin = SFNode.DEFAULT_VALUE
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            print(flush=True)
            raise TypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function GeoProximitySensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<GeoProximitySensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.geoCenter != (0, 0, 0):
            result += " geoCenter='" + self.geoCenter + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'"
        if self.size != (0, 0, 0):
            result += " size='" + self.size + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geoOrigin: # walk each child node, if any
            result += indent
            for each in self.geoOrigin:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</GeoProximitySensor>' + '\n'
#       print('XML serialization complete.')
        return result

class GeoTouchSensor(_X3DTouchSensorNode):
    """
    X3D element
    """
    NAME = 'GeoTouchSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoTouchSensor'
    FIELD_DECLARATIONS = [('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 description='',
                 enabled=True,
                 geoSystem=["GD", "WE"],
                 geoOrigin=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoTouchSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.geoSystem = geoSystem
        self.geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin=None):
        if  geoOrigin is None:
            geoOrigin = SFNode.DEFAULT_VALUE
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            print(flush=True)
            raise TypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function GeoTouchSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<GeoTouchSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geoOrigin: # walk each child node, if any
            result += indent
            for each in self.geoOrigin:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</GeoTouchSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class GeoTransform(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'GeoTransform'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoTransform'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('geoCenter', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput),
                          ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 geoCenter=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 translation=(0, 0, 0),
                 geoOrigin=None,
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoTransform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.geoCenter = geoCenter
        self.geoSystem = geoSystem
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.translation = translation
        self.geoOrigin = geoOrigin
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def geoCenter(self):
        return self.__geoCenter
    @geoCenter.setter
    def geoCenter(self, geoCenter=None):
        if  geoCenter is None:
            geoCenter = SFVec3d.DEFAULT_VALUE
        assertValidSFVec3d(geoCenter)
        self.__geoCenter = geoCenter
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def rotation(self):
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation=None):
        if  rotation is None:
            rotation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        return self.__scale
    @scale.setter
    def scale(self, scale=None):
        if  scale is None:
            scale = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(scale)
        assertPositive('scale', scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation=None):
        if  scaleOrientation is None:
            scaleOrientation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def translation(self):
        return self.__translation
    @translation.setter
    def translation(self, translation=None):
        if  translation is None:
            translation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin=None):
        if  geoOrigin is None:
            geoOrigin = SFNode.DEFAULT_VALUE
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            print(flush=True)
            raise TypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function GeoTransform.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<GeoTransform'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.geoCenter != (0, 0, 0):
            result += " geoCenter='" + self.geoCenter + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + self.rotation + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + self.scale + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + self.scaleOrientation + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + self.translation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geoOrigin: # walk each child node, if any
            result += indent
            for each in self.geoOrigin:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</GeoTransform>' + '\n'
#       print('XML serialization complete.')
        return result

class GeoViewpoint(_X3DViewpointNode):
    """
    X3D element
    """
    NAME = 'GeoViewpoint'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoViewpoint'
    FIELD_DECLARATIONS = [('centerOfRotation', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('fieldOfView', 0.7854, FieldType.SFFloat, AccessType.inputOutput),
                          ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('jump', True, FieldType.SFBool, AccessType.inputOutput),
                          ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('position', (0, 0, 100000), FieldType.SFVec3d, AccessType.inputOutput),
                          ('retainUserOffsets', False, FieldType.SFBool, AccessType.inputOutput),
                          ('speedFactor', 1.0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 centerOfRotation=(0, 0, 0),
                 description='',
                 fieldOfView=0.7854,
                 geoSystem=["GD", "WE"],
                 jump=True,
                 orientation=(0, 0, 1, 0),
                 position=(0, 0, 100000),
                 retainUserOffsets=False,
                 speedFactor=1.0,
                 geoOrigin=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoViewpoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.centerOfRotation = centerOfRotation
        self.description = description
        self.fieldOfView = fieldOfView
        self.geoSystem = geoSystem
        self.jump = jump
        self.orientation = orientation
        self.position = position
        self.retainUserOffsets = retainUserOffsets
        self.speedFactor = speedFactor
        self.geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def centerOfRotation(self):
        return self.__centerOfRotation
    @centerOfRotation.setter
    def centerOfRotation(self, centerOfRotation=None):
        if  centerOfRotation is None:
            centerOfRotation = SFVec3d.DEFAULT_VALUE
        assertValidSFVec3d(centerOfRotation)
        self.__centerOfRotation = centerOfRotation
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def fieldOfView(self):
        return self.__fieldOfView
    @fieldOfView.setter
    def fieldOfView(self, fieldOfView=None):
        if  fieldOfView is None:
            fieldOfView = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(fieldOfView)
        assertGreaterThan('fieldOfView', fieldOfView, 0)
        assertLessThan('fieldOfView', fieldOfView, 3.1416)
        self.__fieldOfView = fieldOfView
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def jump(self):
        return self.__jump
    @jump.setter
    def jump(self, jump=None):
        if  jump is None:
            jump = SFBool.DEFAULT_VALUE
        assertValidSFBool(jump)
        self.__jump = jump
    @property # getter - - - - - - - - - -
    def orientation(self):
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation=None):
        if  orientation is None:
            orientation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def position(self):
        return self.__position
    @position.setter
    def position(self, position=None):
        if  position is None:
            position = SFVec3d.DEFAULT_VALUE
        assertValidSFVec3d(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def retainUserOffsets(self):
        return self.__retainUserOffsets
    @retainUserOffsets.setter
    def retainUserOffsets(self, retainUserOffsets=None):
        if  retainUserOffsets is None:
            retainUserOffsets = SFBool.DEFAULT_VALUE
        assertValidSFBool(retainUserOffsets)
        self.__retainUserOffsets = retainUserOffsets
    @property # getter - - - - - - - - - -
    def speedFactor(self):
        return self.__speedFactor
    @speedFactor.setter
    def speedFactor(self, speedFactor=None):
        if  speedFactor is None:
            speedFactor = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(speedFactor)
        assertNonNegative('speedFactor', speedFactor)
        self.__speedFactor = speedFactor
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin=None):
        if  geoOrigin is None:
            geoOrigin = SFNode.DEFAULT_VALUE
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            print(flush=True)
            raise TypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function GeoViewpoint.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<GeoViewpoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.centerOfRotation != (0, 0, 0):
            result += " centerOfRotation='" + self.centerOfRotation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.fieldOfView != 0.7854:
            result += " fieldOfView='" + self.fieldOfView + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'"
        if self.jump != True:
            result += " jump='" + self.jump + "'"
        if self.orientation != (0, 0, 1, 0):
            result += " orientation='" + self.orientation + "'"
        if self.position != (0, 0, 100000):
            result += " position='" + self.position + "'"
        if self.retainUserOffsets != False:
            result += " retainUserOffsets='" + self.retainUserOffsets + "'"
        if self.speedFactor != 1.0:
            result += " speedFactor='" + self.speedFactor + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geoOrigin: # walk each child node, if any
            result += indent
            for each in self.geoOrigin:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</GeoViewpoint>' + '\n'
#       print('XML serialization complete.')
        return result

class Group(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'Group'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Group'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Group.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Group'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Group>' + '\n'
#       print('XML serialization complete.')
        return result

class HAnimDisplacer(_X3DGeometricPropertyNode):
    """
    X3D element
    """
    NAME = 'HAnimDisplacer'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimDisplacer'
    FIELD_DECLARATIONS = [('coordIndex', list(), FieldType.MFInt32, AccessType.initializeOnly),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('displacements', list(), FieldType.MFVec3f, AccessType.inputOutput),
                          ('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('weight', 0.0, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 coordIndex=list(),
                 description='',
                 displacements=list(),
                 name='',
                 weight=0.0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode HAnimDisplacer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.coordIndex = coordIndex
        self.description = description
        self.displacements = displacements
        self.name = name
        self.weight = weight
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex=None):
        if  coordIndex is None:
            coordIndex = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(coordIndex)
        assertNonNegative('coordIndex', coordIndex)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def displacements(self):
        return self.__displacements
    @displacements.setter
    def displacements(self, displacements=None):
        if  displacements is None:
            displacements = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(displacements)
        self.__displacements = displacements
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def weight(self):
        return self.__weight
    @weight.setter
    def weight(self, weight=None):
        if  weight is None:
            weight = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(weight)
        self.__weight = weight
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function HAnimDisplacer.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<HAnimDisplacer'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.coordIndex != list():
            result += " coordIndex='" + self.coordIndex + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.displacements != list():
            result += " displacements='" + self.displacements + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.weight != 0.0:
            result += " weight='" + self.weight + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</HAnimDisplacer>' + '\n'
#       print('XML serialization complete.')
        return result

class HAnimHumanoid(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'HAnimHumanoid'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimHumanoid'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('info', list(), FieldType.MFString, AccessType.inputOutput),
                          ('jointBindingPositions', [0, 0, 0], FieldType.MFVec3f, AccessType.inputOutput),
                          ('jointBindingRotations', [0, 0, 1, 0], FieldType.MFRotation, AccessType.inputOutput),
                          ('jointBindingScales', [0, 0, 0], FieldType.MFVec3f, AccessType.inputOutput),
                          ('loa', -1, FieldType.SFInt32, AccessType.inputOutput),
                          ('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('skeletalConfiguration', 'BASIC', FieldType.SFString, AccessType.inputOutput),
                          ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('version', '2.0', FieldType.SFString, AccessType.inputOutput),
                          ('skinCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('skinNormal', None, FieldType.SFNode, AccessType.inputOutput),
                          ('joints', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('motions', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('segments', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('sites', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('skeleton', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('skin', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('skinBindingCoords', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('skinBindingNormals', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('viewpoints', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 description='',
                 info=list(),
                 jointBindingPositions=[0, 0, 0],
                 jointBindingRotations=[0, 0, 1, 0],
                 jointBindingScales=[0, 0, 0],
                 loa=-1,
                 name='',
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 skeletalConfiguration='BASIC',
                 translation=(0, 0, 0),
                 version='2.0',
                 skinCoord=None,
                 skinNormal=None,
                 joints=list(),
                 motions=list(),
                 segments=list(),
                 sites=list(),
                 skeleton=list(),
                 skin=list(),
                 skinBindingCoords=list(),
                 skinBindingNormals=list(),
                 viewpoints=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode HAnimHumanoid __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.center = center
        self.description = description
        self.info = info
        self.jointBindingPositions = jointBindingPositions
        self.jointBindingRotations = jointBindingRotations
        self.jointBindingScales = jointBindingScales
        self.loa = loa
        self.name = name
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.skeletalConfiguration = skeletalConfiguration
        self.translation = translation
        self.version = version
        self.skinCoord = skinCoord
        self.skinNormal = skinNormal
        self.joints = joints
        self.motions = motions
        self.segments = segments
        self.sites = sites
        self.skeleton = skeleton
        self.skin = skin
        self.skinBindingCoords = skinBindingCoords
        self.skinBindingNormals = skinBindingNormals
        self.viewpoints = viewpoints
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def info(self):
        return self.__info
    @info.setter
    def info(self, info=None):
        if  info is None:
            info = MFString.DEFAULT_VALUE
        assertValidMFString(info)
        self.__info = info
    @property # getter - - - - - - - - - -
    def jointBindingPositions(self):
        return self.__jointBindingPositions
    @jointBindingPositions.setter
    def jointBindingPositions(self, jointBindingPositions=None):
        if  jointBindingPositions is None:
            jointBindingPositions = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(jointBindingPositions)
        self.__jointBindingPositions = jointBindingPositions
    @property # getter - - - - - - - - - -
    def jointBindingRotations(self):
        return self.__jointBindingRotations
    @jointBindingRotations.setter
    def jointBindingRotations(self, jointBindingRotations=None):
        if  jointBindingRotations is None:
            jointBindingRotations = MFRotation.DEFAULT_VALUE
        assertValidMFRotation(jointBindingRotations)
        self.__jointBindingRotations = jointBindingRotations
    @property # getter - - - - - - - - - -
    def jointBindingScales(self):
        return self.__jointBindingScales
    @jointBindingScales.setter
    def jointBindingScales(self, jointBindingScales=None):
        if  jointBindingScales is None:
            jointBindingScales = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(jointBindingScales)
        self.__jointBindingScales = jointBindingScales
    @property # getter - - - - - - - - - -
    def loa(self):
        return self.__loa
    @loa.setter
    def loa(self, loa=None):
        if  loa is None:
            loa = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(loa)
        assertGreaterThanEquals('loa', loa, -1)
        assertLessThanEquals('loa', loa, 4)
        self.__loa = loa
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def rotation(self):
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation=None):
        if  rotation is None:
            rotation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        return self.__scale
    @scale.setter
    def scale(self, scale=None):
        if  scale is None:
            scale = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(scale)
        assertPositive('scale', scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation=None):
        if  scaleOrientation is None:
            scaleOrientation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def skeletalConfiguration(self):
        return self.__skeletalConfiguration
    @skeletalConfiguration.setter
    def skeletalConfiguration(self, skeletalConfiguration=None):
        if  skeletalConfiguration is None:
            skeletalConfiguration = SFString.DEFAULT_VALUE
        assertValidSFString(skeletalConfiguration)
        self.__skeletalConfiguration = skeletalConfiguration
    @property # getter - - - - - - - - - -
    def translation(self):
        return self.__translation
    @translation.setter
    def translation(self, translation=None):
        if  translation is None:
            translation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def version(self):
        return self.__version
    @version.setter
    def version(self, version=None):
        if  version is None:
            version = SFString.DEFAULT_VALUE
        assertValidSFString(version)
        self.__version = version
    @property # getter - - - - - - - - - -
    def skinCoord(self):
        return self.__skinCoord
    @skinCoord.setter
    def skinCoord(self, skinCoord=None):
        if  skinCoord is None:
            skinCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(skinCoord)
        if not isinstance(skinCoord, object):
            print(flush=True)
            raise TypeError(str(skinCoord) + ' does not have a valid node type object')
        self.__skinCoord = skinCoord
    @property # getter - - - - - - - - - -
    def skinNormal(self):
        return self.__skinNormal
    @skinNormal.setter
    def skinNormal(self, skinNormal=None):
        if  skinNormal is None:
            skinNormal = SFNode.DEFAULT_VALUE
        assertValidSFNode(skinNormal)
        if not isinstance(skinNormal, object):
            print(flush=True)
            raise TypeError(str(skinNormal) + ' does not have a valid node type object')
        self.__skinNormal = skinNormal
    @property # getter - - - - - - - - - -
    def joints(self):
        return self.__joints
    @joints.setter
    def joints(self, joints=None):
        if  joints is None:
            joints = MFNode.DEFAULT_VALUE
        assertValidMFNode(joints)
        self.__joints = joints
    @property # getter - - - - - - - - - -
    def motions(self):
        return self.__motions
    @motions.setter
    def motions(self, motions=None):
        if  motions is None:
            motions = MFNode.DEFAULT_VALUE
        assertValidMFNode(motions)
        self.__motions = motions
    @property # getter - - - - - - - - - -
    def segments(self):
        return self.__segments
    @segments.setter
    def segments(self, segments=None):
        if  segments is None:
            segments = MFNode.DEFAULT_VALUE
        assertValidMFNode(segments)
        self.__segments = segments
    @property # getter - - - - - - - - - -
    def sites(self):
        return self.__sites
    @sites.setter
    def sites(self, sites=None):
        if  sites is None:
            sites = MFNode.DEFAULT_VALUE
        assertValidMFNode(sites)
        self.__sites = sites
    @property # getter - - - - - - - - - -
    def skeleton(self):
        return self.__skeleton
    @skeleton.setter
    def skeleton(self, skeleton=None):
        if  skeleton is None:
            skeleton = MFNode.DEFAULT_VALUE
        assertValidMFNode(skeleton)
        self.__skeleton = skeleton
    @property # getter - - - - - - - - - -
    def skin(self):
        return self.__skin
    @skin.setter
    def skin(self, skin=None):
        if  skin is None:
            skin = MFNode.DEFAULT_VALUE
        assertValidMFNode(skin)
        self.__skin = skin
    @property # getter - - - - - - - - - -
    def skinBindingCoords(self):
        return self.__skinBindingCoords
    @skinBindingCoords.setter
    def skinBindingCoords(self, skinBindingCoords=None):
        if  skinBindingCoords is None:
            skinBindingCoords = MFNode.DEFAULT_VALUE
        assertValidMFNode(skinBindingCoords)
        self.__skinBindingCoords = skinBindingCoords
    @property # getter - - - - - - - - - -
    def skinBindingNormals(self):
        return self.__skinBindingNormals
    @skinBindingNormals.setter
    def skinBindingNormals(self, skinBindingNormals=None):
        if  skinBindingNormals is None:
            skinBindingNormals = MFNode.DEFAULT_VALUE
        assertValidMFNode(skinBindingNormals)
        self.__skinBindingNormals = skinBindingNormals
    @property # getter - - - - - - - - - -
    def viewpoints(self):
        return self.__viewpoints
    @viewpoints.setter
    def viewpoints(self, viewpoints=None):
        if  viewpoints is None:
            viewpoints = MFNode.DEFAULT_VALUE
        assertValidMFNode(viewpoints)
        self.__viewpoints = viewpoints
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function HAnimHumanoid.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<HAnimHumanoid'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.info != list():
            result += " info='" + self.info + "'"
        if self.jointBindingPositions != [0, 0, 0]:
            result += " jointBindingPositions='" + self.jointBindingPositions + "'"
        if self.jointBindingRotations != [0, 0, 1, 0]:
            result += " jointBindingRotations='" + self.jointBindingRotations + "'"
        if self.jointBindingScales != [0, 0, 0]:
            result += " jointBindingScales='" + self.jointBindingScales + "'"
        if self.loa != -1:
            result += " loa='" + self.loa + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + self.rotation + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + self.scale + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + self.scaleOrientation + "'"
        if self.skeletalConfiguration != 'BASIC':
            result += " skeletalConfiguration='" + self.skeletalConfiguration + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + self.translation + "'"
        if self.version != '2.0':
            result += " version='" + self.version + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.skinCoord: # walk each child node, if any
            result += indent
            for each in self.skinCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.skinNormal: # walk each child node, if any
            result += indent
            for each in self.skinNormal:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.joints: # walk each child node, if any
            result += indent
            for each in self.joints:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.motions: # walk each child node, if any
            result += indent
            for each in self.motions:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.segments: # walk each child node, if any
            result += indent
            for each in self.segments:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.sites: # walk each child node, if any
            result += indent
            for each in self.sites:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.skeleton: # walk each child node, if any
            result += indent
            for each in self.skeleton:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.skin: # walk each child node, if any
            result += indent
            for each in self.skin:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.skinBindingCoords: # walk each child node, if any
            result += indent
            for each in self.skinBindingCoords:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.skinBindingNormals: # walk each child node, if any
            result += indent
            for each in self.skinBindingNormals:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.viewpoints: # walk each child node, if any
            result += indent
            for each in self.viewpoints:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</HAnimHumanoid>' + '\n'
#       print('XML serialization complete.')
        return result

class HAnimJoint(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'HAnimJoint'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimJoint'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('limitOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('llimit', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('skinCoordIndex', list(), FieldType.MFInt32, AccessType.inputOutput),
                          ('skinCoordWeight', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('stiffness', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('ulimit', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('displacers', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 description='',
                 limitOrientation=(0, 0, 1, 0),
                 llimit=(0, 0, 0),
                 name='',
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 skinCoordIndex=list(),
                 skinCoordWeight=list(),
                 stiffness=(1, 1, 1),
                 translation=(0, 0, 0),
                 ulimit=(0, 0, 0),
                 children=list(),
                 displacers=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode HAnimJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.center = center
        self.description = description
        self.limitOrientation = limitOrientation
        self.llimit = llimit
        self.name = name
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.skinCoordIndex = skinCoordIndex
        self.skinCoordWeight = skinCoordWeight
        self.stiffness = stiffness
        self.translation = translation
        self.ulimit = ulimit
        self.children = children
        self.displacers = displacers
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def limitOrientation(self):
        return self.__limitOrientation
    @limitOrientation.setter
    def limitOrientation(self, limitOrientation=None):
        if  limitOrientation is None:
            limitOrientation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(limitOrientation)
        self.__limitOrientation = limitOrientation
    @property # getter - - - - - - - - - -
    def llimit(self):
        return self.__llimit
    @llimit.setter
    def llimit(self, llimit=None):
        if  llimit is None:
            llimit = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(llimit)
        self.__llimit = llimit
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def rotation(self):
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation=None):
        if  rotation is None:
            rotation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        return self.__scale
    @scale.setter
    def scale(self, scale=None):
        if  scale is None:
            scale = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(scale)
        assertPositive('scale', scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation=None):
        if  scaleOrientation is None:
            scaleOrientation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def skinCoordIndex(self):
        return self.__skinCoordIndex
    @skinCoordIndex.setter
    def skinCoordIndex(self, skinCoordIndex=None):
        if  skinCoordIndex is None:
            skinCoordIndex = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(skinCoordIndex)
        assertNonNegative('skinCoordIndex', skinCoordIndex)
        self.__skinCoordIndex = skinCoordIndex
    @property # getter - - - - - - - - - -
    def skinCoordWeight(self):
        return self.__skinCoordWeight
    @skinCoordWeight.setter
    def skinCoordWeight(self, skinCoordWeight=None):
        if  skinCoordWeight is None:
            skinCoordWeight = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(skinCoordWeight)
        self.__skinCoordWeight = skinCoordWeight
    @property # getter - - - - - - - - - -
    def stiffness(self):
        return self.__stiffness
    @stiffness.setter
    def stiffness(self, stiffness=None):
        if  stiffness is None:
            stiffness = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(stiffness)
        assertZeroToOne('stiffness', stiffness)
        self.__stiffness = stiffness
    @property # getter - - - - - - - - - -
    def translation(self):
        return self.__translation
    @translation.setter
    def translation(self, translation=None):
        if  translation is None:
            translation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def ulimit(self):
        return self.__ulimit
    @ulimit.setter
    def ulimit(self, ulimit=None):
        if  ulimit is None:
            ulimit = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(ulimit)
        self.__ulimit = ulimit
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def displacers(self):
        return self.__displacers
    @displacers.setter
    def displacers(self, displacers=None):
        if  displacers is None:
            displacers = MFNode.DEFAULT_VALUE
        assertValidMFNode(displacers)
        self.__displacers = displacers
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function HAnimJoint.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<HAnimJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.limitOrientation != (0, 0, 1, 0):
            result += " limitOrientation='" + self.limitOrientation + "'"
        if self.llimit != (0, 0, 0):
            result += " llimit='" + self.llimit + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + self.rotation + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + self.scale + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + self.scaleOrientation + "'"
        if self.skinCoordIndex != list():
            result += " skinCoordIndex='" + self.skinCoordIndex + "'"
        if self.skinCoordWeight != list():
            result += " skinCoordWeight='" + self.skinCoordWeight + "'"
        if self.stiffness != (1, 1, 1):
            result += " stiffness='" + self.stiffness + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + self.translation + "'"
        if self.ulimit != (0, 0, 0):
            result += " ulimit='" + self.ulimit + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.displacers: # walk each child node, if any
            result += indent
            for each in self.displacers:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</HAnimJoint>' + '\n'
#       print('XML serialization complete.')
        return result

class HAnimMotion(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'HAnimMotion'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimMotion'
    FIELD_DECLARATIONS = [('channels', list(), FieldType.MFString, AccessType.inputOutput),
                          ('channelsEnabled', list(), FieldType.MFBool, AccessType.inputOutput),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('enabled', False, FieldType.SFBool, AccessType.inputOutput),
                          ('endFrame', -1, FieldType.SFInt32, AccessType.inputOutput),
                          ('frameDuration', 0.1, FieldType.SFTime, AccessType.inputOutput),
                          ('frameIncrement', 1, FieldType.SFInt32, AccessType.inputOutput),
                          ('frameIndex', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('joints', list(), FieldType.MFString, AccessType.inputOutput),
                          ('loa', -1, FieldType.SFInt32, AccessType.inputOutput),
                          ('loop', False, FieldType.SFBool, AccessType.inputOutput),
                          ('startFrame', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('values', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 channels=list(),
                 channelsEnabled=list(),
                 description='',
                 enabled=False,
                 endFrame=-1,
                 frameDuration=0.1,
                 frameIncrement=1,
                 frameIndex=0,
                 joints=list(),
                 loa=-1,
                 loop=False,
                 startFrame=0,
                 values=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode HAnimMotion __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.channels = channels
        self.channelsEnabled = channelsEnabled
        self.description = description
        self.enabled = enabled
        self.endFrame = endFrame
        self.frameDuration = frameDuration
        self.frameIncrement = frameIncrement
        self.frameIndex = frameIndex
        self.joints = joints
        self.loa = loa
        self.loop = loop
        self.startFrame = startFrame
        self.values = values
    @property # getter - - - - - - - - - -
    def channels(self):
        return self.__channels
    @channels.setter
    def channels(self, channels=None):
        if  channels is None:
            channels = MFString.DEFAULT_VALUE
        assertValidMFString(channels)
        self.__channels = channels
    @property # getter - - - - - - - - - -
    def channelsEnabled(self):
        return self.__channelsEnabled
    @channelsEnabled.setter
    def channelsEnabled(self, channelsEnabled=None):
        if  channelsEnabled is None:
            channelsEnabled = MFBool.DEFAULT_VALUE
        assertValidMFBool(channelsEnabled)
        self.__channelsEnabled = channelsEnabled
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def endFrame(self):
        return self.__endFrame
    @endFrame.setter
    def endFrame(self, endFrame=None):
        if  endFrame is None:
            endFrame = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(endFrame)
        assertGreaterThanEquals('endFrame', endFrame, -1)
        self.__endFrame = endFrame
    @property # getter - - - - - - - - - -
    def frameDuration(self):
        return self.__frameDuration
    @frameDuration.setter
    def frameDuration(self, frameDuration=None):
        if  frameDuration is None:
            frameDuration = SFTime.DEFAULT_VALUE
        assertValidSFTime(frameDuration)
        assertPositive('frameDuration', frameDuration)
        self.__frameDuration = frameDuration
    @property # getter - - - - - - - - - -
    def frameIncrement(self):
        return self.__frameIncrement
    @frameIncrement.setter
    def frameIncrement(self, frameIncrement=None):
        if  frameIncrement is None:
            frameIncrement = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(frameIncrement)
        self.__frameIncrement = frameIncrement
    @property # getter - - - - - - - - - -
    def frameIndex(self):
        return self.__frameIndex
    @frameIndex.setter
    def frameIndex(self, frameIndex=None):
        if  frameIndex is None:
            frameIndex = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(frameIndex)
        assertNonNegative('frameIndex', frameIndex)
        self.__frameIndex = frameIndex
    @property # getter - - - - - - - - - -
    def joints(self):
        return self.__joints
    @joints.setter
    def joints(self, joints=None):
        if  joints is None:
            joints = MFString.DEFAULT_VALUE
        assertValidMFString(joints)
        self.__joints = joints
    @property # getter - - - - - - - - - -
    def loa(self):
        return self.__loa
    @loa.setter
    def loa(self, loa=None):
        if  loa is None:
            loa = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(loa)
        assertGreaterThanEquals('loa', loa, -1)
        assertLessThanEquals('loa', loa, 4)
        self.__loa = loa
    @property # getter - - - - - - - - - -
    def loop(self):
        return self.__loop
    @loop.setter
    def loop(self, loop=None):
        if  loop is None:
            loop = SFBool.DEFAULT_VALUE
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def startFrame(self):
        return self.__startFrame
    @startFrame.setter
    def startFrame(self, startFrame=None):
        if  startFrame is None:
            startFrame = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(startFrame)
        assertNonNegative('startFrame', startFrame)
        self.__startFrame = startFrame
    @property # getter - - - - - - - - - -
    def values(self):
        return self.__values
    @values.setter
    def values(self, values=None):
        if  values is None:
            values = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(values)
        self.__values = values
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function HAnimMotion.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<HAnimMotion'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.channels != list():
            result += " channels='" + self.channels + "'"
        if self.channelsEnabled != list():
            result += " channelsEnabled='" + self.channelsEnabled + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.enabled != False:
            result += " enabled='" + self.enabled + "'"
        if self.endFrame != -1:
            result += " endFrame='" + self.endFrame + "'"
        if self.frameDuration != 0.1:
            result += " frameDuration='" + self.frameDuration + "'"
        if self.frameIncrement != 1:
            result += " frameIncrement='" + self.frameIncrement + "'"
        if self.frameIndex != 0:
            result += " frameIndex='" + self.frameIndex + "'"
        if self.joints != list():
            result += " joints='" + self.joints + "'"
        if self.loa != -1:
            result += " loa='" + self.loa + "'"
        if self.loop != False:
            result += " loop='" + self.loop + "'"
        if self.startFrame != 0:
            result += " startFrame='" + self.startFrame + "'"
        if self.values != list():
            result += " values='" + self.values + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</HAnimMotion>' + '\n'
#       print('XML serialization complete.')
        return result

class HAnimSegment(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'HAnimSegment'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimSegment'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('centerOfMass', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('mass', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('momentsOfInertia', [0, 0, 0, 0, 0, 0, 0, 0, 0], FieldType.MFFloat, AccessType.inputOutput),
                          ('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('displacers', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 centerOfMass=(0, 0, 0),
                 description='',
                 mass=0,
                 momentsOfInertia=[0, 0, 0, 0, 0, 0, 0, 0, 0],
                 name='',
                 coord=None,
                 children=list(),
                 displacers=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode HAnimSegment __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.centerOfMass = centerOfMass
        self.description = description
        self.mass = mass
        self.momentsOfInertia = momentsOfInertia
        self.name = name
        self.coord = coord
        self.children = children
        self.displacers = displacers
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def centerOfMass(self):
        return self.__centerOfMass
    @centerOfMass.setter
    def centerOfMass(self, centerOfMass=None):
        if  centerOfMass is None:
            centerOfMass = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(centerOfMass)
        self.__centerOfMass = centerOfMass
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def mass(self):
        return self.__mass
    @mass.setter
    def mass(self, mass=None):
        if  mass is None:
            mass = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def momentsOfInertia(self):
        return self.__momentsOfInertia
    @momentsOfInertia.setter
    def momentsOfInertia(self, momentsOfInertia=None):
        if  momentsOfInertia is None:
            momentsOfInertia = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(momentsOfInertia)
        assertNonNegative('momentsOfInertia', momentsOfInertia)
        self.__momentsOfInertia = momentsOfInertia
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def displacers(self):
        return self.__displacers
    @displacers.setter
    def displacers(self, displacers=None):
        if  displacers is None:
            displacers = MFNode.DEFAULT_VALUE
        assertValidMFNode(displacers)
        self.__displacers = displacers
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function HAnimSegment.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<HAnimSegment'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.centerOfMass != (0, 0, 0):
            result += " centerOfMass='" + self.centerOfMass + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.mass != 0:
            result += " mass='" + self.mass + "'"
        if self.momentsOfInertia != [0, 0, 0, 0, 0, 0, 0, 0, 0]:
            result += " momentsOfInertia='" + self.momentsOfInertia + "'"
        if self.name:
            result += " name='" + self.name + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.displacers: # walk each child node, if any
            result += indent
            for each in self.displacers:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</HAnimSegment>' + '\n'
#       print('XML serialization complete.')
        return result

class HAnimSite(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'HAnimSite'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimSite'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 description='',
                 name='',
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 translation=(0, 0, 0),
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode HAnimSite __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.center = center
        self.description = description
        self.name = name
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.translation = translation
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def rotation(self):
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation=None):
        if  rotation is None:
            rotation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        return self.__scale
    @scale.setter
    def scale(self, scale=None):
        if  scale is None:
            scale = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(scale)
        assertPositive('scale', scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation=None):
        if  scaleOrientation is None:
            scaleOrientation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def translation(self):
        return self.__translation
    @translation.setter
    def translation(self, translation=None):
        if  translation is None:
            translation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function HAnimSite.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<HAnimSite'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + self.rotation + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + self.scale + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + self.scaleOrientation + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + self.translation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</HAnimSite>' + '\n'
#       print('XML serialization complete.')
        return result

class ImageCubeMapTexture(_X3DEnvironmentTextureNode):
    """
    X3D element
    """
    NAME = 'ImageCubeMapTexture'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ImageCubeMapTexture'
    FIELD_DECLARATIONS = [('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 url=list(),
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ImageCubeMapTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.url = url
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties=None):
        if  textureProperties is None:
            textureProperties = SFNode.DEFAULT_VALUE
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            print(flush=True)
            raise TypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ImageCubeMapTexture.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ImageCubeMapTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.textureProperties: # walk each child node, if any
            result += indent
            for each in self.textureProperties:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ImageCubeMapTexture>' + '\n'
#       print('XML serialization complete.')
        return result

class ImageTexture(_X3DTexture2DNode):
    """
    X3D element
    """
    NAME = 'ImageTexture'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ImageTexture'
    FIELD_DECLARATIONS = [('repeatS', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('repeatT', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 repeatS=True,
                 repeatT=True,
                 url=list(),
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ImageTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.url = url
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def repeatS(self):
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS=None):
        if  repeatS is None:
            repeatS = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT=None):
        if  repeatT is None:
            repeatT = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties=None):
        if  textureProperties is None:
            textureProperties = SFNode.DEFAULT_VALUE
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            print(flush=True)
            raise TypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ImageTexture.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ImageTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.repeatS != True:
            result += " repeatS='" + self.repeatS + "'"
        if self.repeatT != True:
            result += " repeatT='" + self.repeatT + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.textureProperties: # walk each child node, if any
            result += indent
            for each in self.textureProperties:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ImageTexture>' + '\n'
#       print('XML serialization complete.')
        return result

class ImageTexture3D(_X3DTexture3DNode):
    """
    X3D element
    """
    NAME = 'ImageTexture3D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ImageTexture3D'
    FIELD_DECLARATIONS = [('repeatR', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('repeatS', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('repeatT', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 repeatR=False,
                 repeatS=False,
                 repeatT=False,
                 url=list(),
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ImageTexture3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.repeatR = repeatR
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.url = url
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def repeatR(self):
        return self.__repeatR
    @repeatR.setter
    def repeatR(self, repeatR=None):
        if  repeatR is None:
            repeatR = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatR)
        self.__repeatR = repeatR
    @property # getter - - - - - - - - - -
    def repeatS(self):
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS=None):
        if  repeatS is None:
            repeatS = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT=None):
        if  repeatT is None:
            repeatT = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties=None):
        if  textureProperties is None:
            textureProperties = SFNode.DEFAULT_VALUE
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            print(flush=True)
            raise TypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ImageTexture3D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ImageTexture3D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.repeatR != False:
            result += " repeatR='" + self.repeatR + "'"
        if self.repeatS != False:
            result += " repeatS='" + self.repeatS + "'"
        if self.repeatT != False:
            result += " repeatT='" + self.repeatT + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.textureProperties: # walk each child node, if any
            result += indent
            for each in self.textureProperties:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ImageTexture3D>' + '\n'
#       print('XML serialization complete.')
        return result

class IndexedFaceSet(_X3DComposedGeometryNode):
    """
    X3D element
    """
    NAME = 'IndexedFaceSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedFaceSet'
    FIELD_DECLARATIONS = [('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('colorIndex', list(), FieldType.MFInt32, AccessType.initializeOnly),
                          ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('convex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('coordIndex', list(), FieldType.MFInt32, AccessType.initializeOnly),
                          ('creaseAngle', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('normalIndex', list(), FieldType.MFInt32, AccessType.initializeOnly),
                          ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('texCoordIndex', list(), FieldType.MFInt32, AccessType.initializeOnly),
                          ('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('normal', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('attrib', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ccw=True,
                 colorIndex=list(),
                 colorPerVertex=True,
                 convex=True,
                 coordIndex=list(),
                 creaseAngle=0,
                 normalIndex=list(),
                 normalPerVertex=True,
                 solid=True,
                 texCoordIndex=list(),
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IndexedFaceSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorIndex = colorIndex
        self.colorPerVertex = colorPerVertex
        self.convex = convex
        self.coordIndex = coordIndex
        self.creaseAngle = creaseAngle
        self.normalIndex = normalIndex
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.texCoordIndex = texCoordIndex
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorIndex(self):
        return self.__colorIndex
    @colorIndex.setter
    def colorIndex(self, colorIndex=None):
        if  colorIndex is None:
            colorIndex = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(colorIndex)
        assertGreaterThanEquals('colorIndex', colorIndex, -1)
        self.__colorIndex = colorIndex
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex=None):
        if  colorPerVertex is None:
            colorPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def convex(self):
        return self.__convex
    @convex.setter
    def convex(self, convex=None):
        if  convex is None:
            convex = SFBool.DEFAULT_VALUE
        assertValidSFBool(convex)
        self.__convex = convex
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex=None):
        if  coordIndex is None:
            coordIndex = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def creaseAngle(self):
        return self.__creaseAngle
    @creaseAngle.setter
    def creaseAngle(self, creaseAngle=None):
        if  creaseAngle is None:
            creaseAngle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(creaseAngle)
        assertNonNegative('creaseAngle', creaseAngle)
        self.__creaseAngle = creaseAngle
    @property # getter - - - - - - - - - -
    def normalIndex(self):
        return self.__normalIndex
    @normalIndex.setter
    def normalIndex(self, normalIndex=None):
        if  normalIndex is None:
            normalIndex = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(normalIndex)
        assertGreaterThanEquals('normalIndex', normalIndex, -1)
        self.__normalIndex = normalIndex
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex=None):
        if  normalPerVertex is None:
            normalPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def texCoordIndex(self):
        return self.__texCoordIndex
    @texCoordIndex.setter
    def texCoordIndex(self, texCoordIndex=None):
        if  texCoordIndex is None:
            texCoordIndex = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(texCoordIndex)
        assertGreaterThanEquals('texCoordIndex', texCoordIndex, -1)
        self.__texCoordIndex = texCoordIndex
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord=None):
        if  fogCoord is None:
            fogCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            print(flush=True)
            raise TypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal=None):
        if  normal is None:
            normal = SFNode.DEFAULT_VALUE
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            print(flush=True)
            raise TypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            print(flush=True)
            raise TypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib=None):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function IndexedFaceSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<IndexedFaceSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorIndex != list():
            result += " colorIndex='" + self.colorIndex + "'"
        if self.colorPerVertex != True:
            result += " colorPerVertex='" + self.colorPerVertex + "'"
        if self.convex != True:
            result += " convex='" + self.convex + "'"
        if self.coordIndex != list():
            result += " coordIndex='" + self.coordIndex + "'"
        if self.creaseAngle != 0:
            result += " creaseAngle='" + self.creaseAngle + "'"
        if self.normalIndex != list():
            result += " normalIndex='" + self.normalIndex + "'"
        if self.normalPerVertex != True:
            result += " normalPerVertex='" + self.normalPerVertex + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'"
        if self.texCoordIndex != list():
            result += " texCoordIndex='" + self.texCoordIndex + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fogCoord: # walk each child node, if any
            result += indent
            for each in self.fogCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.normal: # walk each child node, if any
            result += indent
            for each in self.normal:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.attrib: # walk each child node, if any
            result += indent
            for each in self.attrib:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</IndexedFaceSet>' + '\n'
#       print('XML serialization complete.')
        return result

class IndexedLineSet(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'IndexedLineSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedLineSet'
    FIELD_DECLARATIONS = [('colorIndex', list(), FieldType.MFInt32, AccessType.initializeOnly),
                          ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('coordIndex', list(), FieldType.MFInt32, AccessType.initializeOnly),
                          ('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('attrib', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 colorIndex=list(),
                 colorPerVertex=True,
                 coordIndex=list(),
                 color=None,
                 coord=None,
                 fogCoord=None,
                 attrib=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IndexedLineSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.colorIndex = colorIndex
        self.colorPerVertex = colorPerVertex
        self.coordIndex = coordIndex
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def colorIndex(self):
        return self.__colorIndex
    @colorIndex.setter
    def colorIndex(self, colorIndex=None):
        if  colorIndex is None:
            colorIndex = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(colorIndex)
        assertGreaterThanEquals('colorIndex', colorIndex, -1)
        self.__colorIndex = colorIndex
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex=None):
        if  colorPerVertex is None:
            colorPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex=None):
        if  coordIndex is None:
            coordIndex = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord=None):
        if  fogCoord is None:
            fogCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            print(flush=True)
            raise TypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib=None):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function IndexedLineSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<IndexedLineSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorIndex != list():
            result += " colorIndex='" + self.colorIndex + "'"
        if self.colorPerVertex != True:
            result += " colorPerVertex='" + self.colorPerVertex + "'"
        if self.coordIndex != list():
            result += " coordIndex='" + self.coordIndex + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fogCoord: # walk each child node, if any
            result += indent
            for each in self.fogCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.attrib: # walk each child node, if any
            result += indent
            for each in self.attrib:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</IndexedLineSet>' + '\n'
#       print('XML serialization complete.')
        return result

class IndexedQuadSet(_X3DComposedGeometryNode):
    """
    IndexedQuadSet is a geometry node that defines quadrilaterals.
    """
    NAME = 'IndexedQuadSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedQuadSet'
    FIELD_DECLARATIONS = [('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('index', list(), FieldType.MFInt32, AccessType.initializeOnly),
                          ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('normal', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('attrib', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 index=list(),
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IndexedQuadSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.index = index
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex=None):
        if  colorPerVertex is None:
            colorPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def index(self):
        return self.__index
    @index.setter
    def index(self, index=None):
        if  index is None:
            index = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(index)
        assertNonNegative('index', index)
        self.__index = index
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex=None):
        if  normalPerVertex is None:
            normalPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord=None):
        if  fogCoord is None:
            fogCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            print(flush=True)
            raise TypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal=None):
        if  normal is None:
            normal = SFNode.DEFAULT_VALUE
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            print(flush=True)
            raise TypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            print(flush=True)
            raise TypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib=None):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function IndexedQuadSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<IndexedQuadSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorPerVertex != True:
            result += " colorPerVertex='" + self.colorPerVertex + "'"
        if self.index != list():
            result += " index='" + self.index + "'"
        if self.normalPerVertex != True:
            result += " normalPerVertex='" + self.normalPerVertex + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fogCoord: # walk each child node, if any
            result += indent
            for each in self.fogCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.normal: # walk each child node, if any
            result += indent
            for each in self.normal:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.attrib: # walk each child node, if any
            result += indent
            for each in self.attrib:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</IndexedQuadSet>' + '\n'
#       print('XML serialization complete.')
        return result

class IndexedTriangleFanSet(_X3DComposedGeometryNode):
    """
    X3D element
    """
    NAME = 'IndexedTriangleFanSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedTriangleFanSet'
    FIELD_DECLARATIONS = [('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('index', list(), FieldType.MFInt32, AccessType.initializeOnly),
                          ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('normal', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('attrib', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 index=list(),
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IndexedTriangleFanSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.index = index
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex=None):
        if  colorPerVertex is None:
            colorPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def index(self):
        return self.__index
    @index.setter
    def index(self, index=None):
        if  index is None:
            index = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(index)
        assertGreaterThanEquals('index', index, -1)
        self.__index = index
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex=None):
        if  normalPerVertex is None:
            normalPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord=None):
        if  fogCoord is None:
            fogCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            print(flush=True)
            raise TypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal=None):
        if  normal is None:
            normal = SFNode.DEFAULT_VALUE
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            print(flush=True)
            raise TypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            print(flush=True)
            raise TypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib=None):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function IndexedTriangleFanSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<IndexedTriangleFanSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorPerVertex != True:
            result += " colorPerVertex='" + self.colorPerVertex + "'"
        if self.index != list():
            result += " index='" + self.index + "'"
        if self.normalPerVertex != True:
            result += " normalPerVertex='" + self.normalPerVertex + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fogCoord: # walk each child node, if any
            result += indent
            for each in self.fogCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.normal: # walk each child node, if any
            result += indent
            for each in self.normal:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.attrib: # walk each child node, if any
            result += indent
            for each in self.attrib:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</IndexedTriangleFanSet>' + '\n'
#       print('XML serialization complete.')
        return result

class IndexedTriangleSet(_X3DComposedGeometryNode):
    """
    X3D element
    """
    NAME = 'IndexedTriangleSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedTriangleSet'
    FIELD_DECLARATIONS = [('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('index', list(), FieldType.MFInt32, AccessType.initializeOnly),
                          ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('normal', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('attrib', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 index=list(),
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IndexedTriangleSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.index = index
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex=None):
        if  colorPerVertex is None:
            colorPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def index(self):
        return self.__index
    @index.setter
    def index(self, index=None):
        if  index is None:
            index = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(index)
        assertNonNegative('index', index)
        self.__index = index
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex=None):
        if  normalPerVertex is None:
            normalPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord=None):
        if  fogCoord is None:
            fogCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            print(flush=True)
            raise TypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal=None):
        if  normal is None:
            normal = SFNode.DEFAULT_VALUE
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            print(flush=True)
            raise TypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            print(flush=True)
            raise TypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib=None):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function IndexedTriangleSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<IndexedTriangleSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorPerVertex != True:
            result += " colorPerVertex='" + self.colorPerVertex + "'"
        if self.index != list():
            result += " index='" + self.index + "'"
        if self.normalPerVertex != True:
            result += " normalPerVertex='" + self.normalPerVertex + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fogCoord: # walk each child node, if any
            result += indent
            for each in self.fogCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.normal: # walk each child node, if any
            result += indent
            for each in self.normal:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.attrib: # walk each child node, if any
            result += indent
            for each in self.attrib:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</IndexedTriangleSet>' + '\n'
#       print('XML serialization complete.')
        return result

class IndexedTriangleStripSet(_X3DComposedGeometryNode):
    """
    X3D element
    """
    NAME = 'IndexedTriangleStripSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedTriangleStripSet'
    FIELD_DECLARATIONS = [('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('index', list(), FieldType.MFInt32, AccessType.initializeOnly),
                          ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('normal', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('attrib', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 index=list(),
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IndexedTriangleStripSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.index = index
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex=None):
        if  colorPerVertex is None:
            colorPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def index(self):
        return self.__index
    @index.setter
    def index(self, index=None):
        if  index is None:
            index = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(index)
        assertGreaterThanEquals('index', index, -1)
        self.__index = index
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex=None):
        if  normalPerVertex is None:
            normalPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord=None):
        if  fogCoord is None:
            fogCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            print(flush=True)
            raise TypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal=None):
        if  normal is None:
            normal = SFNode.DEFAULT_VALUE
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            print(flush=True)
            raise TypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            print(flush=True)
            raise TypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib=None):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function IndexedTriangleStripSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<IndexedTriangleStripSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorPerVertex != True:
            result += " colorPerVertex='" + self.colorPerVertex + "'"
        if self.index != list():
            result += " index='" + self.index + "'"
        if self.normalPerVertex != True:
            result += " normalPerVertex='" + self.normalPerVertex + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fogCoord: # walk each child node, if any
            result += indent
            for each in self.fogCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.normal: # walk each child node, if any
            result += indent
            for each in self.normal:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.attrib: # walk each child node, if any
            result += indent
            for each in self.attrib:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</IndexedTriangleStripSet>' + '\n'
#       print('XML serialization complete.')
        return result

class Inline(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'Inline'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Inline'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('load', True, FieldType.SFBool, AccessType.inputOutput),
                          ('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 load=True,
                 url=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Inline __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.load = load
        self.url = url
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def load(self):
        return self.__load
    @load.setter
    def load(self, load=None):
        if  load is None:
            load = SFBool.DEFAULT_VALUE
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Inline.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Inline'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.load != True:
            result += " load='" + self.load + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Inline>' + '\n'
#       print('XML serialization complete.')
        return result

class IntegerSequencer(_X3DSequencerNode):
    """
    X3D element
    """
    NAME = 'IntegerSequencer'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IntegerSequencer'
    FIELD_DECLARATIONS = [('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFInt32, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IntegerSequencer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(keyValue)
        self.__keyValue = keyValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function IntegerSequencer.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<IntegerSequencer'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</IntegerSequencer>' + '\n'
#       print('XML serialization complete.')
        return result

class IntegerTrigger(_X3DTriggerNode):
    """
    X3D element
    """
    NAME = 'IntegerTrigger'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IntegerTrigger'
    FIELD_DECLARATIONS = [('integerKey', -1, FieldType.SFInt32, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 integerKey=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IntegerTrigger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.integerKey = integerKey
    @property # getter - - - - - - - - - -
    def integerKey(self):
        return self.__integerKey
    @integerKey.setter
    def integerKey(self, integerKey=None):
        if  integerKey is None:
            integerKey = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(integerKey)
        self.__integerKey = integerKey
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function IntegerTrigger.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<IntegerTrigger'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.integerKey != -1:
            result += " integerKey='" + self.integerKey + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</IntegerTrigger>' + '\n'
#       print('XML serialization complete.')
        return result

class IsoSurfaceVolumeData(_X3DVolumeDataNode):
    """
    X3D element
    """
    NAME = 'IsoSurfaceVolumeData'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IsoSurfaceVolumeData'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('contourStepSize', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('dimensions', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('surfaceTolerance', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('surfaceValues', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('gradients', None, FieldType.SFNode, AccessType.inputOutput),
                          ('voxels', None, FieldType.SFNode, AccessType.inputOutput),
                          ('renderStyle', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 contourStepSize=0,
                 dimensions=(1, 1, 1),
                 surfaceTolerance=0,
                 surfaceValues=list(),
                 gradients=None,
                 voxels=None,
                 renderStyle=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IsoSurfaceVolumeData __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.contourStepSize = contourStepSize
        self.dimensions = dimensions
        self.surfaceTolerance = surfaceTolerance
        self.surfaceValues = surfaceValues
        self.gradients = gradients
        self.voxels = voxels
        self.renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def contourStepSize(self):
        return self.__contourStepSize
    @contourStepSize.setter
    def contourStepSize(self, contourStepSize=None):
        if  contourStepSize is None:
            contourStepSize = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(contourStepSize)
        self.__contourStepSize = contourStepSize
    @property # getter - - - - - - - - - -
    def dimensions(self):
        return self.__dimensions
    @dimensions.setter
    def dimensions(self, dimensions=None):
        if  dimensions is None:
            dimensions = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(dimensions)
        assertPositive('dimensions', dimensions)
        self.__dimensions = dimensions
    @property # getter - - - - - - - - - -
    def surfaceTolerance(self):
        return self.__surfaceTolerance
    @surfaceTolerance.setter
    def surfaceTolerance(self, surfaceTolerance=None):
        if  surfaceTolerance is None:
            surfaceTolerance = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(surfaceTolerance)
        assertNonNegative('surfaceTolerance', surfaceTolerance)
        self.__surfaceTolerance = surfaceTolerance
    @property # getter - - - - - - - - - -
    def surfaceValues(self):
        return self.__surfaceValues
    @surfaceValues.setter
    def surfaceValues(self, surfaceValues=None):
        if  surfaceValues is None:
            surfaceValues = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(surfaceValues)
        self.__surfaceValues = surfaceValues
    @property # getter - - - - - - - - - -
    def gradients(self):
        return self.__gradients
    @gradients.setter
    def gradients(self, gradients=None):
        if  gradients is None:
            gradients = SFNode.DEFAULT_VALUE
        assertValidSFNode(gradients)
        if not isinstance(gradients, object):
            print(flush=True)
            raise TypeError(str(gradients) + ' does not have a valid node type object')
        self.__gradients = gradients
    @property # getter - - - - - - - - - -
    def voxels(self):
        return self.__voxels
    @voxels.setter
    def voxels(self, voxels=None):
        if  voxels is None:
            voxels = SFNode.DEFAULT_VALUE
        assertValidSFNode(voxels)
        if not isinstance(voxels, object):
            print(flush=True)
            raise TypeError(str(voxels) + ' does not have a valid node type object')
        self.__voxels = voxels
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle=None):
        if  renderStyle is None:
            renderStyle = MFNode.DEFAULT_VALUE
        assertValidMFNode(renderStyle)
        self.__renderStyle = renderStyle
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function IsoSurfaceVolumeData.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<IsoSurfaceVolumeData'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.contourStepSize != 0:
            result += " contourStepSize='" + self.contourStepSize + "'"
        if self.dimensions != (1, 1, 1):
            result += " dimensions='" + self.dimensions + "'"
        if self.surfaceTolerance != 0:
            result += " surfaceTolerance='" + self.surfaceTolerance + "'"
        if self.surfaceValues != list():
            result += " surfaceValues='" + self.surfaceValues + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.gradients: # walk each child node, if any
            result += indent
            for each in self.gradients:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.voxels: # walk each child node, if any
            result += indent
            for each in self.voxels:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.renderStyle: # walk each child node, if any
            result += indent
            for each in self.renderStyle:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</IsoSurfaceVolumeData>' + '\n'
#       print('XML serialization complete.')
        return result

class KeySensor(_X3DKeyDeviceSensorNode):
    """
    X3D element
    """
    NAME = 'KeySensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#KeySensor'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode KeySensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function KeySensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<KeySensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</KeySensor>' + '\n'
#       print('XML serialization complete.')
        return result

class Layer(_X3DLayerNode):
    """
    X3D element
    """
    NAME = 'Layer'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Layer'
    FIELD_DECLARATIONS = [('isPickable', True, FieldType.SFBool, AccessType.inputOutput),
                          ('viewport', None, FieldType.SFNode, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 isPickable=True,
                 viewport=None,
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Layer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.isPickable = isPickable
        self.viewport = viewport
        self.children = children
    @property # getter - - - - - - - - - -
    def isPickable(self):
        return self.__isPickable
    @isPickable.setter
    def isPickable(self, isPickable=None):
        if  isPickable is None:
            isPickable = SFBool.DEFAULT_VALUE
        assertValidSFBool(isPickable)
        self.__isPickable = isPickable
    @property # getter - - - - - - - - - -
    def viewport(self):
        return self.__viewport
    @viewport.setter
    def viewport(self, viewport=None):
        if  viewport is None:
            viewport = SFNode.DEFAULT_VALUE
        assertValidSFNode(viewport)
        if not isinstance(viewport, object):
            print(flush=True)
            raise TypeError(str(viewport) + ' does not have a valid node type object')
        self.__viewport = viewport
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Layer.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Layer'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.isPickable != True:
            result += " isPickable='" + self.isPickable + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.viewport: # walk each child node, if any
            result += indent
            for each in self.viewport:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Layer>' + '\n'
#       print('XML serialization complete.')
        return result

class LayerSet(_X3DNode):
    """
    X3D element
    """
    NAME = 'LayerSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LayerSet'
    FIELD_DECLARATIONS = [('activeLayer', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('order', [0], FieldType.MFInt32, AccessType.initializeOnly),
                          ('layers', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 activeLayer=0,
                 order=[0],
                 layers=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LayerSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.activeLayer = activeLayer
        self.order = order
        self.layers = layers
    @property # getter - - - - - - - - - -
    def activeLayer(self):
        return self.__activeLayer
    @activeLayer.setter
    def activeLayer(self, activeLayer=None):
        if  activeLayer is None:
            activeLayer = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(activeLayer)
        assertNonNegative('activeLayer', activeLayer)
        self.__activeLayer = activeLayer
    @property # getter - - - - - - - - - -
    def order(self):
        return self.__order
    @order.setter
    def order(self, order=None):
        if  order is None:
            order = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(order)
        assertNonNegative('order', order)
        self.__order = order
    @property # getter - - - - - - - - - -
    def layers(self):
        return self.__layers
    @layers.setter
    def layers(self, layers=None):
        if  layers is None:
            layers = MFNode.DEFAULT_VALUE
        assertValidMFNode(layers)
        self.__layers = layers
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function LayerSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<LayerSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.activeLayer != 0:
            result += " activeLayer='" + self.activeLayer + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.order != [0]:
            result += " order='" + self.order + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.layers: # walk each child node, if any
            result += indent
            for each in self.layers:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</LayerSet>' + '\n'
#       print('XML serialization complete.')
        return result

class Layout(_X3DLayoutNode):
    """
    X3D element
    """
    NAME = 'Layout'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Layout'
    FIELD_DECLARATIONS = [('align', ["CENTER", "CENTER"], FieldType.MFString, AccessType.inputOutput),
                          ('offset', [0, 0], FieldType.MFFloat, AccessType.inputOutput),
                          ('offsetUnits', ["WORLD", "WORLD"], FieldType.MFString, AccessType.inputOutput),
                          ('scaleMode', ["NONE", "NONE"], FieldType.MFString, AccessType.inputOutput),
                          ('size', [1, 1], FieldType.MFFloat, AccessType.initializeOnly),
                          ('sizeUnits', ["WORLD", "WORLD"], FieldType.MFString, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 align=["CENTER", "CENTER"],
                 offset=[0, 0],
                 offsetUnits=["WORLD", "WORLD"],
                 scaleMode=["NONE", "NONE"],
                 size=[1, 1],
                 sizeUnits=["WORLD", "WORLD"],
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Layout __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.align = align
        self.offset = offset
        self.offsetUnits = offsetUnits
        self.scaleMode = scaleMode
        self.size = size
        self.sizeUnits = sizeUnits
    @property # getter - - - - - - - - - -
    def align(self):
        return self.__align
    @align.setter
    def align(self, align=None):
        if  align is None:
            align = MFString.DEFAULT_VALUE
        assertValidMFString(align)
        self.__align = align
    @property # getter - - - - - - - - - -
    def offset(self):
        return self.__offset
    @offset.setter
    def offset(self, offset=None):
        if  offset is None:
            offset = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(offset)
        self.__offset = offset
    @property # getter - - - - - - - - - -
    def offsetUnits(self):
        return self.__offsetUnits
    @offsetUnits.setter
    def offsetUnits(self, offsetUnits=None):
        if  offsetUnits is None:
            offsetUnits = MFString.DEFAULT_VALUE
        assertValidMFString(offsetUnits)
        self.__offsetUnits = offsetUnits
    @property # getter - - - - - - - - - -
    def scaleMode(self):
        return self.__scaleMode
    @scaleMode.setter
    def scaleMode(self, scaleMode=None):
        if  scaleMode is None:
            scaleMode = MFString.DEFAULT_VALUE
        assertValidMFString(scaleMode)
        self.__scaleMode = scaleMode
    @property # getter - - - - - - - - - -
    def size(self):
        return self.__size
    @size.setter
    def size(self, size=None):
        if  size is None:
            size = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def sizeUnits(self):
        return self.__sizeUnits
    @sizeUnits.setter
    def sizeUnits(self, sizeUnits=None):
        if  sizeUnits is None:
            sizeUnits = MFString.DEFAULT_VALUE
        assertValidMFString(sizeUnits)
        self.__sizeUnits = sizeUnits
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Layout.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Layout'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.align != ["CENTER", "CENTER"]:
            result += " align='" + self.align + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.offset != [0, 0]:
            result += " offset='" + self.offset + "'"
        if self.offsetUnits != ["WORLD", "WORLD"]:
            result += " offsetUnits='" + self.offsetUnits + "'"
        if self.scaleMode != ["NONE", "NONE"]:
            result += " scaleMode='" + self.scaleMode + "'"
        if self.size != [1, 1]:
            result += " size='" + self.size + "'"
        if self.sizeUnits != ["WORLD", "WORLD"]:
            result += " sizeUnits='" + self.sizeUnits + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Layout>' + '\n'
#       print('XML serialization complete.')
        return result

class LayoutGroup(_X3DNode):
    """
    X3D element
    """
    NAME = 'LayoutGroup'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LayoutGroup'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('layout', None, FieldType.SFNode, AccessType.inputOutput),
                          ('viewport', None, FieldType.SFNode, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 layout=None,
                 viewport=None,
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LayoutGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.layout = layout
        self.viewport = viewport
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def layout(self):
        return self.__layout
    @layout.setter
    def layout(self, layout=None):
        if  layout is None:
            layout = SFNode.DEFAULT_VALUE
        assertValidSFNode(layout)
        if not isinstance(layout, object):
            print(flush=True)
            raise TypeError(str(layout) + ' does not have a valid node type object')
        self.__layout = layout
    @property # getter - - - - - - - - - -
    def viewport(self):
        return self.__viewport
    @viewport.setter
    def viewport(self, viewport=None):
        if  viewport is None:
            viewport = SFNode.DEFAULT_VALUE
        assertValidSFNode(viewport)
        if not isinstance(viewport, object):
            print(flush=True)
            raise TypeError(str(viewport) + ' does not have a valid node type object')
        self.__viewport = viewport
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function LayoutGroup.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<LayoutGroup'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.layout: # walk each child node, if any
            result += indent
            for each in self.layout:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.viewport: # walk each child node, if any
            result += indent
            for each in self.viewport:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</LayoutGroup>' + '\n'
#       print('XML serialization complete.')
        return result

class LayoutLayer(_X3DLayerNode):
    """
    X3D element
    """
    NAME = 'LayoutLayer'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LayoutLayer'
    FIELD_DECLARATIONS = [('isPickable', True, FieldType.SFBool, AccessType.inputOutput),
                          ('layout', None, FieldType.SFNode, AccessType.inputOutput),
                          ('viewport', None, FieldType.SFNode, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 isPickable=True,
                 layout=None,
                 viewport=None,
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LayoutLayer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.isPickable = isPickable
        self.layout = layout
        self.viewport = viewport
        self.children = children
    @property # getter - - - - - - - - - -
    def isPickable(self):
        return self.__isPickable
    @isPickable.setter
    def isPickable(self, isPickable=None):
        if  isPickable is None:
            isPickable = SFBool.DEFAULT_VALUE
        assertValidSFBool(isPickable)
        self.__isPickable = isPickable
    @property # getter - - - - - - - - - -
    def layout(self):
        return self.__layout
    @layout.setter
    def layout(self, layout=None):
        if  layout is None:
            layout = SFNode.DEFAULT_VALUE
        assertValidSFNode(layout)
        if not isinstance(layout, object):
            print(flush=True)
            raise TypeError(str(layout) + ' does not have a valid node type object')
        self.__layout = layout
    @property # getter - - - - - - - - - -
    def viewport(self):
        return self.__viewport
    @viewport.setter
    def viewport(self, viewport=None):
        if  viewport is None:
            viewport = SFNode.DEFAULT_VALUE
        assertValidSFNode(viewport)
        if not isinstance(viewport, object):
            print(flush=True)
            raise TypeError(str(viewport) + ' does not have a valid node type object')
        self.__viewport = viewport
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function LayoutLayer.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<LayoutLayer'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.isPickable != True:
            result += " isPickable='" + self.isPickable + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.layout: # walk each child node, if any
            result += indent
            for each in self.layout:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.viewport: # walk each child node, if any
            result += indent
            for each in self.viewport:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</LayoutLayer>' + '\n'
#       print('XML serialization complete.')
        return result

class LinePickSensor(_X3DPickSensorNode):
    """
    X3D element
    """
    NAME = 'LinePickSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LinePickSensor'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('intersectionType', 'BOUNDS', FieldType.SFString, AccessType.initializeOnly),
                          ('matchCriterion', 'MATCH_ANY', FieldType.SFString, AccessType.inputOutput),
                          ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput),
                          ('sortOrder', 'CLOSEST', FieldType.SFString, AccessType.initializeOnly),
                          ('pickingGeometry', None, FieldType.SFNode, AccessType.inputOutput),
                          ('pickTarget', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 intersectionType='BOUNDS',
                 matchCriterion='MATCH_ANY',
                 objectType=["ALL"],
                 sortOrder='CLOSEST',
                 pickingGeometry=None,
                 pickTarget=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LinePickSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.intersectionType = intersectionType
        self.matchCriterion = matchCriterion
        self.objectType = objectType
        self.sortOrder = sortOrder
        self.pickingGeometry = pickingGeometry
        self.pickTarget = pickTarget
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intersectionType(self):
        return self.__intersectionType
    @intersectionType.setter
    def intersectionType(self, intersectionType=None):
        if  intersectionType is None:
            intersectionType = SFString.DEFAULT_VALUE
        assertValidSFString(intersectionType)
        self.__intersectionType = intersectionType
    @property # getter - - - - - - - - - -
    def matchCriterion(self):
        return self.__matchCriterion
    @matchCriterion.setter
    def matchCriterion(self, matchCriterion=None):
        if  matchCriterion is None:
            matchCriterion = SFString.DEFAULT_VALUE
        assertValidSFString(matchCriterion)
        self.__matchCriterion = matchCriterion
    @property # getter - - - - - - - - - -
    def objectType(self):
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType=None):
        if  objectType is None:
            objectType = MFString.DEFAULT_VALUE
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def sortOrder(self):
        return self.__sortOrder
    @sortOrder.setter
    def sortOrder(self, sortOrder=None):
        if  sortOrder is None:
            sortOrder = SFString.DEFAULT_VALUE
        assertValidSFString(sortOrder)
        self.__sortOrder = sortOrder
    @property # getter - - - - - - - - - -
    def pickingGeometry(self):
        return self.__pickingGeometry
    @pickingGeometry.setter
    def pickingGeometry(self, pickingGeometry=None):
        if  pickingGeometry is None:
            pickingGeometry = SFNode.DEFAULT_VALUE
        assertValidSFNode(pickingGeometry)
        if not isinstance(pickingGeometry, object):
            print(flush=True)
            raise TypeError(str(pickingGeometry) + ' does not have a valid node type object')
        self.__pickingGeometry = pickingGeometry
    @property # getter - - - - - - - - - -
    def pickTarget(self):
        return self.__pickTarget
    @pickTarget.setter
    def pickTarget(self, pickTarget=None):
        if  pickTarget is None:
            pickTarget = MFNode.DEFAULT_VALUE
        assertValidMFNode(pickTarget)
        self.__pickTarget = pickTarget
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function LinePickSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<LinePickSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.intersectionType != 'BOUNDS':
            result += " intersectionType='" + self.intersectionType + "'"
        if self.matchCriterion != 'MATCH_ANY':
            result += " matchCriterion='" + self.matchCriterion + "'"
        if self.objectType != ["ALL"]:
            result += " objectType='" + self.objectType + "'"
        if self.sortOrder != 'CLOSEST':
            result += " sortOrder='" + self.sortOrder + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.pickingGeometry: # walk each child node, if any
            result += indent
            for each in self.pickingGeometry:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.pickTarget: # walk each child node, if any
            result += indent
            for each in self.pickTarget:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</LinePickSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class LineProperties(_X3DAppearanceChildNode):
    """
    X3D element
    """
    NAME = 'LineProperties'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LineProperties'
    FIELD_DECLARATIONS = [('applied', True, FieldType.SFBool, AccessType.inputOutput),
                          ('linetype', 1, FieldType.SFInt32, AccessType.inputOutput),
                          ('linewidthScaleFactor', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 applied=True,
                 linetype=1,
                 linewidthScaleFactor=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LineProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.applied = applied
        self.linetype = linetype
        self.linewidthScaleFactor = linewidthScaleFactor
    @property # getter - - - - - - - - - -
    def applied(self):
        return self.__applied
    @applied.setter
    def applied(self, applied=None):
        if  applied is None:
            applied = SFBool.DEFAULT_VALUE
        assertValidSFBool(applied)
        self.__applied = applied
    @property # getter - - - - - - - - - -
    def linetype(self):
        return self.__linetype
    @linetype.setter
    def linetype(self, linetype=None):
        if  linetype is None:
            linetype = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(linetype)
        assertGreaterThanEquals('linetype', linetype, 1)
        self.__linetype = linetype
    @property # getter - - - - - - - - - -
    def linewidthScaleFactor(self):
        return self.__linewidthScaleFactor
    @linewidthScaleFactor.setter
    def linewidthScaleFactor(self, linewidthScaleFactor=None):
        if  linewidthScaleFactor is None:
            linewidthScaleFactor = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(linewidthScaleFactor)
        self.__linewidthScaleFactor = linewidthScaleFactor
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function LineProperties.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<LineProperties'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.applied != True:
            result += " applied='" + self.applied + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.linetype != 1:
            result += " linetype='" + self.linetype + "'"
        if self.linewidthScaleFactor != 0:
            result += " linewidthScaleFactor='" + self.linewidthScaleFactor + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</LineProperties>' + '\n'
#       print('XML serialization complete.')
        return result

class LineSet(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'LineSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LineSet'
    FIELD_DECLARATIONS = [('vertexCount', list(), FieldType.MFInt32, AccessType.inputOutput),
                          ('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('attrib', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 vertexCount=list(),
                 color=None,
                 coord=None,
                 fogCoord=None,
                 attrib=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LineSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.vertexCount = vertexCount
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def vertexCount(self):
        return self.__vertexCount
    @vertexCount.setter
    def vertexCount(self, vertexCount=None):
        if  vertexCount is None:
            vertexCount = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(vertexCount)
        assertGreaterThanEquals('vertexCount', vertexCount, 2)
        self.__vertexCount = vertexCount
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord=None):
        if  fogCoord is None:
            fogCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            print(flush=True)
            raise TypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib=None):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function LineSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<LineSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.vertexCount != list():
            result += " vertexCount='" + self.vertexCount + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fogCoord: # walk each child node, if any
            result += indent
            for each in self.fogCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.attrib: # walk each child node, if any
            result += indent
            for each in self.attrib:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</LineSet>' + '\n'
#       print('XML serialization complete.')
        return result

class LoadSensor(_X3DNetworkSensorNode):
    """
    X3D element
    """
    NAME = 'LoadSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LoadSensor'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('timeOut', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('watchList', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 timeOut=0,
                 watchList=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LoadSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.timeOut = timeOut
        self.watchList = watchList
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def timeOut(self):
        return self.__timeOut
    @timeOut.setter
    def timeOut(self, timeOut=None):
        if  timeOut is None:
            timeOut = SFTime.DEFAULT_VALUE
        assertValidSFTime(timeOut)
        assertNonNegative('timeOut', timeOut)
        self.__timeOut = timeOut
    @property # getter - - - - - - - - - -
    def watchList(self):
        return self.__watchList
    @watchList.setter
    def watchList(self, watchList=None):
        if  watchList is None:
            watchList = MFNode.DEFAULT_VALUE
        assertValidMFNode(watchList)
        self.__watchList = watchList
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function LoadSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<LoadSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.timeOut != 0:
            result += " timeOut='" + self.timeOut + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.watchList: # walk each child node, if any
            result += indent
            for each in self.watchList:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</LoadSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class LocalFog(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'LocalFog'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LocalFog'
    FIELD_DECLARATIONS = [('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('fogType', 'LINEAR', FieldType.SFString, AccessType.inputOutput),
                          ('visibilityRange', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 color=(1, 1, 1),
                 enabled=True,
                 fogType='LINEAR',
                 visibilityRange=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LocalFog __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.color = color
        self.enabled = enabled
        self.fogType = fogType
        self.visibilityRange = visibilityRange
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFColor.DEFAULT_VALUE
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def fogType(self):
        return self.__fogType
    @fogType.setter
    def fogType(self, fogType=None):
        if  fogType is None:
            fogType = SFString.DEFAULT_VALUE
        assertValidSFString(fogType)
        self.__fogType = fogType
    @property # getter - - - - - - - - - -
    def visibilityRange(self):
        return self.__visibilityRange
    @visibilityRange.setter
    def visibilityRange(self, visibilityRange=None):
        if  visibilityRange is None:
            visibilityRange = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(visibilityRange)
        assertNonNegative('visibilityRange', visibilityRange)
        self.__visibilityRange = visibilityRange
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function LocalFog.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<LocalFog'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + self.color + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.fogType != 'LINEAR':
            result += " fogType='" + self.fogType + "'"
        if self.visibilityRange != 0:
            result += " visibilityRange='" + self.visibilityRange + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</LocalFog>' + '\n'
#       print('XML serialization complete.')
        return result

class LOD(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'LOD'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LOD'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('forceTransitions', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('range', list(), FieldType.MFFloat, AccessType.initializeOnly),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 forceTransitions=False,
                 range=list(),
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LOD __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.center = center
        self.forceTransitions = forceTransitions
        self.range = range
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def forceTransitions(self):
        return self.__forceTransitions
    @forceTransitions.setter
    def forceTransitions(self, forceTransitions=None):
        if  forceTransitions is None:
            forceTransitions = SFBool.DEFAULT_VALUE
        assertValidSFBool(forceTransitions)
        self.__forceTransitions = forceTransitions
    @property # getter - - - - - - - - - -
    def range(self):
        return self.__range
    @range.setter
    def range(self, range=None):
        if  range is None:
            range = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(range)
        self.__range = range
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function LOD.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<LOD'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.forceTransitions != False:
            result += " forceTransitions='" + self.forceTransitions + "'"
        if self.range != list():
            result += " range='" + self.range + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</LOD>' + '\n'
#       print('XML serialization complete.')
        return result

class Material(_X3DMaterialNode):
    """
    X3D element
    """
    NAME = 'Material'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Material'
    FIELD_DECLARATIONS = [('ambientIntensity', 0.2, FieldType.SFFloat, AccessType.inputOutput),
                          ('diffuseColor', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.inputOutput),
                          ('emissiveColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput),
                          ('shininess', 0.2, FieldType.SFFloat, AccessType.inputOutput),
                          ('specularColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput),
                          ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ambientIntensity=0.2,
                 diffuseColor=(0.8, 0.8, 0.8),
                 emissiveColor=(0, 0, 0),
                 shininess=0.2,
                 specularColor=(0, 0, 0),
                 transparency=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Material __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.diffuseColor = diffuseColor
        self.emissiveColor = emissiveColor
        self.shininess = shininess
        self.specularColor = specularColor
        self.transparency = transparency
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity=None):
        if  ambientIntensity is None:
            ambientIntensity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def diffuseColor(self):
        return self.__diffuseColor
    @diffuseColor.setter
    def diffuseColor(self, diffuseColor=None):
        if  diffuseColor is None:
            diffuseColor = SFColor.DEFAULT_VALUE
        assertValidSFColor(diffuseColor)
        assertZeroToOne('diffuseColor', diffuseColor)
        self.__diffuseColor = diffuseColor
    @property # getter - - - - - - - - - -
    def emissiveColor(self):
        return self.__emissiveColor
    @emissiveColor.setter
    def emissiveColor(self, emissiveColor=None):
        if  emissiveColor is None:
            emissiveColor = SFColor.DEFAULT_VALUE
        assertValidSFColor(emissiveColor)
        assertZeroToOne('emissiveColor', emissiveColor)
        self.__emissiveColor = emissiveColor
    @property # getter - - - - - - - - - -
    def shininess(self):
        return self.__shininess
    @shininess.setter
    def shininess(self, shininess=None):
        if  shininess is None:
            shininess = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(shininess)
        assertZeroToOne('shininess', shininess)
        self.__shininess = shininess
    @property # getter - - - - - - - - - -
    def specularColor(self):
        return self.__specularColor
    @specularColor.setter
    def specularColor(self, specularColor=None):
        if  specularColor is None:
            specularColor = SFColor.DEFAULT_VALUE
        assertValidSFColor(specularColor)
        assertZeroToOne('specularColor', specularColor)
        self.__specularColor = specularColor
    @property # getter - - - - - - - - - -
    def transparency(self):
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency=None):
        if  transparency is None:
            transparency = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Material.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Material'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ambientIntensity != 0.2:
            result += " ambientIntensity='" + self.ambientIntensity + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.diffuseColor != (0.8, 0.8, 0.8):
            result += " diffuseColor='" + self.diffuseColor + "'"
        if self.emissiveColor != (0, 0, 0):
            result += " emissiveColor='" + self.emissiveColor + "'"
        if self.shininess != 0.2:
            result += " shininess='" + self.shininess + "'"
        if self.specularColor != (0, 0, 0):
            result += " specularColor='" + self.specularColor + "'"
        if self.transparency != 0:
            result += " transparency='" + self.transparency + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Material>' + '\n'
#       print('XML serialization complete.')
        return result

class Matrix3VertexAttribute(_X3DVertexAttributeNode):
    """
    X3D element
    """
    NAME = 'Matrix3VertexAttribute'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Matrix3VertexAttribute'
    FIELD_DECLARATIONS = [('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('value', list(), FieldType.MFMatrix3f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 name='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Matrix3VertexAttribute __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        if  value is None:
            value = MFMatrix3f.DEFAULT_VALUE
        assertValidMFMatrix3f(value)
        self.__value = value
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Matrix3VertexAttribute.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Matrix3VertexAttribute'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.value != list():
            result += " value='" + self.value + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Matrix3VertexAttribute>' + '\n'
#       print('XML serialization complete.')
        return result

class Matrix4VertexAttribute(_X3DVertexAttributeNode):
    """
    X3D element
    """
    NAME = 'Matrix4VertexAttribute'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Matrix4VertexAttribute'
    FIELD_DECLARATIONS = [('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('value', list(), FieldType.MFMatrix4f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 name='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Matrix4VertexAttribute __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        if  value is None:
            value = MFMatrix4f.DEFAULT_VALUE
        assertValidMFMatrix4f(value)
        self.__value = value
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Matrix4VertexAttribute.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Matrix4VertexAttribute'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.value != list():
            result += " value='" + self.value + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Matrix4VertexAttribute>' + '\n'
#       print('XML serialization complete.')
        return result

class MetadataBoolean(_X3DMetadataObject):
    """
    The metadata provided by this node is contained in the Boolean values of the value field.
    """
    NAME = 'MetadataBoolean'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataBoolean'
    FIELD_DECLARATIONS = [('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('reference', '', FieldType.SFString, AccessType.inputOutput),
                          ('value', list(), FieldType.MFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 name='',
                 reference='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MetadataBoolean __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        return self.__reference
    @reference.setter
    def reference(self, reference=None):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        if  value is None:
            value = MFBool.DEFAULT_VALUE
        assertValidMFBool(value)
        self.__value = value
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function MetadataBoolean.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<MetadataBoolean'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.reference:
            result += " reference='" + self.reference + "'"
        if self.value != list():
            result += " value='" + self.value + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</MetadataBoolean>' + '\n'
#       print('XML serialization complete.')
        return result

class MetadataDouble(_X3DMetadataObject):
    """
    The metadata provided by this node is contained in the double-precision floating point numbers of the value field.
    """
    NAME = 'MetadataDouble'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataDouble'
    FIELD_DECLARATIONS = [('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('reference', '', FieldType.SFString, AccessType.inputOutput),
                          ('value', list(), FieldType.MFDouble, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 name='',
                 reference='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MetadataDouble __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        return self.__reference
    @reference.setter
    def reference(self, reference=None):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        if  value is None:
            value = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(value)
        self.__value = value
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function MetadataDouble.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<MetadataDouble'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.reference:
            result += " reference='" + self.reference + "'"
        if self.value != list():
            result += " value='" + self.value + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</MetadataDouble>' + '\n'
#       print('XML serialization complete.')
        return result

class MetadataFloat(_X3DMetadataObject):
    """
    The metadata provided by this node is contained in the single-precision floating point numbers of the value field.
    """
    NAME = 'MetadataFloat'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataFloat'
    FIELD_DECLARATIONS = [('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('reference', '', FieldType.SFString, AccessType.inputOutput),
                          ('value', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 name='',
                 reference='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MetadataFloat __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        return self.__reference
    @reference.setter
    def reference(self, reference=None):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        if  value is None:
            value = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(value)
        self.__value = value
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function MetadataFloat.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<MetadataFloat'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.reference:
            result += " reference='" + self.reference + "'"
        if self.value != list():
            result += " value='" + self.value + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</MetadataFloat>' + '\n'
#       print('XML serialization complete.')
        return result

class MetadataInteger(_X3DMetadataObject):
    """
    The metadata provided by this node is contained in the integer numbers of the value field.
    """
    NAME = 'MetadataInteger'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataInteger'
    FIELD_DECLARATIONS = [('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('reference', '', FieldType.SFString, AccessType.inputOutput),
                          ('value', list(), FieldType.MFInt32, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 name='',
                 reference='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MetadataInteger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        return self.__reference
    @reference.setter
    def reference(self, reference=None):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        if  value is None:
            value = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(value)
        self.__value = value
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function MetadataInteger.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<MetadataInteger'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.reference:
            result += " reference='" + self.reference + "'"
        if self.value != list():
            result += " value='" + self.value + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</MetadataInteger>' + '\n'
#       print('XML serialization complete.')
        return result

class MetadataSet(_X3DNode):
    """
    The metadata provided by this node is contained in the metadata nodes of the value field.
    """
    NAME = 'MetadataSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataSet'
    FIELD_DECLARATIONS = [('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('reference', '', FieldType.SFString, AccessType.inputOutput),
                          ('value', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 name='',
                 reference='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MetadataSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        return self.__reference
    @reference.setter
    def reference(self, reference=None):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        if  value is None:
            value = MFNode.DEFAULT_VALUE
        assertValidMFNode(value)
        self.__value = value
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function MetadataSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<MetadataSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.reference:
            result += " reference='" + self.reference + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.value: # walk each child node, if any
            result += indent
            for each in self.value:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</MetadataSet>' + '\n'
#       print('XML serialization complete.')
        return result

class MetadataString(_X3DMetadataObject):
    """
    The metadata provided by this node is contained in the strings of the value field.
    """
    NAME = 'MetadataString'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataString'
    FIELD_DECLARATIONS = [('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('reference', '', FieldType.SFString, AccessType.inputOutput),
                          ('value', list(), FieldType.MFString, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 name='',
                 reference='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MetadataString __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        return self.__reference
    @reference.setter
    def reference(self, reference=None):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value=None):
        if  value is None:
            value = MFString.DEFAULT_VALUE
        assertValidMFString(value)
        self.__value = value
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function MetadataString.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<MetadataString'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.reference:
            result += " reference='" + self.reference + "'"
        if self.value != list():
            result += " value='" + self.value + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</MetadataString>' + '\n'
#       print('XML serialization complete.')
        return result

class MotorJoint(_X3DRigidJointNode):
    """
    MotorJoint drives relative angular velocities between body1 and body2 within a common reference frame.
    """
    NAME = 'MotorJoint'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MotorJoint'
    FIELD_DECLARATIONS = [('autoCalc', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('axis1Angle', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('axis1Torque', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('axis2Angle', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('axis2Torque', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('axis3Angle', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('axis3Torque', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('enabledAxes', 1, FieldType.SFInt32, AccessType.inputOutput),
                          ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput),
                          ('motor1Axis', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('motor2Axis', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('motor3Axis', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('stop1Bounce', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('stop1ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput),
                          ('stop2Bounce', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('stop2ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput),
                          ('stop3Bounce', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('stop3ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput),
                          ('body1', None, FieldType.SFNode, AccessType.inputOutput),
                          ('body2', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 autoCalc=False,
                 axis1Angle=0,
                 axis1Torque=0,
                 axis2Angle=0,
                 axis2Torque=0,
                 axis3Angle=0,
                 axis3Torque=0,
                 enabledAxes=1,
                 forceOutput=["NONE"],
                 motor1Axis=(0, 0, 0),
                 motor2Axis=(0, 0, 0),
                 motor3Axis=(0, 0, 0),
                 stop1Bounce=0,
                 stop1ErrorCorrection=0.8,
                 stop2Bounce=0,
                 stop2ErrorCorrection=0.8,
                 stop3Bounce=0,
                 stop3ErrorCorrection=0.8,
                 body1=None,
                 body2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MotorJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.autoCalc = autoCalc
        self.axis1Angle = axis1Angle
        self.axis1Torque = axis1Torque
        self.axis2Angle = axis2Angle
        self.axis2Torque = axis2Torque
        self.axis3Angle = axis3Angle
        self.axis3Torque = axis3Torque
        self.enabledAxes = enabledAxes
        self.forceOutput = forceOutput
        self.motor1Axis = motor1Axis
        self.motor2Axis = motor2Axis
        self.motor3Axis = motor3Axis
        self.stop1Bounce = stop1Bounce
        self.stop1ErrorCorrection = stop1ErrorCorrection
        self.stop2Bounce = stop2Bounce
        self.stop2ErrorCorrection = stop2ErrorCorrection
        self.stop3Bounce = stop3Bounce
        self.stop3ErrorCorrection = stop3ErrorCorrection
        self.body1 = body1
        self.body2 = body2
    @property # getter - - - - - - - - - -
    def autoCalc(self):
        return self.__autoCalc
    @autoCalc.setter
    def autoCalc(self, autoCalc=None):
        if  autoCalc is None:
            autoCalc = SFBool.DEFAULT_VALUE
        assertValidSFBool(autoCalc)
        self.__autoCalc = autoCalc
    @property # getter - - - - - - - - - -
    def axis1Angle(self):
        return self.__axis1Angle
    @axis1Angle.setter
    def axis1Angle(self, axis1Angle=None):
        if  axis1Angle is None:
            axis1Angle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(axis1Angle)
        self.__axis1Angle = axis1Angle
    @property # getter - - - - - - - - - -
    def axis1Torque(self):
        return self.__axis1Torque
    @axis1Torque.setter
    def axis1Torque(self, axis1Torque=None):
        if  axis1Torque is None:
            axis1Torque = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(axis1Torque)
        self.__axis1Torque = axis1Torque
    @property # getter - - - - - - - - - -
    def axis2Angle(self):
        return self.__axis2Angle
    @axis2Angle.setter
    def axis2Angle(self, axis2Angle=None):
        if  axis2Angle is None:
            axis2Angle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(axis2Angle)
        self.__axis2Angle = axis2Angle
    @property # getter - - - - - - - - - -
    def axis2Torque(self):
        return self.__axis2Torque
    @axis2Torque.setter
    def axis2Torque(self, axis2Torque=None):
        if  axis2Torque is None:
            axis2Torque = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(axis2Torque)
        self.__axis2Torque = axis2Torque
    @property # getter - - - - - - - - - -
    def axis3Angle(self):
        return self.__axis3Angle
    @axis3Angle.setter
    def axis3Angle(self, axis3Angle=None):
        if  axis3Angle is None:
            axis3Angle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(axis3Angle)
        self.__axis3Angle = axis3Angle
    @property # getter - - - - - - - - - -
    def axis3Torque(self):
        return self.__axis3Torque
    @axis3Torque.setter
    def axis3Torque(self, axis3Torque=None):
        if  axis3Torque is None:
            axis3Torque = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(axis3Torque)
        self.__axis3Torque = axis3Torque
    @property # getter - - - - - - - - - -
    def enabledAxes(self):
        return self.__enabledAxes
    @enabledAxes.setter
    def enabledAxes(self, enabledAxes=None):
        if  enabledAxes is None:
            enabledAxes = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(enabledAxes)
        assertGreaterThanEquals('enabledAxes', enabledAxes, 0)
        assertLessThanEquals('enabledAxes', enabledAxes, 3)
        self.__enabledAxes = enabledAxes
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput=None):
        if  forceOutput is None:
            forceOutput = MFString.DEFAULT_VALUE
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def motor1Axis(self):
        return self.__motor1Axis
    @motor1Axis.setter
    def motor1Axis(self, motor1Axis=None):
        if  motor1Axis is None:
            motor1Axis = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(motor1Axis)
        self.__motor1Axis = motor1Axis
    @property # getter - - - - - - - - - -
    def motor2Axis(self):
        return self.__motor2Axis
    @motor2Axis.setter
    def motor2Axis(self, motor2Axis=None):
        if  motor2Axis is None:
            motor2Axis = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(motor2Axis)
        self.__motor2Axis = motor2Axis
    @property # getter - - - - - - - - - -
    def motor3Axis(self):
        return self.__motor3Axis
    @motor3Axis.setter
    def motor3Axis(self, motor3Axis=None):
        if  motor3Axis is None:
            motor3Axis = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(motor3Axis)
        self.__motor3Axis = motor3Axis
    @property # getter - - - - - - - - - -
    def stop1Bounce(self):
        return self.__stop1Bounce
    @stop1Bounce.setter
    def stop1Bounce(self, stop1Bounce=None):
        if  stop1Bounce is None:
            stop1Bounce = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stop1Bounce)
        self.__stop1Bounce = stop1Bounce
    @property # getter - - - - - - - - - -
    def stop1ErrorCorrection(self):
        return self.__stop1ErrorCorrection
    @stop1ErrorCorrection.setter
    def stop1ErrorCorrection(self, stop1ErrorCorrection=None):
        if  stop1ErrorCorrection is None:
            stop1ErrorCorrection = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stop1ErrorCorrection)
        self.__stop1ErrorCorrection = stop1ErrorCorrection
    @property # getter - - - - - - - - - -
    def stop2Bounce(self):
        return self.__stop2Bounce
    @stop2Bounce.setter
    def stop2Bounce(self, stop2Bounce=None):
        if  stop2Bounce is None:
            stop2Bounce = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stop2Bounce)
        self.__stop2Bounce = stop2Bounce
    @property # getter - - - - - - - - - -
    def stop2ErrorCorrection(self):
        return self.__stop2ErrorCorrection
    @stop2ErrorCorrection.setter
    def stop2ErrorCorrection(self, stop2ErrorCorrection=None):
        if  stop2ErrorCorrection is None:
            stop2ErrorCorrection = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stop2ErrorCorrection)
        self.__stop2ErrorCorrection = stop2ErrorCorrection
    @property # getter - - - - - - - - - -
    def stop3Bounce(self):
        return self.__stop3Bounce
    @stop3Bounce.setter
    def stop3Bounce(self, stop3Bounce=None):
        if  stop3Bounce is None:
            stop3Bounce = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stop3Bounce)
        self.__stop3Bounce = stop3Bounce
    @property # getter - - - - - - - - - -
    def stop3ErrorCorrection(self):
        return self.__stop3ErrorCorrection
    @stop3ErrorCorrection.setter
    def stop3ErrorCorrection(self, stop3ErrorCorrection=None):
        if  stop3ErrorCorrection is None:
            stop3ErrorCorrection = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stop3ErrorCorrection)
        self.__stop3ErrorCorrection = stop3ErrorCorrection
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1=None):
        if  body1 is None:
            body1 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            print(flush=True)
            raise TypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2=None):
        if  body2 is None:
            body2 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            print(flush=True)
            raise TypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function MotorJoint.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<MotorJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.autoCalc != False:
            result += " autoCalc='" + self.autoCalc + "'"
        if self.axis1Angle != 0:
            result += " axis1Angle='" + self.axis1Angle + "'"
        if self.axis1Torque != 0:
            result += " axis1Torque='" + self.axis1Torque + "'"
        if self.axis2Angle != 0:
            result += " axis2Angle='" + self.axis2Angle + "'"
        if self.axis2Torque != 0:
            result += " axis2Torque='" + self.axis2Torque + "'"
        if self.axis3Angle != 0:
            result += " axis3Angle='" + self.axis3Angle + "'"
        if self.axis3Torque != 0:
            result += " axis3Torque='" + self.axis3Torque + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabledAxes != 1:
            result += " enabledAxes='" + self.enabledAxes + "'"
        if self.forceOutput != ["NONE"]:
            result += " forceOutput='" + self.forceOutput + "'"
        if self.motor1Axis != (0, 0, 0):
            result += " motor1Axis='" + self.motor1Axis + "'"
        if self.motor2Axis != (0, 0, 0):
            result += " motor2Axis='" + self.motor2Axis + "'"
        if self.motor3Axis != (0, 0, 0):
            result += " motor3Axis='" + self.motor3Axis + "'"
        if self.stop1Bounce != 0:
            result += " stop1Bounce='" + self.stop1Bounce + "'"
        if self.stop1ErrorCorrection != 0.8:
            result += " stop1ErrorCorrection='" + self.stop1ErrorCorrection + "'"
        if self.stop2Bounce != 0:
            result += " stop2Bounce='" + self.stop2Bounce + "'"
        if self.stop2ErrorCorrection != 0.8:
            result += " stop2ErrorCorrection='" + self.stop2ErrorCorrection + "'"
        if self.stop3Bounce != 0:
            result += " stop3Bounce='" + self.stop3Bounce + "'"
        if self.stop3ErrorCorrection != 0.8:
            result += " stop3ErrorCorrection='" + self.stop3ErrorCorrection + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body1: # walk each child node, if any
            result += indent
            for each in self.body1:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body2: # walk each child node, if any
            result += indent
            for each in self.body2:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</MotorJoint>' + '\n'
#       print('XML serialization complete.')
        return result

class MovieTexture(_X3DSoundSourceNode):
    """
    X3D element
    """
    NAME = 'MovieTexture'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MovieTexture'
    FIELD_DECLARATIONS = [('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('loop', False, FieldType.SFBool, AccessType.inputOutput),
                          ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('pitch', 1.0, FieldType.SFFloat, AccessType.inputOutput),
                          ('repeatS', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('repeatT', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('speed', 1.0, FieldType.SFFloat, AccessType.inputOutput),
                          ('startTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 description='',
                 loop=False,
                 pauseTime=0,
                 pitch=1.0,
                 repeatS=True,
                 repeatT=True,
                 resumeTime=0,
                 speed=1.0,
                 startTime=0,
                 stopTime=0,
                 url=list(),
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MovieTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.loop = loop
        self.pauseTime = pauseTime
        self.pitch = pitch
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.resumeTime = resumeTime
        self.speed = speed
        self.startTime = startTime
        self.stopTime = stopTime
        self.url = url
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def loop(self):
        return self.__loop
    @loop.setter
    def loop(self, loop=None):
        if  loop is None:
            loop = SFBool.DEFAULT_VALUE
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime=None):
        if  pauseTime is None:
            pauseTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def pitch(self):
        return self.__pitch
    @pitch.setter
    def pitch(self, pitch=None):
        if  pitch is None:
            pitch = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(pitch)
        assertPositive('pitch', pitch)
        self.__pitch = pitch
    @property # getter - - - - - - - - - -
    def repeatS(self):
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS=None):
        if  repeatS is None:
            repeatS = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT=None):
        if  repeatT is None:
            repeatT = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime=None):
        if  resumeTime is None:
            resumeTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def speed(self):
        return self.__speed
    @speed.setter
    def speed(self, speed=None):
        if  speed is None:
            speed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def startTime(self):
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime=None):
        if  startTime is None:
            startTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime=None):
        if  stopTime is None:
            stopTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties=None):
        if  textureProperties is None:
            textureProperties = SFNode.DEFAULT_VALUE
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            print(flush=True)
            raise TypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function MovieTexture.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<MovieTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.loop != False:
            result += " loop='" + self.loop + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + self.pauseTime + "'"
        if self.pitch != 1.0:
            result += " pitch='" + self.pitch + "'"
        if self.repeatS != True:
            result += " repeatS='" + self.repeatS + "'"
        if self.repeatT != True:
            result += " repeatT='" + self.repeatT + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + self.resumeTime + "'"
        if self.speed != 1.0:
            result += " speed='" + self.speed + "'"
        if self.startTime != 0:
            result += " startTime='" + self.startTime + "'"
        if self.stopTime != 0:
            result += " stopTime='" + self.stopTime + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.textureProperties: # walk each child node, if any
            result += indent
            for each in self.textureProperties:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</MovieTexture>' + '\n'
#       print('XML serialization complete.')
        return result

class MultiTexture(_X3DTextureNode):
    """
    X3D element
    """
    NAME = 'MultiTexture'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MultiTexture'
    FIELD_DECLARATIONS = [('alpha', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput),
                          ('function', list(), FieldType.MFString, AccessType.inputOutput),
                          ('mode', list(), FieldType.MFString, AccessType.inputOutput),
                          ('source', list(), FieldType.MFString, AccessType.inputOutput),
                          ('texture', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 alpha=1,
                 color=(1, 1, 1),
                 function=list(),
                 mode=list(),
                 source=list(),
                 texture=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MultiTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.alpha = alpha
        self.color = color
        self.function = function
        self.mode = mode
        self.source = source
        self.texture = texture
    @property # getter - - - - - - - - - -
    def alpha(self):
        return self.__alpha
    @alpha.setter
    def alpha(self, alpha=None):
        if  alpha is None:
            alpha = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(alpha)
        assertZeroToOne('alpha', alpha)
        self.__alpha = alpha
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFColor.DEFAULT_VALUE
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def function(self):
        return self.__function
    @function.setter
    def function(self, function=None):
        if  function is None:
            function = MFString.DEFAULT_VALUE
        assertValidMFString(function)
        self.__function = function
    @property # getter - - - - - - - - - -
    def mode(self):
        return self.__mode
    @mode.setter
    def mode(self, mode=None):
        if  mode is None:
            mode = MFString.DEFAULT_VALUE
        assertValidMFString(mode)
        self.__mode = mode
    @property # getter - - - - - - - - - -
    def source(self):
        return self.__source
    @source.setter
    def source(self, source=None):
        if  source is None:
            source = MFString.DEFAULT_VALUE
        assertValidMFString(source)
        self.__source = source
    @property # getter - - - - - - - - - -
    def texture(self):
        return self.__texture
    @texture.setter
    def texture(self, texture=None):
        if  texture is None:
            texture = MFNode.DEFAULT_VALUE
        assertValidMFNode(texture)
        self.__texture = texture
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function MultiTexture.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<MultiTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.alpha != 1:
            result += " alpha='" + self.alpha + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + self.color + "'"
        if self.function != list():
            result += " function='" + self.function + "'"
        if self.mode != list():
            result += " mode='" + self.mode + "'"
        if self.source != list():
            result += " source='" + self.source + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texture: # walk each child node, if any
            result += indent
            for each in self.texture:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</MultiTexture>' + '\n'
#       print('XML serialization complete.')
        return result

class MultiTextureCoordinate(_X3DTextureCoordinateNode):
    """
    X3D element
    """
    NAME = 'MultiTextureCoordinate'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MultiTextureCoordinate'
    FIELD_DECLARATIONS = [('texCoord', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 texCoord=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MultiTextureCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.texCoord = texCoord
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = MFNode.DEFAULT_VALUE
        assertValidMFNode(texCoord)
        self.__texCoord = texCoord
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function MultiTextureCoordinate.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<MultiTextureCoordinate'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</MultiTextureCoordinate>' + '\n'
#       print('XML serialization complete.')
        return result

class MultiTextureTransform(_X3DTextureTransformNode):
    """
    X3D element
    """
    NAME = 'MultiTextureTransform'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MultiTextureTransform'
    FIELD_DECLARATIONS = [('textureTransform', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 textureTransform=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MultiTextureTransform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.textureTransform = textureTransform
    @property # getter - - - - - - - - - -
    def textureTransform(self):
        return self.__textureTransform
    @textureTransform.setter
    def textureTransform(self, textureTransform=None):
        if  textureTransform is None:
            textureTransform = MFNode.DEFAULT_VALUE
        assertValidMFNode(textureTransform)
        self.__textureTransform = textureTransform
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function MultiTextureTransform.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<MultiTextureTransform'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.textureTransform: # walk each child node, if any
            result += indent
            for each in self.textureTransform:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</MultiTextureTransform>' + '\n'
#       print('XML serialization complete.')
        return result

class NavigationInfo(_X3DBindableNode):
    """
    X3D element
    """
    NAME = 'NavigationInfo'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NavigationInfo'
    FIELD_DECLARATIONS = [('avatarSize', [0.25, 1.6, 0.75], FieldType.MFFloat, AccessType.inputOutput),
                          ('headlight', True, FieldType.SFBool, AccessType.inputOutput),
                          ('speed', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('transitionTime', 1.0, FieldType.SFTime, AccessType.inputOutput),
                          ('transitionType', ["LINEAR"], FieldType.MFString, AccessType.inputOutput),
                          ('type', ["EXAMINE", "ANY"], FieldType.MFString, AccessType.inputOutput),
                          ('visibilityLimit', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 avatarSize=[0.25, 1.6, 0.75],
                 headlight=True,
                 speed=1,
                 transitionTime=1.0,
                 transitionType=["LINEAR"],
                 type=["EXAMINE", "ANY"],
                 visibilityLimit=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NavigationInfo __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.avatarSize = avatarSize
        self.headlight = headlight
        self.speed = speed
        self.transitionTime = transitionTime
        self.transitionType = transitionType
        self.type = type
        self.visibilityLimit = visibilityLimit
    @property # getter - - - - - - - - - -
    def avatarSize(self):
        return self.__avatarSize
    @avatarSize.setter
    def avatarSize(self, avatarSize=None):
        if  avatarSize is None:
            avatarSize = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(avatarSize)
        assertNonNegative('avatarSize', avatarSize)
        self.__avatarSize = avatarSize
    @property # getter - - - - - - - - - -
    def headlight(self):
        return self.__headlight
    @headlight.setter
    def headlight(self, headlight=None):
        if  headlight is None:
            headlight = SFBool.DEFAULT_VALUE
        assertValidSFBool(headlight)
        self.__headlight = headlight
    @property # getter - - - - - - - - - -
    def speed(self):
        return self.__speed
    @speed.setter
    def speed(self, speed=None):
        if  speed is None:
            speed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def transitionTime(self):
        return self.__transitionTime
    @transitionTime.setter
    def transitionTime(self, transitionTime=None):
        if  transitionTime is None:
            transitionTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(transitionTime)
        assertNonNegative('transitionTime', transitionTime)
        self.__transitionTime = transitionTime
    @property # getter - - - - - - - - - -
    def transitionType(self):
        return self.__transitionType
    @transitionType.setter
    def transitionType(self, transitionType=None):
        if  transitionType is None:
            transitionType = MFString.DEFAULT_VALUE
        assertValidMFString(transitionType)
        self.__transitionType = transitionType
    @property # getter - - - - - - - - - -
    def type(self):
        return self.__type
    @type.setter
    def type(self, type=None):
        if  type is None:
            type = MFString.DEFAULT_VALUE
        assertValidMFString(type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def visibilityLimit(self):
        return self.__visibilityLimit
    @visibilityLimit.setter
    def visibilityLimit(self, visibilityLimit=None):
        if  visibilityLimit is None:
            visibilityLimit = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(visibilityLimit)
        assertNonNegative('visibilityLimit', visibilityLimit)
        self.__visibilityLimit = visibilityLimit
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function NavigationInfo.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<NavigationInfo'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.avatarSize != [0.25, 1.6, 0.75]:
            result += " avatarSize='" + self.avatarSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.headlight != True:
            result += " headlight='" + self.headlight + "'"
        if self.speed != 1:
            result += " speed='" + self.speed + "'"
        if self.transitionTime != 1.0:
            result += " transitionTime='" + self.transitionTime + "'"
        if self.transitionType != ["LINEAR"]:
            result += " transitionType='" + self.transitionType + "'"
        if self.type != ["EXAMINE", "ANY"]:
            result += " type='" + self.type + "'"
        if self.visibilityLimit != 0:
            result += " visibilityLimit='" + self.visibilityLimit + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</NavigationInfo>' + '\n'
#       print('XML serialization complete.')
        return result

class Normal(_X3DNormalNode):
    """
    X3D element
    """
    NAME = 'Normal'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Normal'
    FIELD_DECLARATIONS = [('vector', list(), FieldType.MFVec3f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 vector=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Normal __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.vector = vector
    @property # getter - - - - - - - - - -
    def vector(self):
        return self.__vector
    @vector.setter
    def vector(self, vector=None):
        if  vector is None:
            vector = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(vector)
        assertGreaterThanEquals('vector', vector, -1)
        assertLessThanEquals('vector', vector, 1)
        self.__vector = vector
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Normal.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Normal'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.vector != list():
            result += " vector='" + self.vector + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Normal>' + '\n'
#       print('XML serialization complete.')
        return result

class NormalInterpolator(_X3DInterpolatorNode):
    """
    X3D element
    """
    NAME = 'NormalInterpolator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NormalInterpolator'
    FIELD_DECLARATIONS = [('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFVec3f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NormalInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(keyValue)
        self.__keyValue = keyValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function NormalInterpolator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<NormalInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</NormalInterpolator>' + '\n'
#       print('XML serialization complete.')
        return result

class NurbsCurve(_X3DParametricGeometryNode):
    """
    X3D element
    """
    NAME = 'NurbsCurve'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsCurve'
    FIELD_DECLARATIONS = [('closed', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('knot', list(), FieldType.MFDouble, AccessType.initializeOnly),
                          ('order', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('tessellation', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('weight', list(), FieldType.MFDouble, AccessType.inputOutput),
                          ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 closed=False,
                 knot=list(),
                 order=3,
                 tessellation=0,
                 weight=list(),
                 controlPoint=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsCurve __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.knot = knot
        self.order = order
        self.tessellation = tessellation
        self.weight = weight
        self.controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def closed(self):
        return self.__closed
    @closed.setter
    def closed(self, closed=None):
        if  closed is None:
            closed = SFBool.DEFAULT_VALUE
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def knot(self):
        return self.__knot
    @knot.setter
    def knot(self, knot=None):
        if  knot is None:
            knot = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(knot)
        self.__knot = knot
    @property # getter - - - - - - - - - -
    def order(self):
        return self.__order
    @order.setter
    def order(self, order=None):
        if  order is None:
            order = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 2)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tessellation(self):
        return self.__tessellation
    @tessellation.setter
    def tessellation(self, tessellation=None):
        if  tessellation is None:
            tessellation = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(tessellation)
        self.__tessellation = tessellation
    @property # getter - - - - - - - - - -
    def weight(self):
        return self.__weight
    @weight.setter
    def weight(self, weight=None):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint=None):
        if  controlPoint is None:
            controlPoint = SFNode.DEFAULT_VALUE
        assertValidSFNode(controlPoint)
        if not isinstance(controlPoint, object):
            print(flush=True)
            raise TypeError(str(controlPoint) + ' does not have a valid node type object')
        self.__controlPoint = controlPoint
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function NurbsCurve.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<NurbsCurve'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.closed != False:
            result += " closed='" + self.closed + "'"
        if self.knot != list():
            result += " knot='" + self.knot + "'"
        if self.order != 3:
            result += " order='" + self.order + "'"
        if self.tessellation != 0:
            result += " tessellation='" + self.tessellation + "'"
        if self.weight != list():
            result += " weight='" + self.weight + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.controlPoint: # walk each child node, if any
            result += indent
            for each in self.controlPoint:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</NurbsCurve>' + '\n'
#       print('XML serialization complete.')
        return result

class NurbsCurve2D(_X3DNurbsControlCurveNode):
    """
    X3D element
    """
    NAME = 'NurbsCurve2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsCurve2D'
    FIELD_DECLARATIONS = [('closed', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('controlPoint', list(), FieldType.MFVec2d, AccessType.inputOutput),
                          ('knot', list(), FieldType.MFDouble, AccessType.initializeOnly),
                          ('order', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('tessellation', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('weight', list(), FieldType.MFDouble, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 closed=False,
                 controlPoint=list(),
                 knot=list(),
                 order=3,
                 tessellation=0,
                 weight=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsCurve2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.controlPoint = controlPoint
        self.knot = knot
        self.order = order
        self.tessellation = tessellation
        self.weight = weight
    @property # getter - - - - - - - - - -
    def closed(self):
        return self.__closed
    @closed.setter
    def closed(self, closed=None):
        if  closed is None:
            closed = SFBool.DEFAULT_VALUE
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint=None):
        if  controlPoint is None:
            controlPoint = MFVec2d.DEFAULT_VALUE
        assertValidMFVec2d(controlPoint)
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def knot(self):
        return self.__knot
    @knot.setter
    def knot(self, knot=None):
        if  knot is None:
            knot = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(knot)
        self.__knot = knot
    @property # getter - - - - - - - - - -
    def order(self):
        return self.__order
    @order.setter
    def order(self, order=None):
        if  order is None:
            order = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 2)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tessellation(self):
        return self.__tessellation
    @tessellation.setter
    def tessellation(self, tessellation=None):
        if  tessellation is None:
            tessellation = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(tessellation)
        self.__tessellation = tessellation
    @property # getter - - - - - - - - - -
    def weight(self):
        return self.__weight
    @weight.setter
    def weight(self, weight=None):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function NurbsCurve2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<NurbsCurve2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.closed != False:
            result += " closed='" + self.closed + "'"
        if self.controlPoint != list():
            result += " controlPoint='" + self.controlPoint + "'"
        if self.knot != list():
            result += " knot='" + self.knot + "'"
        if self.order != 3:
            result += " order='" + self.order + "'"
        if self.tessellation != 0:
            result += " tessellation='" + self.tessellation + "'"
        if self.weight != list():
            result += " weight='" + self.weight + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</NurbsCurve2D>' + '\n'
#       print('XML serialization complete.')
        return result

class NurbsOrientationInterpolator(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'NurbsOrientationInterpolator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsOrientationInterpolator'
    FIELD_DECLARATIONS = [('knot', list(), FieldType.MFDouble, AccessType.initializeOnly),
                          ('order', 3, FieldType.SFInt32, AccessType.inputOutput),
                          ('weight', list(), FieldType.MFDouble, AccessType.inputOutput),
                          ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 knot=list(),
                 order=3,
                 weight=list(),
                 controlPoint=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsOrientationInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.knot = knot
        self.order = order
        self.weight = weight
        self.controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def knot(self):
        return self.__knot
    @knot.setter
    def knot(self, knot=None):
        if  knot is None:
            knot = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(knot)
        self.__knot = knot
    @property # getter - - - - - - - - - -
    def order(self):
        return self.__order
    @order.setter
    def order(self, order=None):
        if  order is None:
            order = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 2)
        self.__order = order
    @property # getter - - - - - - - - - -
    def weight(self):
        return self.__weight
    @weight.setter
    def weight(self, weight=None):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint=None):
        if  controlPoint is None:
            controlPoint = SFNode.DEFAULT_VALUE
        assertValidSFNode(controlPoint)
        if not isinstance(controlPoint, object):
            print(flush=True)
            raise TypeError(str(controlPoint) + ' does not have a valid node type object')
        self.__controlPoint = controlPoint
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function NurbsOrientationInterpolator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<NurbsOrientationInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.knot != list():
            result += " knot='" + self.knot + "'"
        if self.order != 3:
            result += " order='" + self.order + "'"
        if self.weight != list():
            result += " weight='" + self.weight + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.controlPoint: # walk each child node, if any
            result += indent
            for each in self.controlPoint:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</NurbsOrientationInterpolator>' + '\n'
#       print('XML serialization complete.')
        return result

class NurbsPatchSurface(_X3DNurbsSurfaceGeometryNode):
    """
    X3D element
    """
    NAME = 'NurbsPatchSurface'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsPatchSurface'
    FIELD_DECLARATIONS = [('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('uClosed', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('uDimension', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('uKnot', list(), FieldType.MFDouble, AccessType.initializeOnly),
                          ('uOrder', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('uTessellation', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('vClosed', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('vDimension', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('vKnot', list(), FieldType.MFDouble, AccessType.initializeOnly),
                          ('vOrder', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('vTessellation', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('weight', list(), FieldType.MFDouble, AccessType.inputOutput),
                          ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 solid=True,
                 uClosed=False,
                 uDimension=0,
                 uKnot=list(),
                 uOrder=3,
                 uTessellation=0,
                 vClosed=False,
                 vDimension=0,
                 vKnot=list(),
                 vOrder=3,
                 vTessellation=0,
                 weight=list(),
                 controlPoint=None,
                 texCoord=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsPatchSurface __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.solid = solid
        self.uClosed = uClosed
        self.uDimension = uDimension
        self.uKnot = uKnot
        self.uOrder = uOrder
        self.uTessellation = uTessellation
        self.vClosed = vClosed
        self.vDimension = vDimension
        self.vKnot = vKnot
        self.vOrder = vOrder
        self.vTessellation = vTessellation
        self.weight = weight
        self.controlPoint = controlPoint
        self.texCoord = texCoord
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def uClosed(self):
        return self.__uClosed
    @uClosed.setter
    def uClosed(self, uClosed=None):
        if  uClosed is None:
            uClosed = SFBool.DEFAULT_VALUE
        assertValidSFBool(uClosed)
        self.__uClosed = uClosed
    @property # getter - - - - - - - - - -
    def uDimension(self):
        return self.__uDimension
    @uDimension.setter
    def uDimension(self, uDimension=None):
        if  uDimension is None:
            uDimension = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(uDimension)
        assertNonNegative('uDimension', uDimension)
        self.__uDimension = uDimension
    @property # getter - - - - - - - - - -
    def uKnot(self):
        return self.__uKnot
    @uKnot.setter
    def uKnot(self, uKnot=None):
        if  uKnot is None:
            uKnot = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(uKnot)
        self.__uKnot = uKnot
    @property # getter - - - - - - - - - -
    def uOrder(self):
        return self.__uOrder
    @uOrder.setter
    def uOrder(self, uOrder=None):
        if  uOrder is None:
            uOrder = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(uOrder)
        assertGreaterThanEquals('uOrder', uOrder, 2)
        self.__uOrder = uOrder
    @property # getter - - - - - - - - - -
    def uTessellation(self):
        return self.__uTessellation
    @uTessellation.setter
    def uTessellation(self, uTessellation=None):
        if  uTessellation is None:
            uTessellation = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(uTessellation)
        self.__uTessellation = uTessellation
    @property # getter - - - - - - - - - -
    def vClosed(self):
        return self.__vClosed
    @vClosed.setter
    def vClosed(self, vClosed=None):
        if  vClosed is None:
            vClosed = SFBool.DEFAULT_VALUE
        assertValidSFBool(vClosed)
        self.__vClosed = vClosed
    @property # getter - - - - - - - - - -
    def vDimension(self):
        return self.__vDimension
    @vDimension.setter
    def vDimension(self, vDimension=None):
        if  vDimension is None:
            vDimension = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(vDimension)
        assertNonNegative('vDimension', vDimension)
        self.__vDimension = vDimension
    @property # getter - - - - - - - - - -
    def vKnot(self):
        return self.__vKnot
    @vKnot.setter
    def vKnot(self, vKnot=None):
        if  vKnot is None:
            vKnot = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(vKnot)
        self.__vKnot = vKnot
    @property # getter - - - - - - - - - -
    def vOrder(self):
        return self.__vOrder
    @vOrder.setter
    def vOrder(self, vOrder=None):
        if  vOrder is None:
            vOrder = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(vOrder)
        assertGreaterThanEquals('vOrder', vOrder, 2)
        self.__vOrder = vOrder
    @property # getter - - - - - - - - - -
    def vTessellation(self):
        return self.__vTessellation
    @vTessellation.setter
    def vTessellation(self, vTessellation=None):
        if  vTessellation is None:
            vTessellation = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(vTessellation)
        self.__vTessellation = vTessellation
    @property # getter - - - - - - - - - -
    def weight(self):
        return self.__weight
    @weight.setter
    def weight(self, weight=None):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint=None):
        if  controlPoint is None:
            controlPoint = SFNode.DEFAULT_VALUE
        assertValidSFNode(controlPoint)
        if not isinstance(controlPoint, object):
            print(flush=True)
            raise TypeError(str(controlPoint) + ' does not have a valid node type object')
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            print(flush=True)
            raise TypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function NurbsPatchSurface.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<NurbsPatchSurface'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'"
        if self.uClosed != False:
            result += " uClosed='" + self.uClosed + "'"
        if self.uDimension != 0:
            result += " uDimension='" + self.uDimension + "'"
        if self.uKnot != list():
            result += " uKnot='" + self.uKnot + "'"
        if self.uOrder != 3:
            result += " uOrder='" + self.uOrder + "'"
        if self.uTessellation != 0:
            result += " uTessellation='" + self.uTessellation + "'"
        if self.vClosed != False:
            result += " vClosed='" + self.vClosed + "'"
        if self.vDimension != 0:
            result += " vDimension='" + self.vDimension + "'"
        if self.vKnot != list():
            result += " vKnot='" + self.vKnot + "'"
        if self.vOrder != 3:
            result += " vOrder='" + self.vOrder + "'"
        if self.vTessellation != 0:
            result += " vTessellation='" + self.vTessellation + "'"
        if self.weight != list():
            result += " weight='" + self.weight + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.controlPoint: # walk each child node, if any
            result += indent
            for each in self.controlPoint:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</NurbsPatchSurface>' + '\n'
#       print('XML serialization complete.')
        return result

class NurbsPositionInterpolator(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'NurbsPositionInterpolator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsPositionInterpolator'
    FIELD_DECLARATIONS = [('knot', list(), FieldType.MFDouble, AccessType.initializeOnly),
                          ('order', 3, FieldType.SFInt32, AccessType.inputOutput),
                          ('weight', list(), FieldType.MFDouble, AccessType.inputOutput),
                          ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 knot=list(),
                 order=3,
                 weight=list(),
                 controlPoint=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsPositionInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.knot = knot
        self.order = order
        self.weight = weight
        self.controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def knot(self):
        return self.__knot
    @knot.setter
    def knot(self, knot=None):
        if  knot is None:
            knot = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(knot)
        self.__knot = knot
    @property # getter - - - - - - - - - -
    def order(self):
        return self.__order
    @order.setter
    def order(self, order=None):
        if  order is None:
            order = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 2)
        self.__order = order
    @property # getter - - - - - - - - - -
    def weight(self):
        return self.__weight
    @weight.setter
    def weight(self, weight=None):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint=None):
        if  controlPoint is None:
            controlPoint = SFNode.DEFAULT_VALUE
        assertValidSFNode(controlPoint)
        if not isinstance(controlPoint, object):
            print(flush=True)
            raise TypeError(str(controlPoint) + ' does not have a valid node type object')
        self.__controlPoint = controlPoint
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function NurbsPositionInterpolator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<NurbsPositionInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.knot != list():
            result += " knot='" + self.knot + "'"
        if self.order != 3:
            result += " order='" + self.order + "'"
        if self.weight != list():
            result += " weight='" + self.weight + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.controlPoint: # walk each child node, if any
            result += indent
            for each in self.controlPoint:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</NurbsPositionInterpolator>' + '\n'
#       print('XML serialization complete.')
        return result

class NurbsSet(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'NurbsSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsSet'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('tessellationScale', 1.0, FieldType.SFFloat, AccessType.inputOutput),
                          ('geometry', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 tessellationScale=1.0,
                 geometry=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.tessellationScale = tessellationScale
        self.geometry = geometry
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def tessellationScale(self):
        return self.__tessellationScale
    @tessellationScale.setter
    def tessellationScale(self, tessellationScale=None):
        if  tessellationScale is None:
            tessellationScale = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(tessellationScale)
        assertPositive('tessellationScale', tessellationScale)
        self.__tessellationScale = tessellationScale
    @property # getter - - - - - - - - - -
    def geometry(self):
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry=None):
        if  geometry is None:
            geometry = MFNode.DEFAULT_VALUE
        assertValidMFNode(geometry)
        self.__geometry = geometry
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function NurbsSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<NurbsSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.tessellationScale != 1.0:
            result += " tessellationScale='" + self.tessellationScale + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geometry: # walk each child node, if any
            result += indent
            for each in self.geometry:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</NurbsSet>' + '\n'
#       print('XML serialization complete.')
        return result

class NurbsSurfaceInterpolator(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'NurbsSurfaceInterpolator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsSurfaceInterpolator'
    FIELD_DECLARATIONS = [('uDimension', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('uKnot', list(), FieldType.MFDouble, AccessType.initializeOnly),
                          ('uOrder', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('vDimension', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('vKnot', list(), FieldType.MFDouble, AccessType.initializeOnly),
                          ('vOrder', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('weight', list(), FieldType.MFDouble, AccessType.inputOutput),
                          ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 uDimension=0,
                 uKnot=list(),
                 uOrder=3,
                 vDimension=0,
                 vKnot=list(),
                 vOrder=3,
                 weight=list(),
                 controlPoint=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsSurfaceInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.uDimension = uDimension
        self.uKnot = uKnot
        self.uOrder = uOrder
        self.vDimension = vDimension
        self.vKnot = vKnot
        self.vOrder = vOrder
        self.weight = weight
        self.controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def uDimension(self):
        return self.__uDimension
    @uDimension.setter
    def uDimension(self, uDimension=None):
        if  uDimension is None:
            uDimension = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(uDimension)
        assertNonNegative('uDimension', uDimension)
        self.__uDimension = uDimension
    @property # getter - - - - - - - - - -
    def uKnot(self):
        return self.__uKnot
    @uKnot.setter
    def uKnot(self, uKnot=None):
        if  uKnot is None:
            uKnot = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(uKnot)
        self.__uKnot = uKnot
    @property # getter - - - - - - - - - -
    def uOrder(self):
        return self.__uOrder
    @uOrder.setter
    def uOrder(self, uOrder=None):
        if  uOrder is None:
            uOrder = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(uOrder)
        assertGreaterThanEquals('uOrder', uOrder, 2)
        self.__uOrder = uOrder
    @property # getter - - - - - - - - - -
    def vDimension(self):
        return self.__vDimension
    @vDimension.setter
    def vDimension(self, vDimension=None):
        if  vDimension is None:
            vDimension = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(vDimension)
        assertNonNegative('vDimension', vDimension)
        self.__vDimension = vDimension
    @property # getter - - - - - - - - - -
    def vKnot(self):
        return self.__vKnot
    @vKnot.setter
    def vKnot(self, vKnot=None):
        if  vKnot is None:
            vKnot = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(vKnot)
        self.__vKnot = vKnot
    @property # getter - - - - - - - - - -
    def vOrder(self):
        return self.__vOrder
    @vOrder.setter
    def vOrder(self, vOrder=None):
        if  vOrder is None:
            vOrder = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(vOrder)
        assertGreaterThanEquals('vOrder', vOrder, 2)
        self.__vOrder = vOrder
    @property # getter - - - - - - - - - -
    def weight(self):
        return self.__weight
    @weight.setter
    def weight(self, weight=None):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint=None):
        if  controlPoint is None:
            controlPoint = SFNode.DEFAULT_VALUE
        assertValidSFNode(controlPoint)
        if not isinstance(controlPoint, object):
            print(flush=True)
            raise TypeError(str(controlPoint) + ' does not have a valid node type object')
        self.__controlPoint = controlPoint
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function NurbsSurfaceInterpolator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<NurbsSurfaceInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.uDimension != 0:
            result += " uDimension='" + self.uDimension + "'"
        if self.uKnot != list():
            result += " uKnot='" + self.uKnot + "'"
        if self.uOrder != 3:
            result += " uOrder='" + self.uOrder + "'"
        if self.vDimension != 0:
            result += " vDimension='" + self.vDimension + "'"
        if self.vKnot != list():
            result += " vKnot='" + self.vKnot + "'"
        if self.vOrder != 3:
            result += " vOrder='" + self.vOrder + "'"
        if self.weight != list():
            result += " weight='" + self.weight + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.controlPoint: # walk each child node, if any
            result += indent
            for each in self.controlPoint:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</NurbsSurfaceInterpolator>' + '\n'
#       print('XML serialization complete.')
        return result

class NurbsSweptSurface(_X3DParametricGeometryNode):
    """
    X3D element
    """
    NAME = 'NurbsSweptSurface'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsSweptSurface'
    FIELD_DECLARATIONS = [('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('crossSectionCurve', None, FieldType.SFNode, AccessType.inputOutput),
                          ('trajectoryCurve', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ccw=True,
                 solid=True,
                 crossSectionCurve=None,
                 trajectoryCurve=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsSweptSurface __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.solid = solid
        self.crossSectionCurve = crossSectionCurve
        self.trajectoryCurve = trajectoryCurve
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def crossSectionCurve(self):
        return self.__crossSectionCurve
    @crossSectionCurve.setter
    def crossSectionCurve(self, crossSectionCurve=None):
        if  crossSectionCurve is None:
            crossSectionCurve = SFNode.DEFAULT_VALUE
        assertValidSFNode(crossSectionCurve)
        if not isinstance(crossSectionCurve, object):
            print(flush=True)
            raise TypeError(str(crossSectionCurve) + ' does not have a valid node type object')
        self.__crossSectionCurve = crossSectionCurve
    @property # getter - - - - - - - - - -
    def trajectoryCurve(self):
        return self.__trajectoryCurve
    @trajectoryCurve.setter
    def trajectoryCurve(self, trajectoryCurve=None):
        if  trajectoryCurve is None:
            trajectoryCurve = SFNode.DEFAULT_VALUE
        assertValidSFNode(trajectoryCurve)
        if not isinstance(trajectoryCurve, object):
            print(flush=True)
            raise TypeError(str(trajectoryCurve) + ' does not have a valid node type object')
        self.__trajectoryCurve = trajectoryCurve
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function NurbsSweptSurface.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<NurbsSweptSurface'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.crossSectionCurve: # walk each child node, if any
            result += indent
            for each in self.crossSectionCurve:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.trajectoryCurve: # walk each child node, if any
            result += indent
            for each in self.trajectoryCurve:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</NurbsSweptSurface>' + '\n'
#       print('XML serialization complete.')
        return result

class NurbsSwungSurface(_X3DParametricGeometryNode):
    """
    X3D element
    """
    NAME = 'NurbsSwungSurface'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsSwungSurface'
    FIELD_DECLARATIONS = [('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('profileCurve', None, FieldType.SFNode, AccessType.inputOutput),
                          ('trajectoryCurve', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ccw=True,
                 solid=True,
                 profileCurve=None,
                 trajectoryCurve=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsSwungSurface __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.solid = solid
        self.profileCurve = profileCurve
        self.trajectoryCurve = trajectoryCurve
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def profileCurve(self):
        return self.__profileCurve
    @profileCurve.setter
    def profileCurve(self, profileCurve=None):
        if  profileCurve is None:
            profileCurve = SFNode.DEFAULT_VALUE
        assertValidSFNode(profileCurve)
        if not isinstance(profileCurve, object):
            print(flush=True)
            raise TypeError(str(profileCurve) + ' does not have a valid node type object')
        self.__profileCurve = profileCurve
    @property # getter - - - - - - - - - -
    def trajectoryCurve(self):
        return self.__trajectoryCurve
    @trajectoryCurve.setter
    def trajectoryCurve(self, trajectoryCurve=None):
        if  trajectoryCurve is None:
            trajectoryCurve = SFNode.DEFAULT_VALUE
        assertValidSFNode(trajectoryCurve)
        if not isinstance(trajectoryCurve, object):
            print(flush=True)
            raise TypeError(str(trajectoryCurve) + ' does not have a valid node type object')
        self.__trajectoryCurve = trajectoryCurve
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function NurbsSwungSurface.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<NurbsSwungSurface'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.profileCurve: # walk each child node, if any
            result += indent
            for each in self.profileCurve:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.trajectoryCurve: # walk each child node, if any
            result += indent
            for each in self.trajectoryCurve:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</NurbsSwungSurface>' + '\n'
#       print('XML serialization complete.')
        return result

class NurbsTextureCoordinate(_X3DNode):
    """
    X3D element
    """
    NAME = 'NurbsTextureCoordinate'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsTextureCoordinate'
    FIELD_DECLARATIONS = [('controlPoint', list(), FieldType.MFVec2f, AccessType.inputOutput),
                          ('uDimension', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('uKnot', list(), FieldType.MFDouble, AccessType.initializeOnly),
                          ('uOrder', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('vDimension', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('vKnot', list(), FieldType.MFDouble, AccessType.initializeOnly),
                          ('vOrder', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('weight', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 controlPoint=list(),
                 uDimension=0,
                 uKnot=list(),
                 uOrder=3,
                 vDimension=0,
                 vKnot=list(),
                 vOrder=3,
                 weight=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsTextureCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.controlPoint = controlPoint
        self.uDimension = uDimension
        self.uKnot = uKnot
        self.uOrder = uOrder
        self.vDimension = vDimension
        self.vKnot = vKnot
        self.vOrder = vOrder
        self.weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint=None):
        if  controlPoint is None:
            controlPoint = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(controlPoint)
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def uDimension(self):
        return self.__uDimension
    @uDimension.setter
    def uDimension(self, uDimension=None):
        if  uDimension is None:
            uDimension = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(uDimension)
        assertNonNegative('uDimension', uDimension)
        self.__uDimension = uDimension
    @property # getter - - - - - - - - - -
    def uKnot(self):
        return self.__uKnot
    @uKnot.setter
    def uKnot(self, uKnot=None):
        if  uKnot is None:
            uKnot = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(uKnot)
        self.__uKnot = uKnot
    @property # getter - - - - - - - - - -
    def uOrder(self):
        return self.__uOrder
    @uOrder.setter
    def uOrder(self, uOrder=None):
        if  uOrder is None:
            uOrder = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(uOrder)
        assertGreaterThanEquals('uOrder', uOrder, 2)
        self.__uOrder = uOrder
    @property # getter - - - - - - - - - -
    def vDimension(self):
        return self.__vDimension
    @vDimension.setter
    def vDimension(self, vDimension=None):
        if  vDimension is None:
            vDimension = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(vDimension)
        assertNonNegative('vDimension', vDimension)
        self.__vDimension = vDimension
    @property # getter - - - - - - - - - -
    def vKnot(self):
        return self.__vKnot
    @vKnot.setter
    def vKnot(self, vKnot=None):
        if  vKnot is None:
            vKnot = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(vKnot)
        self.__vKnot = vKnot
    @property # getter - - - - - - - - - -
    def vOrder(self):
        return self.__vOrder
    @vOrder.setter
    def vOrder(self, vOrder=None):
        if  vOrder is None:
            vOrder = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(vOrder)
        assertGreaterThanEquals('vOrder', vOrder, 2)
        self.__vOrder = vOrder
    @property # getter - - - - - - - - - -
    def weight(self):
        return self.__weight
    @weight.setter
    def weight(self, weight=None):
        if  weight is None:
            weight = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function NurbsTextureCoordinate.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<NurbsTextureCoordinate'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.controlPoint != list():
            result += " controlPoint='" + self.controlPoint + "'"
        if self.uDimension != 0:
            result += " uDimension='" + self.uDimension + "'"
        if self.uKnot != list():
            result += " uKnot='" + self.uKnot + "'"
        if self.uOrder != 3:
            result += " uOrder='" + self.uOrder + "'"
        if self.vDimension != 0:
            result += " vDimension='" + self.vDimension + "'"
        if self.vKnot != list():
            result += " vKnot='" + self.vKnot + "'"
        if self.vOrder != 3:
            result += " vOrder='" + self.vOrder + "'"
        if self.weight != list():
            result += " weight='" + self.weight + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</NurbsTextureCoordinate>' + '\n'
#       print('XML serialization complete.')
        return result

class NurbsTrimmedSurface(_X3DNurbsSurfaceGeometryNode):
    """
    X3D element
    """
    NAME = 'NurbsTrimmedSurface'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsTrimmedSurface'
    FIELD_DECLARATIONS = [('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('uClosed', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('uDimension', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('uKnot', list(), FieldType.MFDouble, AccessType.initializeOnly),
                          ('uOrder', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('uTessellation', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('vClosed', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('vDimension', 0, FieldType.SFInt32, AccessType.initializeOnly),
                          ('vKnot', list(), FieldType.MFDouble, AccessType.initializeOnly),
                          ('vOrder', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('vTessellation', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('weight', list(), FieldType.MFDouble, AccessType.inputOutput),
                          ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('trimmingContour', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 solid=True,
                 uClosed=False,
                 uDimension=0,
                 uKnot=list(),
                 uOrder=3,
                 uTessellation=0,
                 vClosed=False,
                 vDimension=0,
                 vKnot=list(),
                 vOrder=3,
                 vTessellation=0,
                 weight=list(),
                 controlPoint=None,
                 texCoord=None,
                 trimmingContour=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsTrimmedSurface __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.solid = solid
        self.uClosed = uClosed
        self.uDimension = uDimension
        self.uKnot = uKnot
        self.uOrder = uOrder
        self.uTessellation = uTessellation
        self.vClosed = vClosed
        self.vDimension = vDimension
        self.vKnot = vKnot
        self.vOrder = vOrder
        self.vTessellation = vTessellation
        self.weight = weight
        self.controlPoint = controlPoint
        self.texCoord = texCoord
        self.trimmingContour = trimmingContour
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def uClosed(self):
        return self.__uClosed
    @uClosed.setter
    def uClosed(self, uClosed=None):
        if  uClosed is None:
            uClosed = SFBool.DEFAULT_VALUE
        assertValidSFBool(uClosed)
        self.__uClosed = uClosed
    @property # getter - - - - - - - - - -
    def uDimension(self):
        return self.__uDimension
    @uDimension.setter
    def uDimension(self, uDimension=None):
        if  uDimension is None:
            uDimension = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(uDimension)
        assertNonNegative('uDimension', uDimension)
        self.__uDimension = uDimension
    @property # getter - - - - - - - - - -
    def uKnot(self):
        return self.__uKnot
    @uKnot.setter
    def uKnot(self, uKnot=None):
        if  uKnot is None:
            uKnot = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(uKnot)
        self.__uKnot = uKnot
    @property # getter - - - - - - - - - -
    def uOrder(self):
        return self.__uOrder
    @uOrder.setter
    def uOrder(self, uOrder=None):
        if  uOrder is None:
            uOrder = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(uOrder)
        assertGreaterThanEquals('uOrder', uOrder, 2)
        self.__uOrder = uOrder
    @property # getter - - - - - - - - - -
    def uTessellation(self):
        return self.__uTessellation
    @uTessellation.setter
    def uTessellation(self, uTessellation=None):
        if  uTessellation is None:
            uTessellation = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(uTessellation)
        self.__uTessellation = uTessellation
    @property # getter - - - - - - - - - -
    def vClosed(self):
        return self.__vClosed
    @vClosed.setter
    def vClosed(self, vClosed=None):
        if  vClosed is None:
            vClosed = SFBool.DEFAULT_VALUE
        assertValidSFBool(vClosed)
        self.__vClosed = vClosed
    @property # getter - - - - - - - - - -
    def vDimension(self):
        return self.__vDimension
    @vDimension.setter
    def vDimension(self, vDimension=None):
        if  vDimension is None:
            vDimension = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(vDimension)
        assertNonNegative('vDimension', vDimension)
        self.__vDimension = vDimension
    @property # getter - - - - - - - - - -
    def vKnot(self):
        return self.__vKnot
    @vKnot.setter
    def vKnot(self, vKnot=None):
        if  vKnot is None:
            vKnot = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(vKnot)
        self.__vKnot = vKnot
    @property # getter - - - - - - - - - -
    def vOrder(self):
        return self.__vOrder
    @vOrder.setter
    def vOrder(self, vOrder=None):
        if  vOrder is None:
            vOrder = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(vOrder)
        assertGreaterThanEquals('vOrder', vOrder, 2)
        self.__vOrder = vOrder
    @property # getter - - - - - - - - - -
    def vTessellation(self):
        return self.__vTessellation
    @vTessellation.setter
    def vTessellation(self, vTessellation=None):
        if  vTessellation is None:
            vTessellation = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(vTessellation)
        self.__vTessellation = vTessellation
    @property # getter - - - - - - - - - -
    def weight(self):
        return self.__weight
    @weight.setter
    def weight(self, weight=None):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE
        assertValidMFDouble(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint=None):
        if  controlPoint is None:
            controlPoint = SFNode.DEFAULT_VALUE
        assertValidSFNode(controlPoint)
        if not isinstance(controlPoint, object):
            print(flush=True)
            raise TypeError(str(controlPoint) + ' does not have a valid node type object')
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            print(flush=True)
            raise TypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def trimmingContour(self):
        return self.__trimmingContour
    @trimmingContour.setter
    def trimmingContour(self, trimmingContour=None):
        if  trimmingContour is None:
            trimmingContour = MFNode.DEFAULT_VALUE
        assertValidMFNode(trimmingContour)
        self.__trimmingContour = trimmingContour
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function NurbsTrimmedSurface.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<NurbsTrimmedSurface'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'"
        if self.uClosed != False:
            result += " uClosed='" + self.uClosed + "'"
        if self.uDimension != 0:
            result += " uDimension='" + self.uDimension + "'"
        if self.uKnot != list():
            result += " uKnot='" + self.uKnot + "'"
        if self.uOrder != 3:
            result += " uOrder='" + self.uOrder + "'"
        if self.uTessellation != 0:
            result += " uTessellation='" + self.uTessellation + "'"
        if self.vClosed != False:
            result += " vClosed='" + self.vClosed + "'"
        if self.vDimension != 0:
            result += " vDimension='" + self.vDimension + "'"
        if self.vKnot != list():
            result += " vKnot='" + self.vKnot + "'"
        if self.vOrder != 3:
            result += " vOrder='" + self.vOrder + "'"
        if self.vTessellation != 0:
            result += " vTessellation='" + self.vTessellation + "'"
        if self.weight != list():
            result += " weight='" + self.weight + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.controlPoint: # walk each child node, if any
            result += indent
            for each in self.controlPoint:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.trimmingContour: # walk each child node, if any
            result += indent
            for each in self.trimmingContour:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</NurbsTrimmedSurface>' + '\n'
#       print('XML serialization complete.')
        return result

class OpacityMapVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    X3D element
    """
    NAME = 'OpacityMapVolumeStyle'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OpacityMapVolumeStyle'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('transferFunction', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 transferFunction=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode OpacityMapVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.transferFunction = transferFunction
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def transferFunction(self):
        return self.__transferFunction
    @transferFunction.setter
    def transferFunction(self, transferFunction=None):
        if  transferFunction is None:
            transferFunction = SFNode.DEFAULT_VALUE
        assertValidSFNode(transferFunction)
        if not isinstance(transferFunction, object):
            print(flush=True)
            raise TypeError(str(transferFunction) + ' does not have a valid node type object')
        self.__transferFunction = transferFunction
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function OpacityMapVolumeStyle.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<OpacityMapVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.transferFunction: # walk each child node, if any
            result += indent
            for each in self.transferFunction:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</OpacityMapVolumeStyle>' + '\n'
#       print('XML serialization complete.')
        return result

class OrientationChaser(_X3DChaserNode):
    """
    X3D element
    """
    NAME = 'OrientationChaser'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OrientationChaser'
    FIELD_DECLARATIONS = [('duration', 1, FieldType.SFTime, AccessType.initializeOnly),
                          ('initialDestination', (0, 1, 0, 0), FieldType.SFRotation, AccessType.initializeOnly),
                          ('initialValue', (0, 1, 0, 0), FieldType.SFRotation, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 duration=1,
                 initialDestination=(0, 1, 0, 0),
                 initialValue=(0, 1, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode OrientationChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        return self.__duration
    @duration.setter
    def duration(self, duration=None):
        if  duration is None:
            duration = SFTime.DEFAULT_VALUE
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(initialValue)
        self.__initialValue = initialValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function OrientationChaser.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<OrientationChaser'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + self.duration + "'"
        if self.initialDestination != (0, 1, 0, 0):
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != (0, 1, 0, 0):
            result += " initialValue='" + self.initialValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</OrientationChaser>' + '\n'
#       print('XML serialization complete.')
        return result

class OrientationDamper(_X3DDamperNode):
    """
    X3D element
    """
    NAME = 'OrientationDamper'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OrientationDamper'
    FIELD_DECLARATIONS = [('initialDestination', (0, 1, 0, 0), FieldType.SFRotation, AccessType.initializeOnly),
                          ('initialValue', (0, 1, 0, 0), FieldType.SFRotation, AccessType.initializeOnly),
                          ('order', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput),
                          ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 initialDestination=(0, 1, 0, 0),
                 initialValue=(0, 1, 0, 0),
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode OrientationDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        return self.__order
    @order.setter
    def order(self, order=None):
        if  order is None:
            order = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        return self.__tau
    @tau.setter
    def tau(self, tau=None):
        if  tau is None:
            tau = SFTime.DEFAULT_VALUE
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance=None):
        if  tolerance is None:
            tolerance = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function OrientationDamper.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<OrientationDamper'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != (0, 1, 0, 0):
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != (0, 1, 0, 0):
            result += " initialValue='" + self.initialValue + "'"
        if self.order != 3:
            result += " order='" + self.order + "'"
        if self.tau != 0.3:
            result += " tau='" + self.tau + "'"
        if self.tolerance != -1:
            result += " tolerance='" + self.tolerance + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</OrientationDamper>' + '\n'
#       print('XML serialization complete.')
        return result

class OrientationInterpolator(_X3DInterpolatorNode):
    """
    X3D element
    """
    NAME = 'OrientationInterpolator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OrientationInterpolator'
    FIELD_DECLARATIONS = [('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFRotation, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode OrientationInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFRotation.DEFAULT_VALUE
        assertValidMFRotation(keyValue)
        self.__keyValue = keyValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function OrientationInterpolator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<OrientationInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</OrientationInterpolator>' + '\n'
#       print('XML serialization complete.')
        return result

class OrthoViewpoint(_X3DViewpointNode):
    """
    X3D element
    """
    NAME = 'OrthoViewpoint'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OrthoViewpoint'
    FIELD_DECLARATIONS = [('centerOfRotation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('fieldOfView', [-1, -1, 1, 1], FieldType.MFFloat, AccessType.inputOutput),
                          ('jump', True, FieldType.SFBool, AccessType.inputOutput),
                          ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('position', (0, 0, 10), FieldType.SFVec3f, AccessType.inputOutput),
                          ('retainUserOffsets', False, FieldType.SFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 centerOfRotation=(0, 0, 0),
                 description='',
                 fieldOfView=[-1, -1, 1, 1],
                 jump=True,
                 orientation=(0, 0, 1, 0),
                 position=(0, 0, 10),
                 retainUserOffsets=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode OrthoViewpoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.centerOfRotation = centerOfRotation
        self.description = description
        self.fieldOfView = fieldOfView
        self.jump = jump
        self.orientation = orientation
        self.position = position
        self.retainUserOffsets = retainUserOffsets
    @property # getter - - - - - - - - - -
    def centerOfRotation(self):
        return self.__centerOfRotation
    @centerOfRotation.setter
    def centerOfRotation(self, centerOfRotation=None):
        if  centerOfRotation is None:
            centerOfRotation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(centerOfRotation)
        self.__centerOfRotation = centerOfRotation
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def fieldOfView(self):
        return self.__fieldOfView
    @fieldOfView.setter
    def fieldOfView(self, fieldOfView=None):
        if  fieldOfView is None:
            fieldOfView = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(fieldOfView)
        self.__fieldOfView = fieldOfView
    @property # getter - - - - - - - - - -
    def jump(self):
        return self.__jump
    @jump.setter
    def jump(self, jump=None):
        if  jump is None:
            jump = SFBool.DEFAULT_VALUE
        assertValidSFBool(jump)
        self.__jump = jump
    @property # getter - - - - - - - - - -
    def orientation(self):
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation=None):
        if  orientation is None:
            orientation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def position(self):
        return self.__position
    @position.setter
    def position(self, position=None):
        if  position is None:
            position = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def retainUserOffsets(self):
        return self.__retainUserOffsets
    @retainUserOffsets.setter
    def retainUserOffsets(self, retainUserOffsets=None):
        if  retainUserOffsets is None:
            retainUserOffsets = SFBool.DEFAULT_VALUE
        assertValidSFBool(retainUserOffsets)
        self.__retainUserOffsets = retainUserOffsets
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function OrthoViewpoint.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<OrthoViewpoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.centerOfRotation != (0, 0, 0):
            result += " centerOfRotation='" + self.centerOfRotation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.fieldOfView != [-1, -1, 1, 1]:
            result += " fieldOfView='" + self.fieldOfView + "'"
        if self.jump != True:
            result += " jump='" + self.jump + "'"
        if self.orientation != (0, 0, 1, 0):
            result += " orientation='" + self.orientation + "'"
        if self.position != (0, 0, 10):
            result += " position='" + self.position + "'"
        if self.retainUserOffsets != False:
            result += " retainUserOffsets='" + self.retainUserOffsets + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</OrthoViewpoint>' + '\n'
#       print('XML serialization complete.')
        return result

class PackagedShader(_X3DShaderNode):
    """
    PackagedShader can contain field declarations, but no CDATA section of plain-text source code.
    """
    NAME = 'PackagedShader'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PackagedShader'
    FIELD_DECLARATIONS = [('language', '', FieldType.SFString, AccessType.initializeOnly),
                          ('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('field', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 language='',
                 url=list(),
                 field=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PackagedShader __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.language = language
        self.url = url
        self.field = field
    @property # getter - - - - - - - - - -
    def language(self):
        return self.__language
    @language.setter
    def language(self, language=None):
        if  language is None:
            language = SFString.DEFAULT_VALUE
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def field(self):
        return self.__field
    @field.setter
    def field(self, field=None):
        if  field is None:
            field = MFNode.DEFAULT_VALUE
        assertValidMFNode(field)
        self.__field = field
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PackagedShader.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PackagedShader'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.language:
            result += " language='" + self.language + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.field: # walk each child node, if any
            result += indent
            for each in self.field:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PackagedShader>' + '\n'
#       print('XML serialization complete.')
        return result

class ParticleSystem(_X3DShapeNode):
    """
    X3D element
    """
    NAME = 'ParticleSystem'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ParticleSystem'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('colorKey', list(), FieldType.MFFloat, AccessType.initializeOnly),
                          ('createParticles', True, FieldType.SFBool, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('geometryType', 'QUAD', FieldType.SFString, AccessType.initializeOnly),
                          ('lifetimeVariation', 0.25, FieldType.SFFloat, AccessType.inputOutput),
                          ('maxParticles', 200, FieldType.SFInt32, AccessType.inputOutput),
                          ('particleLifetime', 5, FieldType.SFFloat, AccessType.inputOutput),
                          ('particleSize', (0.02, 0.02), FieldType.SFVec2f, AccessType.inputOutput),
                          ('texCoordKey', list(), FieldType.MFFloat, AccessType.initializeOnly),
                          ('appearance', None, FieldType.SFNode, AccessType.inputOutput),
                          ('colorRamp', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('emitter', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('geometry', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoordRamp', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('physics', list(), FieldType.MFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 colorKey=list(),
                 createParticles=True,
                 enabled=True,
                 geometryType='QUAD',
                 lifetimeVariation=0.25,
                 maxParticles=200,
                 particleLifetime=5,
                 particleSize=(0.02, 0.02),
                 texCoordKey=list(),
                 appearance=None,
                 colorRamp=None,
                 emitter=None,
                 geometry=None,
                 texCoordRamp=None,
                 physics=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ParticleSystem __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.colorKey = colorKey
        self.createParticles = createParticles
        self.enabled = enabled
        self.geometryType = geometryType
        self.lifetimeVariation = lifetimeVariation
        self.maxParticles = maxParticles
        self.particleLifetime = particleLifetime
        self.particleSize = particleSize
        self.texCoordKey = texCoordKey
        self.appearance = appearance
        self.colorRamp = colorRamp
        self.emitter = emitter
        self.geometry = geometry
        self.geometry = geometry
        self.texCoordRamp = texCoordRamp
        self.physics = physics
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def colorKey(self):
        return self.__colorKey
    @colorKey.setter
    def colorKey(self, colorKey=None):
        if  colorKey is None:
            colorKey = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(colorKey)
        assertNonNegative('colorKey', colorKey)
        self.__colorKey = colorKey
    @property # getter - - - - - - - - - -
    def createParticles(self):
        return self.__createParticles
    @createParticles.setter
    def createParticles(self, createParticles=None):
        if  createParticles is None:
            createParticles = SFBool.DEFAULT_VALUE
        assertValidSFBool(createParticles)
        self.__createParticles = createParticles
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def geometryType(self):
        return self.__geometryType
    @geometryType.setter
    def geometryType(self, geometryType=None):
        if  geometryType is None:
            geometryType = SFString.DEFAULT_VALUE
        assertValidSFString(geometryType)
        self.__geometryType = geometryType
    @property # getter - - - - - - - - - -
    def lifetimeVariation(self):
        return self.__lifetimeVariation
    @lifetimeVariation.setter
    def lifetimeVariation(self, lifetimeVariation=None):
        if  lifetimeVariation is None:
            lifetimeVariation = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(lifetimeVariation)
        assertZeroToOne('lifetimeVariation', lifetimeVariation)
        self.__lifetimeVariation = lifetimeVariation
    @property # getter - - - - - - - - - -
    def maxParticles(self):
        return self.__maxParticles
    @maxParticles.setter
    def maxParticles(self, maxParticles=None):
        if  maxParticles is None:
            maxParticles = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(maxParticles)
        assertNonNegative('maxParticles', maxParticles)
        self.__maxParticles = maxParticles
    @property # getter - - - - - - - - - -
    def particleLifetime(self):
        return self.__particleLifetime
    @particleLifetime.setter
    def particleLifetime(self, particleLifetime=None):
        if  particleLifetime is None:
            particleLifetime = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(particleLifetime)
        assertNonNegative('particleLifetime', particleLifetime)
        self.__particleLifetime = particleLifetime
    @property # getter - - - - - - - - - -
    def particleSize(self):
        return self.__particleSize
    @particleSize.setter
    def particleSize(self, particleSize=None):
        if  particleSize is None:
            particleSize = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(particleSize)
        assertNonNegative('particleSize', particleSize)
        self.__particleSize = particleSize
    @property # getter - - - - - - - - - -
    def texCoordKey(self):
        return self.__texCoordKey
    @texCoordKey.setter
    def texCoordKey(self, texCoordKey=None):
        if  texCoordKey is None:
            texCoordKey = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(texCoordKey)
        assertNonNegative('texCoordKey', texCoordKey)
        self.__texCoordKey = texCoordKey
    @property # getter - - - - - - - - - -
    def appearance(self):
        return self.__appearance
    @appearance.setter
    def appearance(self, appearance=None):
        if  appearance is None:
            appearance = SFNode.DEFAULT_VALUE
        assertValidSFNode(appearance)
        if not isinstance(appearance, object):
            print(flush=True)
            raise TypeError(str(appearance) + ' does not have a valid node type object')
        self.__appearance = appearance
    @property # getter - - - - - - - - - -
    def colorRamp(self):
        return self.__colorRamp
    @colorRamp.setter
    def colorRamp(self, colorRamp=None):
        if  colorRamp is None:
            colorRamp = SFNode.DEFAULT_VALUE
        assertValidSFNode(colorRamp)
        if not isinstance(colorRamp, object):
            print(flush=True)
            raise TypeError(str(colorRamp) + ' does not have a valid node type object')
        self.__colorRamp = colorRamp
    @property # getter - - - - - - - - - -
    def emitter(self):
        return self.__emitter
    @emitter.setter
    def emitter(self, emitter=None):
        if  emitter is None:
            emitter = SFNode.DEFAULT_VALUE
        assertValidSFNode(emitter)
        if not isinstance(emitter, object):
            print(flush=True)
            raise TypeError(str(emitter) + ' does not have a valid node type object')
        self.__emitter = emitter
    @property # getter - - - - - - - - - -
    def geometry(self):
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry=None):
        if  geometry is None:
            geometry = SFNode.DEFAULT_VALUE
        assertValidSFNode(geometry)
        if not isinstance(geometry, object):
            print(flush=True)
            raise TypeError(str(geometry) + ' does not have a valid node type object')
        self.__geometry = geometry
    @property # getter - - - - - - - - - -
    def geometry(self):
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry=None):
        if  geometry is None:
            geometry = SFNode.DEFAULT_VALUE
        assertValidSFNode(geometry)
        if not isinstance(geometry, object):
            print(flush=True)
            raise TypeError(str(geometry) + ' does not have a valid node type object')
        self.__geometry = geometry
    @property # getter - - - - - - - - - -
    def texCoordRamp(self):
        return self.__texCoordRamp
    @texCoordRamp.setter
    def texCoordRamp(self, texCoordRamp=None):
        if  texCoordRamp is None:
            texCoordRamp = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoordRamp)
        if not isinstance(texCoordRamp, object):
            print(flush=True)
            raise TypeError(str(texCoordRamp) + ' does not have a valid node type object')
        self.__texCoordRamp = texCoordRamp
    @property # getter - - - - - - - - - -
    def physics(self):
        return self.__physics
    @physics.setter
    def physics(self, physics=None):
        if  physics is None:
            physics = MFNode.DEFAULT_VALUE
        assertValidMFNode(physics)
        self.__physics = physics
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ParticleSystem.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ParticleSystem'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorKey != list():
            result += " colorKey='" + self.colorKey + "'"
        if self.createParticles != True:
            result += " createParticles='" + self.createParticles + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.geometryType != 'QUAD':
            result += " geometryType='" + self.geometryType + "'"
        if self.lifetimeVariation != 0.25:
            result += " lifetimeVariation='" + self.lifetimeVariation + "'"
        if self.maxParticles != 200:
            result += " maxParticles='" + self.maxParticles + "'"
        if self.particleLifetime != 5:
            result += " particleLifetime='" + self.particleLifetime + "'"
        if self.particleSize != (0.02, 0.02):
            result += " particleSize='" + self.particleSize + "'"
        if self.texCoordKey != list():
            result += " texCoordKey='" + self.texCoordKey + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.appearance: # walk each child node, if any
            result += indent
            for each in self.appearance:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.colorRamp: # walk each child node, if any
            result += indent
            for each in self.colorRamp:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.emitter: # walk each child node, if any
            result += indent
            for each in self.emitter:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geometry: # walk each child node, if any
            result += indent
            for each in self.geometry:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoordRamp: # walk each child node, if any
            result += indent
            for each in self.texCoordRamp:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.physics: # walk each child node, if any
            result += indent
            for each in self.physics:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ParticleSystem>' + '\n'
#       print('XML serialization complete.')
        return result

class PickableGroup(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'PickableGroup'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PickableGroup'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput),
                          ('pickable', True, FieldType.SFBool, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 objectType=["ALL"],
                 pickable=True,
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PickableGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.objectType = objectType
        self.pickable = pickable
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def objectType(self):
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType=None):
        if  objectType is None:
            objectType = MFString.DEFAULT_VALUE
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def pickable(self):
        return self.__pickable
    @pickable.setter
    def pickable(self, pickable=None):
        if  pickable is None:
            pickable = SFBool.DEFAULT_VALUE
        assertValidSFBool(pickable)
        self.__pickable = pickable
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PickableGroup.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PickableGroup'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.objectType != ["ALL"]:
            result += " objectType='" + self.objectType + "'"
        if self.pickable != True:
            result += " pickable='" + self.pickable + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PickableGroup>' + '\n'
#       print('XML serialization complete.')
        return result

class PixelTexture(_X3DTexture2DNode):
    """
    X3D element
    """
    NAME = 'PixelTexture'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PixelTexture'
    FIELD_DECLARATIONS = [('image', [0, 0, 0], FieldType.SFImage, AccessType.inputOutput),
                          ('repeatS', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('repeatT', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 image=[0, 0, 0],
                 repeatS=True,
                 repeatT=True,
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PixelTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.image = image
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def image(self):
        return self.__image
    @image.setter
    def image(self, image=None):
        if  image is None:
            image = SFImage.DEFAULT_VALUE
        assertValidSFImage(image)
        self.__image = image
    @property # getter - - - - - - - - - -
    def repeatS(self):
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS=None):
        if  repeatS is None:
            repeatS = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT=None):
        if  repeatT is None:
            repeatT = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties=None):
        if  textureProperties is None:
            textureProperties = SFNode.DEFAULT_VALUE
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            print(flush=True)
            raise TypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PixelTexture.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PixelTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.image != [0, 0, 0]:
            result += " image='" + self.image + "'"
        if self.repeatS != True:
            result += " repeatS='" + self.repeatS + "'"
        if self.repeatT != True:
            result += " repeatT='" + self.repeatT + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.textureProperties: # walk each child node, if any
            result += indent
            for each in self.textureProperties:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PixelTexture>' + '\n'
#       print('XML serialization complete.')
        return result

class PixelTexture3D(_X3DTexture3DNode):
    """
    X3D element
    """
    NAME = 'PixelTexture3D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PixelTexture3D'
    FIELD_DECLARATIONS = [('image', [0, 0, 0, 0], FieldType.MFInt32, AccessType.inputOutput),
                          ('repeatR', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('repeatS', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('repeatT', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 image=[0, 0, 0, 0],
                 repeatR=False,
                 repeatS=False,
                 repeatT=False,
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PixelTexture3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.image = image
        self.repeatR = repeatR
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def image(self):
        return self.__image
    @image.setter
    def image(self, image=None):
        if  image is None:
            image = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(image)
        self.__image = image
    @property # getter - - - - - - - - - -
    def repeatR(self):
        return self.__repeatR
    @repeatR.setter
    def repeatR(self, repeatR=None):
        if  repeatR is None:
            repeatR = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatR)
        self.__repeatR = repeatR
    @property # getter - - - - - - - - - -
    def repeatS(self):
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS=None):
        if  repeatS is None:
            repeatS = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT=None):
        if  repeatT is None:
            repeatT = SFBool.DEFAULT_VALUE
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties=None):
        if  textureProperties is None:
            textureProperties = SFNode.DEFAULT_VALUE
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            print(flush=True)
            raise TypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PixelTexture3D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PixelTexture3D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.image != [0, 0, 0, 0]:
            result += " image='" + self.image + "'"
        if self.repeatR != False:
            result += " repeatR='" + self.repeatR + "'"
        if self.repeatS != False:
            result += " repeatS='" + self.repeatS + "'"
        if self.repeatT != False:
            result += " repeatT='" + self.repeatT + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.textureProperties: # walk each child node, if any
            result += indent
            for each in self.textureProperties:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PixelTexture3D>' + '\n'
#       print('XML serialization complete.')
        return result

class PlaneSensor(_X3DDragSensorNode):
    """
    X3D element
    """
    NAME = 'PlaneSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PlaneSensor'
    FIELD_DECLARATIONS = [('autoOffset', True, FieldType.SFBool, AccessType.inputOutput),
                          ('axisRotation', (0, 1, 0, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('maxPosition', (-1, -1), FieldType.SFVec2f, AccessType.inputOutput),
                          ('minPosition', (0, 0), FieldType.SFVec2f, AccessType.inputOutput),
                          ('offset', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 autoOffset=True,
                 axisRotation=(0, 1, 0, 0),
                 description='',
                 enabled=True,
                 maxPosition=(-1, -1),
                 minPosition=(0, 0),
                 offset=(0, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PlaneSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.autoOffset = autoOffset
        self.axisRotation = axisRotation
        self.description = description
        self.enabled = enabled
        self.maxPosition = maxPosition
        self.minPosition = minPosition
        self.offset = offset
    @property # getter - - - - - - - - - -
    def autoOffset(self):
        return self.__autoOffset
    @autoOffset.setter
    def autoOffset(self, autoOffset=None):
        if  autoOffset is None:
            autoOffset = SFBool.DEFAULT_VALUE
        assertValidSFBool(autoOffset)
        self.__autoOffset = autoOffset
    @property # getter - - - - - - - - - -
    def axisRotation(self):
        return self.__axisRotation
    @axisRotation.setter
    def axisRotation(self, axisRotation=None):
        if  axisRotation is None:
            axisRotation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(axisRotation)
        self.__axisRotation = axisRotation
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def maxPosition(self):
        return self.__maxPosition
    @maxPosition.setter
    def maxPosition(self, maxPosition=None):
        if  maxPosition is None:
            maxPosition = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(maxPosition)
        self.__maxPosition = maxPosition
    @property # getter - - - - - - - - - -
    def minPosition(self):
        return self.__minPosition
    @minPosition.setter
    def minPosition(self, minPosition=None):
        if  minPosition is None:
            minPosition = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(minPosition)
        self.__minPosition = minPosition
    @property # getter - - - - - - - - - -
    def offset(self):
        return self.__offset
    @offset.setter
    def offset(self, offset=None):
        if  offset is None:
            offset = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(offset)
        self.__offset = offset
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PlaneSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PlaneSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.autoOffset != True:
            result += " autoOffset='" + self.autoOffset + "'"
        if self.axisRotation != (0, 1, 0, 0):
            result += " axisRotation='" + self.axisRotation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.maxPosition != (-1, -1):
            result += " maxPosition='" + self.maxPosition + "'"
        if self.minPosition != (0, 0):
            result += " minPosition='" + self.minPosition + "'"
        if self.offset != (0, 0, 0):
            result += " offset='" + self.offset + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PlaneSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class PointEmitter(_X3DParticleEmitterNode):
    """
    X3D element
    """
    NAME = 'PointEmitter'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointEmitter'
    FIELD_DECLARATIONS = [('direction', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('mass', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('speed', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('surfaceArea', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 direction=(0, 1, 0),
                 mass=0,
                 position=(0, 0, 0),
                 speed=0,
                 surfaceArea=0,
                 variation=0.25,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PointEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.direction = direction
        self.mass = mass
        self.position = position
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
    @property # getter - - - - - - - - - -
    def direction(self):
        return self.__direction
    @direction.setter
    def direction(self, direction=None):
        if  direction is None:
            direction = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def mass(self):
        return self.__mass
    @mass.setter
    def mass(self, mass=None):
        if  mass is None:
            mass = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def position(self):
        return self.__position
    @position.setter
    def position(self, position=None):
        if  position is None:
            position = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def speed(self):
        return self.__speed
    @speed.setter
    def speed(self, speed=None):
        if  speed is None:
            speed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea=None):
        if  surfaceArea is None:
            surfaceArea = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        return self.__variation
    @variation.setter
    def variation(self, variation=None):
        if  variation is None:
            variation = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PointEmitter.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PointEmitter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.direction != (0, 1, 0):
            result += " direction='" + self.direction + "'"
        if self.mass != 0:
            result += " mass='" + self.mass + "'"
        if self.position != (0, 0, 0):
            result += " position='" + self.position + "'"
        if self.speed != 0:
            result += " speed='" + self.speed + "'"
        if self.surfaceArea != 0:
            result += " surfaceArea='" + self.surfaceArea + "'"
        if self.variation != 0.25:
            result += " variation='" + self.variation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PointEmitter>' + '\n'
#       print('XML serialization complete.')
        return result

class PointLight(_X3DLightNode):
    """
    Linear attenuation may occur at level 2, full support at level 3.
    """
    NAME = 'PointLight'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointLight'
    FIELD_DECLARATIONS = [('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('attenuation', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput),
                          ('global_', True, FieldType.SFBool, AccessType.inputOutput),
                          ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('on', True, FieldType.SFBool, AccessType.inputOutput),
                          ('radius', 100, FieldType.SFFloat, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ambientIntensity=0,
                 attenuation=(1, 0, 0),
                 color=(1, 1, 1),
                 global_=True,
                 intensity=1,
                 location=(0, 0, 0),
                 on=True,
                 radius=100,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PointLight __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.attenuation = attenuation
        self.color = color
        self.global_ = global_
        self.intensity = intensity
        self.location = location
        self.on = on
        self.radius = radius
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity=None):
        if  ambientIntensity is None:
            ambientIntensity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def attenuation(self):
        return self.__attenuation
    @attenuation.setter
    def attenuation(self, attenuation=None):
        if  attenuation is None:
            attenuation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(attenuation)
        assertNonNegative('attenuation', attenuation)
        self.__attenuation = attenuation
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFColor.DEFAULT_VALUE
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def global_(self):
        return self.__global_
    @global_.setter
    def global_(self, global_=None):
        if  global_ is None:
            global_ = SFBool.DEFAULT_VALUE
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity=None):
        if  intensity is None:
            intensity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(intensity)
        assertZeroToOne('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        return self.__location
    @location.setter
    def location(self, location=None):
        if  location is None:
            location = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def on(self):
        return self.__on
    @on.setter
    def on(self, on=None):
        if  on is None:
            on = SFBool.DEFAULT_VALUE
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def radius(self):
        return self.__radius
    @radius.setter
    def radius(self, radius=None):
        if  radius is None:
            radius = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(radius)
        assertNonNegative('radius', radius)
        self.__radius = radius
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PointLight.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PointLight'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ambientIntensity != 0:
            result += " ambientIntensity='" + self.ambientIntensity + "'"
        if self.attenuation != (1, 0, 0):
            result += " attenuation='" + self.attenuation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + self.color + "'"
        if self.global_ != True:
            result += " global_='" + self.global_ + "'"
        if self.intensity != 1:
            result += " intensity='" + self.intensity + "'"
        if self.location != (0, 0, 0):
            result += " location='" + self.location + "'"
        if self.on != True:
            result += " on='" + self.on + "'"
        if self.radius != 100:
            result += " radius='" + self.radius + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PointLight>' + '\n'
#       print('XML serialization complete.')
        return result

class PointPickSensor(_X3DPickSensorNode):
    """
    X3D element
    """
    NAME = 'PointPickSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointPickSensor'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('intersectionType', 'BOUNDS', FieldType.SFString, AccessType.initializeOnly),
                          ('matchCriterion', 'MATCH_ANY', FieldType.SFString, AccessType.inputOutput),
                          ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput),
                          ('sortOrder', 'CLOSEST', FieldType.SFString, AccessType.initializeOnly),
                          ('pickingGeometry', None, FieldType.SFNode, AccessType.inputOutput),
                          ('pickTarget', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 intersectionType='BOUNDS',
                 matchCriterion='MATCH_ANY',
                 objectType=["ALL"],
                 sortOrder='CLOSEST',
                 pickingGeometry=None,
                 pickTarget=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PointPickSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.intersectionType = intersectionType
        self.matchCriterion = matchCriterion
        self.objectType = objectType
        self.sortOrder = sortOrder
        self.pickingGeometry = pickingGeometry
        self.pickTarget = pickTarget
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intersectionType(self):
        return self.__intersectionType
    @intersectionType.setter
    def intersectionType(self, intersectionType=None):
        if  intersectionType is None:
            intersectionType = SFString.DEFAULT_VALUE
        assertValidSFString(intersectionType)
        self.__intersectionType = intersectionType
    @property # getter - - - - - - - - - -
    def matchCriterion(self):
        return self.__matchCriterion
    @matchCriterion.setter
    def matchCriterion(self, matchCriterion=None):
        if  matchCriterion is None:
            matchCriterion = SFString.DEFAULT_VALUE
        assertValidSFString(matchCriterion)
        self.__matchCriterion = matchCriterion
    @property # getter - - - - - - - - - -
    def objectType(self):
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType=None):
        if  objectType is None:
            objectType = MFString.DEFAULT_VALUE
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def sortOrder(self):
        return self.__sortOrder
    @sortOrder.setter
    def sortOrder(self, sortOrder=None):
        if  sortOrder is None:
            sortOrder = SFString.DEFAULT_VALUE
        assertValidSFString(sortOrder)
        self.__sortOrder = sortOrder
    @property # getter - - - - - - - - - -
    def pickingGeometry(self):
        return self.__pickingGeometry
    @pickingGeometry.setter
    def pickingGeometry(self, pickingGeometry=None):
        if  pickingGeometry is None:
            pickingGeometry = SFNode.DEFAULT_VALUE
        assertValidSFNode(pickingGeometry)
        if not isinstance(pickingGeometry, object):
            print(flush=True)
            raise TypeError(str(pickingGeometry) + ' does not have a valid node type object')
        self.__pickingGeometry = pickingGeometry
    @property # getter - - - - - - - - - -
    def pickTarget(self):
        return self.__pickTarget
    @pickTarget.setter
    def pickTarget(self, pickTarget=None):
        if  pickTarget is None:
            pickTarget = MFNode.DEFAULT_VALUE
        assertValidMFNode(pickTarget)
        self.__pickTarget = pickTarget
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PointPickSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PointPickSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.intersectionType != 'BOUNDS':
            result += " intersectionType='" + self.intersectionType + "'"
        if self.matchCriterion != 'MATCH_ANY':
            result += " matchCriterion='" + self.matchCriterion + "'"
        if self.objectType != ["ALL"]:
            result += " objectType='" + self.objectType + "'"
        if self.sortOrder != 'CLOSEST':
            result += " sortOrder='" + self.sortOrder + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.pickingGeometry: # walk each child node, if any
            result += indent
            for each in self.pickingGeometry:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.pickTarget: # walk each child node, if any
            result += indent
            for each in self.pickTarget:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PointPickSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class PointProperties(_X3DAppearanceChildNode):
    """
    X3D element
    """
    NAME = 'PointProperties'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointProperties'
    FIELD_DECLARATIONS = [('colorMode', 'TEXTURE_AND_POINT_COLOR', FieldType.SFString, AccessType.inputOutput),
                          ('pointSizeAttenuation', [1, 0, 0], FieldType.MFFloat, AccessType.inputOutput),
                          ('pointSizeMaxValue', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('pointSizeMinValue', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('pointSizeScaleFactor', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 colorMode='TEXTURE_AND_POINT_COLOR',
                 pointSizeAttenuation=[1, 0, 0],
                 pointSizeMaxValue=1,
                 pointSizeMinValue=1,
                 pointSizeScaleFactor=1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PointProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.colorMode = colorMode
        self.pointSizeAttenuation = pointSizeAttenuation
        self.pointSizeMaxValue = pointSizeMaxValue
        self.pointSizeMinValue = pointSizeMinValue
        self.pointSizeScaleFactor = pointSizeScaleFactor
    @property # getter - - - - - - - - - -
    def colorMode(self):
        return self.__colorMode
    @colorMode.setter
    def colorMode(self, colorMode=None):
        if  colorMode is None:
            colorMode = SFString.DEFAULT_VALUE
        assertValidSFString(colorMode)
        self.__colorMode = colorMode
    @property # getter - - - - - - - - - -
    def pointSizeAttenuation(self):
        return self.__pointSizeAttenuation
    @pointSizeAttenuation.setter
    def pointSizeAttenuation(self, pointSizeAttenuation=None):
        if  pointSizeAttenuation is None:
            pointSizeAttenuation = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(pointSizeAttenuation)
        self.__pointSizeAttenuation = pointSizeAttenuation
    @property # getter - - - - - - - - - -
    def pointSizeMaxValue(self):
        return self.__pointSizeMaxValue
    @pointSizeMaxValue.setter
    def pointSizeMaxValue(self, pointSizeMaxValue=None):
        if  pointSizeMaxValue is None:
            pointSizeMaxValue = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(pointSizeMaxValue)
        assertNonNegative('pointSizeMaxValue', pointSizeMaxValue)
        self.__pointSizeMaxValue = pointSizeMaxValue
    @property # getter - - - - - - - - - -
    def pointSizeMinValue(self):
        return self.__pointSizeMinValue
    @pointSizeMinValue.setter
    def pointSizeMinValue(self, pointSizeMinValue=None):
        if  pointSizeMinValue is None:
            pointSizeMinValue = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(pointSizeMinValue)
        assertNonNegative('pointSizeMinValue', pointSizeMinValue)
        self.__pointSizeMinValue = pointSizeMinValue
    @property # getter - - - - - - - - - -
    def pointSizeScaleFactor(self):
        return self.__pointSizeScaleFactor
    @pointSizeScaleFactor.setter
    def pointSizeScaleFactor(self, pointSizeScaleFactor=None):
        if  pointSizeScaleFactor is None:
            pointSizeScaleFactor = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(pointSizeScaleFactor)
        assertGreaterThanEquals('pointSizeScaleFactor', pointSizeScaleFactor, 1)
        self.__pointSizeScaleFactor = pointSizeScaleFactor
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PointProperties.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PointProperties'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorMode != 'TEXTURE_AND_POINT_COLOR':
            result += " colorMode='" + self.colorMode + "'"
        if self.pointSizeAttenuation != [1, 0, 0]:
            result += " pointSizeAttenuation='" + self.pointSizeAttenuation + "'"
        if self.pointSizeMaxValue != 1:
            result += " pointSizeMaxValue='" + self.pointSizeMaxValue + "'"
        if self.pointSizeMinValue != 1:
            result += " pointSizeMinValue='" + self.pointSizeMinValue + "'"
        if self.pointSizeScaleFactor != 1:
            result += " pointSizeScaleFactor='" + self.pointSizeScaleFactor + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PointProperties>' + '\n'
#       print('XML serialization complete.')
        return result

class PointSet(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'PointSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointSet'
    FIELD_DECLARATIONS = [('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('attrib', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 attrib=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PointSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord=None):
        if  fogCoord is None:
            fogCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            print(flush=True)
            raise TypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib=None):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PointSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PointSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fogCoord: # walk each child node, if any
            result += indent
            for each in self.fogCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.attrib: # walk each child node, if any
            result += indent
            for each in self.attrib:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PointSet>' + '\n'
#       print('XML serialization complete.')
        return result

class Polyline2D(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'Polyline2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Polyline2D'
    FIELD_DECLARATIONS = [('lineSegments', list(), FieldType.MFVec2f, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 lineSegments=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Polyline2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.lineSegments = lineSegments
    @property # getter - - - - - - - - - -
    def lineSegments(self):
        return self.__lineSegments
    @lineSegments.setter
    def lineSegments(self, lineSegments=None):
        if  lineSegments is None:
            lineSegments = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(lineSegments)
        self.__lineSegments = lineSegments
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Polyline2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Polyline2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.lineSegments != list():
            result += " lineSegments='" + self.lineSegments + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Polyline2D>' + '\n'
#       print('XML serialization complete.')
        return result

class PolylineEmitter(_X3DParticleEmitterNode):
    """
    X3D element
    """
    NAME = 'PolylineEmitter'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PolylineEmitter'
    FIELD_DECLARATIONS = [('coordIndex', [-1], FieldType.MFInt32, AccessType.initializeOnly),
                          ('direction', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('mass', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('speed', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('surfaceArea', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 coordIndex=[-1],
                 direction=(0, 1, 0),
                 mass=0,
                 speed=0,
                 surfaceArea=0,
                 variation=0.25,
                 coord=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PolylineEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.coordIndex = coordIndex
        self.direction = direction
        self.mass = mass
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
        self.coord = coord
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex=None):
        if  coordIndex is None:
            coordIndex = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def direction(self):
        return self.__direction
    @direction.setter
    def direction(self, direction=None):
        if  direction is None:
            direction = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(direction)
        assertGreaterThanEquals('direction', direction, -1)
        assertLessThanEquals('direction', direction, 1)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def mass(self):
        return self.__mass
    @mass.setter
    def mass(self, mass=None):
        if  mass is None:
            mass = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def speed(self):
        return self.__speed
    @speed.setter
    def speed(self, speed=None):
        if  speed is None:
            speed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea=None):
        if  surfaceArea is None:
            surfaceArea = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        return self.__variation
    @variation.setter
    def variation(self, variation=None):
        if  variation is None:
            variation = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PolylineEmitter.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PolylineEmitter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.coordIndex != [-1]:
            result += " coordIndex='" + self.coordIndex + "'"
        if self.direction != (0, 1, 0):
            result += " direction='" + self.direction + "'"
        if self.mass != 0:
            result += " mass='" + self.mass + "'"
        if self.speed != 0:
            result += " speed='" + self.speed + "'"
        if self.surfaceArea != 0:
            result += " surfaceArea='" + self.surfaceArea + "'"
        if self.variation != 0.25:
            result += " variation='" + self.variation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PolylineEmitter>' + '\n'
#       print('XML serialization complete.')
        return result

class Polypoint2D(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'Polypoint2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Polypoint2D'
    FIELD_DECLARATIONS = [('point', list(), FieldType.MFVec2f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 point=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Polypoint2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.point = point
    @property # getter - - - - - - - - - -
    def point(self):
        return self.__point
    @point.setter
    def point(self, point=None):
        if  point is None:
            point = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(point)
        self.__point = point
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Polypoint2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Polypoint2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.point != list():
            result += " point='" + self.point + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Polypoint2D>' + '\n'
#       print('XML serialization complete.')
        return result

class PositionChaser(_X3DChaserNode):
    """
    X3D element
    """
    NAME = 'PositionChaser'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionChaser'
    FIELD_DECLARATIONS = [('duration', 1, FieldType.SFTime, AccessType.initializeOnly),
                          ('initialDestination', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('initialValue', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 duration=1,
                 initialDestination=(0, 0, 0),
                 initialValue=(0, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PositionChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        return self.__duration
    @duration.setter
    def duration(self, duration=None):
        if  duration is None:
            duration = SFTime.DEFAULT_VALUE
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(initialValue)
        self.__initialValue = initialValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PositionChaser.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PositionChaser'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + self.duration + "'"
        if self.initialDestination != (0, 0, 0):
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != (0, 0, 0):
            result += " initialValue='" + self.initialValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PositionChaser>' + '\n'
#       print('XML serialization complete.')
        return result

class PositionChaser2D(_X3DChaserNode):
    """
    X3D element
    """
    NAME = 'PositionChaser2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionChaser2D'
    FIELD_DECLARATIONS = [('duration', 1, FieldType.SFTime, AccessType.initializeOnly),
                          ('initialDestination', (0, 0), FieldType.SFVec2f, AccessType.initializeOnly),
                          ('initialValue', (0, 0), FieldType.SFVec2f, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 duration=1,
                 initialDestination=(0, 0),
                 initialValue=(0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PositionChaser2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        return self.__duration
    @duration.setter
    def duration(self, duration=None):
        if  duration is None:
            duration = SFTime.DEFAULT_VALUE
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(initialValue)
        self.__initialValue = initialValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PositionChaser2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PositionChaser2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + self.duration + "'"
        if self.initialDestination != (0, 0):
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != (0, 0):
            result += " initialValue='" + self.initialValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PositionChaser2D>' + '\n'
#       print('XML serialization complete.')
        return result

class PositionDamper(_X3DDamperNode):
    """
    X3D element
    """
    NAME = 'PositionDamper'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionDamper'
    FIELD_DECLARATIONS = [('initialDestination', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('initialValue', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('order', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput),
                          ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 initialDestination=(0, 0, 0),
                 initialValue=(0, 0, 0),
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PositionDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        return self.__order
    @order.setter
    def order(self, order=None):
        if  order is None:
            order = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        return self.__tau
    @tau.setter
    def tau(self, tau=None):
        if  tau is None:
            tau = SFTime.DEFAULT_VALUE
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance=None):
        if  tolerance is None:
            tolerance = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PositionDamper.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PositionDamper'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != (0, 0, 0):
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != (0, 0, 0):
            result += " initialValue='" + self.initialValue + "'"
        if self.order != 3:
            result += " order='" + self.order + "'"
        if self.tau != 0.3:
            result += " tau='" + self.tau + "'"
        if self.tolerance != -1:
            result += " tolerance='" + self.tolerance + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PositionDamper>' + '\n'
#       print('XML serialization complete.')
        return result

class PositionDamper2D(_X3DDamperNode):
    """
    X3D element
    """
    NAME = 'PositionDamper2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionDamper2D'
    FIELD_DECLARATIONS = [('initialDestination', (0, 0), FieldType.SFVec2f, AccessType.initializeOnly),
                          ('initialValue', (0, 0), FieldType.SFVec2f, AccessType.initializeOnly),
                          ('order', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput),
                          ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 initialDestination=(0, 0),
                 initialValue=(0, 0),
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PositionDamper2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        return self.__order
    @order.setter
    def order(self, order=None):
        if  order is None:
            order = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        return self.__tau
    @tau.setter
    def tau(self, tau=None):
        if  tau is None:
            tau = SFTime.DEFAULT_VALUE
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance=None):
        if  tolerance is None:
            tolerance = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PositionDamper2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PositionDamper2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != (0, 0):
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != (0, 0):
            result += " initialValue='" + self.initialValue + "'"
        if self.order != 3:
            result += " order='" + self.order + "'"
        if self.tau != 0.3:
            result += " tau='" + self.tau + "'"
        if self.tolerance != -1:
            result += " tolerance='" + self.tolerance + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PositionDamper2D>' + '\n'
#       print('XML serialization complete.')
        return result

class PositionInterpolator(_X3DInterpolatorNode):
    """
    X3D element
    """
    NAME = 'PositionInterpolator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionInterpolator'
    FIELD_DECLARATIONS = [('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFVec3f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PositionInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(keyValue)
        self.__keyValue = keyValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PositionInterpolator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PositionInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PositionInterpolator>' + '\n'
#       print('XML serialization complete.')
        return result

class PositionInterpolator2D(_X3DInterpolatorNode):
    """
    X3D element
    """
    NAME = 'PositionInterpolator2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionInterpolator2D'
    FIELD_DECLARATIONS = [('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFVec2f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PositionInterpolator2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(keyValue)
        self.__keyValue = keyValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PositionInterpolator2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PositionInterpolator2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PositionInterpolator2D>' + '\n'
#       print('XML serialization complete.')
        return result

class PrimitivePickSensor(_X3DPickSensorNode):
    """
    If a non-uniform scale is applied to the pick sensor, correct results may require level 3 support.
    """
    NAME = 'PrimitivePickSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PrimitivePickSensor'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('intersectionType', 'BOUNDS', FieldType.SFString, AccessType.initializeOnly),
                          ('matchCriterion', 'MATCH_ANY', FieldType.SFString, AccessType.inputOutput),
                          ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput),
                          ('sortOrder', 'CLOSEST', FieldType.SFString, AccessType.initializeOnly),
                          ('pickingGeometry', None, FieldType.SFNode, AccessType.inputOutput),
                          ('pickTarget', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 intersectionType='BOUNDS',
                 matchCriterion='MATCH_ANY',
                 objectType=["ALL"],
                 sortOrder='CLOSEST',
                 pickingGeometry=None,
                 pickTarget=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PrimitivePickSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.intersectionType = intersectionType
        self.matchCriterion = matchCriterion
        self.objectType = objectType
        self.sortOrder = sortOrder
        self.pickingGeometry = pickingGeometry
        self.pickTarget = pickTarget
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intersectionType(self):
        return self.__intersectionType
    @intersectionType.setter
    def intersectionType(self, intersectionType=None):
        if  intersectionType is None:
            intersectionType = SFString.DEFAULT_VALUE
        assertValidSFString(intersectionType)
        self.__intersectionType = intersectionType
    @property # getter - - - - - - - - - -
    def matchCriterion(self):
        return self.__matchCriterion
    @matchCriterion.setter
    def matchCriterion(self, matchCriterion=None):
        if  matchCriterion is None:
            matchCriterion = SFString.DEFAULT_VALUE
        assertValidSFString(matchCriterion)
        self.__matchCriterion = matchCriterion
    @property # getter - - - - - - - - - -
    def objectType(self):
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType=None):
        if  objectType is None:
            objectType = MFString.DEFAULT_VALUE
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def sortOrder(self):
        return self.__sortOrder
    @sortOrder.setter
    def sortOrder(self, sortOrder=None):
        if  sortOrder is None:
            sortOrder = SFString.DEFAULT_VALUE
        assertValidSFString(sortOrder)
        self.__sortOrder = sortOrder
    @property # getter - - - - - - - - - -
    def pickingGeometry(self):
        return self.__pickingGeometry
    @pickingGeometry.setter
    def pickingGeometry(self, pickingGeometry=None):
        if  pickingGeometry is None:
            pickingGeometry = SFNode.DEFAULT_VALUE
        assertValidSFNode(pickingGeometry)
        if not isinstance(pickingGeometry, object):
            print(flush=True)
            raise TypeError(str(pickingGeometry) + ' does not have a valid node type object')
        self.__pickingGeometry = pickingGeometry
    @property # getter - - - - - - - - - -
    def pickTarget(self):
        return self.__pickTarget
    @pickTarget.setter
    def pickTarget(self, pickTarget=None):
        if  pickTarget is None:
            pickTarget = MFNode.DEFAULT_VALUE
        assertValidMFNode(pickTarget)
        self.__pickTarget = pickTarget
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function PrimitivePickSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<PrimitivePickSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.intersectionType != 'BOUNDS':
            result += " intersectionType='" + self.intersectionType + "'"
        if self.matchCriterion != 'MATCH_ANY':
            result += " matchCriterion='" + self.matchCriterion + "'"
        if self.objectType != ["ALL"]:
            result += " objectType='" + self.objectType + "'"
        if self.sortOrder != 'CLOSEST':
            result += " sortOrder='" + self.sortOrder + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.pickingGeometry: # walk each child node, if any
            result += indent
            for each in self.pickingGeometry:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.pickTarget: # walk each child node, if any
            result += indent
            for each in self.pickTarget:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</PrimitivePickSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class ProgramShader(_X3DShaderNode):
    """
    ProgramShader contains no field declarations and no plain-text source code.
    """
    NAME = 'ProgramShader'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProgramShader'
    FIELD_DECLARATIONS = [('language', '', FieldType.SFString, AccessType.initializeOnly),
                          ('programs', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 language='',
                 programs=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ProgramShader __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.language = language
        self.programs = programs
    @property # getter - - - - - - - - - -
    def language(self):
        return self.__language
    @language.setter
    def language(self, language=None):
        if  language is None:
            language = SFString.DEFAULT_VALUE
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def programs(self):
        return self.__programs
    @programs.setter
    def programs(self, programs=None):
        if  programs is None:
            programs = MFNode.DEFAULT_VALUE
        assertValidMFNode(programs)
        self.__programs = programs
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ProgramShader.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ProgramShader'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.language:
            result += " language='" + self.language + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.programs: # walk each child node, if any
            result += indent
            for each in self.programs:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ProgramShader>' + '\n'
#       print('XML serialization complete.')
        return result

class ProjectionVolumeStyle(_X3DVolumeRenderStyleNode):
    """
    X3D element
    """
    NAME = 'ProjectionVolumeStyle'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProjectionVolumeStyle'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('intensityThreshold', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('type', 'MAX', FieldType.SFString, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 intensityThreshold=0,
                 type='MAX',
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ProjectionVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.intensityThreshold = intensityThreshold
        self.type = type
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intensityThreshold(self):
        return self.__intensityThreshold
    @intensityThreshold.setter
    def intensityThreshold(self, intensityThreshold=None):
        if  intensityThreshold is None:
            intensityThreshold = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(intensityThreshold)
        assertZeroToOne('intensityThreshold', intensityThreshold)
        self.__intensityThreshold = intensityThreshold
    @property # getter - - - - - - - - - -
    def type(self):
        return self.__type
    @type.setter
    def type(self, type=None):
        if  type is None:
            type = SFString.DEFAULT_VALUE
        assertValidSFString(type)
        self.__type = type
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ProjectionVolumeStyle.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ProjectionVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.intensityThreshold != 0:
            result += " intensityThreshold='" + self.intensityThreshold + "'"
        if self.type != 'MAX':
            result += " type='" + self.type + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ProjectionVolumeStyle>' + '\n'
#       print('XML serialization complete.')
        return result

class ProtoInstance(_X3DPrototypeInstance):
    """
    ProtoInstance can override field default values via fieldValue initializations. Non-recursive nested ProtoInstance and ProtoDeclare statements are allowed within a ProtoDeclare.
    """
    NAME = 'ProtoInstance'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoInstance'
    FIELD_DECLARATIONS = [('name', '', FieldType.SFString, AccessType.inputOutput),
                          ('fieldValue', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 name='',
                 fieldValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ProtoInstance __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.fieldValue = fieldValue
    @property # getter - - - - - - - - - -
    def name(self):
        return self.__name
    @name.setter
    def name(self, name=None):
        if  name is None:
            name = SFString.DEFAULT_VALUE
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def fieldValue(self):
        return self.__fieldValue
    @fieldValue.setter
    def fieldValue(self, fieldValue=None):
        if  fieldValue is None:
            fieldValue = MFNode.DEFAULT_VALUE
        assertValidMFNode(fieldValue)
        self.__fieldValue = fieldValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ProtoInstance.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ProtoInstance'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fieldValue: # walk each child node, if any
            result += indent
            for each in self.fieldValue:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ProtoInstance>' + '\n'
#       print('XML serialization complete.')
        return result

class ProximitySensor(_X3DEnvironmentalSensorNode):
    """
    X3D element
    """
    NAME = 'ProximitySensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProximitySensor'
    FIELD_DECLARATIONS = [('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 center=(0, 0, 0),
                 enabled=True,
                 size=(0, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ProximitySensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.enabled = enabled
        self.size = size
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def size(self):
        return self.__size
    @size.setter
    def size(self, size=None):
        if  size is None:
            size = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(size)
        assertNonNegative('size', size)
        self.__size = size
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ProximitySensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ProximitySensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.size != (0, 0, 0):
            result += " size='" + self.size + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ProximitySensor>' + '\n'
#       print('XML serialization complete.')
        return result

class QuadSet(_X3DComposedGeometryNode):
    """
    QuadSet is a geometry node that defines quadrilaterals.
    """
    NAME = 'QuadSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#QuadSet'
    FIELD_DECLARATIONS = [('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('normal', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('attrib', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode QuadSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex=None):
        if  colorPerVertex is None:
            colorPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex=None):
        if  normalPerVertex is None:
            normalPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord=None):
        if  fogCoord is None:
            fogCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            print(flush=True)
            raise TypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal=None):
        if  normal is None:
            normal = SFNode.DEFAULT_VALUE
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            print(flush=True)
            raise TypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            print(flush=True)
            raise TypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib=None):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function QuadSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<QuadSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorPerVertex != True:
            result += " colorPerVertex='" + self.colorPerVertex + "'"
        if self.normalPerVertex != True:
            result += " normalPerVertex='" + self.normalPerVertex + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fogCoord: # walk each child node, if any
            result += indent
            for each in self.fogCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.normal: # walk each child node, if any
            result += indent
            for each in self.normal:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.attrib: # walk each child node, if any
            result += indent
            for each in self.attrib:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</QuadSet>' + '\n'
#       print('XML serialization complete.')
        return result

class ReceiverPdu(_X3DNetworkSensorNode):
    """
    X3D element
    """
    NAME = 'ReceiverPdu'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ReceiverPdu'
    FIELD_DECLARATIONS = [('address', 'localhost', FieldType.SFString, AccessType.inputOutput),
                          ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('entityID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput),
                          ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('multicastRelayHost', '', FieldType.SFString, AccessType.inputOutput),
                          ('multicastRelayPort', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('networkMode', 'standAlone', FieldType.SFString, AccessType.inputOutput),
                          ('port', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('radioID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('readInterval', 0.1, FieldType.SFTime, AccessType.inputOutput),
                          ('receivedPower', 0.0, FieldType.SFFloat, AccessType.inputOutput),
                          ('receiverState', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('rtpHeaderExpected', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('transmitterApplicationID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('transmitterEntityID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('transmitterRadioID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('transmitterSiteID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('whichGeometry', 1, FieldType.SFInt32, AccessType.inputOutput),
                          ('writeInterval', 1.0, FieldType.SFTime, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 address='localhost',
                 applicationID=0,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 enabled=True,
                 entityID=0,
                 geoCoords=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 multicastRelayHost='',
                 multicastRelayPort=0,
                 networkMode='standAlone',
                 port=0,
                 radioID=0,
                 readInterval=0.1,
                 receivedPower=0.0,
                 receiverState=0,
                 rtpHeaderExpected=False,
                 siteID=0,
                 transmitterApplicationID=0,
                 transmitterEntityID=0,
                 transmitterRadioID=0,
                 transmitterSiteID=0,
                 whichGeometry=1,
                 writeInterval=1.0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ReceiverPdu __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.applicationID = applicationID
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.enabled = enabled
        self.entityID = entityID
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.multicastRelayHost = multicastRelayHost
        self.multicastRelayPort = multicastRelayPort
        self.networkMode = networkMode
        self.port = port
        self.radioID = radioID
        self.readInterval = readInterval
        self.receivedPower = receivedPower
        self.receiverState = receiverState
        self.rtpHeaderExpected = rtpHeaderExpected
        self.siteID = siteID
        self.transmitterApplicationID = transmitterApplicationID
        self.transmitterEntityID = transmitterEntityID
        self.transmitterRadioID = transmitterRadioID
        self.transmitterSiteID = transmitterSiteID
        self.whichGeometry = whichGeometry
        self.writeInterval = writeInterval
    @property # getter - - - - - - - - - -
    def address(self):
        return self.__address
    @address.setter
    def address(self, address=None):
        if  address is None:
            address = SFString.DEFAULT_VALUE
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def applicationID(self):
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID=None):
        if  applicationID is None:
            applicationID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def entityID(self):
        return self.__entityID
    @entityID.setter
    def entityID(self, entityID=None):
        if  entityID is None:
            entityID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(entityID)
        self.__entityID = entityID
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords=None):
        if  geoCoords is None:
            geoCoords = SFVec3d.DEFAULT_VALUE
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def multicastRelayHost(self):
        return self.__multicastRelayHost
    @multicastRelayHost.setter
    def multicastRelayHost(self, multicastRelayHost=None):
        if  multicastRelayHost is None:
            multicastRelayHost = SFString.DEFAULT_VALUE
        assertValidSFString(multicastRelayHost)
        self.__multicastRelayHost = multicastRelayHost
    @property # getter - - - - - - - - - -
    def multicastRelayPort(self):
        return self.__multicastRelayPort
    @multicastRelayPort.setter
    def multicastRelayPort(self, multicastRelayPort=None):
        if  multicastRelayPort is None:
            multicastRelayPort = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(multicastRelayPort)
        self.__multicastRelayPort = multicastRelayPort
    @property # getter - - - - - - - - - -
    def networkMode(self):
        return self.__networkMode
    @networkMode.setter
    def networkMode(self, networkMode=None):
        if  networkMode is None:
            networkMode = SFString.DEFAULT_VALUE
        assertValidSFString(networkMode)
        self.__networkMode = networkMode
    @property # getter - - - - - - - - - -
    def port(self):
        return self.__port
    @port.setter
    def port(self, port=None):
        if  port is None:
            port = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def radioID(self):
        return self.__radioID
    @radioID.setter
    def radioID(self, radioID=None):
        if  radioID is None:
            radioID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(radioID)
        self.__radioID = radioID
    @property # getter - - - - - - - - - -
    def readInterval(self):
        return self.__readInterval
    @readInterval.setter
    def readInterval(self, readInterval=None):
        if  readInterval is None:
            readInterval = SFTime.DEFAULT_VALUE
        assertValidSFTime(readInterval)
        assertNonNegative('readInterval', readInterval)
        self.__readInterval = readInterval
    @property # getter - - - - - - - - - -
    def receivedPower(self):
        return self.__receivedPower
    @receivedPower.setter
    def receivedPower(self, receivedPower=None):
        if  receivedPower is None:
            receivedPower = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(receivedPower)
        self.__receivedPower = receivedPower
    @property # getter - - - - - - - - - -
    def receiverState(self):
        return self.__receiverState
    @receiverState.setter
    def receiverState(self, receiverState=None):
        if  receiverState is None:
            receiverState = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(receiverState)
        self.__receiverState = receiverState
    @property # getter - - - - - - - - - -
    def rtpHeaderExpected(self):
        return self.__rtpHeaderExpected
    @rtpHeaderExpected.setter
    def rtpHeaderExpected(self, rtpHeaderExpected=None):
        if  rtpHeaderExpected is None:
            rtpHeaderExpected = SFBool.DEFAULT_VALUE
        assertValidSFBool(rtpHeaderExpected)
        self.__rtpHeaderExpected = rtpHeaderExpected
    @property # getter - - - - - - - - - -
    def siteID(self):
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID=None):
        if  siteID is None:
            siteID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def transmitterApplicationID(self):
        return self.__transmitterApplicationID
    @transmitterApplicationID.setter
    def transmitterApplicationID(self, transmitterApplicationID=None):
        if  transmitterApplicationID is None:
            transmitterApplicationID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(transmitterApplicationID)
        self.__transmitterApplicationID = transmitterApplicationID
    @property # getter - - - - - - - - - -
    def transmitterEntityID(self):
        return self.__transmitterEntityID
    @transmitterEntityID.setter
    def transmitterEntityID(self, transmitterEntityID=None):
        if  transmitterEntityID is None:
            transmitterEntityID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(transmitterEntityID)
        self.__transmitterEntityID = transmitterEntityID
    @property # getter - - - - - - - - - -
    def transmitterRadioID(self):
        return self.__transmitterRadioID
    @transmitterRadioID.setter
    def transmitterRadioID(self, transmitterRadioID=None):
        if  transmitterRadioID is None:
            transmitterRadioID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(transmitterRadioID)
        self.__transmitterRadioID = transmitterRadioID
    @property # getter - - - - - - - - - -
    def transmitterSiteID(self):
        return self.__transmitterSiteID
    @transmitterSiteID.setter
    def transmitterSiteID(self, transmitterSiteID=None):
        if  transmitterSiteID is None:
            transmitterSiteID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(transmitterSiteID)
        self.__transmitterSiteID = transmitterSiteID
    @property # getter - - - - - - - - - -
    def whichGeometry(self):
        return self.__whichGeometry
    @whichGeometry.setter
    def whichGeometry(self, whichGeometry=None):
        if  whichGeometry is None:
            whichGeometry = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(whichGeometry)
        self.__whichGeometry = whichGeometry
    @property # getter - - - - - - - - - -
    def writeInterval(self):
        return self.__writeInterval
    @writeInterval.setter
    def writeInterval(self, writeInterval=None):
        if  writeInterval is None:
            writeInterval = SFTime.DEFAULT_VALUE
        assertValidSFTime(writeInterval)
        assertNonNegative('writeInterval', writeInterval)
        self.__writeInterval = writeInterval
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ReceiverPdu.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ReceiverPdu'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.address != 'localhost':
            result += " address='" + self.address + "'"
        if self.applicationID != 0:
            result += " applicationID='" + self.applicationID + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.entityID != 0:
            result += " entityID='" + self.entityID + "'"
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords='" + self.geoCoords + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'"
        if self.multicastRelayHost:
            result += " multicastRelayHost='" + self.multicastRelayHost + "'"
        if self.multicastRelayPort != 0:
            result += " multicastRelayPort='" + self.multicastRelayPort + "'"
        if self.networkMode != 'standAlone':
            result += " networkMode='" + self.networkMode + "'"
        if self.port != 0:
            result += " port='" + self.port + "'"
        if self.radioID != 0:
            result += " radioID='" + self.radioID + "'"
        if self.readInterval != 0.1:
            result += " readInterval='" + self.readInterval + "'"
        if self.receivedPower != 0.0:
            result += " receivedPower='" + self.receivedPower + "'"
        if self.receiverState != 0:
            result += " receiverState='" + self.receiverState + "'"
        if self.rtpHeaderExpected != False:
            result += " rtpHeaderExpected='" + self.rtpHeaderExpected + "'"
        if self.siteID != 0:
            result += " siteID='" + self.siteID + "'"
        if self.transmitterApplicationID != 0:
            result += " transmitterApplicationID='" + self.transmitterApplicationID + "'"
        if self.transmitterEntityID != 0:
            result += " transmitterEntityID='" + self.transmitterEntityID + "'"
        if self.transmitterRadioID != 0:
            result += " transmitterRadioID='" + self.transmitterRadioID + "'"
        if self.transmitterSiteID != 0:
            result += " transmitterSiteID='" + self.transmitterSiteID + "'"
        if self.whichGeometry != 1:
            result += " whichGeometry='" + self.whichGeometry + "'"
        if self.writeInterval != 1.0:
            result += " writeInterval='" + self.writeInterval + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ReceiverPdu>' + '\n'
#       print('XML serialization complete.')
        return result

class Rectangle2D(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'Rectangle2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Rectangle2D'
    FIELD_DECLARATIONS = [('size', (2, 2), FieldType.SFVec2f, AccessType.initializeOnly),
                          ('solid', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 size=(2, 2),
                 solid=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Rectangle2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.size = size
        self.solid = solid
    @property # getter - - - - - - - - - -
    def size(self):
        return self.__size
    @size.setter
    def size(self, size=None):
        if  size is None:
            size = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(size)
        assertPositive('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Rectangle2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Rectangle2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.size != (2, 2):
            result += " size='" + self.size + "'"
        if self.solid != False:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Rectangle2D>' + '\n'
#       print('XML serialization complete.')
        return result

class RigidBody(_X3DNode):
    """
    RigidBody describes a collection of shapes with a mass distribution that is affected by the physics model.
    """
    NAME = 'RigidBody'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#RigidBody'
    FIELD_DECLARATIONS = [('angularDampingFactor', 0.001, FieldType.SFFloat, AccessType.inputOutput),
                          ('angularVelocity', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('autoDamp', False, FieldType.SFBool, AccessType.inputOutput),
                          ('autoDisable', False, FieldType.SFBool, AccessType.inputOutput),
                          ('centerOfMass', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('disableAngularSpeed', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('disableLinearSpeed', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('disableTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('finiteRotationAxis', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('fixed', False, FieldType.SFBool, AccessType.inputOutput),
                          ('forces', list(), FieldType.MFVec3f, AccessType.inputOutput),
                          ('inertia', (1, 0, 0, 0, 1, 0, 0, 0, 1), FieldType.SFMatrix3f, AccessType.inputOutput),
                          ('linearDampingFactor', 0.001, FieldType.SFFloat, AccessType.inputOutput),
                          ('linearVelocity', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('mass', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('torques', list(), FieldType.MFVec3f, AccessType.inputOutput),
                          ('useFiniteRotation', False, FieldType.SFBool, AccessType.inputOutput),
                          ('useGlobalGravity', True, FieldType.SFBool, AccessType.inputOutput),
                          ('massDensityModel', None, FieldType.SFNode, AccessType.inputOutput),
                          ('geometry', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 angularDampingFactor=0.001,
                 angularVelocity=(0, 0, 0),
                 autoDamp=False,
                 autoDisable=False,
                 centerOfMass=(0, 0, 0),
                 disableAngularSpeed=0,
                 disableLinearSpeed=0,
                 disableTime=0,
                 enabled=True,
                 finiteRotationAxis=(0, 1, 0),
                 fixed=False,
                 forces=list(),
                 inertia=(1, 0, 0, 0, 1, 0, 0, 0, 1),
                 linearDampingFactor=0.001,
                 linearVelocity=(0, 0, 0),
                 mass=1,
                 orientation=(0, 0, 1, 0),
                 position=(0, 0, 0),
                 torques=list(),
                 useFiniteRotation=False,
                 useGlobalGravity=True,
                 massDensityModel=None,
                 geometry=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode RigidBody __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.angularDampingFactor = angularDampingFactor
        self.angularVelocity = angularVelocity
        self.autoDamp = autoDamp
        self.autoDisable = autoDisable
        self.centerOfMass = centerOfMass
        self.disableAngularSpeed = disableAngularSpeed
        self.disableLinearSpeed = disableLinearSpeed
        self.disableTime = disableTime
        self.enabled = enabled
        self.finiteRotationAxis = finiteRotationAxis
        self.fixed = fixed
        self.forces = forces
        self.inertia = inertia
        self.linearDampingFactor = linearDampingFactor
        self.linearVelocity = linearVelocity
        self.mass = mass
        self.orientation = orientation
        self.position = position
        self.torques = torques
        self.useFiniteRotation = useFiniteRotation
        self.useGlobalGravity = useGlobalGravity
        self.massDensityModel = massDensityModel
        self.geometry = geometry
    @property # getter - - - - - - - - - -
    def angularDampingFactor(self):
        return self.__angularDampingFactor
    @angularDampingFactor.setter
    def angularDampingFactor(self, angularDampingFactor=None):
        if  angularDampingFactor is None:
            angularDampingFactor = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(angularDampingFactor)
        self.__angularDampingFactor = angularDampingFactor
    @property # getter - - - - - - - - - -
    def angularVelocity(self):
        return self.__angularVelocity
    @angularVelocity.setter
    def angularVelocity(self, angularVelocity=None):
        if  angularVelocity is None:
            angularVelocity = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(angularVelocity)
        self.__angularVelocity = angularVelocity
    @property # getter - - - - - - - - - -
    def autoDamp(self):
        return self.__autoDamp
    @autoDamp.setter
    def autoDamp(self, autoDamp=None):
        if  autoDamp is None:
            autoDamp = SFBool.DEFAULT_VALUE
        assertValidSFBool(autoDamp)
        self.__autoDamp = autoDamp
    @property # getter - - - - - - - - - -
    def autoDisable(self):
        return self.__autoDisable
    @autoDisable.setter
    def autoDisable(self, autoDisable=None):
        if  autoDisable is None:
            autoDisable = SFBool.DEFAULT_VALUE
        assertValidSFBool(autoDisable)
        self.__autoDisable = autoDisable
    @property # getter - - - - - - - - - -
    def centerOfMass(self):
        return self.__centerOfMass
    @centerOfMass.setter
    def centerOfMass(self, centerOfMass=None):
        if  centerOfMass is None:
            centerOfMass = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(centerOfMass)
        self.__centerOfMass = centerOfMass
    @property # getter - - - - - - - - - -
    def disableAngularSpeed(self):
        return self.__disableAngularSpeed
    @disableAngularSpeed.setter
    def disableAngularSpeed(self, disableAngularSpeed=None):
        if  disableAngularSpeed is None:
            disableAngularSpeed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(disableAngularSpeed)
        self.__disableAngularSpeed = disableAngularSpeed
    @property # getter - - - - - - - - - -
    def disableLinearSpeed(self):
        return self.__disableLinearSpeed
    @disableLinearSpeed.setter
    def disableLinearSpeed(self, disableLinearSpeed=None):
        if  disableLinearSpeed is None:
            disableLinearSpeed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(disableLinearSpeed)
        self.__disableLinearSpeed = disableLinearSpeed
    @property # getter - - - - - - - - - -
    def disableTime(self):
        return self.__disableTime
    @disableTime.setter
    def disableTime(self, disableTime=None):
        if  disableTime is None:
            disableTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(disableTime)
        assertNonNegative('disableTime', disableTime)
        self.__disableTime = disableTime
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def finiteRotationAxis(self):
        return self.__finiteRotationAxis
    @finiteRotationAxis.setter
    def finiteRotationAxis(self, finiteRotationAxis=None):
        if  finiteRotationAxis is None:
            finiteRotationAxis = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(finiteRotationAxis)
        self.__finiteRotationAxis = finiteRotationAxis
    @property # getter - - - - - - - - - -
    def fixed(self):
        return self.__fixed
    @fixed.setter
    def fixed(self, fixed=None):
        if  fixed is None:
            fixed = SFBool.DEFAULT_VALUE
        assertValidSFBool(fixed)
        self.__fixed = fixed
    @property # getter - - - - - - - - - -
    def forces(self):
        return self.__forces
    @forces.setter
    def forces(self, forces=None):
        if  forces is None:
            forces = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(forces)
        self.__forces = forces
    @property # getter - - - - - - - - - -
    def inertia(self):
        return self.__inertia
    @inertia.setter
    def inertia(self, inertia=None):
        if  inertia is None:
            inertia = SFMatrix3f.DEFAULT_VALUE
        assertValidSFMatrix3f(inertia)
        self.__inertia = inertia
    @property # getter - - - - - - - - - -
    def linearDampingFactor(self):
        return self.__linearDampingFactor
    @linearDampingFactor.setter
    def linearDampingFactor(self, linearDampingFactor=None):
        if  linearDampingFactor is None:
            linearDampingFactor = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(linearDampingFactor)
        self.__linearDampingFactor = linearDampingFactor
    @property # getter - - - - - - - - - -
    def linearVelocity(self):
        return self.__linearVelocity
    @linearVelocity.setter
    def linearVelocity(self, linearVelocity=None):
        if  linearVelocity is None:
            linearVelocity = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(linearVelocity)
        self.__linearVelocity = linearVelocity
    @property # getter - - - - - - - - - -
    def mass(self):
        return self.__mass
    @mass.setter
    def mass(self, mass=None):
        if  mass is None:
            mass = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def orientation(self):
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation=None):
        if  orientation is None:
            orientation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def position(self):
        return self.__position
    @position.setter
    def position(self, position=None):
        if  position is None:
            position = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def torques(self):
        return self.__torques
    @torques.setter
    def torques(self, torques=None):
        if  torques is None:
            torques = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(torques)
        self.__torques = torques
    @property # getter - - - - - - - - - -
    def useFiniteRotation(self):
        return self.__useFiniteRotation
    @useFiniteRotation.setter
    def useFiniteRotation(self, useFiniteRotation=None):
        if  useFiniteRotation is None:
            useFiniteRotation = SFBool.DEFAULT_VALUE
        assertValidSFBool(useFiniteRotation)
        self.__useFiniteRotation = useFiniteRotation
    @property # getter - - - - - - - - - -
    def useGlobalGravity(self):
        return self.__useGlobalGravity
    @useGlobalGravity.setter
    def useGlobalGravity(self, useGlobalGravity=None):
        if  useGlobalGravity is None:
            useGlobalGravity = SFBool.DEFAULT_VALUE
        assertValidSFBool(useGlobalGravity)
        self.__useGlobalGravity = useGlobalGravity
    @property # getter - - - - - - - - - -
    def massDensityModel(self):
        return self.__massDensityModel
    @massDensityModel.setter
    def massDensityModel(self, massDensityModel=None):
        if  massDensityModel is None:
            massDensityModel = SFNode.DEFAULT_VALUE
        assertValidSFNode(massDensityModel)
        if not isinstance(massDensityModel, object):
            print(flush=True)
            raise TypeError(str(massDensityModel) + ' does not have a valid node type object')
        self.__massDensityModel = massDensityModel
    @property # getter - - - - - - - - - -
    def geometry(self):
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry=None):
        if  geometry is None:
            geometry = MFNode.DEFAULT_VALUE
        assertValidMFNode(geometry)
        self.__geometry = geometry
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function RigidBody.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<RigidBody'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.angularDampingFactor != 0.001:
            result += " angularDampingFactor='" + self.angularDampingFactor + "'"
        if self.angularVelocity != (0, 0, 0):
            result += " angularVelocity='" + self.angularVelocity + "'"
        if self.autoDamp != False:
            result += " autoDamp='" + self.autoDamp + "'"
        if self.autoDisable != False:
            result += " autoDisable='" + self.autoDisable + "'"
        if self.centerOfMass != (0, 0, 0):
            result += " centerOfMass='" + self.centerOfMass + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.disableAngularSpeed != 0:
            result += " disableAngularSpeed='" + self.disableAngularSpeed + "'"
        if self.disableLinearSpeed != 0:
            result += " disableLinearSpeed='" + self.disableLinearSpeed + "'"
        if self.disableTime != 0:
            result += " disableTime='" + self.disableTime + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.finiteRotationAxis != (0, 1, 0):
            result += " finiteRotationAxis='" + self.finiteRotationAxis + "'"
        if self.fixed != False:
            result += " fixed='" + self.fixed + "'"
        if self.forces != list():
            result += " forces='" + self.forces + "'"
        if self.inertia != (1, 0, 0, 0, 1, 0, 0, 0, 1):
            result += " inertia='" + self.inertia + "'"
        if self.linearDampingFactor != 0.001:
            result += " linearDampingFactor='" + self.linearDampingFactor + "'"
        if self.linearVelocity != (0, 0, 0):
            result += " linearVelocity='" + self.linearVelocity + "'"
        if self.mass != 1:
            result += " mass='" + self.mass + "'"
        if self.orientation != (0, 0, 1, 0):
            result += " orientation='" + self.orientation + "'"
        if self.position != (0, 0, 0):
            result += " position='" + self.position + "'"
        if self.torques != list():
            result += " torques='" + self.torques + "'"
        if self.useFiniteRotation != False:
            result += " useFiniteRotation='" + self.useFiniteRotation + "'"
        if self.useGlobalGravity != True:
            result += " useGlobalGravity='" + self.useGlobalGravity + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.massDensityModel: # walk each child node, if any
            result += indent
            for each in self.massDensityModel:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geometry: # walk each child node, if any
            result += indent
            for each in self.geometry:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</RigidBody>' + '\n'
#       print('XML serialization complete.')
        return result

class RigidBodyCollection(_X3DChildNode):
    """
    RigidBodyCollection represents a system of bodies that interact within a single physics model.
    """
    NAME = 'RigidBodyCollection'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#RigidBodyCollection'
    FIELD_DECLARATIONS = [('autoDisable', False, FieldType.SFBool, AccessType.inputOutput),
                          ('constantForceMix', 0.0001, FieldType.SFFloat, AccessType.inputOutput),
                          ('contactSurfaceThickness', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('disableAngularSpeed', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('disableLinearSpeed', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('disableTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('errorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput),
                          ('gravity', (0, -9.8, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('iterations', 10, FieldType.SFInt32, AccessType.inputOutput),
                          ('maxCorrectionSpeed', -1, FieldType.SFFloat, AccessType.inputOutput),
                          ('preferAccuracy', False, FieldType.SFBool, AccessType.inputOutput),
                          ('collider', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('bodies', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('joints', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 autoDisable=False,
                 constantForceMix=0.0001,
                 contactSurfaceThickness=0,
                 disableAngularSpeed=0,
                 disableLinearSpeed=0,
                 disableTime=0,
                 enabled=True,
                 errorCorrection=0.8,
                 gravity=(0, -9.8, 0),
                 iterations=10,
                 maxCorrectionSpeed=-1,
                 preferAccuracy=False,
                 collider=None,
                 bodies=list(),
                 joints=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode RigidBodyCollection __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.autoDisable = autoDisable
        self.constantForceMix = constantForceMix
        self.contactSurfaceThickness = contactSurfaceThickness
        self.disableAngularSpeed = disableAngularSpeed
        self.disableLinearSpeed = disableLinearSpeed
        self.disableTime = disableTime
        self.enabled = enabled
        self.errorCorrection = errorCorrection
        self.gravity = gravity
        self.iterations = iterations
        self.maxCorrectionSpeed = maxCorrectionSpeed
        self.preferAccuracy = preferAccuracy
        self.collider = collider
        self.bodies = bodies
        self.joints = joints
    @property # getter - - - - - - - - - -
    def autoDisable(self):
        return self.__autoDisable
    @autoDisable.setter
    def autoDisable(self, autoDisable=None):
        if  autoDisable is None:
            autoDisable = SFBool.DEFAULT_VALUE
        assertValidSFBool(autoDisable)
        self.__autoDisable = autoDisable
    @property # getter - - - - - - - - - -
    def constantForceMix(self):
        return self.__constantForceMix
    @constantForceMix.setter
    def constantForceMix(self, constantForceMix=None):
        if  constantForceMix is None:
            constantForceMix = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(constantForceMix)
        self.__constantForceMix = constantForceMix
    @property # getter - - - - - - - - - -
    def contactSurfaceThickness(self):
        return self.__contactSurfaceThickness
    @contactSurfaceThickness.setter
    def contactSurfaceThickness(self, contactSurfaceThickness=None):
        if  contactSurfaceThickness is None:
            contactSurfaceThickness = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(contactSurfaceThickness)
        self.__contactSurfaceThickness = contactSurfaceThickness
    @property # getter - - - - - - - - - -
    def disableAngularSpeed(self):
        return self.__disableAngularSpeed
    @disableAngularSpeed.setter
    def disableAngularSpeed(self, disableAngularSpeed=None):
        if  disableAngularSpeed is None:
            disableAngularSpeed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(disableAngularSpeed)
        self.__disableAngularSpeed = disableAngularSpeed
    @property # getter - - - - - - - - - -
    def disableLinearSpeed(self):
        return self.__disableLinearSpeed
    @disableLinearSpeed.setter
    def disableLinearSpeed(self, disableLinearSpeed=None):
        if  disableLinearSpeed is None:
            disableLinearSpeed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(disableLinearSpeed)
        self.__disableLinearSpeed = disableLinearSpeed
    @property # getter - - - - - - - - - -
    def disableTime(self):
        return self.__disableTime
    @disableTime.setter
    def disableTime(self, disableTime=None):
        if  disableTime is None:
            disableTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(disableTime)
        assertNonNegative('disableTime', disableTime)
        self.__disableTime = disableTime
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def errorCorrection(self):
        return self.__errorCorrection
    @errorCorrection.setter
    def errorCorrection(self, errorCorrection=None):
        if  errorCorrection is None:
            errorCorrection = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(errorCorrection)
        self.__errorCorrection = errorCorrection
    @property # getter - - - - - - - - - -
    def gravity(self):
        return self.__gravity
    @gravity.setter
    def gravity(self, gravity=None):
        if  gravity is None:
            gravity = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(gravity)
        self.__gravity = gravity
    @property # getter - - - - - - - - - -
    def iterations(self):
        return self.__iterations
    @iterations.setter
    def iterations(self, iterations=None):
        if  iterations is None:
            iterations = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(iterations)
        self.__iterations = iterations
    @property # getter - - - - - - - - - -
    def maxCorrectionSpeed(self):
        return self.__maxCorrectionSpeed
    @maxCorrectionSpeed.setter
    def maxCorrectionSpeed(self, maxCorrectionSpeed=None):
        if  maxCorrectionSpeed is None:
            maxCorrectionSpeed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(maxCorrectionSpeed)
        self.__maxCorrectionSpeed = maxCorrectionSpeed
    @property # getter - - - - - - - - - -
    def preferAccuracy(self):
        return self.__preferAccuracy
    @preferAccuracy.setter
    def preferAccuracy(self, preferAccuracy=None):
        if  preferAccuracy is None:
            preferAccuracy = SFBool.DEFAULT_VALUE
        assertValidSFBool(preferAccuracy)
        self.__preferAccuracy = preferAccuracy
    @property # getter - - - - - - - - - -
    def collider(self):
        return self.__collider
    @collider.setter
    def collider(self, collider=None):
        if  collider is None:
            collider = SFNode.DEFAULT_VALUE
        assertValidSFNode(collider)
        if not isinstance(collider, object):
            print(flush=True)
            raise TypeError(str(collider) + ' does not have a valid node type object')
        self.__collider = collider
    @property # getter - - - - - - - - - -
    def bodies(self):
        return self.__bodies
    @bodies.setter
    def bodies(self, bodies=None):
        if  bodies is None:
            bodies = MFNode.DEFAULT_VALUE
        assertValidMFNode(bodies)
        self.__bodies = bodies
    @property # getter - - - - - - - - - -
    def joints(self):
        return self.__joints
    @joints.setter
    def joints(self, joints=None):
        if  joints is None:
            joints = MFNode.DEFAULT_VALUE
        assertValidMFNode(joints)
        self.__joints = joints
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function RigidBodyCollection.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<RigidBodyCollection'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.autoDisable != False:
            result += " autoDisable='" + self.autoDisable + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.constantForceMix != 0.0001:
            result += " constantForceMix='" + self.constantForceMix + "'"
        if self.contactSurfaceThickness != 0:
            result += " contactSurfaceThickness='" + self.contactSurfaceThickness + "'"
        if self.disableAngularSpeed != 0:
            result += " disableAngularSpeed='" + self.disableAngularSpeed + "'"
        if self.disableLinearSpeed != 0:
            result += " disableLinearSpeed='" + self.disableLinearSpeed + "'"
        if self.disableTime != 0:
            result += " disableTime='" + self.disableTime + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.errorCorrection != 0.8:
            result += " errorCorrection='" + self.errorCorrection + "'"
        if self.gravity != (0, -9.8, 0):
            result += " gravity='" + self.gravity + "'"
        if self.iterations != 10:
            result += " iterations='" + self.iterations + "'"
        if self.maxCorrectionSpeed != -1:
            result += " maxCorrectionSpeed='" + self.maxCorrectionSpeed + "'"
        if self.preferAccuracy != False:
            result += " preferAccuracy='" + self.preferAccuracy + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.collider: # walk each child node, if any
            result += indent
            for each in self.collider:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.bodies: # walk each child node, if any
            result += indent
            for each in self.bodies:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.joints: # walk each child node, if any
            result += indent
            for each in self.joints:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</RigidBodyCollection>' + '\n'
#       print('XML serialization complete.')
        return result

class ScalarChaser(_X3DChaserNode):
    """
    X3D element
    """
    NAME = 'ScalarChaser'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScalarChaser'
    FIELD_DECLARATIONS = [('duration', 1, FieldType.SFTime, AccessType.initializeOnly),
                          ('initialDestination', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('initialValue', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 duration=1,
                 initialDestination=0,
                 initialValue=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ScalarChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        return self.__duration
    @duration.setter
    def duration(self, duration=None):
        if  duration is None:
            duration = SFTime.DEFAULT_VALUE
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(initialValue)
        self.__initialValue = initialValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ScalarChaser.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ScalarChaser'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + self.duration + "'"
        if self.initialDestination != 0:
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != 0:
            result += " initialValue='" + self.initialValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ScalarChaser>' + '\n'
#       print('XML serialization complete.')
        return result

class ScalarDamper(_X3DDamperNode):
    """
    X3D element
    """
    NAME = 'ScalarDamper'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScalarDamper'
    FIELD_DECLARATIONS = [('initialDestination', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('initialValue', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('order', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput),
                          ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 initialDestination=0,
                 initialValue=0,
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ScalarDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        return self.__order
    @order.setter
    def order(self, order=None):
        if  order is None:
            order = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        return self.__tau
    @tau.setter
    def tau(self, tau=None):
        if  tau is None:
            tau = SFTime.DEFAULT_VALUE
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance=None):
        if  tolerance is None:
            tolerance = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ScalarDamper.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ScalarDamper'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != 0:
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != 0:
            result += " initialValue='" + self.initialValue + "'"
        if self.order != 3:
            result += " order='" + self.order + "'"
        if self.tau != 0.3:
            result += " tau='" + self.tau + "'"
        if self.tolerance != -1:
            result += " tolerance='" + self.tolerance + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ScalarDamper>' + '\n'
#       print('XML serialization complete.')
        return result

class ScalarInterpolator(_X3DInterpolatorNode):
    """
    X3D element
    """
    NAME = 'ScalarInterpolator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScalarInterpolator'
    FIELD_DECLARATIONS = [('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ScalarInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(keyValue)
        self.__keyValue = keyValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ScalarInterpolator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ScalarInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ScalarInterpolator>' + '\n'
#       print('XML serialization complete.')
        return result

class ScreenFontStyle(_X3DFontStyleNode):
    """
    X3D element
    """
    NAME = 'ScreenFontStyle'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScreenFontStyle'
    FIELD_DECLARATIONS = [('family', ["SERIF"], FieldType.MFString, AccessType.initializeOnly),
                          ('horizontal', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('justify', ["BEGIN"], FieldType.MFString, AccessType.initializeOnly),
                          ('language', '', FieldType.SFString, AccessType.initializeOnly),
                          ('leftToRight', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('pointSize', 12.0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('spacing', 1.0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('style', 'PLAIN', FieldType.SFString, AccessType.initializeOnly),
                          ('topToBottom', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 family=["SERIF"],
                 horizontal=True,
                 justify=["BEGIN"],
                 language='',
                 leftToRight=True,
                 pointSize=12.0,
                 spacing=1.0,
                 style='PLAIN',
                 topToBottom=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ScreenFontStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.family = family
        self.horizontal = horizontal
        self.justify = justify
        self.language = language
        self.leftToRight = leftToRight
        self.pointSize = pointSize
        self.spacing = spacing
        self.style = style
        self.topToBottom = topToBottom
    @property # getter - - - - - - - - - -
    def family(self):
        return self.__family
    @family.setter
    def family(self, family=None):
        if  family is None:
            family = MFString.DEFAULT_VALUE
        assertValidMFString(family)
        self.__family = family
    @property # getter - - - - - - - - - -
    def horizontal(self):
        return self.__horizontal
    @horizontal.setter
    def horizontal(self, horizontal=None):
        if  horizontal is None:
            horizontal = SFBool.DEFAULT_VALUE
        assertValidSFBool(horizontal)
        self.__horizontal = horizontal
    @property # getter - - - - - - - - - -
    def justify(self):
        return self.__justify
    @justify.setter
    def justify(self, justify=None):
        if  justify is None:
            justify = MFString.DEFAULT_VALUE
        assertValidMFString(justify)
        self.__justify = justify
    @property # getter - - - - - - - - - -
    def language(self):
        return self.__language
    @language.setter
    def language(self, language=None):
        if  language is None:
            language = SFString.DEFAULT_VALUE
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def leftToRight(self):
        return self.__leftToRight
    @leftToRight.setter
    def leftToRight(self, leftToRight=None):
        if  leftToRight is None:
            leftToRight = SFBool.DEFAULT_VALUE
        assertValidSFBool(leftToRight)
        self.__leftToRight = leftToRight
    @property # getter - - - - - - - - - -
    def pointSize(self):
        return self.__pointSize
    @pointSize.setter
    def pointSize(self, pointSize=None):
        if  pointSize is None:
            pointSize = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(pointSize)
        assertPositive('pointSize', pointSize)
        self.__pointSize = pointSize
    @property # getter - - - - - - - - - -
    def spacing(self):
        return self.__spacing
    @spacing.setter
    def spacing(self, spacing=None):
        if  spacing is None:
            spacing = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(spacing)
        assertNonNegative('spacing', spacing)
        self.__spacing = spacing
    @property # getter - - - - - - - - - -
    def style(self):
        return self.__style
    @style.setter
    def style(self, style=None):
        if  style is None:
            style = SFString.DEFAULT_VALUE
        assertValidSFString(style)
        self.__style = style
    @property # getter - - - - - - - - - -
    def topToBottom(self):
        return self.__topToBottom
    @topToBottom.setter
    def topToBottom(self, topToBottom=None):
        if  topToBottom is None:
            topToBottom = SFBool.DEFAULT_VALUE
        assertValidSFBool(topToBottom)
        self.__topToBottom = topToBottom
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ScreenFontStyle.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ScreenFontStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.family != ["SERIF"]:
            result += " family='" + self.family + "'"
        if self.horizontal != True:
            result += " horizontal='" + self.horizontal + "'"
        if self.justify != ["BEGIN"]:
            result += " justify='" + self.justify + "'"
        if self.language:
            result += " language='" + self.language + "'"
        if self.leftToRight != True:
            result += " leftToRight='" + self.leftToRight + "'"
        if self.pointSize != 12.0:
            result += " pointSize='" + self.pointSize + "'"
        if self.spacing != 1.0:
            result += " spacing='" + self.spacing + "'"
        if self.style != 'PLAIN':
            result += " style='" + self.style + "'"
        if self.topToBottom != True:
            result += " topToBottom='" + self.topToBottom + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ScreenFontStyle>' + '\n'
#       print('XML serialization complete.')
        return result

class ScreenGroup(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'ScreenGroup'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScreenGroup'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ScreenGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ScreenGroup.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ScreenGroup'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ScreenGroup>' + '\n'
#       print('XML serialization complete.')
        return result

class Script(_X3DScriptNode):
    """
    X3D element
    """
    NAME = 'Script'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Script'
    FIELD_DECLARATIONS = [('directOutput', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('mustEvaluate', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('field', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 directOutput=False,
                 mustEvaluate=False,
                 url=list(),
                 field=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Script __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.directOutput = directOutput
        self.mustEvaluate = mustEvaluate
        self.url = url
        self.field = field
    @property # getter - - - - - - - - - -
    def directOutput(self):
        return self.__directOutput
    @directOutput.setter
    def directOutput(self, directOutput=None):
        if  directOutput is None:
            directOutput = SFBool.DEFAULT_VALUE
        assertValidSFBool(directOutput)
        self.__directOutput = directOutput
    @property # getter - - - - - - - - - -
    def mustEvaluate(self):
        return self.__mustEvaluate
    @mustEvaluate.setter
    def mustEvaluate(self, mustEvaluate=None):
        if  mustEvaluate is None:
            mustEvaluate = SFBool.DEFAULT_VALUE
        assertValidSFBool(mustEvaluate)
        self.__mustEvaluate = mustEvaluate
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def field(self):
        return self.__field
    @field.setter
    def field(self, field=None):
        if  field is None:
            field = MFNode.DEFAULT_VALUE
        assertValidMFNode(field)
        self.__field = field
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Script.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Script'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.directOutput != False:
            result += " directOutput='" + self.directOutput + "'"
        if self.mustEvaluate != False:
            result += " mustEvaluate='" + self.mustEvaluate + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.field: # walk each child node, if any
            result += indent
            for each in self.field:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Script>' + '\n'
#       print('XML serialization complete.')
        return result

class SegmentedVolumeData(_X3DVolumeDataNode):
    """
    X3D element
    """
    NAME = 'SegmentedVolumeData'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SegmentedVolumeData'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('dimensions', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('segmentEnabled', list(), FieldType.MFBool, AccessType.inputOutput),
                          ('segmentIdentifiers', None, FieldType.SFNode, AccessType.inputOutput),
                          ('voxels', None, FieldType.SFNode, AccessType.inputOutput),
                          ('renderStyle', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 dimensions=(1, 1, 1),
                 segmentEnabled=list(),
                 segmentIdentifiers=None,
                 voxels=None,
                 renderStyle=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SegmentedVolumeData __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.dimensions = dimensions
        self.segmentEnabled = segmentEnabled
        self.segmentIdentifiers = segmentIdentifiers
        self.voxels = voxels
        self.renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def dimensions(self):
        return self.__dimensions
    @dimensions.setter
    def dimensions(self, dimensions=None):
        if  dimensions is None:
            dimensions = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(dimensions)
        assertPositive('dimensions', dimensions)
        self.__dimensions = dimensions
    @property # getter - - - - - - - - - -
    def segmentEnabled(self):
        return self.__segmentEnabled
    @segmentEnabled.setter
    def segmentEnabled(self, segmentEnabled=None):
        if  segmentEnabled is None:
            segmentEnabled = MFBool.DEFAULT_VALUE
        assertValidMFBool(segmentEnabled)
        self.__segmentEnabled = segmentEnabled
    @property # getter - - - - - - - - - -
    def segmentIdentifiers(self):
        return self.__segmentIdentifiers
    @segmentIdentifiers.setter
    def segmentIdentifiers(self, segmentIdentifiers=None):
        if  segmentIdentifiers is None:
            segmentIdentifiers = SFNode.DEFAULT_VALUE
        assertValidSFNode(segmentIdentifiers)
        if not isinstance(segmentIdentifiers, object):
            print(flush=True)
            raise TypeError(str(segmentIdentifiers) + ' does not have a valid node type object')
        self.__segmentIdentifiers = segmentIdentifiers
    @property # getter - - - - - - - - - -
    def voxels(self):
        return self.__voxels
    @voxels.setter
    def voxels(self, voxels=None):
        if  voxels is None:
            voxels = SFNode.DEFAULT_VALUE
        assertValidSFNode(voxels)
        if not isinstance(voxels, object):
            print(flush=True)
            raise TypeError(str(voxels) + ' does not have a valid node type object')
        self.__voxels = voxels
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle=None):
        if  renderStyle is None:
            renderStyle = MFNode.DEFAULT_VALUE
        assertValidMFNode(renderStyle)
        self.__renderStyle = renderStyle
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function SegmentedVolumeData.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<SegmentedVolumeData'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.dimensions != (1, 1, 1):
            result += " dimensions='" + self.dimensions + "'"
        if self.segmentEnabled != list():
            result += " segmentEnabled='" + self.segmentEnabled + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.segmentIdentifiers: # walk each child node, if any
            result += indent
            for each in self.segmentIdentifiers:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.voxels: # walk each child node, if any
            result += indent
            for each in self.voxels:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.renderStyle: # walk each child node, if any
            result += indent
            for each in self.renderStyle:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</SegmentedVolumeData>' + '\n'
#       print('XML serialization complete.')
        return result

class ShadedVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    All fields fully supported except shadows supported with at least Phong shading at level 3. All fields fully supported with at least Phong shading and Henyey-Greenstein phase function, shadows fully supported at level 4.
    """
    NAME = 'ShadedVolumeStyle'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ShadedVolumeStyle'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('lighting', False, FieldType.SFBool, AccessType.inputOutput),
                          ('phaseFunction', 'Henyey-Greenstein', FieldType.SFString, AccessType.initializeOnly),
                          ('shadows', False, FieldType.SFBool, AccessType.inputOutput),
                          ('material', None, FieldType.SFNode, AccessType.inputOutput),
                          ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 lighting=False,
                 phaseFunction='Henyey-Greenstein',
                 shadows=False,
                 material=None,
                 surfaceNormals=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ShadedVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.lighting = lighting
        self.phaseFunction = phaseFunction
        self.shadows = shadows
        self.material = material
        self.surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def lighting(self):
        return self.__lighting
    @lighting.setter
    def lighting(self, lighting=None):
        if  lighting is None:
            lighting = SFBool.DEFAULT_VALUE
        assertValidSFBool(lighting)
        self.__lighting = lighting
    @property # getter - - - - - - - - - -
    def phaseFunction(self):
        return self.__phaseFunction
    @phaseFunction.setter
    def phaseFunction(self, phaseFunction=None):
        if  phaseFunction is None:
            phaseFunction = SFString.DEFAULT_VALUE
        assertValidSFString(phaseFunction)
        self.__phaseFunction = phaseFunction
    @property # getter - - - - - - - - - -
    def shadows(self):
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows=None):
        if  shadows is None:
            shadows = SFBool.DEFAULT_VALUE
        assertValidSFBool(shadows)
        self.__shadows = shadows
    @property # getter - - - - - - - - - -
    def material(self):
        return self.__material
    @material.setter
    def material(self, material=None):
        if  material is None:
            material = SFNode.DEFAULT_VALUE
        assertValidSFNode(material)
        if not isinstance(material, object):
            print(flush=True)
            raise TypeError(str(material) + ' does not have a valid node type object')
        self.__material = material
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals=None):
        if  surfaceNormals is None:
            surfaceNormals = SFNode.DEFAULT_VALUE
        assertValidSFNode(surfaceNormals)
        if not isinstance(surfaceNormals, object):
            print(flush=True)
            raise TypeError(str(surfaceNormals) + ' does not have a valid node type object')
        self.__surfaceNormals = surfaceNormals
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ShadedVolumeStyle.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ShadedVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.lighting != False:
            result += " lighting='" + self.lighting + "'"
        if self.phaseFunction != 'Henyey-Greenstein':
            result += " phaseFunction='" + self.phaseFunction + "'"
        if self.shadows != False:
            result += " shadows='" + self.shadows + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.material: # walk each child node, if any
            result += indent
            for each in self.material:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.surfaceNormals: # walk each child node, if any
            result += indent
            for each in self.surfaceNormals:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ShadedVolumeStyle>' + '\n'
#       print('XML serialization complete.')
        return result

class ShaderPart(_X3DNode):
    """
    ShaderPart can contain a CDATA section of plain-text source code.
    """
    NAME = 'ShaderPart'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ShaderPart'
    FIELD_DECLARATIONS = [('type', 'VERTEX', FieldType.SFString, AccessType.inputOutput),
                          ('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 type='VERTEX',
                 url=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ShaderPart __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.type = type
        self.url = url
    @property # getter - - - - - - - - - -
    def type(self):
        return self.__type
    @type.setter
    def type(self, type=None):
        if  type is None:
            type = SFString.DEFAULT_VALUE
        assertValidSFString(type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ShaderPart.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ShaderPart'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.type != 'VERTEX':
            result += " type='" + self.type + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ShaderPart>' + '\n'
#       print('XML serialization complete.')
        return result

class ShaderProgram(_X3DNode):
    """
    ShaderProgram can contain field declarations and a CDATA section of plain-text source code.
    """
    NAME = 'ShaderProgram'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ShaderProgram'
    FIELD_DECLARATIONS = [('type', 'VERTEX', FieldType.SFString, AccessType.inputOutput),
                          ('url', list(), FieldType.MFString, AccessType.inputOutput),
                          ('field', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 type='VERTEX',
                 url=list(),
                 field=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ShaderProgram __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.type = type
        self.url = url
        self.field = field
    @property # getter - - - - - - - - - -
    def type(self):
        return self.__type
    @type.setter
    def type(self, type=None):
        if  type is None:
            type = SFString.DEFAULT_VALUE
        assertValidSFString(type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def url(self):
        return self.__url
    @url.setter
    def url(self, url=None):
        if  url is None:
            url = MFString.DEFAULT_VALUE
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def field(self):
        return self.__field
    @field.setter
    def field(self, field=None):
        if  field is None:
            field = MFNode.DEFAULT_VALUE
        assertValidMFNode(field)
        self.__field = field
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ShaderProgram.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ShaderProgram'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.type != 'VERTEX':
            result += " type='" + self.type + "'"
        if self.url != list():
            result += " url='" + self.url + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.field: # walk each child node, if any
            result += indent
            for each in self.field:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ShaderProgram>' + '\n'
#       print('XML serialization complete.')
        return result

class Shape(_X3DShapeNode):
    """
    X3D element
    """
    NAME = 'Shape'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Shape'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('appearance', None, FieldType.SFNode, AccessType.inputOutput),
                          ('geometry', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 appearance=None,
                 geometry=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Shape __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.appearance = appearance
        self.geometry = geometry
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def appearance(self):
        return self.__appearance
    @appearance.setter
    def appearance(self, appearance=None):
        if  appearance is None:
            appearance = SFNode.DEFAULT_VALUE
        assertValidSFNode(appearance)
        if not isinstance(appearance, object):
            print(flush=True)
            raise TypeError(str(appearance) + ' does not have a valid node type object')
        self.__appearance = appearance
    @property # getter - - - - - - - - - -
    def geometry(self):
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry=None):
        if  geometry is None:
            geometry = SFNode.DEFAULT_VALUE
        assertValidSFNode(geometry)
        if not isinstance(geometry, object):
            print(flush=True)
            raise TypeError(str(geometry) + ' does not have a valid node type object')
        self.__geometry = geometry
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Shape.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Shape'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.appearance: # walk each child node, if any
            result += indent
            for each in self.appearance:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.geometry: # walk each child node, if any
            result += indent
            for each in self.geometry:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Shape>' + '\n'
#       print('XML serialization complete.')
        return result

class SignalPdu(_X3DNetworkSensorNode):
    """
    X3D element
    """
    NAME = 'SignalPdu'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SignalPdu'
    FIELD_DECLARATIONS = [('address', 'localhost', FieldType.SFString, AccessType.inputOutput),
                          ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('data', list(), FieldType.MFInt32, AccessType.inputOutput),
                          ('dataLength', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('encodingScheme', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('entityID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput),
                          ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('multicastRelayHost', '', FieldType.SFString, AccessType.inputOutput),
                          ('multicastRelayPort', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('networkMode', 'standAlone', FieldType.SFString, AccessType.inputOutput),
                          ('port', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('radioID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('readInterval', 0.1, FieldType.SFTime, AccessType.inputOutput),
                          ('rtpHeaderExpected', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('sampleRate', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('samples', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('tdlType', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('whichGeometry', 1, FieldType.SFInt32, AccessType.inputOutput),
                          ('writeInterval', 1.0, FieldType.SFTime, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 address='localhost',
                 applicationID=0,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 data=list(),
                 dataLength=0,
                 enabled=True,
                 encodingScheme=0,
                 entityID=0,
                 geoCoords=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 multicastRelayHost='',
                 multicastRelayPort=0,
                 networkMode='standAlone',
                 port=0,
                 radioID=0,
                 readInterval=0.1,
                 rtpHeaderExpected=False,
                 sampleRate=0,
                 samples=0,
                 siteID=0,
                 tdlType=0,
                 whichGeometry=1,
                 writeInterval=1.0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SignalPdu __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.applicationID = applicationID
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.data = data
        self.dataLength = dataLength
        self.enabled = enabled
        self.encodingScheme = encodingScheme
        self.entityID = entityID
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.multicastRelayHost = multicastRelayHost
        self.multicastRelayPort = multicastRelayPort
        self.networkMode = networkMode
        self.port = port
        self.radioID = radioID
        self.readInterval = readInterval
        self.rtpHeaderExpected = rtpHeaderExpected
        self.sampleRate = sampleRate
        self.samples = samples
        self.siteID = siteID
        self.tdlType = tdlType
        self.whichGeometry = whichGeometry
        self.writeInterval = writeInterval
    @property # getter - - - - - - - - - -
    def address(self):
        return self.__address
    @address.setter
    def address(self, address=None):
        if  address is None:
            address = SFString.DEFAULT_VALUE
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def applicationID(self):
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID=None):
        if  applicationID is None:
            applicationID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def data(self):
        return self.__data
    @data.setter
    def data(self, data=None):
        if  data is None:
            data = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(data)
        self.__data = data
    @property # getter - - - - - - - - - -
    def dataLength(self):
        return self.__dataLength
    @dataLength.setter
    def dataLength(self, dataLength=None):
        if  dataLength is None:
            dataLength = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(dataLength)
        self.__dataLength = dataLength
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def encodingScheme(self):
        return self.__encodingScheme
    @encodingScheme.setter
    def encodingScheme(self, encodingScheme=None):
        if  encodingScheme is None:
            encodingScheme = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(encodingScheme)
        self.__encodingScheme = encodingScheme
    @property # getter - - - - - - - - - -
    def entityID(self):
        return self.__entityID
    @entityID.setter
    def entityID(self, entityID=None):
        if  entityID is None:
            entityID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(entityID)
        self.__entityID = entityID
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords=None):
        if  geoCoords is None:
            geoCoords = SFVec3d.DEFAULT_VALUE
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def multicastRelayHost(self):
        return self.__multicastRelayHost
    @multicastRelayHost.setter
    def multicastRelayHost(self, multicastRelayHost=None):
        if  multicastRelayHost is None:
            multicastRelayHost = SFString.DEFAULT_VALUE
        assertValidSFString(multicastRelayHost)
        self.__multicastRelayHost = multicastRelayHost
    @property # getter - - - - - - - - - -
    def multicastRelayPort(self):
        return self.__multicastRelayPort
    @multicastRelayPort.setter
    def multicastRelayPort(self, multicastRelayPort=None):
        if  multicastRelayPort is None:
            multicastRelayPort = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(multicastRelayPort)
        self.__multicastRelayPort = multicastRelayPort
    @property # getter - - - - - - - - - -
    def networkMode(self):
        return self.__networkMode
    @networkMode.setter
    def networkMode(self, networkMode=None):
        if  networkMode is None:
            networkMode = SFString.DEFAULT_VALUE
        assertValidSFString(networkMode)
        self.__networkMode = networkMode
    @property # getter - - - - - - - - - -
    def port(self):
        return self.__port
    @port.setter
    def port(self, port=None):
        if  port is None:
            port = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def radioID(self):
        return self.__radioID
    @radioID.setter
    def radioID(self, radioID=None):
        if  radioID is None:
            radioID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(radioID)
        self.__radioID = radioID
    @property # getter - - - - - - - - - -
    def readInterval(self):
        return self.__readInterval
    @readInterval.setter
    def readInterval(self, readInterval=None):
        if  readInterval is None:
            readInterval = SFTime.DEFAULT_VALUE
        assertValidSFTime(readInterval)
        assertNonNegative('readInterval', readInterval)
        self.__readInterval = readInterval
    @property # getter - - - - - - - - - -
    def rtpHeaderExpected(self):
        return self.__rtpHeaderExpected
    @rtpHeaderExpected.setter
    def rtpHeaderExpected(self, rtpHeaderExpected=None):
        if  rtpHeaderExpected is None:
            rtpHeaderExpected = SFBool.DEFAULT_VALUE
        assertValidSFBool(rtpHeaderExpected)
        self.__rtpHeaderExpected = rtpHeaderExpected
    @property # getter - - - - - - - - - -
    def sampleRate(self):
        return self.__sampleRate
    @sampleRate.setter
    def sampleRate(self, sampleRate=None):
        if  sampleRate is None:
            sampleRate = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(sampleRate)
        self.__sampleRate = sampleRate
    @property # getter - - - - - - - - - -
    def samples(self):
        return self.__samples
    @samples.setter
    def samples(self, samples=None):
        if  samples is None:
            samples = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(samples)
        self.__samples = samples
    @property # getter - - - - - - - - - -
    def siteID(self):
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID=None):
        if  siteID is None:
            siteID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def tdlType(self):
        return self.__tdlType
    @tdlType.setter
    def tdlType(self, tdlType=None):
        if  tdlType is None:
            tdlType = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(tdlType)
        self.__tdlType = tdlType
    @property # getter - - - - - - - - - -
    def whichGeometry(self):
        return self.__whichGeometry
    @whichGeometry.setter
    def whichGeometry(self, whichGeometry=None):
        if  whichGeometry is None:
            whichGeometry = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(whichGeometry)
        self.__whichGeometry = whichGeometry
    @property # getter - - - - - - - - - -
    def writeInterval(self):
        return self.__writeInterval
    @writeInterval.setter
    def writeInterval(self, writeInterval=None):
        if  writeInterval is None:
            writeInterval = SFTime.DEFAULT_VALUE
        assertValidSFTime(writeInterval)
        assertNonNegative('writeInterval', writeInterval)
        self.__writeInterval = writeInterval
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function SignalPdu.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<SignalPdu'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.address != 'localhost':
            result += " address='" + self.address + "'"
        if self.applicationID != 0:
            result += " applicationID='" + self.applicationID + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.data != list():
            result += " data='" + self.data + "'"
        if self.dataLength != 0:
            result += " dataLength='" + self.dataLength + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.encodingScheme != 0:
            result += " encodingScheme='" + self.encodingScheme + "'"
        if self.entityID != 0:
            result += " entityID='" + self.entityID + "'"
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords='" + self.geoCoords + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'"
        if self.multicastRelayHost:
            result += " multicastRelayHost='" + self.multicastRelayHost + "'"
        if self.multicastRelayPort != 0:
            result += " multicastRelayPort='" + self.multicastRelayPort + "'"
        if self.networkMode != 'standAlone':
            result += " networkMode='" + self.networkMode + "'"
        if self.port != 0:
            result += " port='" + self.port + "'"
        if self.radioID != 0:
            result += " radioID='" + self.radioID + "'"
        if self.readInterval != 0.1:
            result += " readInterval='" + self.readInterval + "'"
        if self.rtpHeaderExpected != False:
            result += " rtpHeaderExpected='" + self.rtpHeaderExpected + "'"
        if self.sampleRate != 0:
            result += " sampleRate='" + self.sampleRate + "'"
        if self.samples != 0:
            result += " samples='" + self.samples + "'"
        if self.siteID != 0:
            result += " siteID='" + self.siteID + "'"
        if self.tdlType != 0:
            result += " tdlType='" + self.tdlType + "'"
        if self.whichGeometry != 1:
            result += " whichGeometry='" + self.whichGeometry + "'"
        if self.writeInterval != 1.0:
            result += " writeInterval='" + self.writeInterval + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</SignalPdu>' + '\n'
#       print('XML serialization complete.')
        return result

class SilhouetteEnhancementVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    X3D element
    """
    NAME = 'SilhouetteEnhancementVolumeStyle'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SilhouetteEnhancementVolumeStyle'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('silhouetteBoundaryOpacity', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('silhouetteRetainedOpacity', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('silhouetteSharpness', 0.5, FieldType.SFFloat, AccessType.inputOutput),
                          ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 silhouetteBoundaryOpacity=0,
                 silhouetteRetainedOpacity=1,
                 silhouetteSharpness=0.5,
                 surfaceNormals=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SilhouetteEnhancementVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.silhouetteBoundaryOpacity = silhouetteBoundaryOpacity
        self.silhouetteRetainedOpacity = silhouetteRetainedOpacity
        self.silhouetteSharpness = silhouetteSharpness
        self.surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def silhouetteBoundaryOpacity(self):
        return self.__silhouetteBoundaryOpacity
    @silhouetteBoundaryOpacity.setter
    def silhouetteBoundaryOpacity(self, silhouetteBoundaryOpacity=None):
        if  silhouetteBoundaryOpacity is None:
            silhouetteBoundaryOpacity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(silhouetteBoundaryOpacity)
        assertZeroToOne('silhouetteBoundaryOpacity', silhouetteBoundaryOpacity)
        self.__silhouetteBoundaryOpacity = silhouetteBoundaryOpacity
    @property # getter - - - - - - - - - -
    def silhouetteRetainedOpacity(self):
        return self.__silhouetteRetainedOpacity
    @silhouetteRetainedOpacity.setter
    def silhouetteRetainedOpacity(self, silhouetteRetainedOpacity=None):
        if  silhouetteRetainedOpacity is None:
            silhouetteRetainedOpacity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(silhouetteRetainedOpacity)
        assertZeroToOne('silhouetteRetainedOpacity', silhouetteRetainedOpacity)
        self.__silhouetteRetainedOpacity = silhouetteRetainedOpacity
    @property # getter - - - - - - - - - -
    def silhouetteSharpness(self):
        return self.__silhouetteSharpness
    @silhouetteSharpness.setter
    def silhouetteSharpness(self, silhouetteSharpness=None):
        if  silhouetteSharpness is None:
            silhouetteSharpness = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(silhouetteSharpness)
        assertNonNegative('silhouetteSharpness', silhouetteSharpness)
        self.__silhouetteSharpness = silhouetteSharpness
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals=None):
        if  surfaceNormals is None:
            surfaceNormals = SFNode.DEFAULT_VALUE
        assertValidSFNode(surfaceNormals)
        if not isinstance(surfaceNormals, object):
            print(flush=True)
            raise TypeError(str(surfaceNormals) + ' does not have a valid node type object')
        self.__surfaceNormals = surfaceNormals
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function SilhouetteEnhancementVolumeStyle.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<SilhouetteEnhancementVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.silhouetteBoundaryOpacity != 0:
            result += " silhouetteBoundaryOpacity='" + self.silhouetteBoundaryOpacity + "'"
        if self.silhouetteRetainedOpacity != 1:
            result += " silhouetteRetainedOpacity='" + self.silhouetteRetainedOpacity + "'"
        if self.silhouetteSharpness != 0.5:
            result += " silhouetteSharpness='" + self.silhouetteSharpness + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.surfaceNormals: # walk each child node, if any
            result += indent
            for each in self.surfaceNormals:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</SilhouetteEnhancementVolumeStyle>' + '\n'
#       print('XML serialization complete.')
        return result

class SingleAxisHingeJoint(_X3DRigidJointNode):
    """
    SingleAxisHingeJoint has single axis about which to rotate, similar to a traditional door hinge. Contains two RigidBody nodes (containerField values body1, body2).
    """
    NAME = 'SingleAxisHingeJoint'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SingleAxisHingeJoint'
    FIELD_DECLARATIONS = [('anchorPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('axis', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput),
                          ('maxAngle', 3.141592653, FieldType.SFFloat, AccessType.inputOutput),
                          ('minAngle', -3.141592653, FieldType.SFFloat, AccessType.inputOutput),
                          ('stopBounce', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('stopErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput),
                          ('body1', None, FieldType.SFNode, AccessType.inputOutput),
                          ('body2', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 anchorPoint=(0, 0, 0),
                 axis=(0, 0, 0),
                 forceOutput=["NONE"],
                 maxAngle=3.141592653,
                 minAngle=-3.141592653,
                 stopBounce=0,
                 stopErrorCorrection=0.8,
                 body1=None,
                 body2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SingleAxisHingeJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.anchorPoint = anchorPoint
        self.axis = axis
        self.forceOutput = forceOutput
        self.maxAngle = maxAngle
        self.minAngle = minAngle
        self.stopBounce = stopBounce
        self.stopErrorCorrection = stopErrorCorrection
        self.body1 = body1
        self.body2 = body2
    @property # getter - - - - - - - - - -
    def anchorPoint(self):
        return self.__anchorPoint
    @anchorPoint.setter
    def anchorPoint(self, anchorPoint=None):
        if  anchorPoint is None:
            anchorPoint = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(anchorPoint)
        self.__anchorPoint = anchorPoint
    @property # getter - - - - - - - - - -
    def axis(self):
        return self.__axis
    @axis.setter
    def axis(self, axis=None):
        if  axis is None:
            axis = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(axis)
        self.__axis = axis
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput=None):
        if  forceOutput is None:
            forceOutput = MFString.DEFAULT_VALUE
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def maxAngle(self):
        return self.__maxAngle
    @maxAngle.setter
    def maxAngle(self, maxAngle=None):
        if  maxAngle is None:
            maxAngle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(maxAngle)
        self.__maxAngle = maxAngle
    @property # getter - - - - - - - - - -
    def minAngle(self):
        return self.__minAngle
    @minAngle.setter
    def minAngle(self, minAngle=None):
        if  minAngle is None:
            minAngle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(minAngle)
        self.__minAngle = minAngle
    @property # getter - - - - - - - - - -
    def stopBounce(self):
        return self.__stopBounce
    @stopBounce.setter
    def stopBounce(self, stopBounce=None):
        if  stopBounce is None:
            stopBounce = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stopBounce)
        self.__stopBounce = stopBounce
    @property # getter - - - - - - - - - -
    def stopErrorCorrection(self):
        return self.__stopErrorCorrection
    @stopErrorCorrection.setter
    def stopErrorCorrection(self, stopErrorCorrection=None):
        if  stopErrorCorrection is None:
            stopErrorCorrection = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stopErrorCorrection)
        self.__stopErrorCorrection = stopErrorCorrection
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1=None):
        if  body1 is None:
            body1 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            print(flush=True)
            raise TypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2=None):
        if  body2 is None:
            body2 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            print(flush=True)
            raise TypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function SingleAxisHingeJoint.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<SingleAxisHingeJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.anchorPoint != (0, 0, 0):
            result += " anchorPoint='" + self.anchorPoint + "'"
        if self.axis != (0, 0, 0):
            result += " axis='" + self.axis + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.forceOutput != ["NONE"]:
            result += " forceOutput='" + self.forceOutput + "'"
        if self.maxAngle != 3.141592653:
            result += " maxAngle='" + self.maxAngle + "'"
        if self.minAngle != -3.141592653:
            result += " minAngle='" + self.minAngle + "'"
        if self.stopBounce != 0:
            result += " stopBounce='" + self.stopBounce + "'"
        if self.stopErrorCorrection != 0.8:
            result += " stopErrorCorrection='" + self.stopErrorCorrection + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body1: # walk each child node, if any
            result += indent
            for each in self.body1:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body2: # walk each child node, if any
            result += indent
            for each in self.body2:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</SingleAxisHingeJoint>' + '\n'
#       print('XML serialization complete.')
        return result

class SliderJoint(_X3DRigidJointNode):
    """
    SliderJoint constrains all movement between body1 and body2 along a single axis. Contains two RigidBody nodes (containerField values body1, body2).
    """
    NAME = 'SliderJoint'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SliderJoint'
    FIELD_DECLARATIONS = [('axis', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput),
                          ('maxSeparation', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('minSeparation', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('sliderForce', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('stopBounce', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('stopErrorCorrection', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('body1', None, FieldType.SFNode, AccessType.inputOutput),
                          ('body2', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 axis=(0, 1, 0),
                 forceOutput=["NONE"],
                 maxSeparation=1,
                 minSeparation=0,
                 sliderForce=0,
                 stopBounce=0,
                 stopErrorCorrection=1,
                 body1=None,
                 body2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SliderJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.axis = axis
        self.forceOutput = forceOutput
        self.maxSeparation = maxSeparation
        self.minSeparation = minSeparation
        self.sliderForce = sliderForce
        self.stopBounce = stopBounce
        self.stopErrorCorrection = stopErrorCorrection
        self.body1 = body1
        self.body2 = body2
    @property # getter - - - - - - - - - -
    def axis(self):
        return self.__axis
    @axis.setter
    def axis(self, axis=None):
        if  axis is None:
            axis = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(axis)
        self.__axis = axis
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput=None):
        if  forceOutput is None:
            forceOutput = MFString.DEFAULT_VALUE
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def maxSeparation(self):
        return self.__maxSeparation
    @maxSeparation.setter
    def maxSeparation(self, maxSeparation=None):
        if  maxSeparation is None:
            maxSeparation = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(maxSeparation)
        self.__maxSeparation = maxSeparation
    @property # getter - - - - - - - - - -
    def minSeparation(self):
        return self.__minSeparation
    @minSeparation.setter
    def minSeparation(self, minSeparation=None):
        if  minSeparation is None:
            minSeparation = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(minSeparation)
        self.__minSeparation = minSeparation
    @property # getter - - - - - - - - - -
    def sliderForce(self):
        return self.__sliderForce
    @sliderForce.setter
    def sliderForce(self, sliderForce=None):
        if  sliderForce is None:
            sliderForce = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(sliderForce)
        self.__sliderForce = sliderForce
    @property # getter - - - - - - - - - -
    def stopBounce(self):
        return self.__stopBounce
    @stopBounce.setter
    def stopBounce(self, stopBounce=None):
        if  stopBounce is None:
            stopBounce = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stopBounce)
        self.__stopBounce = stopBounce
    @property # getter - - - - - - - - - -
    def stopErrorCorrection(self):
        return self.__stopErrorCorrection
    @stopErrorCorrection.setter
    def stopErrorCorrection(self, stopErrorCorrection=None):
        if  stopErrorCorrection is None:
            stopErrorCorrection = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stopErrorCorrection)
        self.__stopErrorCorrection = stopErrorCorrection
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1=None):
        if  body1 is None:
            body1 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            print(flush=True)
            raise TypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2=None):
        if  body2 is None:
            body2 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            print(flush=True)
            raise TypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function SliderJoint.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<SliderJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.axis != (0, 1, 0):
            result += " axis='" + self.axis + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.forceOutput != ["NONE"]:
            result += " forceOutput='" + self.forceOutput + "'"
        if self.maxSeparation != 1:
            result += " maxSeparation='" + self.maxSeparation + "'"
        if self.minSeparation != 0:
            result += " minSeparation='" + self.minSeparation + "'"
        if self.sliderForce != 0:
            result += " sliderForce='" + self.sliderForce + "'"
        if self.stopBounce != 0:
            result += " stopBounce='" + self.stopBounce + "'"
        if self.stopErrorCorrection != 1:
            result += " stopErrorCorrection='" + self.stopErrorCorrection + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body1: # walk each child node, if any
            result += indent
            for each in self.body1:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body2: # walk each child node, if any
            result += indent
            for each in self.body2:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</SliderJoint>' + '\n'
#       print('XML serialization complete.')
        return result

class Sound(_X3DSoundNode):
    """
    X3D element
    """
    NAME = 'Sound'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Sound'
    FIELD_DECLARATIONS = [('direction', (0, 0, 1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('maxBack', 10, FieldType.SFFloat, AccessType.inputOutput),
                          ('maxFront', 10, FieldType.SFFloat, AccessType.inputOutput),
                          ('minBack', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('minFront', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('priority', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('spatialize', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('source', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 direction=(0, 0, 1),
                 intensity=1,
                 location=(0, 0, 0),
                 maxBack=10,
                 maxFront=10,
                 minBack=1,
                 minFront=1,
                 priority=0,
                 spatialize=True,
                 source=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Sound __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.direction = direction
        self.intensity = intensity
        self.location = location
        self.maxBack = maxBack
        self.maxFront = maxFront
        self.minBack = minBack
        self.minFront = minFront
        self.priority = priority
        self.spatialize = spatialize
        self.source = source
    @property # getter - - - - - - - - - -
    def direction(self):
        return self.__direction
    @direction.setter
    def direction(self, direction=None):
        if  direction is None:
            direction = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def intensity(self):
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity=None):
        if  intensity is None:
            intensity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(intensity)
        assertZeroToOne('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        return self.__location
    @location.setter
    def location(self, location=None):
        if  location is None:
            location = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def maxBack(self):
        return self.__maxBack
    @maxBack.setter
    def maxBack(self, maxBack=None):
        if  maxBack is None:
            maxBack = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(maxBack)
        assertNonNegative('maxBack', maxBack)
        self.__maxBack = maxBack
    @property # getter - - - - - - - - - -
    def maxFront(self):
        return self.__maxFront
    @maxFront.setter
    def maxFront(self, maxFront=None):
        if  maxFront is None:
            maxFront = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(maxFront)
        assertNonNegative('maxFront', maxFront)
        self.__maxFront = maxFront
    @property # getter - - - - - - - - - -
    def minBack(self):
        return self.__minBack
    @minBack.setter
    def minBack(self, minBack=None):
        if  minBack is None:
            minBack = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(minBack)
        assertNonNegative('minBack', minBack)
        self.__minBack = minBack
    @property # getter - - - - - - - - - -
    def minFront(self):
        return self.__minFront
    @minFront.setter
    def minFront(self, minFront=None):
        if  minFront is None:
            minFront = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(minFront)
        assertNonNegative('minFront', minFront)
        self.__minFront = minFront
    @property # getter - - - - - - - - - -
    def priority(self):
        return self.__priority
    @priority.setter
    def priority(self, priority=None):
        if  priority is None:
            priority = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(priority)
        assertZeroToOne('priority', priority)
        self.__priority = priority
    @property # getter - - - - - - - - - -
    def spatialize(self):
        return self.__spatialize
    @spatialize.setter
    def spatialize(self, spatialize=None):
        if  spatialize is None:
            spatialize = SFBool.DEFAULT_VALUE
        assertValidSFBool(spatialize)
        self.__spatialize = spatialize
    @property # getter - - - - - - - - - -
    def source(self):
        return self.__source
    @source.setter
    def source(self, source=None):
        if  source is None:
            source = SFNode.DEFAULT_VALUE
        assertValidSFNode(source)
        if not isinstance(source, object):
            print(flush=True)
            raise TypeError(str(source) + ' does not have a valid node type object')
        self.__source = source
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Sound.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Sound'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.direction != (0, 0, 1):
            result += " direction='" + self.direction + "'"
        if self.intensity != 1:
            result += " intensity='" + self.intensity + "'"
        if self.location != (0, 0, 0):
            result += " location='" + self.location + "'"
        if self.maxBack != 10:
            result += " maxBack='" + self.maxBack + "'"
        if self.maxFront != 10:
            result += " maxFront='" + self.maxFront + "'"
        if self.minBack != 1:
            result += " minBack='" + self.minBack + "'"
        if self.minFront != 1:
            result += " minFront='" + self.minFront + "'"
        if self.priority != 0:
            result += " priority='" + self.priority + "'"
        if self.spatialize != True:
            result += " spatialize='" + self.spatialize + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.source: # walk each child node, if any
            result += indent
            for each in self.source:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Sound>' + '\n'
#       print('XML serialization complete.')
        return result

class Sphere(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'Sphere'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Sphere'
    FIELD_DECLARATIONS = [('radius', 1, FieldType.SFFloat, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 radius=1,
                 solid=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Sphere __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.radius = radius
        self.solid = solid
    @property # getter - - - - - - - - - -
    def radius(self):
        return self.__radius
    @radius.setter
    def radius(self, radius=None):
        if  radius is None:
            radius = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Sphere.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Sphere'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.radius != 1:
            result += " radius='" + self.radius + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Sphere>' + '\n'
#       print('XML serialization complete.')
        return result

class SphereSensor(_X3DDragSensorNode):
    """
    X3D element
    """
    NAME = 'SphereSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SphereSensor'
    FIELD_DECLARATIONS = [('autoOffset', True, FieldType.SFBool, AccessType.inputOutput),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('offset', (0, 1, 0, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 autoOffset=True,
                 description='',
                 enabled=True,
                 offset=(0, 1, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SphereSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.autoOffset = autoOffset
        self.description = description
        self.enabled = enabled
        self.offset = offset
    @property # getter - - - - - - - - - -
    def autoOffset(self):
        return self.__autoOffset
    @autoOffset.setter
    def autoOffset(self, autoOffset=None):
        if  autoOffset is None:
            autoOffset = SFBool.DEFAULT_VALUE
        assertValidSFBool(autoOffset)
        self.__autoOffset = autoOffset
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def offset(self):
        return self.__offset
    @offset.setter
    def offset(self, offset=None):
        if  offset is None:
            offset = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(offset)
        self.__offset = offset
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function SphereSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<SphereSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.autoOffset != True:
            result += " autoOffset='" + self.autoOffset + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.offset != (0, 1, 0, 0):
            result += " offset='" + self.offset + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</SphereSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class SplinePositionInterpolator(_X3DInterpolatorNode):
    """
    X3D element
    """
    NAME = 'SplinePositionInterpolator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SplinePositionInterpolator'
    FIELD_DECLARATIONS = [('closed', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFVec3f, AccessType.inputOutput),
                          ('keyVelocity', list(), FieldType.MFVec3f, AccessType.inputOutput),
                          ('normalizeVelocity', False, FieldType.SFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 closed=False,
                 key=list(),
                 keyValue=list(),
                 keyVelocity=list(),
                 normalizeVelocity=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SplinePositionInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.key = key
        self.keyValue = keyValue
        self.keyVelocity = keyVelocity
        self.normalizeVelocity = normalizeVelocity
    @property # getter - - - - - - - - - -
    def closed(self):
        return self.__closed
    @closed.setter
    def closed(self, closed=None):
        if  closed is None:
            closed = SFBool.DEFAULT_VALUE
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def keyVelocity(self):
        return self.__keyVelocity
    @keyVelocity.setter
    def keyVelocity(self, keyVelocity=None):
        if  keyVelocity is None:
            keyVelocity = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(keyVelocity)
        self.__keyVelocity = keyVelocity
    @property # getter - - - - - - - - - -
    def normalizeVelocity(self):
        return self.__normalizeVelocity
    @normalizeVelocity.setter
    def normalizeVelocity(self, normalizeVelocity=None):
        if  normalizeVelocity is None:
            normalizeVelocity = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalizeVelocity)
        self.__normalizeVelocity = normalizeVelocity
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function SplinePositionInterpolator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<SplinePositionInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.closed != False:
            result += " closed='" + self.closed + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'"
        if self.keyVelocity != list():
            result += " keyVelocity='" + self.keyVelocity + "'"
        if self.normalizeVelocity != False:
            result += " normalizeVelocity='" + self.normalizeVelocity + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</SplinePositionInterpolator>' + '\n'
#       print('XML serialization complete.')
        return result

class SplinePositionInterpolator2D(_X3DInterpolatorNode):
    """
    X3D element
    """
    NAME = 'SplinePositionInterpolator2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SplinePositionInterpolator2D'
    FIELD_DECLARATIONS = [('closed', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFVec2f, AccessType.inputOutput),
                          ('keyVelocity', list(), FieldType.MFVec2f, AccessType.inputOutput),
                          ('normalizeVelocity', False, FieldType.SFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 closed=False,
                 key=list(),
                 keyValue=list(),
                 keyVelocity=list(),
                 normalizeVelocity=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SplinePositionInterpolator2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.key = key
        self.keyValue = keyValue
        self.keyVelocity = keyVelocity
        self.normalizeVelocity = normalizeVelocity
    @property # getter - - - - - - - - - -
    def closed(self):
        return self.__closed
    @closed.setter
    def closed(self, closed=None):
        if  closed is None:
            closed = SFBool.DEFAULT_VALUE
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def keyVelocity(self):
        return self.__keyVelocity
    @keyVelocity.setter
    def keyVelocity(self, keyVelocity=None):
        if  keyVelocity is None:
            keyVelocity = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(keyVelocity)
        self.__keyVelocity = keyVelocity
    @property # getter - - - - - - - - - -
    def normalizeVelocity(self):
        return self.__normalizeVelocity
    @normalizeVelocity.setter
    def normalizeVelocity(self, normalizeVelocity=None):
        if  normalizeVelocity is None:
            normalizeVelocity = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalizeVelocity)
        self.__normalizeVelocity = normalizeVelocity
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function SplinePositionInterpolator2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<SplinePositionInterpolator2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.closed != False:
            result += " closed='" + self.closed + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'"
        if self.keyVelocity != list():
            result += " keyVelocity='" + self.keyVelocity + "'"
        if self.normalizeVelocity != False:
            result += " normalizeVelocity='" + self.normalizeVelocity + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</SplinePositionInterpolator2D>' + '\n'
#       print('XML serialization complete.')
        return result

class SplineScalarInterpolator(_X3DInterpolatorNode):
    """
    X3D element
    """
    NAME = 'SplineScalarInterpolator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SplineScalarInterpolator'
    FIELD_DECLARATIONS = [('closed', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyVelocity', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('normalizeVelocity', False, FieldType.SFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 closed=False,
                 key=list(),
                 keyValue=list(),
                 keyVelocity=list(),
                 normalizeVelocity=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SplineScalarInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.key = key
        self.keyValue = keyValue
        self.keyVelocity = keyVelocity
        self.normalizeVelocity = normalizeVelocity
    @property # getter - - - - - - - - - -
    def closed(self):
        return self.__closed
    @closed.setter
    def closed(self, closed=None):
        if  closed is None:
            closed = SFBool.DEFAULT_VALUE
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def keyVelocity(self):
        return self.__keyVelocity
    @keyVelocity.setter
    def keyVelocity(self, keyVelocity=None):
        if  keyVelocity is None:
            keyVelocity = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(keyVelocity)
        self.__keyVelocity = keyVelocity
    @property # getter - - - - - - - - - -
    def normalizeVelocity(self):
        return self.__normalizeVelocity
    @normalizeVelocity.setter
    def normalizeVelocity(self, normalizeVelocity=None):
        if  normalizeVelocity is None:
            normalizeVelocity = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalizeVelocity)
        self.__normalizeVelocity = normalizeVelocity
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function SplineScalarInterpolator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<SplineScalarInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.closed != False:
            result += " closed='" + self.closed + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'"
        if self.keyVelocity != list():
            result += " keyVelocity='" + self.keyVelocity + "'"
        if self.normalizeVelocity != False:
            result += " normalizeVelocity='" + self.normalizeVelocity + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</SplineScalarInterpolator>' + '\n'
#       print('XML serialization complete.')
        return result

class SpotLight(_X3DLightNode):
    """
    Linear attenuation may occur at level 2, full support at level 3.
    """
    NAME = 'SpotLight'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SpotLight'
    FIELD_DECLARATIONS = [('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('attenuation', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('beamWidth', 0.7854, FieldType.SFFloat, AccessType.inputOutput),
                          ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput),
                          ('cutOffAngle', 1.570796, FieldType.SFFloat, AccessType.inputOutput),
                          ('direction', (0, 0, -1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('global_', True, FieldType.SFBool, AccessType.inputOutput),
                          ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('on', True, FieldType.SFBool, AccessType.inputOutput),
                          ('radius', 100, FieldType.SFFloat, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ambientIntensity=0,
                 attenuation=(1, 0, 0),
                 beamWidth=0.7854,
                 color=(1, 1, 1),
                 cutOffAngle=1.570796,
                 direction=(0, 0, -1),
                 global_=True,
                 intensity=1,
                 location=(0, 0, 0),
                 on=True,
                 radius=100,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SpotLight __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.attenuation = attenuation
        self.beamWidth = beamWidth
        self.color = color
        self.cutOffAngle = cutOffAngle
        self.direction = direction
        self.global_ = global_
        self.intensity = intensity
        self.location = location
        self.on = on
        self.radius = radius
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity=None):
        if  ambientIntensity is None:
            ambientIntensity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def attenuation(self):
        return self.__attenuation
    @attenuation.setter
    def attenuation(self, attenuation=None):
        if  attenuation is None:
            attenuation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(attenuation)
        assertNonNegative('attenuation', attenuation)
        self.__attenuation = attenuation
    @property # getter - - - - - - - - - -
    def beamWidth(self):
        return self.__beamWidth
    @beamWidth.setter
    def beamWidth(self, beamWidth=None):
        if  beamWidth is None:
            beamWidth = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(beamWidth)
        assertGreaterThan('beamWidth', beamWidth, 0)
        assertLessThanEquals('beamWidth', beamWidth, 1.570796)
        self.__beamWidth = beamWidth
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFColor.DEFAULT_VALUE
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def cutOffAngle(self):
        return self.__cutOffAngle
    @cutOffAngle.setter
    def cutOffAngle(self, cutOffAngle=None):
        if  cutOffAngle is None:
            cutOffAngle = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(cutOffAngle)
        assertGreaterThan('cutOffAngle', cutOffAngle, 0)
        assertLessThanEquals('cutOffAngle', cutOffAngle, 1.570796)
        self.__cutOffAngle = cutOffAngle
    @property # getter - - - - - - - - - -
    def direction(self):
        return self.__direction
    @direction.setter
    def direction(self, direction=None):
        if  direction is None:
            direction = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def global_(self):
        return self.__global_
    @global_.setter
    def global_(self, global_=None):
        if  global_ is None:
            global_ = SFBool.DEFAULT_VALUE
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity=None):
        if  intensity is None:
            intensity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(intensity)
        assertZeroToOne('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        return self.__location
    @location.setter
    def location(self, location=None):
        if  location is None:
            location = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def on(self):
        return self.__on
    @on.setter
    def on(self, on=None):
        if  on is None:
            on = SFBool.DEFAULT_VALUE
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def radius(self):
        return self.__radius
    @radius.setter
    def radius(self, radius=None):
        if  radius is None:
            radius = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(radius)
        assertNonNegative('radius', radius)
        self.__radius = radius
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function SpotLight.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<SpotLight'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ambientIntensity != 0:
            result += " ambientIntensity='" + self.ambientIntensity + "'"
        if self.attenuation != (1, 0, 0):
            result += " attenuation='" + self.attenuation + "'"
        if self.beamWidth != 0.7854:
            result += " beamWidth='" + self.beamWidth + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + self.color + "'"
        if self.cutOffAngle != 1.570796:
            result += " cutOffAngle='" + self.cutOffAngle + "'"
        if self.direction != (0, 0, -1):
            result += " direction='" + self.direction + "'"
        if self.global_ != True:
            result += " global_='" + self.global_ + "'"
        if self.intensity != 1:
            result += " intensity='" + self.intensity + "'"
        if self.location != (0, 0, 0):
            result += " location='" + self.location + "'"
        if self.on != True:
            result += " on='" + self.on + "'"
        if self.radius != 100:
            result += " radius='" + self.radius + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</SpotLight>' + '\n'
#       print('XML serialization complete.')
        return result

class SquadOrientationInterpolator(_X3DInterpolatorNode):
    """
    X3D element
    """
    NAME = 'SquadOrientationInterpolator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SquadOrientationInterpolator'
    FIELD_DECLARATIONS = [('key', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('keyValue', list(), FieldType.MFRotation, AccessType.inputOutput),
                          ('normalizeVelocity', False, FieldType.SFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 normalizeVelocity=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SquadOrientationInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
        self.normalizeVelocity = normalizeVelocity
    @property # getter - - - - - - - - - -
    def key(self):
        return self.__key
    @key.setter
    def key(self, key=None):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue=None):
        if  keyValue is None:
            keyValue = MFRotation.DEFAULT_VALUE
        assertValidMFRotation(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def normalizeVelocity(self):
        return self.__normalizeVelocity
    @normalizeVelocity.setter
    def normalizeVelocity(self, normalizeVelocity=None):
        if  normalizeVelocity is None:
            normalizeVelocity = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalizeVelocity)
        self.__normalizeVelocity = normalizeVelocity
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function SquadOrientationInterpolator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<SquadOrientationInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + self.key + "'"
        if self.keyValue != list():
            result += " keyValue='" + self.keyValue + "'"
        if self.normalizeVelocity != False:
            result += " normalizeVelocity='" + self.normalizeVelocity + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</SquadOrientationInterpolator>' + '\n'
#       print('XML serialization complete.')
        return result

class StaticGroup(_X3DChildNode):
    """
    StaticGroup is similar to Group node but does not allow access to children after creation time.
    """
    NAME = 'StaticGroup'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#StaticGroup'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('children', list(), FieldType.MFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode StaticGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function StaticGroup.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<StaticGroup'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</StaticGroup>' + '\n'
#       print('XML serialization complete.')
        return result

class StringSensor(_X3DKeyDeviceSensorNode):
    """
    X3D element
    """
    NAME = 'StringSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#StringSensor'
    FIELD_DECLARATIONS = [('deletionAllowed', True, FieldType.SFBool, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 deletionAllowed=True,
                 enabled=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode StringSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.deletionAllowed = deletionAllowed
        self.enabled = enabled
    @property # getter - - - - - - - - - -
    def deletionAllowed(self):
        return self.__deletionAllowed
    @deletionAllowed.setter
    def deletionAllowed(self, deletionAllowed=None):
        if  deletionAllowed is None:
            deletionAllowed = SFBool.DEFAULT_VALUE
        assertValidSFBool(deletionAllowed)
        self.__deletionAllowed = deletionAllowed
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function StringSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<StringSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.deletionAllowed != True:
            result += " deletionAllowed='" + self.deletionAllowed + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</StringSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class SurfaceEmitter(_X3DParticleEmitterNode):
    """
    X3D element
    """
    NAME = 'SurfaceEmitter'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SurfaceEmitter'
    FIELD_DECLARATIONS = [('coordIndex', [-1], FieldType.MFInt32, AccessType.initializeOnly),
                          ('mass', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('speed', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('surfaceArea', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput),
                          ('surface', None, FieldType.SFNode, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 coordIndex=[-1],
                 mass=0,
                 speed=0,
                 surfaceArea=0,
                 variation=0.25,
                 surface=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SurfaceEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.coordIndex = coordIndex
        self.mass = mass
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
        self.surface = surface
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex=None):
        if  coordIndex is None:
            coordIndex = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def mass(self):
        return self.__mass
    @mass.setter
    def mass(self, mass=None):
        if  mass is None:
            mass = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def speed(self):
        return self.__speed
    @speed.setter
    def speed(self, speed=None):
        if  speed is None:
            speed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea=None):
        if  surfaceArea is None:
            surfaceArea = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        return self.__variation
    @variation.setter
    def variation(self, variation=None):
        if  variation is None:
            variation = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    @property # getter - - - - - - - - - -
    def surface(self):
        return self.__surface
    @surface.setter
    def surface(self, surface=None):
        if  surface is None:
            surface = SFNode.DEFAULT_VALUE
        assertValidSFNode(surface)
        if not isinstance(surface, object):
            print(flush=True)
            raise TypeError(str(surface) + ' does not have a valid node type object')
        self.__surface = surface
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function SurfaceEmitter.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<SurfaceEmitter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.coordIndex != [-1]:
            result += " coordIndex='" + self.coordIndex + "'"
        if self.mass != 0:
            result += " mass='" + self.mass + "'"
        if self.speed != 0:
            result += " speed='" + self.speed + "'"
        if self.surfaceArea != 0:
            result += " surfaceArea='" + self.surfaceArea + "'"
        if self.variation != 0.25:
            result += " variation='" + self.variation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.surface: # walk each child node, if any
            result += indent
            for each in self.surface:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</SurfaceEmitter>' + '\n'
#       print('XML serialization complete.')
        return result

class Switch(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'Switch'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Switch'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('whichChoice', -1, FieldType.SFInt32, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 whichChoice=-1,
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Switch __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.whichChoice = whichChoice
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def whichChoice(self):
        return self.__whichChoice
    @whichChoice.setter
    def whichChoice(self, whichChoice=None):
        if  whichChoice is None:
            whichChoice = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(whichChoice)
        assertGreaterThanEquals('whichChoice', whichChoice, -1)
        self.__whichChoice = whichChoice
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Switch.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Switch'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.whichChoice != -1:
            result += " whichChoice='" + self.whichChoice + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Switch>' + '\n'
#       print('XML serialization complete.')
        return result

class TexCoordChaser2D(_X3DChaserNode):
    """
    X3D element
    """
    NAME = 'TexCoordChaser2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TexCoordChaser2D'
    FIELD_DECLARATIONS = [('duration', 1, FieldType.SFTime, AccessType.initializeOnly),
                          ('initialDestination', list(), FieldType.MFVec2f, AccessType.initializeOnly),
                          ('initialValue', list(), FieldType.MFVec2f, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 duration=1,
                 initialDestination=list(),
                 initialValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TexCoordChaser2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        return self.__duration
    @duration.setter
    def duration(self, duration=None):
        if  duration is None:
            duration = SFTime.DEFAULT_VALUE
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(initialValue)
        self.__initialValue = initialValue
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TexCoordChaser2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TexCoordChaser2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + self.duration + "'"
        if self.initialDestination != list():
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != list():
            result += " initialValue='" + self.initialValue + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TexCoordChaser2D>' + '\n'
#       print('XML serialization complete.')
        return result

class TexCoordDamper2D(_X3DDamperNode):
    """
    X3D element
    """
    NAME = 'TexCoordDamper2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TexCoordDamper2D'
    FIELD_DECLARATIONS = [('initialDestination', list(), FieldType.MFVec2f, AccessType.initializeOnly),
                          ('initialValue', list(), FieldType.MFVec2f, AccessType.initializeOnly),
                          ('order', 3, FieldType.SFInt32, AccessType.initializeOnly),
                          ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput),
                          ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 initialDestination=list(),
                 initialValue=list(),
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TexCoordDamper2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination=None):
        if  initialDestination is None:
            initialDestination = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue=None):
        if  initialValue is None:
            initialValue = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        return self.__order
    @order.setter
    def order(self, order=None):
        if  order is None:
            order = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        return self.__tau
    @tau.setter
    def tau(self, tau=None):
        if  tau is None:
            tau = SFTime.DEFAULT_VALUE
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance=None):
        if  tolerance is None:
            tolerance = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TexCoordDamper2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TexCoordDamper2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != list():
            result += " initialDestination='" + self.initialDestination + "'"
        if self.initialValue != list():
            result += " initialValue='" + self.initialValue + "'"
        if self.order != 3:
            result += " order='" + self.order + "'"
        if self.tau != 0.3:
            result += " tau='" + self.tau + "'"
        if self.tolerance != -1:
            result += " tolerance='" + self.tolerance + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TexCoordDamper2D>' + '\n'
#       print('XML serialization complete.')
        return result

class Text(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'Text'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Text'
    FIELD_DECLARATIONS = [('length', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('maxExtent', 0.0, FieldType.SFFloat, AccessType.inputOutput),
                          ('solid', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('string', list(), FieldType.MFString, AccessType.inputOutput),
                          ('fontStyle', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 length=list(),
                 maxExtent=0.0,
                 solid=False,
                 string=list(),
                 fontStyle=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Text __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.length = length
        self.maxExtent = maxExtent
        self.solid = solid
        self.string = string
        self.fontStyle = fontStyle
    @property # getter - - - - - - - - - -
    def length(self):
        return self.__length
    @length.setter
    def length(self, length=None):
        if  length is None:
            length = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(length)
        assertNonNegative('length', length)
        self.__length = length
    @property # getter - - - - - - - - - -
    def maxExtent(self):
        return self.__maxExtent
    @maxExtent.setter
    def maxExtent(self, maxExtent=None):
        if  maxExtent is None:
            maxExtent = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(maxExtent)
        assertNonNegative('maxExtent', maxExtent)
        self.__maxExtent = maxExtent
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def string(self):
        return self.__string
    @string.setter
    def string(self, string=None):
        if  string is None:
            string = MFString.DEFAULT_VALUE
        assertValidMFString(string)
        self.__string = string
    @property # getter - - - - - - - - - -
    def fontStyle(self):
        return self.__fontStyle
    @fontStyle.setter
    def fontStyle(self, fontStyle=None):
        if  fontStyle is None:
            fontStyle = SFNode.DEFAULT_VALUE
        assertValidSFNode(fontStyle)
        if not isinstance(fontStyle, object):
            print(flush=True)
            raise TypeError(str(fontStyle) + ' does not have a valid node type object')
        self.__fontStyle = fontStyle
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Text.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Text'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.length != list():
            result += " length='" + self.length + "'"
        if self.maxExtent != 0.0:
            result += " maxExtent='" + self.maxExtent + "'"
        if self.solid != False:
            result += " solid='" + self.solid + "'"
        if self.string != list():
            result += " string='" + self.string + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fontStyle: # walk each child node, if any
            result += indent
            for each in self.fontStyle:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Text>' + '\n'
#       print('XML serialization complete.')
        return result

class TextureBackground(_X3DBackgroundNode):
    """
    X3D element
    """
    NAME = 'TextureBackground'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureBackground'
    FIELD_DECLARATIONS = [('groundAngle', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('groundColor', list(), FieldType.MFColor, AccessType.inputOutput),
                          ('skyAngle', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('skyColor', [0, 0, 0], FieldType.MFColor, AccessType.inputOutput),
                          ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('backTexture', None, FieldType.SFNode, AccessType.inputOutput),
                          ('bottomTexture', None, FieldType.SFNode, AccessType.inputOutput),
                          ('frontTexture', None, FieldType.SFNode, AccessType.inputOutput),
                          ('leftTexture', None, FieldType.SFNode, AccessType.inputOutput),
                          ('rightTexture', None, FieldType.SFNode, AccessType.inputOutput),
                          ('topTexture', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 groundAngle=list(),
                 groundColor=list(),
                 skyAngle=list(),
                 skyColor=[0, 0, 0],
                 transparency=0,
                 backTexture=None,
                 bottomTexture=None,
                 frontTexture=None,
                 leftTexture=None,
                 rightTexture=None,
                 topTexture=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureBackground __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.groundAngle = groundAngle
        self.groundColor = groundColor
        self.skyAngle = skyAngle
        self.skyColor = skyColor
        self.transparency = transparency
        self.backTexture = backTexture
        self.bottomTexture = bottomTexture
        self.frontTexture = frontTexture
        self.leftTexture = leftTexture
        self.rightTexture = rightTexture
        self.topTexture = topTexture
    @property # getter - - - - - - - - - -
    def groundAngle(self):
        return self.__groundAngle
    @groundAngle.setter
    def groundAngle(self, groundAngle=None):
        if  groundAngle is None:
            groundAngle = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(groundAngle)
        assertGreaterThanEquals('groundAngle', groundAngle, 0)
        assertLessThanEquals('groundAngle', groundAngle, 1.5708)
        self.__groundAngle = groundAngle
    @property # getter - - - - - - - - - -
    def groundColor(self):
        return self.__groundColor
    @groundColor.setter
    def groundColor(self, groundColor=None):
        if  groundColor is None:
            groundColor = MFColor.DEFAULT_VALUE
        assertValidMFColor(groundColor)
        assertZeroToOne('groundColor', groundColor)
        self.__groundColor = groundColor
    @property # getter - - - - - - - - - -
    def skyAngle(self):
        return self.__skyAngle
    @skyAngle.setter
    def skyAngle(self, skyAngle=None):
        if  skyAngle is None:
            skyAngle = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(skyAngle)
        assertGreaterThanEquals('skyAngle', skyAngle, 0)
        assertLessThanEquals('skyAngle', skyAngle, 3.1416)
        self.__skyAngle = skyAngle
    @property # getter - - - - - - - - - -
    def skyColor(self):
        return self.__skyColor
    @skyColor.setter
    def skyColor(self, skyColor=None):
        if  skyColor is None:
            skyColor = MFColor.DEFAULT_VALUE
        assertValidMFColor(skyColor)
        assertZeroToOne('skyColor', skyColor)
        self.__skyColor = skyColor
    @property # getter - - - - - - - - - -
    def transparency(self):
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency=None):
        if  transparency is None:
            transparency = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    @property # getter - - - - - - - - - -
    def backTexture(self):
        return self.__backTexture
    @backTexture.setter
    def backTexture(self, backTexture=None):
        if  backTexture is None:
            backTexture = SFNode.DEFAULT_VALUE
        assertValidSFNode(backTexture)
        if not isinstance(backTexture, object):
            print(flush=True)
            raise TypeError(str(backTexture) + ' does not have a valid node type object')
        self.__backTexture = backTexture
    @property # getter - - - - - - - - - -
    def bottomTexture(self):
        return self.__bottomTexture
    @bottomTexture.setter
    def bottomTexture(self, bottomTexture=None):
        if  bottomTexture is None:
            bottomTexture = SFNode.DEFAULT_VALUE
        assertValidSFNode(bottomTexture)
        if not isinstance(bottomTexture, object):
            print(flush=True)
            raise TypeError(str(bottomTexture) + ' does not have a valid node type object')
        self.__bottomTexture = bottomTexture
    @property # getter - - - - - - - - - -
    def frontTexture(self):
        return self.__frontTexture
    @frontTexture.setter
    def frontTexture(self, frontTexture=None):
        if  frontTexture is None:
            frontTexture = SFNode.DEFAULT_VALUE
        assertValidSFNode(frontTexture)
        if not isinstance(frontTexture, object):
            print(flush=True)
            raise TypeError(str(frontTexture) + ' does not have a valid node type object')
        self.__frontTexture = frontTexture
    @property # getter - - - - - - - - - -
    def leftTexture(self):
        return self.__leftTexture
    @leftTexture.setter
    def leftTexture(self, leftTexture=None):
        if  leftTexture is None:
            leftTexture = SFNode.DEFAULT_VALUE
        assertValidSFNode(leftTexture)
        if not isinstance(leftTexture, object):
            print(flush=True)
            raise TypeError(str(leftTexture) + ' does not have a valid node type object')
        self.__leftTexture = leftTexture
    @property # getter - - - - - - - - - -
    def rightTexture(self):
        return self.__rightTexture
    @rightTexture.setter
    def rightTexture(self, rightTexture=None):
        if  rightTexture is None:
            rightTexture = SFNode.DEFAULT_VALUE
        assertValidSFNode(rightTexture)
        if not isinstance(rightTexture, object):
            print(flush=True)
            raise TypeError(str(rightTexture) + ' does not have a valid node type object')
        self.__rightTexture = rightTexture
    @property # getter - - - - - - - - - -
    def topTexture(self):
        return self.__topTexture
    @topTexture.setter
    def topTexture(self, topTexture=None):
        if  topTexture is None:
            topTexture = SFNode.DEFAULT_VALUE
        assertValidSFNode(topTexture)
        if not isinstance(topTexture, object):
            print(flush=True)
            raise TypeError(str(topTexture) + ' does not have a valid node type object')
        self.__topTexture = topTexture
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TextureBackground.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TextureBackground'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.groundAngle != list():
            result += " groundAngle='" + self.groundAngle + "'"
        if self.groundColor != list():
            result += " groundColor='" + self.groundColor + "'"
        if self.skyAngle != list():
            result += " skyAngle='" + self.skyAngle + "'"
        if self.skyColor != [0, 0, 0]:
            result += " skyColor='" + self.skyColor + "'"
        if self.transparency != 0:
            result += " transparency='" + self.transparency + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.backTexture: # walk each child node, if any
            result += indent
            for each in self.backTexture:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.bottomTexture: # walk each child node, if any
            result += indent
            for each in self.bottomTexture:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.frontTexture: # walk each child node, if any
            result += indent
            for each in self.frontTexture:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.leftTexture: # walk each child node, if any
            result += indent
            for each in self.leftTexture:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.rightTexture: # walk each child node, if any
            result += indent
            for each in self.rightTexture:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.topTexture: # walk each child node, if any
            result += indent
            for each in self.topTexture:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TextureBackground>' + '\n'
#       print('XML serialization complete.')
        return result

class TextureCoordinate(_X3DTextureCoordinateNode):
    """
    X3D element
    """
    NAME = 'TextureCoordinate'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureCoordinate'
    FIELD_DECLARATIONS = [('point', list(), FieldType.MFVec2f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 point=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.point = point
    @property # getter - - - - - - - - - -
    def point(self):
        return self.__point
    @point.setter
    def point(self, point=None):
        if  point is None:
            point = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(point)
        self.__point = point
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TextureCoordinate.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TextureCoordinate'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.point != list():
            result += " point='" + self.point + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TextureCoordinate>' + '\n'
#       print('XML serialization complete.')
        return result

class TextureCoordinate3D(_X3DTextureCoordinateNode):
    """
    X3D element
    """
    NAME = 'TextureCoordinate3D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureCoordinate3D'
    FIELD_DECLARATIONS = [('point', list(), FieldType.MFVec3f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 point=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureCoordinate3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.point = point
    @property # getter - - - - - - - - - -
    def point(self):
        return self.__point
    @point.setter
    def point(self, point=None):
        if  point is None:
            point = MFVec3f.DEFAULT_VALUE
        assertValidMFVec3f(point)
        self.__point = point
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TextureCoordinate3D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TextureCoordinate3D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.point != list():
            result += " point='" + self.point + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TextureCoordinate3D>' + '\n'
#       print('XML serialization complete.')
        return result

class TextureCoordinate4D(_X3DTextureCoordinateNode):
    """
    X3D element
    """
    NAME = 'TextureCoordinate4D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureCoordinate4D'
    FIELD_DECLARATIONS = [('point', list(), FieldType.MFVec4f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 point=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureCoordinate4D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.point = point
    @property # getter - - - - - - - - - -
    def point(self):
        return self.__point
    @point.setter
    def point(self, point=None):
        if  point is None:
            point = MFVec4f.DEFAULT_VALUE
        assertValidMFVec4f(point)
        self.__point = point
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TextureCoordinate4D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TextureCoordinate4D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.point != list():
            result += " point='" + self.point + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TextureCoordinate4D>' + '\n'
#       print('XML serialization complete.')
        return result

class TextureCoordinateGenerator(_X3DTextureCoordinateNode):
    """
    X3D element
    """
    NAME = 'TextureCoordinateGenerator'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureCoordinateGenerator'
    FIELD_DECLARATIONS = [('mode', 'SPHERE', FieldType.SFString, AccessType.inputOutput),
                          ('parameter', list(), FieldType.MFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 mode='SPHERE',
                 parameter=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureCoordinateGenerator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.mode = mode
        self.parameter = parameter
    @property # getter - - - - - - - - - -
    def mode(self):
        return self.__mode
    @mode.setter
    def mode(self, mode=None):
        if  mode is None:
            mode = SFString.DEFAULT_VALUE
        assertValidSFString(mode)
        self.__mode = mode
    @property # getter - - - - - - - - - -
    def parameter(self):
        return self.__parameter
    @parameter.setter
    def parameter(self, parameter=None):
        if  parameter is None:
            parameter = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(parameter)
        self.__parameter = parameter
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TextureCoordinateGenerator.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TextureCoordinateGenerator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.mode != 'SPHERE':
            result += " mode='" + self.mode + "'"
        if self.parameter != list():
            result += " parameter='" + self.parameter + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TextureCoordinateGenerator>' + '\n'
#       print('XML serialization complete.')
        return result

class TextureProperties(_X3DNode):
    """
    X3D element
    """
    NAME = 'TextureProperties'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureProperties'
    FIELD_DECLARATIONS = [('anisotropicDegree', 1, FieldType.SFFloat, AccessType.inputOutput),
                          ('borderColor', (0, 0, 0, 0), FieldType.SFColorRGBA, AccessType.inputOutput),
                          ('borderWidth', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('boundaryModeR', 'REPEAT', FieldType.SFString, AccessType.inputOutput),
                          ('boundaryModeS', 'REPEAT', FieldType.SFString, AccessType.inputOutput),
                          ('boundaryModeT', 'REPEAT', FieldType.SFString, AccessType.inputOutput),
                          ('generateMipMaps', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('magnificationFilter', 'FASTEST', FieldType.SFString, AccessType.inputOutput),
                          ('minificationFilter', 'FASTEST', FieldType.SFString, AccessType.inputOutput),
                          ('textureCompression', 'FASTEST', FieldType.SFString, AccessType.inputOutput),
                          ('texturePriority', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 anisotropicDegree=1,
                 borderColor=(0, 0, 0, 0),
                 borderWidth=0,
                 boundaryModeR='REPEAT',
                 boundaryModeS='REPEAT',
                 boundaryModeT='REPEAT',
                 generateMipMaps=False,
                 magnificationFilter='FASTEST',
                 minificationFilter='FASTEST',
                 textureCompression='FASTEST',
                 texturePriority=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.anisotropicDegree = anisotropicDegree
        self.borderColor = borderColor
        self.borderWidth = borderWidth
        self.boundaryModeR = boundaryModeR
        self.boundaryModeS = boundaryModeS
        self.boundaryModeT = boundaryModeT
        self.generateMipMaps = generateMipMaps
        self.magnificationFilter = magnificationFilter
        self.minificationFilter = minificationFilter
        self.textureCompression = textureCompression
        self.texturePriority = texturePriority
    @property # getter - - - - - - - - - -
    def anisotropicDegree(self):
        return self.__anisotropicDegree
    @anisotropicDegree.setter
    def anisotropicDegree(self, anisotropicDegree=None):
        if  anisotropicDegree is None:
            anisotropicDegree = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(anisotropicDegree)
        assertGreaterThanEquals('anisotropicDegree', anisotropicDegree, 1)
        self.__anisotropicDegree = anisotropicDegree
    @property # getter - - - - - - - - - -
    def borderColor(self):
        return self.__borderColor
    @borderColor.setter
    def borderColor(self, borderColor=None):
        if  borderColor is None:
            borderColor = SFColorRGBA.DEFAULT_VALUE
        assertValidSFColorRGBA(borderColor)
        assertZeroToOne('borderColor', borderColor)
        self.__borderColor = borderColor
    @property # getter - - - - - - - - - -
    def borderWidth(self):
        return self.__borderWidth
    @borderWidth.setter
    def borderWidth(self, borderWidth=None):
        if  borderWidth is None:
            borderWidth = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(borderWidth)
        assertNonNegative('borderWidth', borderWidth)
        self.__borderWidth = borderWidth
    @property # getter - - - - - - - - - -
    def boundaryModeR(self):
        return self.__boundaryModeR
    @boundaryModeR.setter
    def boundaryModeR(self, boundaryModeR=None):
        if  boundaryModeR is None:
            boundaryModeR = SFString.DEFAULT_VALUE
        assertValidSFString(boundaryModeR)
        self.__boundaryModeR = boundaryModeR
    @property # getter - - - - - - - - - -
    def boundaryModeS(self):
        return self.__boundaryModeS
    @boundaryModeS.setter
    def boundaryModeS(self, boundaryModeS=None):
        if  boundaryModeS is None:
            boundaryModeS = SFString.DEFAULT_VALUE
        assertValidSFString(boundaryModeS)
        self.__boundaryModeS = boundaryModeS
    @property # getter - - - - - - - - - -
    def boundaryModeT(self):
        return self.__boundaryModeT
    @boundaryModeT.setter
    def boundaryModeT(self, boundaryModeT=None):
        if  boundaryModeT is None:
            boundaryModeT = SFString.DEFAULT_VALUE
        assertValidSFString(boundaryModeT)
        self.__boundaryModeT = boundaryModeT
    @property # getter - - - - - - - - - -
    def generateMipMaps(self):
        return self.__generateMipMaps
    @generateMipMaps.setter
    def generateMipMaps(self, generateMipMaps=None):
        if  generateMipMaps is None:
            generateMipMaps = SFBool.DEFAULT_VALUE
        assertValidSFBool(generateMipMaps)
        self.__generateMipMaps = generateMipMaps
    @property # getter - - - - - - - - - -
    def magnificationFilter(self):
        return self.__magnificationFilter
    @magnificationFilter.setter
    def magnificationFilter(self, magnificationFilter=None):
        if  magnificationFilter is None:
            magnificationFilter = SFString.DEFAULT_VALUE
        assertValidSFString(magnificationFilter)
        self.__magnificationFilter = magnificationFilter
    @property # getter - - - - - - - - - -
    def minificationFilter(self):
        return self.__minificationFilter
    @minificationFilter.setter
    def minificationFilter(self, minificationFilter=None):
        if  minificationFilter is None:
            minificationFilter = SFString.DEFAULT_VALUE
        assertValidSFString(minificationFilter)
        self.__minificationFilter = minificationFilter
    @property # getter - - - - - - - - - -
    def textureCompression(self):
        return self.__textureCompression
    @textureCompression.setter
    def textureCompression(self, textureCompression=None):
        if  textureCompression is None:
            textureCompression = SFString.DEFAULT_VALUE
        assertValidSFString(textureCompression)
        self.__textureCompression = textureCompression
    @property # getter - - - - - - - - - -
    def texturePriority(self):
        return self.__texturePriority
    @texturePriority.setter
    def texturePriority(self, texturePriority=None):
        if  texturePriority is None:
            texturePriority = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(texturePriority)
        assertZeroToOne('texturePriority', texturePriority)
        self.__texturePriority = texturePriority
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TextureProperties.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TextureProperties'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.anisotropicDegree != 1:
            result += " anisotropicDegree='" + self.anisotropicDegree + "'"
        if self.borderColor != (0, 0, 0, 0):
            result += " borderColor='" + self.borderColor + "'"
        if self.borderWidth != 0:
            result += " borderWidth='" + self.borderWidth + "'"
        if self.boundaryModeR != 'REPEAT':
            result += " boundaryModeR='" + self.boundaryModeR + "'"
        if self.boundaryModeS != 'REPEAT':
            result += " boundaryModeS='" + self.boundaryModeS + "'"
        if self.boundaryModeT != 'REPEAT':
            result += " boundaryModeT='" + self.boundaryModeT + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.generateMipMaps != False:
            result += " generateMipMaps='" + self.generateMipMaps + "'"
        if self.magnificationFilter != 'FASTEST':
            result += " magnificationFilter='" + self.magnificationFilter + "'"
        if self.minificationFilter != 'FASTEST':
            result += " minificationFilter='" + self.minificationFilter + "'"
        if self.textureCompression != 'FASTEST':
            result += " textureCompression='" + self.textureCompression + "'"
        if self.texturePriority != 0:
            result += " texturePriority='" + self.texturePriority + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TextureProperties>' + '\n'
#       print('XML serialization complete.')
        return result

class TextureTransform(_X3DTextureTransformNode):
    """
    X3D element
    """
    NAME = 'TextureTransform'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureTransform'
    FIELD_DECLARATIONS = [('center', (0, 0), FieldType.SFVec2f, AccessType.inputOutput),
                          ('rotation', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('scale', (1, 1), FieldType.SFVec2f, AccessType.inputOutput),
                          ('translation', (0, 0), FieldType.SFVec2f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 center=(0, 0),
                 rotation=0,
                 scale=(1, 1),
                 translation=(0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureTransform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.rotation = rotation
        self.scale = scale
        self.translation = translation
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def rotation(self):
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation=None):
        if  rotation is None:
            rotation = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        return self.__scale
    @scale.setter
    def scale(self, scale=None):
        if  scale is None:
            scale = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def translation(self):
        return self.__translation
    @translation.setter
    def translation(self, translation=None):
        if  translation is None:
            translation = SFVec2f.DEFAULT_VALUE
        assertValidSFVec2f(translation)
        self.__translation = translation
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TextureTransform.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TextureTransform'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.rotation != 0:
            result += " rotation='" + self.rotation + "'"
        if self.scale != (1, 1):
            result += " scale='" + self.scale + "'"
        if self.translation != (0, 0):
            result += " translation='" + self.translation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TextureTransform>' + '\n'
#       print('XML serialization complete.')
        return result

class TextureTransform3D(_X3DTextureTransformNode):
    """
    X3D element
    """
    NAME = 'TextureTransform3D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureTransform3D'
    FIELD_DECLARATIONS = [('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 center=(0, 0, 0),
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 translation=(0, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureTransform3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.rotation = rotation
        self.scale = scale
        self.translation = translation
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def rotation(self):
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation=None):
        if  rotation is None:
            rotation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        return self.__scale
    @scale.setter
    def scale(self, scale=None):
        if  scale is None:
            scale = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def translation(self):
        return self.__translation
    @translation.setter
    def translation(self, translation=None):
        if  translation is None:
            translation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(translation)
        self.__translation = translation
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TextureTransform3D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TextureTransform3D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + self.rotation + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + self.scale + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + self.translation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TextureTransform3D>' + '\n'
#       print('XML serialization complete.')
        return result

class TextureTransformMatrix3D(_X3DTextureTransformNode):
    """
    X3D element
    """
    NAME = 'TextureTransformMatrix3D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureTransformMatrix3D'
    FIELD_DECLARATIONS = [('matrix', (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), FieldType.SFMatrix4f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 matrix=(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureTransformMatrix3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.matrix = matrix
    @property # getter - - - - - - - - - -
    def matrix(self):
        return self.__matrix
    @matrix.setter
    def matrix(self, matrix=None):
        if  matrix is None:
            matrix = SFMatrix4f.DEFAULT_VALUE
        assertValidSFMatrix4f(matrix)
        self.__matrix = matrix
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TextureTransformMatrix3D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TextureTransformMatrix3D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.matrix != (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1):
            result += " matrix='" + self.matrix + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TextureTransformMatrix3D>' + '\n'
#       print('XML serialization complete.')
        return result

class TimeSensor(_X3DTimeDependentNode):
    """
    X3D element
    """
    NAME = 'TimeSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TimeSensor'
    FIELD_DECLARATIONS = [('cycleInterval', 1.0, FieldType.SFTime, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('loop', False, FieldType.SFBool, AccessType.inputOutput),
                          ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('startTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 cycleInterval=1.0,
                 enabled=True,
                 loop=False,
                 pauseTime=0,
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TimeSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.cycleInterval = cycleInterval
        self.enabled = enabled
        self.loop = loop
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
    @property # getter - - - - - - - - - -
    def cycleInterval(self):
        return self.__cycleInterval
    @cycleInterval.setter
    def cycleInterval(self, cycleInterval=None):
        if  cycleInterval is None:
            cycleInterval = SFTime.DEFAULT_VALUE
        assertValidSFTime(cycleInterval)
        assertNonNegative('cycleInterval', cycleInterval)
        self.__cycleInterval = cycleInterval
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def loop(self):
        return self.__loop
    @loop.setter
    def loop(self, loop=None):
        if  loop is None:
            loop = SFBool.DEFAULT_VALUE
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime=None):
        if  pauseTime is None:
            pauseTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime=None):
        if  resumeTime is None:
            resumeTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime=None):
        if  startTime is None:
            startTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime=None):
        if  stopTime is None:
            stopTime = SFTime.DEFAULT_VALUE
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TimeSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TimeSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.cycleInterval != 1.0:
            result += " cycleInterval='" + self.cycleInterval + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.loop != False:
            result += " loop='" + self.loop + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + self.pauseTime + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + self.resumeTime + "'"
        if self.startTime != 0:
            result += " startTime='" + self.startTime + "'"
        if self.stopTime != 0:
            result += " stopTime='" + self.stopTime + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TimeSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class TimeTrigger(_X3DTriggerNode):
    """
    X3D element
    """
    NAME = 'TimeTrigger'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TimeTrigger'
    FIELD_DECLARATIONS = [('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TimeTrigger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TimeTrigger.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TimeTrigger'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TimeTrigger>' + '\n'
#       print('XML serialization complete.')
        return result

class ToneMappedVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    X3D element
    """
    NAME = 'ToneMappedVolumeStyle'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ToneMappedVolumeStyle'
    FIELD_DECLARATIONS = [('coolColor', (0, 0, 1, 0), FieldType.SFColorRGBA, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('warmColor', (1, 1, 0, 0), FieldType.SFColorRGBA, AccessType.inputOutput),
                          ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 coolColor=(0, 0, 1, 0),
                 enabled=True,
                 warmColor=(1, 1, 0, 0),
                 surfaceNormals=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ToneMappedVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.coolColor = coolColor
        self.enabled = enabled
        self.warmColor = warmColor
        self.surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def coolColor(self):
        return self.__coolColor
    @coolColor.setter
    def coolColor(self, coolColor=None):
        if  coolColor is None:
            coolColor = SFColorRGBA.DEFAULT_VALUE
        assertValidSFColorRGBA(coolColor)
        assertZeroToOne('coolColor', coolColor)
        self.__coolColor = coolColor
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def warmColor(self):
        return self.__warmColor
    @warmColor.setter
    def warmColor(self, warmColor=None):
        if  warmColor is None:
            warmColor = SFColorRGBA.DEFAULT_VALUE
        assertValidSFColorRGBA(warmColor)
        assertZeroToOne('warmColor', warmColor)
        self.__warmColor = warmColor
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals=None):
        if  surfaceNormals is None:
            surfaceNormals = SFNode.DEFAULT_VALUE
        assertValidSFNode(surfaceNormals)
        if not isinstance(surfaceNormals, object):
            print(flush=True)
            raise TypeError(str(surfaceNormals) + ' does not have a valid node type object')
        self.__surfaceNormals = surfaceNormals
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ToneMappedVolumeStyle.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ToneMappedVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.coolColor != (0, 0, 1, 0):
            result += " coolColor='" + self.coolColor + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.warmColor != (1, 1, 0, 0):
            result += " warmColor='" + self.warmColor + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.surfaceNormals: # walk each child node, if any
            result += indent
            for each in self.surfaceNormals:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ToneMappedVolumeStyle>' + '\n'
#       print('XML serialization complete.')
        return result

class TouchSensor(_X3DTouchSensorNode):
    """
    X3D element
    """
    NAME = 'TouchSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TouchSensor'
    FIELD_DECLARATIONS = [('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 description='',
                 enabled=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TouchSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TouchSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TouchSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TouchSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class Transform(_X3DGroupingNode):
    """
    X3D element
    """
    NAME = 'Transform'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Transform'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 translation=(0, 0, 0),
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Transform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.center = center
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.translation = translation
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def rotation(self):
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation=None):
        if  rotation is None:
            rotation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        return self.__scale
    @scale.setter
    def scale(self, scale=None):
        if  scale is None:
            scale = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation=None):
        if  scaleOrientation is None:
            scaleOrientation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def translation(self):
        return self.__translation
    @translation.setter
    def translation(self, translation=None):
        if  translation is None:
            translation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Transform.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Transform'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + self.rotation + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + self.scale + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + self.scaleOrientation + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + self.translation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Transform>' + '\n'
#       print('XML serialization complete.')
        return result

class TransformSensor(_X3DEnvironmentalSensorNode):
    """
    X3D element
    """
    NAME = 'TransformSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TransformSensor'
    FIELD_DECLARATIONS = [('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('targetObject', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 center=(0, 0, 0),
                 enabled=True,
                 size=(0, 0, 0),
                 targetObject=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TransformSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.enabled = enabled
        self.size = size
        self.targetObject = targetObject
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def size(self):
        return self.__size
    @size.setter
    def size(self, size=None):
        if  size is None:
            size = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(size)
        assertNonNegative('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def targetObject(self):
        return self.__targetObject
    @targetObject.setter
    def targetObject(self, targetObject=None):
        if  targetObject is None:
            targetObject = SFNode.DEFAULT_VALUE
        assertValidSFNode(targetObject)
        if not isinstance(targetObject, object):
            print(flush=True)
            raise TypeError(str(targetObject) + ' does not have a valid node type object')
        self.__targetObject = targetObject
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TransformSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TransformSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.size != (0, 0, 0):
            result += " size='" + self.size + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.targetObject: # walk each child node, if any
            result += indent
            for each in self.targetObject:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TransformSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class TransmitterPdu(_X3DNetworkSensorNode):
    """
    X3D element
    """
    NAME = 'TransmitterPdu'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TransmitterPdu'
    FIELD_DECLARATIONS = [('address', 'localhost', FieldType.SFString, AccessType.inputOutput),
                          ('antennaLocation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('antennaPatternLength', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('antennaPatternType', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('cryptoKeyID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('cryptoSystem', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('entityID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('frequency', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput),
                          ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly),
                          ('inputSource', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('lengthOfModulationParameters', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('modulationTypeDetail', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('modulationTypeMajor', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('modulationTypeSpreadSpectrum', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('modulationTypeSystem', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('multicastRelayHost', '', FieldType.SFString, AccessType.inputOutput),
                          ('multicastRelayPort', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('networkMode', 'standAlone', FieldType.SFString, AccessType.inputOutput),
                          ('port', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('power', 0.0, FieldType.SFFloat, AccessType.inputOutput),
                          ('radioEntityTypeCategory', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('radioEntityTypeCountry', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('radioEntityTypeDomain', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('radioEntityTypeKind', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('radioEntityTypeNomenclature', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('radioEntityTypeNomenclatureVersion', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('radioID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('readInterval', 0.1, FieldType.SFTime, AccessType.inputOutput),
                          ('relativeAntennaLocation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('rtpHeaderExpected', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('transmitFrequencyBandwidth', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('transmitState', 0, FieldType.SFInt32, AccessType.inputOutput),
                          ('whichGeometry', 1, FieldType.SFInt32, AccessType.inputOutput),
                          ('writeInterval', 1.0, FieldType.SFTime, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 address='localhost',
                 antennaLocation=(0, 0, 0),
                 antennaPatternLength=0,
                 antennaPatternType=0,
                 applicationID=0,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 cryptoKeyID=0,
                 cryptoSystem=0,
                 enabled=True,
                 entityID=0,
                 frequency=0,
                 geoCoords=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 inputSource=0,
                 lengthOfModulationParameters=0,
                 modulationTypeDetail=0,
                 modulationTypeMajor=0,
                 modulationTypeSpreadSpectrum=0,
                 modulationTypeSystem=0,
                 multicastRelayHost='',
                 multicastRelayPort=0,
                 networkMode='standAlone',
                 port=0,
                 power=0.0,
                 radioEntityTypeCategory=0,
                 radioEntityTypeCountry=0,
                 radioEntityTypeDomain=0,
                 radioEntityTypeKind=0,
                 radioEntityTypeNomenclature=0,
                 radioEntityTypeNomenclatureVersion=0,
                 radioID=0,
                 readInterval=0.1,
                 relativeAntennaLocation=(0, 0, 0),
                 rtpHeaderExpected=False,
                 siteID=0,
                 transmitFrequencyBandwidth=0,
                 transmitState=0,
                 whichGeometry=1,
                 writeInterval=1.0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TransmitterPdu __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.antennaLocation = antennaLocation
        self.antennaPatternLength = antennaPatternLength
        self.antennaPatternType = antennaPatternType
        self.applicationID = applicationID
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.cryptoKeyID = cryptoKeyID
        self.cryptoSystem = cryptoSystem
        self.enabled = enabled
        self.entityID = entityID
        self.frequency = frequency
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.inputSource = inputSource
        self.lengthOfModulationParameters = lengthOfModulationParameters
        self.modulationTypeDetail = modulationTypeDetail
        self.modulationTypeMajor = modulationTypeMajor
        self.modulationTypeSpreadSpectrum = modulationTypeSpreadSpectrum
        self.modulationTypeSystem = modulationTypeSystem
        self.multicastRelayHost = multicastRelayHost
        self.multicastRelayPort = multicastRelayPort
        self.networkMode = networkMode
        self.port = port
        self.power = power
        self.radioEntityTypeCategory = radioEntityTypeCategory
        self.radioEntityTypeCountry = radioEntityTypeCountry
        self.radioEntityTypeDomain = radioEntityTypeDomain
        self.radioEntityTypeKind = radioEntityTypeKind
        self.radioEntityTypeNomenclature = radioEntityTypeNomenclature
        self.radioEntityTypeNomenclatureVersion = radioEntityTypeNomenclatureVersion
        self.radioID = radioID
        self.readInterval = readInterval
        self.relativeAntennaLocation = relativeAntennaLocation
        self.rtpHeaderExpected = rtpHeaderExpected
        self.siteID = siteID
        self.transmitFrequencyBandwidth = transmitFrequencyBandwidth
        self.transmitState = transmitState
        self.whichGeometry = whichGeometry
        self.writeInterval = writeInterval
    @property # getter - - - - - - - - - -
    def address(self):
        return self.__address
    @address.setter
    def address(self, address=None):
        if  address is None:
            address = SFString.DEFAULT_VALUE
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def antennaLocation(self):
        return self.__antennaLocation
    @antennaLocation.setter
    def antennaLocation(self, antennaLocation=None):
        if  antennaLocation is None:
            antennaLocation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(antennaLocation)
        self.__antennaLocation = antennaLocation
    @property # getter - - - - - - - - - -
    def antennaPatternLength(self):
        return self.__antennaPatternLength
    @antennaPatternLength.setter
    def antennaPatternLength(self, antennaPatternLength=None):
        if  antennaPatternLength is None:
            antennaPatternLength = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(antennaPatternLength)
        self.__antennaPatternLength = antennaPatternLength
    @property # getter - - - - - - - - - -
    def antennaPatternType(self):
        return self.__antennaPatternType
    @antennaPatternType.setter
    def antennaPatternType(self, antennaPatternType=None):
        if  antennaPatternType is None:
            antennaPatternType = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(antennaPatternType)
        self.__antennaPatternType = antennaPatternType
    @property # getter - - - - - - - - - -
    def applicationID(self):
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID=None):
        if  applicationID is None:
            applicationID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def cryptoKeyID(self):
        return self.__cryptoKeyID
    @cryptoKeyID.setter
    def cryptoKeyID(self, cryptoKeyID=None):
        if  cryptoKeyID is None:
            cryptoKeyID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(cryptoKeyID)
        self.__cryptoKeyID = cryptoKeyID
    @property # getter - - - - - - - - - -
    def cryptoSystem(self):
        return self.__cryptoSystem
    @cryptoSystem.setter
    def cryptoSystem(self, cryptoSystem=None):
        if  cryptoSystem is None:
            cryptoSystem = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(cryptoSystem)
        self.__cryptoSystem = cryptoSystem
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def entityID(self):
        return self.__entityID
    @entityID.setter
    def entityID(self, entityID=None):
        if  entityID is None:
            entityID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(entityID)
        self.__entityID = entityID
    @property # getter - - - - - - - - - -
    def frequency(self):
        return self.__frequency
    @frequency.setter
    def frequency(self, frequency=None):
        if  frequency is None:
            frequency = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(frequency)
        self.__frequency = frequency
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords=None):
        if  geoCoords is None:
            geoCoords = SFVec3d.DEFAULT_VALUE
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem=None):
        if  geoSystem is None:
            geoSystem = MFString.DEFAULT_VALUE
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def inputSource(self):
        return self.__inputSource
    @inputSource.setter
    def inputSource(self, inputSource=None):
        if  inputSource is None:
            inputSource = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(inputSource)
        self.__inputSource = inputSource
    @property # getter - - - - - - - - - -
    def lengthOfModulationParameters(self):
        return self.__lengthOfModulationParameters
    @lengthOfModulationParameters.setter
    def lengthOfModulationParameters(self, lengthOfModulationParameters=None):
        if  lengthOfModulationParameters is None:
            lengthOfModulationParameters = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(lengthOfModulationParameters)
        self.__lengthOfModulationParameters = lengthOfModulationParameters
    @property # getter - - - - - - - - - -
    def modulationTypeDetail(self):
        return self.__modulationTypeDetail
    @modulationTypeDetail.setter
    def modulationTypeDetail(self, modulationTypeDetail=None):
        if  modulationTypeDetail is None:
            modulationTypeDetail = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(modulationTypeDetail)
        self.__modulationTypeDetail = modulationTypeDetail
    @property # getter - - - - - - - - - -
    def modulationTypeMajor(self):
        return self.__modulationTypeMajor
    @modulationTypeMajor.setter
    def modulationTypeMajor(self, modulationTypeMajor=None):
        if  modulationTypeMajor is None:
            modulationTypeMajor = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(modulationTypeMajor)
        self.__modulationTypeMajor = modulationTypeMajor
    @property # getter - - - - - - - - - -
    def modulationTypeSpreadSpectrum(self):
        return self.__modulationTypeSpreadSpectrum
    @modulationTypeSpreadSpectrum.setter
    def modulationTypeSpreadSpectrum(self, modulationTypeSpreadSpectrum=None):
        if  modulationTypeSpreadSpectrum is None:
            modulationTypeSpreadSpectrum = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(modulationTypeSpreadSpectrum)
        self.__modulationTypeSpreadSpectrum = modulationTypeSpreadSpectrum
    @property # getter - - - - - - - - - -
    def modulationTypeSystem(self):
        return self.__modulationTypeSystem
    @modulationTypeSystem.setter
    def modulationTypeSystem(self, modulationTypeSystem=None):
        if  modulationTypeSystem is None:
            modulationTypeSystem = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(modulationTypeSystem)
        self.__modulationTypeSystem = modulationTypeSystem
    @property # getter - - - - - - - - - -
    def multicastRelayHost(self):
        return self.__multicastRelayHost
    @multicastRelayHost.setter
    def multicastRelayHost(self, multicastRelayHost=None):
        if  multicastRelayHost is None:
            multicastRelayHost = SFString.DEFAULT_VALUE
        assertValidSFString(multicastRelayHost)
        self.__multicastRelayHost = multicastRelayHost
    @property # getter - - - - - - - - - -
    def multicastRelayPort(self):
        return self.__multicastRelayPort
    @multicastRelayPort.setter
    def multicastRelayPort(self, multicastRelayPort=None):
        if  multicastRelayPort is None:
            multicastRelayPort = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(multicastRelayPort)
        self.__multicastRelayPort = multicastRelayPort
    @property # getter - - - - - - - - - -
    def networkMode(self):
        return self.__networkMode
    @networkMode.setter
    def networkMode(self, networkMode=None):
        if  networkMode is None:
            networkMode = SFString.DEFAULT_VALUE
        assertValidSFString(networkMode)
        self.__networkMode = networkMode
    @property # getter - - - - - - - - - -
    def port(self):
        return self.__port
    @port.setter
    def port(self, port=None):
        if  port is None:
            port = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def power(self):
        return self.__power
    @power.setter
    def power(self, power=None):
        if  power is None:
            power = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(power)
        self.__power = power
    @property # getter - - - - - - - - - -
    def radioEntityTypeCategory(self):
        return self.__radioEntityTypeCategory
    @radioEntityTypeCategory.setter
    def radioEntityTypeCategory(self, radioEntityTypeCategory=None):
        if  radioEntityTypeCategory is None:
            radioEntityTypeCategory = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(radioEntityTypeCategory)
        self.__radioEntityTypeCategory = radioEntityTypeCategory
    @property # getter - - - - - - - - - -
    def radioEntityTypeCountry(self):
        return self.__radioEntityTypeCountry
    @radioEntityTypeCountry.setter
    def radioEntityTypeCountry(self, radioEntityTypeCountry=None):
        if  radioEntityTypeCountry is None:
            radioEntityTypeCountry = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(radioEntityTypeCountry)
        self.__radioEntityTypeCountry = radioEntityTypeCountry
    @property # getter - - - - - - - - - -
    def radioEntityTypeDomain(self):
        return self.__radioEntityTypeDomain
    @radioEntityTypeDomain.setter
    def radioEntityTypeDomain(self, radioEntityTypeDomain=None):
        if  radioEntityTypeDomain is None:
            radioEntityTypeDomain = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(radioEntityTypeDomain)
        self.__radioEntityTypeDomain = radioEntityTypeDomain
    @property # getter - - - - - - - - - -
    def radioEntityTypeKind(self):
        return self.__radioEntityTypeKind
    @radioEntityTypeKind.setter
    def radioEntityTypeKind(self, radioEntityTypeKind=None):
        if  radioEntityTypeKind is None:
            radioEntityTypeKind = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(radioEntityTypeKind)
        self.__radioEntityTypeKind = radioEntityTypeKind
    @property # getter - - - - - - - - - -
    def radioEntityTypeNomenclature(self):
        return self.__radioEntityTypeNomenclature
    @radioEntityTypeNomenclature.setter
    def radioEntityTypeNomenclature(self, radioEntityTypeNomenclature=None):
        if  radioEntityTypeNomenclature is None:
            radioEntityTypeNomenclature = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(radioEntityTypeNomenclature)
        self.__radioEntityTypeNomenclature = radioEntityTypeNomenclature
    @property # getter - - - - - - - - - -
    def radioEntityTypeNomenclatureVersion(self):
        return self.__radioEntityTypeNomenclatureVersion
    @radioEntityTypeNomenclatureVersion.setter
    def radioEntityTypeNomenclatureVersion(self, radioEntityTypeNomenclatureVersion=None):
        if  radioEntityTypeNomenclatureVersion is None:
            radioEntityTypeNomenclatureVersion = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(radioEntityTypeNomenclatureVersion)
        self.__radioEntityTypeNomenclatureVersion = radioEntityTypeNomenclatureVersion
    @property # getter - - - - - - - - - -
    def radioID(self):
        return self.__radioID
    @radioID.setter
    def radioID(self, radioID=None):
        if  radioID is None:
            radioID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(radioID)
        self.__radioID = radioID
    @property # getter - - - - - - - - - -
    def readInterval(self):
        return self.__readInterval
    @readInterval.setter
    def readInterval(self, readInterval=None):
        if  readInterval is None:
            readInterval = SFTime.DEFAULT_VALUE
        assertValidSFTime(readInterval)
        assertNonNegative('readInterval', readInterval)
        self.__readInterval = readInterval
    @property # getter - - - - - - - - - -
    def relativeAntennaLocation(self):
        return self.__relativeAntennaLocation
    @relativeAntennaLocation.setter
    def relativeAntennaLocation(self, relativeAntennaLocation=None):
        if  relativeAntennaLocation is None:
            relativeAntennaLocation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(relativeAntennaLocation)
        self.__relativeAntennaLocation = relativeAntennaLocation
    @property # getter - - - - - - - - - -
    def rtpHeaderExpected(self):
        return self.__rtpHeaderExpected
    @rtpHeaderExpected.setter
    def rtpHeaderExpected(self, rtpHeaderExpected=None):
        if  rtpHeaderExpected is None:
            rtpHeaderExpected = SFBool.DEFAULT_VALUE
        assertValidSFBool(rtpHeaderExpected)
        self.__rtpHeaderExpected = rtpHeaderExpected
    @property # getter - - - - - - - - - -
    def siteID(self):
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID=None):
        if  siteID is None:
            siteID = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def transmitFrequencyBandwidth(self):
        return self.__transmitFrequencyBandwidth
    @transmitFrequencyBandwidth.setter
    def transmitFrequencyBandwidth(self, transmitFrequencyBandwidth=None):
        if  transmitFrequencyBandwidth is None:
            transmitFrequencyBandwidth = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(transmitFrequencyBandwidth)
        self.__transmitFrequencyBandwidth = transmitFrequencyBandwidth
    @property # getter - - - - - - - - - -
    def transmitState(self):
        return self.__transmitState
    @transmitState.setter
    def transmitState(self, transmitState=None):
        if  transmitState is None:
            transmitState = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(transmitState)
        self.__transmitState = transmitState
    @property # getter - - - - - - - - - -
    def whichGeometry(self):
        return self.__whichGeometry
    @whichGeometry.setter
    def whichGeometry(self, whichGeometry=None):
        if  whichGeometry is None:
            whichGeometry = SFInt32.DEFAULT_VALUE
        assertValidSFInt32(whichGeometry)
        self.__whichGeometry = whichGeometry
    @property # getter - - - - - - - - - -
    def writeInterval(self):
        return self.__writeInterval
    @writeInterval.setter
    def writeInterval(self, writeInterval=None):
        if  writeInterval is None:
            writeInterval = SFTime.DEFAULT_VALUE
        assertValidSFTime(writeInterval)
        assertNonNegative('writeInterval', writeInterval)
        self.__writeInterval = writeInterval
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TransmitterPdu.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TransmitterPdu'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.address != 'localhost':
            result += " address='" + self.address + "'"
        if self.antennaLocation != (0, 0, 0):
            result += " antennaLocation='" + self.antennaLocation + "'"
        if self.antennaPatternLength != 0:
            result += " antennaPatternLength='" + self.antennaPatternLength + "'"
        if self.antennaPatternType != 0:
            result += " antennaPatternType='" + self.antennaPatternType + "'"
        if self.applicationID != 0:
            result += " applicationID='" + self.applicationID + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.cryptoKeyID != 0:
            result += " cryptoKeyID='" + self.cryptoKeyID + "'"
        if self.cryptoSystem != 0:
            result += " cryptoSystem='" + self.cryptoSystem + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.entityID != 0:
            result += " entityID='" + self.entityID + "'"
        if self.frequency != 0:
            result += " frequency='" + self.frequency + "'"
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords='" + self.geoCoords + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + self.geoSystem + "'"
        if self.inputSource != 0:
            result += " inputSource='" + self.inputSource + "'"
        if self.lengthOfModulationParameters != 0:
            result += " lengthOfModulationParameters='" + self.lengthOfModulationParameters + "'"
        if self.modulationTypeDetail != 0:
            result += " modulationTypeDetail='" + self.modulationTypeDetail + "'"
        if self.modulationTypeMajor != 0:
            result += " modulationTypeMajor='" + self.modulationTypeMajor + "'"
        if self.modulationTypeSpreadSpectrum != 0:
            result += " modulationTypeSpreadSpectrum='" + self.modulationTypeSpreadSpectrum + "'"
        if self.modulationTypeSystem != 0:
            result += " modulationTypeSystem='" + self.modulationTypeSystem + "'"
        if self.multicastRelayHost:
            result += " multicastRelayHost='" + self.multicastRelayHost + "'"
        if self.multicastRelayPort != 0:
            result += " multicastRelayPort='" + self.multicastRelayPort + "'"
        if self.networkMode != 'standAlone':
            result += " networkMode='" + self.networkMode + "'"
        if self.port != 0:
            result += " port='" + self.port + "'"
        if self.power != 0.0:
            result += " power='" + self.power + "'"
        if self.radioEntityTypeCategory != 0:
            result += " radioEntityTypeCategory='" + self.radioEntityTypeCategory + "'"
        if self.radioEntityTypeCountry != 0:
            result += " radioEntityTypeCountry='" + self.radioEntityTypeCountry + "'"
        if self.radioEntityTypeDomain != 0:
            result += " radioEntityTypeDomain='" + self.radioEntityTypeDomain + "'"
        if self.radioEntityTypeKind != 0:
            result += " radioEntityTypeKind='" + self.radioEntityTypeKind + "'"
        if self.radioEntityTypeNomenclature != 0:
            result += " radioEntityTypeNomenclature='" + self.radioEntityTypeNomenclature + "'"
        if self.radioEntityTypeNomenclatureVersion != 0:
            result += " radioEntityTypeNomenclatureVersion='" + self.radioEntityTypeNomenclatureVersion + "'"
        if self.radioID != 0:
            result += " radioID='" + self.radioID + "'"
        if self.readInterval != 0.1:
            result += " readInterval='" + self.readInterval + "'"
        if self.relativeAntennaLocation != (0, 0, 0):
            result += " relativeAntennaLocation='" + self.relativeAntennaLocation + "'"
        if self.rtpHeaderExpected != False:
            result += " rtpHeaderExpected='" + self.rtpHeaderExpected + "'"
        if self.siteID != 0:
            result += " siteID='" + self.siteID + "'"
        if self.transmitFrequencyBandwidth != 0:
            result += " transmitFrequencyBandwidth='" + self.transmitFrequencyBandwidth + "'"
        if self.transmitState != 0:
            result += " transmitState='" + self.transmitState + "'"
        if self.whichGeometry != 1:
            result += " whichGeometry='" + self.whichGeometry + "'"
        if self.writeInterval != 1.0:
            result += " writeInterval='" + self.writeInterval + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TransmitterPdu>' + '\n'
#       print('XML serialization complete.')
        return result

class TriangleFanSet(_X3DComposedGeometryNode):
    """
    X3D element
    """
    NAME = 'TriangleFanSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TriangleFanSet'
    FIELD_DECLARATIONS = [('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('fanCount', list(), FieldType.MFInt32, AccessType.inputOutput),
                          ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('normal', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('attrib', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 fanCount=list(),
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TriangleFanSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.fanCount = fanCount
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex=None):
        if  colorPerVertex is None:
            colorPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def fanCount(self):
        return self.__fanCount
    @fanCount.setter
    def fanCount(self, fanCount=None):
        if  fanCount is None:
            fanCount = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(fanCount)
        assertGreaterThanEquals('fanCount', fanCount, 3)
        self.__fanCount = fanCount
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex=None):
        if  normalPerVertex is None:
            normalPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord=None):
        if  fogCoord is None:
            fogCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            print(flush=True)
            raise TypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal=None):
        if  normal is None:
            normal = SFNode.DEFAULT_VALUE
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            print(flush=True)
            raise TypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            print(flush=True)
            raise TypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib=None):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TriangleFanSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TriangleFanSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorPerVertex != True:
            result += " colorPerVertex='" + self.colorPerVertex + "'"
        if self.fanCount != list():
            result += " fanCount='" + self.fanCount + "'"
        if self.normalPerVertex != True:
            result += " normalPerVertex='" + self.normalPerVertex + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fogCoord: # walk each child node, if any
            result += indent
            for each in self.fogCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.normal: # walk each child node, if any
            result += indent
            for each in self.normal:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.attrib: # walk each child node, if any
            result += indent
            for each in self.attrib:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TriangleFanSet>' + '\n'
#       print('XML serialization complete.')
        return result

class TriangleSet(_X3DComposedGeometryNode):
    """
    X3D element
    """
    NAME = 'TriangleSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TriangleSet'
    FIELD_DECLARATIONS = [('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('normal', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('attrib', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TriangleSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex=None):
        if  colorPerVertex is None:
            colorPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex=None):
        if  normalPerVertex is None:
            normalPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord=None):
        if  fogCoord is None:
            fogCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            print(flush=True)
            raise TypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal=None):
        if  normal is None:
            normal = SFNode.DEFAULT_VALUE
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            print(flush=True)
            raise TypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            print(flush=True)
            raise TypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib=None):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TriangleSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TriangleSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorPerVertex != True:
            result += " colorPerVertex='" + self.colorPerVertex + "'"
        if self.normalPerVertex != True:
            result += " normalPerVertex='" + self.normalPerVertex + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fogCoord: # walk each child node, if any
            result += indent
            for each in self.fogCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.normal: # walk each child node, if any
            result += indent
            for each in self.normal:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.attrib: # walk each child node, if any
            result += indent
            for each in self.attrib:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TriangleSet>' + '\n'
#       print('XML serialization complete.')
        return result

class TriangleSet2D(_X3DGeometryNode):
    """
    X3D element
    """
    NAME = 'TriangleSet2D'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TriangleSet2D'
    FIELD_DECLARATIONS = [('solid', False, FieldType.SFBool, AccessType.initializeOnly),
                          ('vertices', list(), FieldType.MFVec2f, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 solid=False,
                 vertices=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TriangleSet2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.solid = solid
        self.vertices = vertices
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def vertices(self):
        return self.__vertices
    @vertices.setter
    def vertices(self, vertices=None):
        if  vertices is None:
            vertices = MFVec2f.DEFAULT_VALUE
        assertValidMFVec2f(vertices)
        self.__vertices = vertices
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TriangleSet2D.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TriangleSet2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.solid != False:
            result += " solid='" + self.solid + "'"
        if self.vertices != list():
            result += " vertices='" + self.vertices + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TriangleSet2D>' + '\n'
#       print('XML serialization complete.')
        return result

class TriangleStripSet(_X3DComposedGeometryNode):
    """
    X3D element
    """
    NAME = 'TriangleStripSet'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TriangleStripSet'
    FIELD_DECLARATIONS = [('ccw', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('solid', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('stripCount', list(), FieldType.MFInt32, AccessType.inputOutput),
                          ('color', None, FieldType.SFNode, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('normal', None, FieldType.SFNode, AccessType.inputOutput),
                          ('texCoord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('attrib', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 normalPerVertex=True,
                 solid=True,
                 stripCount=list(),
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TriangleStripSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.stripCount = stripCount
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw=None):
        if  ccw is None:
            ccw = SFBool.DEFAULT_VALUE
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex=None):
        if  colorPerVertex is None:
            colorPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex=None):
        if  normalPerVertex is None:
            normalPerVertex = SFBool.DEFAULT_VALUE
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        return self.__solid
    @solid.setter
    def solid(self, solid=None):
        if  solid is None:
            solid = SFBool.DEFAULT_VALUE
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def stripCount(self):
        return self.__stripCount
    @stripCount.setter
    def stripCount(self, stripCount=None):
        if  stripCount is None:
            stripCount = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(stripCount)
        assertGreaterThanEquals('stripCount', stripCount, 3)
        self.__stripCount = stripCount
    @property # getter - - - - - - - - - -
    def color(self):
        return self.__color
    @color.setter
    def color(self, color=None):
        if  color is None:
            color = SFNode.DEFAULT_VALUE
        assertValidSFNode(color)
        if not isinstance(color, object):
            print(flush=True)
            raise TypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord=None):
        if  fogCoord is None:
            fogCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            print(flush=True)
            raise TypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal=None):
        if  normal is None:
            normal = SFNode.DEFAULT_VALUE
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            print(flush=True)
            raise TypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord=None):
        if  texCoord is None:
            texCoord = SFNode.DEFAULT_VALUE
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            print(flush=True)
            raise TypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib=None):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TriangleStripSet.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TriangleStripSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ccw != True:
            result += " ccw='" + self.ccw + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorPerVertex != True:
            result += " colorPerVertex='" + self.colorPerVertex + "'"
        if self.normalPerVertex != True:
            result += " normalPerVertex='" + self.normalPerVertex + "'"
        if self.solid != True:
            result += " solid='" + self.solid + "'"
        if self.stripCount != list():
            result += " stripCount='" + self.stripCount + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.color: # walk each child node, if any
            result += indent
            for each in self.color:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.fogCoord: # walk each child node, if any
            result += indent
            for each in self.fogCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.normal: # walk each child node, if any
            result += indent
            for each in self.normal:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.texCoord: # walk each child node, if any
            result += indent
            for each in self.texCoord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.attrib: # walk each child node, if any
            result += indent
            for each in self.attrib:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TriangleStripSet>' + '\n'
#       print('XML serialization complete.')
        return result

class TwoSidedMaterial(_X3DMaterialNode):
    """
    X3D element
    """
    NAME = 'TwoSidedMaterial'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TwoSidedMaterial'
    FIELD_DECLARATIONS = [('ambientIntensity', 0.2, FieldType.SFFloat, AccessType.inputOutput),
                          ('backAmbientIntensity', 0.2, FieldType.SFFloat, AccessType.inputOutput),
                          ('backDiffuseColor', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.inputOutput),
                          ('backEmissiveColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput),
                          ('backShininess', 0.2, FieldType.SFFloat, AccessType.inputOutput),
                          ('backSpecularColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput),
                          ('backTransparency', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('diffuseColor', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.inputOutput),
                          ('emissiveColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput),
                          ('separateBackColor', False, FieldType.SFBool, AccessType.inputOutput),
                          ('shininess', 0.2, FieldType.SFFloat, AccessType.inputOutput),
                          ('specularColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput),
                          ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 ambientIntensity=0.2,
                 backAmbientIntensity=0.2,
                 backDiffuseColor=(0.8, 0.8, 0.8),
                 backEmissiveColor=(0, 0, 0),
                 backShininess=0.2,
                 backSpecularColor=(0, 0, 0),
                 backTransparency=0,
                 diffuseColor=(0.8, 0.8, 0.8),
                 emissiveColor=(0, 0, 0),
                 separateBackColor=False,
                 shininess=0.2,
                 specularColor=(0, 0, 0),
                 transparency=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TwoSidedMaterial __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.backAmbientIntensity = backAmbientIntensity
        self.backDiffuseColor = backDiffuseColor
        self.backEmissiveColor = backEmissiveColor
        self.backShininess = backShininess
        self.backSpecularColor = backSpecularColor
        self.backTransparency = backTransparency
        self.diffuseColor = diffuseColor
        self.emissiveColor = emissiveColor
        self.separateBackColor = separateBackColor
        self.shininess = shininess
        self.specularColor = specularColor
        self.transparency = transparency
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity=None):
        if  ambientIntensity is None:
            ambientIntensity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def backAmbientIntensity(self):
        return self.__backAmbientIntensity
    @backAmbientIntensity.setter
    def backAmbientIntensity(self, backAmbientIntensity=None):
        if  backAmbientIntensity is None:
            backAmbientIntensity = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(backAmbientIntensity)
        assertZeroToOne('backAmbientIntensity', backAmbientIntensity)
        self.__backAmbientIntensity = backAmbientIntensity
    @property # getter - - - - - - - - - -
    def backDiffuseColor(self):
        return self.__backDiffuseColor
    @backDiffuseColor.setter
    def backDiffuseColor(self, backDiffuseColor=None):
        if  backDiffuseColor is None:
            backDiffuseColor = SFColor.DEFAULT_VALUE
        assertValidSFColor(backDiffuseColor)
        assertZeroToOne('backDiffuseColor', backDiffuseColor)
        self.__backDiffuseColor = backDiffuseColor
    @property # getter - - - - - - - - - -
    def backEmissiveColor(self):
        return self.__backEmissiveColor
    @backEmissiveColor.setter
    def backEmissiveColor(self, backEmissiveColor=None):
        if  backEmissiveColor is None:
            backEmissiveColor = SFColor.DEFAULT_VALUE
        assertValidSFColor(backEmissiveColor)
        assertZeroToOne('backEmissiveColor', backEmissiveColor)
        self.__backEmissiveColor = backEmissiveColor
    @property # getter - - - - - - - - - -
    def backShininess(self):
        return self.__backShininess
    @backShininess.setter
    def backShininess(self, backShininess=None):
        if  backShininess is None:
            backShininess = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(backShininess)
        assertZeroToOne('backShininess', backShininess)
        self.__backShininess = backShininess
    @property # getter - - - - - - - - - -
    def backSpecularColor(self):
        return self.__backSpecularColor
    @backSpecularColor.setter
    def backSpecularColor(self, backSpecularColor=None):
        if  backSpecularColor is None:
            backSpecularColor = SFColor.DEFAULT_VALUE
        assertValidSFColor(backSpecularColor)
        assertZeroToOne('backSpecularColor', backSpecularColor)
        self.__backSpecularColor = backSpecularColor
    @property # getter - - - - - - - - - -
    def backTransparency(self):
        return self.__backTransparency
    @backTransparency.setter
    def backTransparency(self, backTransparency=None):
        if  backTransparency is None:
            backTransparency = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(backTransparency)
        assertZeroToOne('backTransparency', backTransparency)
        self.__backTransparency = backTransparency
    @property # getter - - - - - - - - - -
    def diffuseColor(self):
        return self.__diffuseColor
    @diffuseColor.setter
    def diffuseColor(self, diffuseColor=None):
        if  diffuseColor is None:
            diffuseColor = SFColor.DEFAULT_VALUE
        assertValidSFColor(diffuseColor)
        assertZeroToOne('diffuseColor', diffuseColor)
        self.__diffuseColor = diffuseColor
    @property # getter - - - - - - - - - -
    def emissiveColor(self):
        return self.__emissiveColor
    @emissiveColor.setter
    def emissiveColor(self, emissiveColor=None):
        if  emissiveColor is None:
            emissiveColor = SFColor.DEFAULT_VALUE
        assertValidSFColor(emissiveColor)
        assertZeroToOne('emissiveColor', emissiveColor)
        self.__emissiveColor = emissiveColor
    @property # getter - - - - - - - - - -
    def separateBackColor(self):
        return self.__separateBackColor
    @separateBackColor.setter
    def separateBackColor(self, separateBackColor=None):
        if  separateBackColor is None:
            separateBackColor = SFBool.DEFAULT_VALUE
        assertValidSFBool(separateBackColor)
        self.__separateBackColor = separateBackColor
    @property # getter - - - - - - - - - -
    def shininess(self):
        return self.__shininess
    @shininess.setter
    def shininess(self, shininess=None):
        if  shininess is None:
            shininess = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(shininess)
        assertZeroToOne('shininess', shininess)
        self.__shininess = shininess
    @property # getter - - - - - - - - - -
    def specularColor(self):
        return self.__specularColor
    @specularColor.setter
    def specularColor(self, specularColor=None):
        if  specularColor is None:
            specularColor = SFColor.DEFAULT_VALUE
        assertValidSFColor(specularColor)
        assertZeroToOne('specularColor', specularColor)
        self.__specularColor = specularColor
    @property # getter - - - - - - - - - -
    def transparency(self):
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency=None):
        if  transparency is None:
            transparency = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function TwoSidedMaterial.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<TwoSidedMaterial'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ambientIntensity != 0.2:
            result += " ambientIntensity='" + self.ambientIntensity + "'"
        if self.backAmbientIntensity != 0.2:
            result += " backAmbientIntensity='" + self.backAmbientIntensity + "'"
        if self.backDiffuseColor != (0.8, 0.8, 0.8):
            result += " backDiffuseColor='" + self.backDiffuseColor + "'"
        if self.backEmissiveColor != (0, 0, 0):
            result += " backEmissiveColor='" + self.backEmissiveColor + "'"
        if self.backShininess != 0.2:
            result += " backShininess='" + self.backShininess + "'"
        if self.backSpecularColor != (0, 0, 0):
            result += " backSpecularColor='" + self.backSpecularColor + "'"
        if self.backTransparency != 0:
            result += " backTransparency='" + self.backTransparency + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.diffuseColor != (0.8, 0.8, 0.8):
            result += " diffuseColor='" + self.diffuseColor + "'"
        if self.emissiveColor != (0, 0, 0):
            result += " emissiveColor='" + self.emissiveColor + "'"
        if self.separateBackColor != False:
            result += " separateBackColor='" + self.separateBackColor + "'"
        if self.shininess != 0.2:
            result += " shininess='" + self.shininess + "'"
        if self.specularColor != (0, 0, 0):
            result += " specularColor='" + self.specularColor + "'"
        if self.transparency != 0:
            result += " transparency='" + self.transparency + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</TwoSidedMaterial>' + '\n'
#       print('XML serialization complete.')
        return result

class UniversalJoint(_X3DRigidJointNode):
    """
    UniversalJoint is like a BallJoint that constrains an extra degree of rotational freedom.
    """
    NAME = 'UniversalJoint'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#UniversalJoint'
    FIELD_DECLARATIONS = [('anchorPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('axis1', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('axis2', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput),
                          ('stop1Bounce', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('stop1ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput),
                          ('stop2Bounce', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('stop2ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput),
                          ('body1', None, FieldType.SFNode, AccessType.inputOutput),
                          ('body2', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 anchorPoint=(0, 0, 0),
                 axis1=(0, 0, 0),
                 axis2=(0, 0, 0),
                 forceOutput=["NONE"],
                 stop1Bounce=0,
                 stop1ErrorCorrection=0.8,
                 stop2Bounce=0,
                 stop2ErrorCorrection=0.8,
                 body1=None,
                 body2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode UniversalJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.anchorPoint = anchorPoint
        self.axis1 = axis1
        self.axis2 = axis2
        self.forceOutput = forceOutput
        self.stop1Bounce = stop1Bounce
        self.stop1ErrorCorrection = stop1ErrorCorrection
        self.stop2Bounce = stop2Bounce
        self.stop2ErrorCorrection = stop2ErrorCorrection
        self.body1 = body1
        self.body2 = body2
    @property # getter - - - - - - - - - -
    def anchorPoint(self):
        return self.__anchorPoint
    @anchorPoint.setter
    def anchorPoint(self, anchorPoint=None):
        if  anchorPoint is None:
            anchorPoint = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(anchorPoint)
        self.__anchorPoint = anchorPoint
    @property # getter - - - - - - - - - -
    def axis1(self):
        return self.__axis1
    @axis1.setter
    def axis1(self, axis1=None):
        if  axis1 is None:
            axis1 = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(axis1)
        self.__axis1 = axis1
    @property # getter - - - - - - - - - -
    def axis2(self):
        return self.__axis2
    @axis2.setter
    def axis2(self, axis2=None):
        if  axis2 is None:
            axis2 = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(axis2)
        self.__axis2 = axis2
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput=None):
        if  forceOutput is None:
            forceOutput = MFString.DEFAULT_VALUE
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def stop1Bounce(self):
        return self.__stop1Bounce
    @stop1Bounce.setter
    def stop1Bounce(self, stop1Bounce=None):
        if  stop1Bounce is None:
            stop1Bounce = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stop1Bounce)
        assertZeroToOne('stop1Bounce', stop1Bounce)
        self.__stop1Bounce = stop1Bounce
    @property # getter - - - - - - - - - -
    def stop1ErrorCorrection(self):
        return self.__stop1ErrorCorrection
    @stop1ErrorCorrection.setter
    def stop1ErrorCorrection(self, stop1ErrorCorrection=None):
        if  stop1ErrorCorrection is None:
            stop1ErrorCorrection = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stop1ErrorCorrection)
        assertZeroToOne('stop1ErrorCorrection', stop1ErrorCorrection)
        self.__stop1ErrorCorrection = stop1ErrorCorrection
    @property # getter - - - - - - - - - -
    def stop2Bounce(self):
        return self.__stop2Bounce
    @stop2Bounce.setter
    def stop2Bounce(self, stop2Bounce=None):
        if  stop2Bounce is None:
            stop2Bounce = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stop2Bounce)
        assertZeroToOne('stop2Bounce', stop2Bounce)
        self.__stop2Bounce = stop2Bounce
    @property # getter - - - - - - - - - -
    def stop2ErrorCorrection(self):
        return self.__stop2ErrorCorrection
    @stop2ErrorCorrection.setter
    def stop2ErrorCorrection(self, stop2ErrorCorrection=None):
        if  stop2ErrorCorrection is None:
            stop2ErrorCorrection = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(stop2ErrorCorrection)
        assertZeroToOne('stop2ErrorCorrection', stop2ErrorCorrection)
        self.__stop2ErrorCorrection = stop2ErrorCorrection
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1=None):
        if  body1 is None:
            body1 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            print(flush=True)
            raise TypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2=None):
        if  body2 is None:
            body2 = SFNode.DEFAULT_VALUE
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            print(flush=True)
            raise TypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function UniversalJoint.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<UniversalJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.anchorPoint != (0, 0, 0):
            result += " anchorPoint='" + self.anchorPoint + "'"
        if self.axis1 != (0, 0, 0):
            result += " axis1='" + self.axis1 + "'"
        if self.axis2 != (0, 0, 0):
            result += " axis2='" + self.axis2 + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.forceOutput != ["NONE"]:
            result += " forceOutput='" + self.forceOutput + "'"
        if self.stop1Bounce != 0:
            result += " stop1Bounce='" + self.stop1Bounce + "'"
        if self.stop1ErrorCorrection != 0.8:
            result += " stop1ErrorCorrection='" + self.stop1ErrorCorrection + "'"
        if self.stop2Bounce != 0:
            result += " stop2Bounce='" + self.stop2Bounce + "'"
        if self.stop2ErrorCorrection != 0.8:
            result += " stop2ErrorCorrection='" + self.stop2ErrorCorrection + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body1: # walk each child node, if any
            result += indent
            for each in self.body1:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.body2: # walk each child node, if any
            result += indent
            for each in self.body2:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</UniversalJoint>' + '\n'
#       print('XML serialization complete.')
        return result

class Viewpoint(_X3DViewpointNode):
    """
    X3D element
    """
    NAME = 'Viewpoint'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Viewpoint'
    FIELD_DECLARATIONS = [('centerOfRotation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('fieldOfView', 0.7854, FieldType.SFFloat, AccessType.inputOutput),
                          ('jump', True, FieldType.SFBool, AccessType.inputOutput),
                          ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput),
                          ('position', (0, 0, 10), FieldType.SFVec3f, AccessType.inputOutput),
                          ('retainUserOffsets', False, FieldType.SFBool, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 centerOfRotation=(0, 0, 0),
                 description='',
                 fieldOfView=0.7854,
                 jump=True,
                 orientation=(0, 0, 1, 0),
                 position=(0, 0, 10),
                 retainUserOffsets=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Viewpoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.centerOfRotation = centerOfRotation
        self.description = description
        self.fieldOfView = fieldOfView
        self.jump = jump
        self.orientation = orientation
        self.position = position
        self.retainUserOffsets = retainUserOffsets
    @property # getter - - - - - - - - - -
    def centerOfRotation(self):
        return self.__centerOfRotation
    @centerOfRotation.setter
    def centerOfRotation(self, centerOfRotation=None):
        if  centerOfRotation is None:
            centerOfRotation = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(centerOfRotation)
        self.__centerOfRotation = centerOfRotation
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def fieldOfView(self):
        return self.__fieldOfView
    @fieldOfView.setter
    def fieldOfView(self, fieldOfView=None):
        if  fieldOfView is None:
            fieldOfView = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(fieldOfView)
        assertGreaterThan('fieldOfView', fieldOfView, 0)
        assertLessThan('fieldOfView', fieldOfView, 3.1416)
        self.__fieldOfView = fieldOfView
    @property # getter - - - - - - - - - -
    def jump(self):
        return self.__jump
    @jump.setter
    def jump(self, jump=None):
        if  jump is None:
            jump = SFBool.DEFAULT_VALUE
        assertValidSFBool(jump)
        self.__jump = jump
    @property # getter - - - - - - - - - -
    def orientation(self):
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation=None):
        if  orientation is None:
            orientation = SFRotation.DEFAULT_VALUE
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def position(self):
        return self.__position
    @position.setter
    def position(self, position=None):
        if  position is None:
            position = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def retainUserOffsets(self):
        return self.__retainUserOffsets
    @retainUserOffsets.setter
    def retainUserOffsets(self, retainUserOffsets=None):
        if  retainUserOffsets is None:
            retainUserOffsets = SFBool.DEFAULT_VALUE
        assertValidSFBool(retainUserOffsets)
        self.__retainUserOffsets = retainUserOffsets
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Viewpoint.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Viewpoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.centerOfRotation != (0, 0, 0):
            result += " centerOfRotation='" + self.centerOfRotation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.fieldOfView != 0.7854:
            result += " fieldOfView='" + self.fieldOfView + "'"
        if self.jump != True:
            result += " jump='" + self.jump + "'"
        if self.orientation != (0, 0, 1, 0):
            result += " orientation='" + self.orientation + "'"
        if self.position != (0, 0, 10):
            result += " position='" + self.position + "'"
        if self.retainUserOffsets != False:
            result += " retainUserOffsets='" + self.retainUserOffsets + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Viewpoint>' + '\n'
#       print('XML serialization complete.')
        return result

class ViewpointGroup(_X3DChildNode):
    """
    X3D element
    """
    NAME = 'ViewpointGroup'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ViewpointGroup'
    FIELD_DECLARATIONS = [('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('description', '', FieldType.SFString, AccessType.inputOutput),
                          ('displayed', True, FieldType.SFBool, AccessType.inputOutput),
                          ('retainUserOffsets', False, FieldType.SFBool, AccessType.inputOutput),
                          ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 center=(0, 0, 0),
                 description='',
                 displayed=True,
                 retainUserOffsets=False,
                 size=(0, 0, 0),
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ViewpointGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.description = description
        self.displayed = displayed
        self.retainUserOffsets = retainUserOffsets
        self.size = size
        self.children = children
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description=None):
        if  description is None:
            description = SFString.DEFAULT_VALUE
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def displayed(self):
        return self.__displayed
    @displayed.setter
    def displayed(self, displayed=None):
        if  displayed is None:
            displayed = SFBool.DEFAULT_VALUE
        assertValidSFBool(displayed)
        self.__displayed = displayed
    @property # getter - - - - - - - - - -
    def retainUserOffsets(self):
        return self.__retainUserOffsets
    @retainUserOffsets.setter
    def retainUserOffsets(self, retainUserOffsets=None):
        if  retainUserOffsets is None:
            retainUserOffsets = SFBool.DEFAULT_VALUE
        assertValidSFBool(retainUserOffsets)
        self.__retainUserOffsets = retainUserOffsets
    @property # getter - - - - - - - - - -
    def size(self):
        return self.__size
    @size.setter
    def size(self, size=None):
        if  size is None:
            size = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function ViewpointGroup.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<ViewpointGroup'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.displayed != True:
            result += " displayed='" + self.displayed + "'"
        if self.retainUserOffsets != False:
            result += " retainUserOffsets='" + self.retainUserOffsets + "'"
        if self.size != (0, 0, 0):
            result += " size='" + self.size + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</ViewpointGroup>' + '\n'
#       print('XML serialization complete.')
        return result

class Viewport(_X3DViewportNode):
    """
    X3D element
    """
    NAME = 'Viewport'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Viewport'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('clipBoundary', [0, 1, 0, 1], FieldType.MFFloat, AccessType.inputOutput),
                          ('children', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 clipBoundary=[0, 1, 0, 1],
                 children=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Viewport __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.clipBoundary = clipBoundary
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def clipBoundary(self):
        return self.__clipBoundary
    @clipBoundary.setter
    def clipBoundary(self, clipBoundary=None):
        if  clipBoundary is None:
            clipBoundary = MFFloat.DEFAULT_VALUE
        assertValidMFFloat(clipBoundary)
        assertZeroToOne('clipBoundary', clipBoundary)
        self.__clipBoundary = clipBoundary
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children=None):
        if  children is None:
            children = MFNode.DEFAULT_VALUE
        assertValidMFNode(children)
        self.__children = children
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function Viewport.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<Viewport'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.clipBoundary != [0, 1, 0, 1]:
            result += " clipBoundary='" + self.clipBoundary + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.children: # walk each child node, if any
            result += indent
            for each in self.children:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</Viewport>' + '\n'
#       print('XML serialization complete.')
        return result

class VisibilitySensor(_X3DEnvironmentalSensorNode):
    """
    X3D element
    """
    NAME = 'VisibilitySensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#VisibilitySensor'
    FIELD_DECLARATIONS = [('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 center=(0, 0, 0),
                 enabled=True,
                 size=(0, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode VisibilitySensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.enabled = enabled
        self.size = size
    @property # getter - - - - - - - - - -
    def center(self):
        return self.__center
    @center.setter
    def center(self, center=None):
        if  center is None:
            center = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def size(self):
        return self.__size
    @size.setter
    def size(self, size=None):
        if  size is None:
            size = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(size)
        assertNonNegative('size', size)
        self.__size = size
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function VisibilitySensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<VisibilitySensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0, 0):
            result += " center='" + self.center + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.size != (0, 0, 0):
            result += " size='" + self.size + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</VisibilitySensor>' + '\n'
#       print('XML serialization complete.')
        return result

class VolumeData(_X3DVolumeDataNode):
    """
    X3D element
    """
    NAME = 'VolumeData'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#VolumeData'
    FIELD_DECLARATIONS = [('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly),
                          ('dimensions', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput),
                          ('renderStyle', None, FieldType.SFNode, AccessType.inputOutput),
                          ('voxels', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxSize=(-1, -1, -1),
                 dimensions=(1, 1, 1),
                 renderStyle=None,
                 voxels=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode VolumeData __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxSize = bboxSize
        self.dimensions = dimensions
        self.renderStyle = renderStyle
        self.voxels = voxels
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter=None):
        if  bboxCenter is None:
            bboxCenter = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize=None):
        if  bboxSize is None:
            bboxSize = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def dimensions(self):
        return self.__dimensions
    @dimensions.setter
    def dimensions(self, dimensions=None):
        if  dimensions is None:
            dimensions = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(dimensions)
        assertPositive('dimensions', dimensions)
        self.__dimensions = dimensions
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle=None):
        if  renderStyle is None:
            renderStyle = SFNode.DEFAULT_VALUE
        assertValidSFNode(renderStyle)
        if not isinstance(renderStyle, object):
            print(flush=True)
            raise TypeError(str(renderStyle) + ' does not have a valid node type object')
        self.__renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def voxels(self):
        return self.__voxels
    @voxels.setter
    def voxels(self, voxels=None):
        if  voxels is None:
            voxels = SFNode.DEFAULT_VALUE
        assertValidSFNode(voxels)
        if not isinstance(voxels, object):
            print(flush=True)
            raise TypeError(str(voxels) + ' does not have a valid node type object')
        self.__voxels = voxels
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function VolumeData.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<VolumeData'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + self.bboxCenter + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + self.bboxSize + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.dimensions != (1, 1, 1):
            result += " dimensions='" + self.dimensions + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.renderStyle: # walk each child node, if any
            result += indent
            for each in self.renderStyle:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.voxels: # walk each child node, if any
            result += indent
            for each in self.voxels:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</VolumeData>' + '\n'
#       print('XML serialization complete.')
        return result

class VolumeEmitter(_X3DParticleEmitterNode):
    """
    X3D element
    """
    NAME = 'VolumeEmitter'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#VolumeEmitter'
    FIELD_DECLARATIONS = [('coordIndex', [-1], FieldType.MFInt32, AccessType.initializeOnly),
                          ('direction', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('internal', True, FieldType.SFBool, AccessType.initializeOnly),
                          ('mass', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('speed', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('surfaceArea', 0, FieldType.SFFloat, AccessType.initializeOnly),
                          ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput),
                          ('coord', None, FieldType.SFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 coordIndex=[-1],
                 direction=(0, 1, 0),
                 internal=True,
                 mass=0,
                 speed=0,
                 surfaceArea=0,
                 variation=0.25,
                 coord=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode VolumeEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.coordIndex = coordIndex
        self.direction = direction
        self.internal = internal
        self.mass = mass
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
        self.coord = coord
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex=None):
        if  coordIndex is None:
            coordIndex = MFInt32.DEFAULT_VALUE
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def direction(self):
        return self.__direction
    @direction.setter
    def direction(self, direction=None):
        if  direction is None:
            direction = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(direction)
        assertGreaterThanEquals('direction', direction, -1)
        assertLessThanEquals('direction', direction, 1)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def internal(self):
        return self.__internal
    @internal.setter
    def internal(self, internal=None):
        if  internal is None:
            internal = SFBool.DEFAULT_VALUE
        assertValidSFBool(internal)
        self.__internal = internal
    @property # getter - - - - - - - - - -
    def mass(self):
        return self.__mass
    @mass.setter
    def mass(self, mass=None):
        if  mass is None:
            mass = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def speed(self):
        return self.__speed
    @speed.setter
    def speed(self, speed=None):
        if  speed is None:
            speed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea=None):
        if  surfaceArea is None:
            surfaceArea = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        return self.__variation
    @variation.setter
    def variation(self, variation=None):
        if  variation is None:
            variation = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    @property # getter - - - - - - - - - -
    def coord(self):
        return self.__coord
    @coord.setter
    def coord(self, coord=None):
        if  coord is None:
            coord = SFNode.DEFAULT_VALUE
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            print(flush=True)
            raise TypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function VolumeEmitter.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<VolumeEmitter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.coordIndex != [-1]:
            result += " coordIndex='" + self.coordIndex + "'"
        if self.direction != (0, 1, 0):
            result += " direction='" + self.direction + "'"
        if self.internal != True:
            result += " internal='" + self.internal + "'"
        if self.mass != 0:
            result += " mass='" + self.mass + "'"
        if self.speed != 0:
            result += " speed='" + self.speed + "'"
        if self.surfaceArea != 0:
            result += " surfaceArea='" + self.surfaceArea + "'"
        if self.variation != 0.25:
            result += " variation='" + self.variation + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.coord: # walk each child node, if any
            result += indent
            for each in self.coord:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</VolumeEmitter>' + '\n'
#       print('XML serialization complete.')
        return result

class VolumePickSensor(_X3DPickSensorNode):
    """
    X3D element
    """
    NAME = 'VolumePickSensor'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#VolumePickSensor'
    FIELD_DECLARATIONS = [('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('intersectionType', 'BOUNDS', FieldType.SFString, AccessType.initializeOnly),
                          ('matchCriterion', 'MATCH_ANY', FieldType.SFString, AccessType.inputOutput),
                          ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput),
                          ('sortOrder', 'CLOSEST', FieldType.SFString, AccessType.initializeOnly),
                          ('pickingGeometry', None, FieldType.SFNode, AccessType.inputOutput),
                          ('pickTarget', list(), FieldType.MFNode, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 enabled=True,
                 intersectionType='BOUNDS',
                 matchCriterion='MATCH_ANY',
                 objectType=["ALL"],
                 sortOrder='CLOSEST',
                 pickingGeometry=None,
                 pickTarget=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode VolumePickSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.intersectionType = intersectionType
        self.matchCriterion = matchCriterion
        self.objectType = objectType
        self.sortOrder = sortOrder
        self.pickingGeometry = pickingGeometry
        self.pickTarget = pickTarget
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intersectionType(self):
        return self.__intersectionType
    @intersectionType.setter
    def intersectionType(self, intersectionType=None):
        if  intersectionType is None:
            intersectionType = SFString.DEFAULT_VALUE
        assertValidSFString(intersectionType)
        self.__intersectionType = intersectionType
    @property # getter - - - - - - - - - -
    def matchCriterion(self):
        return self.__matchCriterion
    @matchCriterion.setter
    def matchCriterion(self, matchCriterion=None):
        if  matchCriterion is None:
            matchCriterion = SFString.DEFAULT_VALUE
        assertValidSFString(matchCriterion)
        self.__matchCriterion = matchCriterion
    @property # getter - - - - - - - - - -
    def objectType(self):
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType=None):
        if  objectType is None:
            objectType = MFString.DEFAULT_VALUE
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def sortOrder(self):
        return self.__sortOrder
    @sortOrder.setter
    def sortOrder(self, sortOrder=None):
        if  sortOrder is None:
            sortOrder = SFString.DEFAULT_VALUE
        assertValidSFString(sortOrder)
        self.__sortOrder = sortOrder
    @property # getter - - - - - - - - - -
    def pickingGeometry(self):
        return self.__pickingGeometry
    @pickingGeometry.setter
    def pickingGeometry(self, pickingGeometry=None):
        if  pickingGeometry is None:
            pickingGeometry = SFNode.DEFAULT_VALUE
        assertValidSFNode(pickingGeometry)
        if not isinstance(pickingGeometry, object):
            print(flush=True)
            raise TypeError(str(pickingGeometry) + ' does not have a valid node type object')
        self.__pickingGeometry = pickingGeometry
    @property # getter - - - - - - - - - -
    def pickTarget(self):
        return self.__pickTarget
    @pickTarget.setter
    def pickTarget(self, pickTarget=None):
        if  pickTarget is None:
            pickTarget = MFNode.DEFAULT_VALUE
        assertValidMFNode(pickTarget)
        self.__pickTarget = pickTarget
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function VolumePickSensor.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<VolumePickSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.intersectionType != 'BOUNDS':
            result += " intersectionType='" + self.intersectionType + "'"
        if self.matchCriterion != 'MATCH_ANY':
            result += " matchCriterion='" + self.matchCriterion + "'"
        if self.objectType != ["ALL"]:
            result += " objectType='" + self.objectType + "'"
        if self.sortOrder != 'CLOSEST':
            result += " sortOrder='" + self.sortOrder + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.pickingGeometry: # walk each child node, if any
            result += indent
            for each in self.pickingGeometry:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.pickTarget: # walk each child node, if any
            result += indent
            for each in self.pickTarget:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</VolumePickSensor>' + '\n'
#       print('XML serialization complete.')
        return result

class WindPhysicsModel(_X3DParticlePhysicsModelNode):
    """
    X3D element
    """
    NAME = 'WindPhysicsModel'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#WindPhysicsModel'
    FIELD_DECLARATIONS = [('direction', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput),
                          ('enabled', True, FieldType.SFBool, AccessType.inputOutput),
                          ('gustiness', 0.1, FieldType.SFFloat, AccessType.inputOutput),
                          ('speed', 0.1, FieldType.SFFloat, AccessType.inputOutput),
                          ('turbulence', 0, FieldType.SFFloat, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 direction=(1, 0, 0),
                 enabled=True,
                 gustiness=0.1,
                 speed=0.1,
                 turbulence=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode WindPhysicsModel __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.direction = direction
        self.enabled = enabled
        self.gustiness = gustiness
        self.speed = speed
        self.turbulence = turbulence
    @property # getter - - - - - - - - - -
    def direction(self):
        return self.__direction
    @direction.setter
    def direction(self, direction=None):
        if  direction is None:
            direction = SFVec3f.DEFAULT_VALUE
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled=None):
        if  enabled is None:
            enabled = SFBool.DEFAULT_VALUE
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gustiness(self):
        return self.__gustiness
    @gustiness.setter
    def gustiness(self, gustiness=None):
        if  gustiness is None:
            gustiness = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(gustiness)
        assertNonNegative('gustiness', gustiness)
        self.__gustiness = gustiness
    @property # getter - - - - - - - - - -
    def speed(self):
        return self.__speed
    @speed.setter
    def speed(self, speed=None):
        if  speed is None:
            speed = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def turbulence(self):
        return self.__turbulence
    @turbulence.setter
    def turbulence(self, turbulence=None):
        if  turbulence is None:
            turbulence = SFFloat.DEFAULT_VALUE
        assertValidSFFloat(turbulence)
        assertZeroToOne('turbulence', turbulence)
        self.__turbulence = turbulence
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function WindPhysicsModel.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<WindPhysicsModel'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.direction != (1, 0, 0):
            result += " direction='" + self.direction + "'"
        if self.enabled != True:
            result += " enabled='" + self.enabled + "'"
        if self.gustiness != 0.1:
            result += " gustiness='" + self.gustiness + "'"
        if self.speed != 0.1:
            result += " speed='" + self.speed + "'"
        if self.turbulence != 0:
            result += " turbulence='" + self.turbulence + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</WindPhysicsModel>' + '\n'
#       print('XML serialization complete.')
        return result

class WorldInfo(_X3DInfoNode):
    """
    WorldInfo contains a title and simple persistent metadata information about an X3D scene. This node is strictly for documentation purposes and has no effect on the visual appearance or behaviour of the world.
    """
    NAME = 'WorldInfo'
    SPECIFICATION_URL = ''
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#WorldInfo'
    FIELD_DECLARATIONS = [('info', list(), FieldType.MFString, AccessType.inputOutput),
                          ('title', '', FieldType.SFString, AccessType.inputOutput),
                          ('DEF', '', FieldType.SFString, AccessType.inputOutput),
                          ('USE', '', FieldType.SFString, AccessType.inputOutput),
                          ('class_', '', FieldType.SFString, AccessType.inputOutput),
                          ('IS', None, FieldType.SFNode, AccessType.inputOutput),
                          ('metadata', None, FieldType.SFNode, AccessType.inputOutput)]
    def __init__(self,
                 info=list(),
                 title='',
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode WorldInfo __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')')
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.info = info
        self.title = title
    @property # getter - - - - - - - - - -
    def info(self):
        return self.__info
    @info.setter
    def info(self, info=None):
        if  info is None:
            info = MFString.DEFAULT_VALUE
        assertValidMFString(info)
        self.__info = info
    @property # getter - - - - - - - - - -
    def title(self):
        return self.__title
    @title.setter
    def title(self, title=None):
        if  title is None:
            title = SFString.DEFAULT_VALUE
        assertValidSFString(title)
        self.__title = title
    # output function - - - - - - - - - -
    def toXML(self, indentLevel=0):
        """ provide Canonical X3D output serialization using XML encoding """
        indent = '  ' * indentLevel
        result = ''
        # if _DEBUG: result += indent + '# invoked class function WorldInfo.toXML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        print(result)
        result += indent + '<WorldInfo'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.info != list():
            result += " info='" + self.info + "'"
        if self.title:
            result += " title='" + self.title + "'" + '>' + '\n'
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.IS: # walk each child node, if any
            result += indent
            for each in self.IS:
                each.toXML(indentLevel=indentLevel+1)
        ## result += indent + '  ' + 'TODO iterate over each child element' + '\n'
        if self.metadata: # walk each child node, if any
            result += indent
            for each in self.metadata:
                each.toXML(indentLevel=indentLevel+1)
        result += indent + '</WorldInfo>' + '\n'
#       print('XML serialization complete.')
        return result

###############################################

# Python x3d Package Loading Complete

print("x3d package loaded, have fun with X3D Graphics!")

###############################################
