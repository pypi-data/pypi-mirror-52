# coding: utf-8

"""
    Felix' Website mit Blog

    The api of my blog.  # noqa: E501

    The version of the OpenAPI document: 0.0.1
    Contact: felix@felix-scholz.org
    Generated by: https://openapi-generator.tech
"""

from __future__ import absolute_import

from multiprocessing.pool import AsyncResult
from typing import Union, Tuple, List, Optional

from urllib3._collections import HTTPHeaderDict

from website_python_client.models.category import Category

from website_python_client.api.api import Api, RequestMethod
from website_python_client.configuration import Configuration
from website_python_client.exceptions import ApiValueError, ApiException, ApiNotFoundException


class CategoryApi(Api):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, configuration: Configuration):
        super().__init__(configuration)

    def create(self, category: Category, sync: bool = False)\
            -> Union[Tuple[Union[Category, List[Category], dict], int, HTTPHeaderDict], AsyncResult]:
        """

        :param category:
        :param sync:
        :return:
        """
        self.accept = ['application/json']
        self.content_type = ['application/x-www-form-urlencoded']
        self.auth(['ApiSecurity', 'ApiWriteSecurity'])

        if category.title is None:
            raise ApiException('The category must have an title.')
        if category.slug is None:
            raise ApiException('The category must have an slug.')

        if not sync:
            return self._call_api(
                '/category', RequestMethod.POST, None, [], body=None, post_params=category.post_params(), files=[],
                _preload_content=category, _request_timeout=300)
        else:
            thread = self.pool.apply_async(self._call_api, (
                '/category', RequestMethod.POST, None, [], None, category.post_params(), [], category, 300))

        return thread

    def delete(self, category: Union[Category, str], sync: bool = False) \
            -> Union[Tuple[Union[Category, List[Category], dict], int, HTTPHeaderDict], AsyncResult]:
        """

        :param category:
        :param sync:
        :return:
        """
        if not isinstance(category, Category):
            category = Category(category)

        self.accept = ['application/json']
        self.content_type = ['application/json']
        self.auth(['ApiSecurity', 'ApiWriteSecurity'])

        if not sync:
            return self._call_api(
                '/category/{category}', RequestMethod.DELETE, [('category', category.identifier)], [],
                body=None, post_params=[], files=[], _preload_content=category, _request_timeout=300)
        else:
            thread = self.pool.apply_async(self._call_api, (
                '/category/{category}', RequestMethod.DELETE, [('category', category.identifier)], [], None, [], [],
                category, 300))

        return thread

    def show(self, category: Union[Category, str], embedded_categories: bool = True, sync: bool = False) \
            -> Union[Tuple[Union[Category, List[Category], dict], int, HTTPHeaderDict], AsyncResult]:
        """

        :param category:
        :param embedded_categories:
        :param sync:
        :return:
        """
        if not isinstance(category, Category):
            category = Category(category)

        query_params = [('embeddedCategories', int(embedded_categories))]

        self.accept = ['application/json']
        self.content_type = ['application/json']
        self.auth(['ApiSecurity', 'ApiReadSecurity'])

        if not sync:
            return self._call_api('/category/{category}', RequestMethod.GET, [('category', category.identifier)],
                                  query_params, body=None, post_params=[], files=[],
                                  _preload_content=category, _request_timeout=300)
        else:
            thread = self.pool.apply_async(self._call_api, (
                '/category/{category}', RequestMethod.GET, [('category', category.identifier)], query_params, None,
                [], [], category, 300))

        return thread

    def show_or_create(self, category: Category, sync: bool = False) \
            -> Union[Tuple[Union[Category, List[Category], dict], int, HTTPHeaderDict], AsyncResult]:
        try:
            return self.show(category, False, sync)
        except ApiNotFoundException:
            return self.create(category, sync)

    def list(self, page: int = 1, per_page: int = 100, sync: bool = False) \
            -> Union[Tuple[Union[Category, List[Category], dict], int, HTTPHeaderDict], AsyncResult]:
        """"""
        if page < 1:
            raise ApiValueError(
                "Invalid value for parameter `per_page` when calling `list_post`," +
                " must be a value greater than or equal to `1`")

        if per_page < 1:
            raise ApiValueError(
                "Invalid value for parameter `page` when calling `list_post`," +
                "must be a value greater than or equal to `1`")

        query_params: List[Tuple[str, int]] = [
            ('page', page),
            ('perPage', per_page)
        ]

        self.accept = ['application/json']
        self.content_type = ['application/json']
        self.auth(['ApiSecurity', 'ApiReadSecurity'])

        if not sync:
            return self._call_api('/category', RequestMethod.GET, None, query_params,
                                  body=None, post_params=[], files=[], _preload_content=Category, _request_timeout=300)
        else:
            thread = self.pool.apply_async(self._call_api, (
                '/category', RequestMethod.GET, None, query_params, None, [], [], Category, 300))

        return thread

    def update(self, category: Category, only: Optional[List[str]] = None, sync: bool = False) \
            -> Union[Tuple[Union[Category, List[Category], dict], int, HTTPHeaderDict], AsyncResult]:
        """

        :param only:
        :param category:
        :param sync:
        :return:
        """

        self.accept = ['application/json']
        self.content_type = ['application/x-www-form-urlencoded']
        self.auth(['ApiSecurity', 'ApiWriteSecurity'])

        if not sync:
            return self._call_api('/category/{category}', RequestMethod.PUT, [('category', category.identifier)], [],
                                  body=None, post_params=category.post_params(only), files=[],
                                  _preload_content=category, _request_timeout=300)
        else:
            thread = self.pool.apply_async(self._call_api, (
                '/category/{category}', RequestMethod.PUT, [('category', category.identifier)], [], None,
                category.post_params(only), [], category, 300))

        return thread

    def update_or_create(self, category: Category, sync: bool = False) \
            -> Union[Tuple[Union[Category, List[Category], dict], int, HTTPHeaderDict], AsyncResult]:
        try:
            return self.update(category, None, sync)
        except ApiNotFoundException:
            return self.create(category, sync)
