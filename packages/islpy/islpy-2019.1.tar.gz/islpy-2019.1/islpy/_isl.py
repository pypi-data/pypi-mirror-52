# AUTOMATICALLY GENERATED by gen_wrap.py -- do not edit

from __future__ import print_function

import six
import sys
import logging
import threading


_PY3 = sys.version_info >= (3,)

is_win = sys.platform.startswith('win32')

from islpy._isl_cffi import ffi

if is_win:
    lib = ffi.dlopen('_isl_cffi.pyd')
else:
    lib = ffi.dlopen(None)

from cffi import FFI
libc_ffi = FFI()

cdef_string = '''
    char *strdup(const char *s);
    void free(void *ptr);
    '''

if is_win:
    cdef_string = cdef_string.replace('strdup', '_strdup')

libc_ffi.cdef(cdef_string)

if is_win and sys.version_info >= (3,5):
    libc = libc_ffi.dlopen('ucrtbase')
else:
    libc = libc_ffi.dlopen(None)


class Error(Exception):
    pass


class IslTypeError(Error, TypeError):
    pass

_context_use_map = {}

def _deref_ctx(ctx_data, ctx_iptr):
    _context_use_map[ctx_iptr] -= 1
    if _context_use_map[ctx_iptr] == 0:
        del _context_use_map[ctx_iptr]
        lib.isl_ctx_free(ctx_data)


def _get_last_error_str(ctx_data):
    code = lib.isl_ctx_last_error(ctx_data)
    for name in dir(error):
        if name.startswith("_"):
            continue
        if getattr(error, name) == code:
            return "isl_error_"+name

    return "(unknown error)"


class _ISLObjectBase(object):
    def __init__(self, _data):
        self._setup(_data)

    def _setup(self, data):
        assert not hasattr(self, "data")
        assert isinstance(data, ffi.CData)
        self.data =  data

        self._set_ctx_data()
        iptr = self._ctx_iptr
        _context_use_map[iptr] = _context_use_map.get(iptr, 0) + 1

    def _reset(self, data):
        assert self.data is not None
        assert isinstance(data, ffi.CData)

        _deref_ctx(self._ctx_data, self._ctx_iptr)
        self.data = data

        self._set_ctx_data()
        iptr = self._ctx_iptr
        _context_use_map[iptr] = _context_use_map.get(iptr, 0) + 1

    def _set_ctx_data(self):
        self._ctx_data = self._get_ctx_data()
        self._ctx_iptr = int(ffi.cast("intptr_t", self._get_ctx_data()))

    def _release(self):
        if self.data is None:
            raise Error("cannot release already-released object")

        data = self.data
        if _deref_ctx is not None:
            _deref_ctx(self._ctx_data, self._ctx_iptr)
        else:
            # This can happen if we're called super-late in cleanup.
            # Since everything else is already mopped up, we really
            # can't do what it takes to mop up this context.
            # So we leak it (i.e. leave it for the OS to clean up.)
            pass

        self.data = None
        return data

    def __eq__(self, other):
        return (type(self) == type(other) and self.data == other.data)

    def __ne__(self, other):
        return not self.__eq__(other)


class _EnumBase(object):
    @classmethod
    def find_value(cls, v):
        for name in dir(cls):
            if getattr(cls, name) == v:
                return name

        raise ValueError("Value '%s' not found in enum" % v)


class _ManagedCString(object):
    def __init__(self, cdata):
        if is_win:
            self.data = libc._strdup(cdata)
        else:
            self.data = libc.strdup(cdata)
        if self.data == libc_ffi.NULL:
            raise Error("strdup() failed")

    def release(self):
        if self.data is None:
            raise Error("cannot release already-released object")

        data = self.data
        self.data = None
        return data

    def __del__(self):
        libc.free(self.data)


if _PY3:
    class DelayedKeyboardInterrupt(object):
        def __enter__(self):
            self.previous_switch_interval = sys.getswitchinterval()
            sys.setswitchinterval(10000000)

        def __exit__(self, type, value, traceback):
            sys.setswitchinterval(self.previous_switch_interval)
else:
    class DelayedKeyboardInterrupt(object):
        def __enter__(self):
            self.previous_check_interval = sys.getcheckinterval()
            sys.setcheckinterval(100000000)

        def __exit__(self, type, value, traceback):
            sys.setcheckinterval(self.previous_check_interval)


# {{{ enums

class format(_EnumBase):
    ISL = lib.ISL_FORMAT_ISL
    POLYLIB = lib.ISL_FORMAT_POLYLIB
    POLYLIB_CONSTRAINTS = lib.ISL_FORMAT_POLYLIB_CONSTRAINTS
    OMEGA = lib.ISL_FORMAT_OMEGA
    C = lib.ISL_FORMAT_C
    LATEX = lib.ISL_FORMAT_LATEX
    EXT_POLYLIB = lib.ISL_FORMAT_EXT_POLYLIB

class ast_expr_type(_EnumBase):
    error = lib.isl_ast_expr_error
    op = lib.isl_ast_expr_op
    id = lib.isl_ast_expr_id
    int = lib.isl_ast_expr_int

class bound(_EnumBase):
    BERNSTEIN = lib.ISL_BOUND_BERNSTEIN
    RANGE = lib.ISL_BOUND_RANGE

class yaml_style(_EnumBase):
    BLOCK = lib.ISL_YAML_STYLE_BLOCK
    FLOW = lib.ISL_YAML_STYLE_FLOW

class on_error(_EnumBase):
    WARN = lib.ISL_ON_ERROR_WARN
    CONTINUE = lib.ISL_ON_ERROR_CONTINUE
    ABORT = lib.ISL_ON_ERROR_ABORT

class schedule_node_type(_EnumBase):
    error = lib.isl_schedule_node_error
    band = lib.isl_schedule_node_band
    context = lib.isl_schedule_node_context
    domain = lib.isl_schedule_node_domain
    expansion = lib.isl_schedule_node_expansion
    extension = lib.isl_schedule_node_extension
    filter = lib.isl_schedule_node_filter
    leaf = lib.isl_schedule_node_leaf
    guard = lib.isl_schedule_node_guard
    mark = lib.isl_schedule_node_mark
    sequence = lib.isl_schedule_node_sequence
    set = lib.isl_schedule_node_set

class error(_EnumBase):
    none = lib.isl_error_none
    abort = lib.isl_error_abort
    alloc = lib.isl_error_alloc
    unknown = lib.isl_error_unknown
    internal = lib.isl_error_internal
    invalid = lib.isl_error_invalid
    quota = lib.isl_error_quota
    unsupported = lib.isl_error_unsupported

class dim_type(_EnumBase):
    cst = lib.isl_dim_cst
    param = lib.isl_dim_param
    in_ = lib.isl_dim_in
    out = lib.isl_dim_out
    set = lib.isl_dim_set
    div = lib.isl_dim_div
    all = lib.isl_dim_all

class ast_loop_type(_EnumBase):
    error = lib.isl_ast_loop_error
    default = lib.isl_ast_loop_default
    atomic = lib.isl_ast_loop_atomic
    unroll = lib.isl_ast_loop_unroll
    separate = lib.isl_ast_loop_separate

class ast_node_type(_EnumBase):
    error = lib.isl_ast_node_error
    for_ = lib.isl_ast_node_for
    if_ = lib.isl_ast_node_if
    block = lib.isl_ast_node_block
    mark = lib.isl_ast_node_mark
    user = lib.isl_ast_node_user

class stat(_EnumBase):
    error = lib.isl_stat_error
    ok = lib.isl_stat_ok

class fold(_EnumBase):
    min = lib.isl_fold_min
    max = lib.isl_fold_max
    list = lib.isl_fold_list

class schedule_algorithm(_EnumBase):
    ISL = lib.ISL_SCHEDULE_ALGORITHM_ISL
    FEAUTRIER = lib.ISL_SCHEDULE_ALGORITHM_FEAUTRIER

class ast_op_type(_EnumBase):
    error = lib.isl_ast_op_error
    and_ = lib.isl_ast_op_and
    and_then = lib.isl_ast_op_and_then
    or_ = lib.isl_ast_op_or
    or_else = lib.isl_ast_op_or_else
    max = lib.isl_ast_op_max
    min = lib.isl_ast_op_min
    minus = lib.isl_ast_op_minus
    add = lib.isl_ast_op_add
    sub = lib.isl_ast_op_sub
    mul = lib.isl_ast_op_mul
    div = lib.isl_ast_op_div
    fdiv_q = lib.isl_ast_op_fdiv_q
    pdiv_q = lib.isl_ast_op_pdiv_q
    pdiv_r = lib.isl_ast_op_pdiv_r
    zdiv_r = lib.isl_ast_op_zdiv_r
    cond = lib.isl_ast_op_cond
    select = lib.isl_ast_op_select
    eq = lib.isl_ast_op_eq
    le = lib.isl_ast_op_le
    lt = lib.isl_ast_op_lt
    ge = lib.isl_ast_op_ge
    gt = lib.isl_ast_op_gt
    call = lib.isl_ast_op_call
    access = lib.isl_ast_op_access
    member = lib.isl_ast_op_member
    address_of = lib.isl_ast_op_address_of

# }}}
# {{{ declare classes

class Context(_ISLObjectBase):
    _base_name = 'ctx'

    def _get_ctx_data(self):
        return self.data
    
    def __del__(self):
        if self.data is not None:
            self._release()

class IdList(_ISLObjectBase):
    _base_name = 'id_list'

    def _get_ctx_data(self):
        return lib.isl_id_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_id_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_id_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of IdList")
    
        return IdList(_data=data)

class ValList(_ISLObjectBase):
    _base_name = 'val_list'

    def _get_ctx_data(self):
        return lib.isl_val_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_val_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_val_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of ValList")
    
        return ValList(_data=data)

class BasicSetList(_ISLObjectBase):
    _base_name = 'basic_set_list'

    def _get_ctx_data(self):
        return lib.isl_basic_set_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_basic_set_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_basic_set_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of BasicSetList")
    
        return BasicSetList(_data=data)

class BasicMapList(_ISLObjectBase):
    _base_name = 'basic_map_list'

    def _get_ctx_data(self):
        return lib.isl_basic_map_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_basic_map_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_basic_map_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of BasicMapList")
    
        return BasicMapList(_data=data)

class SetList(_ISLObjectBase):
    _base_name = 'set_list'

    def _get_ctx_data(self):
        return lib.isl_set_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_set_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_set_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of SetList")
    
        return SetList(_data=data)

class MapList(_ISLObjectBase):
    _base_name = 'map_list'

    def _get_ctx_data(self):
        return lib.isl_map_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_map_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_map_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of MapList")
    
        return MapList(_data=data)

class UnionSetList(_ISLObjectBase):
    _base_name = 'union_set_list'

    def _get_ctx_data(self):
        return lib.isl_union_set_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_union_set_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_union_set_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of UnionSetList")
    
        return UnionSetList(_data=data)

class ConstraintList(_ISLObjectBase):
    _base_name = 'constraint_list'

    def _get_ctx_data(self):
        return lib.isl_constraint_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_constraint_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_constraint_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of ConstraintList")
    
        return ConstraintList(_data=data)

class AffList(_ISLObjectBase):
    _base_name = 'aff_list'

    def _get_ctx_data(self):
        return lib.isl_aff_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_aff_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_aff_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of AffList")
    
        return AffList(_data=data)

class PwAffList(_ISLObjectBase):
    _base_name = 'pw_aff_list'

    def _get_ctx_data(self):
        return lib.isl_pw_aff_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_pw_aff_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_pw_aff_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of PwAffList")
    
        return PwAffList(_data=data)

class PwMultiAffList(_ISLObjectBase):
    _base_name = 'pw_multi_aff_list'

    def _get_ctx_data(self):
        return lib.isl_pw_multi_aff_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_pw_multi_aff_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_pw_multi_aff_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of PwMultiAffList")
    
        return PwMultiAffList(_data=data)

class AstExprList(_ISLObjectBase):
    _base_name = 'ast_expr_list'

    def _get_ctx_data(self):
        return lib.isl_ast_expr_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_ast_expr_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_ast_expr_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of AstExprList")
    
        return AstExprList(_data=data)

class AstNodeList(_ISLObjectBase):
    _base_name = 'ast_node_list'

    def _get_ctx_data(self):
        return lib.isl_ast_node_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_ast_node_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_ast_node_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of AstNodeList")
    
        return AstNodeList(_data=data)

class PwQPolynomialList(_ISLObjectBase):
    _base_name = 'pw_qpolynomial_list'

    def _get_ctx_data(self):
        return lib.isl_pw_qpolynomial_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_pw_qpolynomial_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_pw_qpolynomial_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of PwQPolynomialList")
    
        return PwQPolynomialList(_data=data)

class PwQPolynomialFoldList(_ISLObjectBase):
    _base_name = 'pw_qpolynomial_fold_list'

    def _get_ctx_data(self):
        return lib.isl_pw_qpolynomial_fold_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_pw_qpolynomial_fold_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_pw_qpolynomial_fold_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of PwQPolynomialFoldList")
    
        return PwQPolynomialFoldList(_data=data)

class IdToAstExpr(_ISLObjectBase):
    _base_name = 'id_to_ast_expr'

    def _get_ctx_data(self):
        return lib.isl_id_to_ast_expr_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_id_to_ast_expr_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_id_to_ast_expr_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of IdToAstExpr")
    
        return IdToAstExpr(_data=data)

class Printer(_ISLObjectBase):
    _base_name = 'printer'

    def _get_ctx_data(self):
        return lib.isl_printer_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_printer_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

class Val(_ISLObjectBase):
    _base_name = 'val'

    def _get_ctx_data(self):
        return lib.isl_val_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_val_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_val_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Val")
    
        return Val(_data=data)

class MultiVal(_ISLObjectBase):
    _base_name = 'multi_val'

    def _get_ctx_data(self):
        return lib.isl_multi_val_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_multi_val_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_multi_val_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of MultiVal")
    
        return MultiVal(_data=data)

class Vec(_ISLObjectBase):
    _base_name = 'vec'

    def _get_ctx_data(self):
        return lib.isl_vec_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_vec_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_vec_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Vec")
    
        return Vec(_data=data)

class Mat(_ISLObjectBase):
    _base_name = 'mat'

    def _get_ctx_data(self):
        return lib.isl_mat_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_mat_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_mat_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Mat")
    
        return Mat(_data=data)

class FixedBox(_ISLObjectBase):
    _base_name = 'fixed_box'

    def _get_ctx_data(self):
        return lib.isl_fixed_box_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_fixed_box_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_fixed_box_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of FixedBox")
    
        return FixedBox(_data=data)

class Aff(_ISLObjectBase):
    _base_name = 'aff'

    def _get_ctx_data(self):
        return lib.isl_aff_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_aff_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_aff_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Aff")
    
        return Aff(_data=data)

class PwAff(_ISLObjectBase):
    _base_name = 'pw_aff'

    def _get_ctx_data(self):
        return lib.isl_pw_aff_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_pw_aff_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_pw_aff_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of PwAff")
    
        return PwAff(_data=data)

class UnionPwAff(_ISLObjectBase):
    _base_name = 'union_pw_aff'

    def _get_ctx_data(self):
        return lib.isl_union_pw_aff_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_union_pw_aff_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_union_pw_aff_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of UnionPwAff")
    
        return UnionPwAff(_data=data)

class MultiAff(_ISLObjectBase):
    _base_name = 'multi_aff'

    def _get_ctx_data(self):
        return lib.isl_multi_aff_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_multi_aff_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_multi_aff_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of MultiAff")
    
        return MultiAff(_data=data)

class MultiPwAff(_ISLObjectBase):
    _base_name = 'multi_pw_aff'

    def _get_ctx_data(self):
        return lib.isl_multi_pw_aff_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_multi_pw_aff_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_multi_pw_aff_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of MultiPwAff")
    
        return MultiPwAff(_data=data)

class PwMultiAff(_ISLObjectBase):
    _base_name = 'pw_multi_aff'

    def _get_ctx_data(self):
        return lib.isl_pw_multi_aff_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_pw_multi_aff_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_pw_multi_aff_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of PwMultiAff")
    
        return PwMultiAff(_data=data)

class UnionPwMultiAff(_ISLObjectBase):
    _base_name = 'union_pw_multi_aff'

    def _get_ctx_data(self):
        return lib.isl_union_pw_multi_aff_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_union_pw_multi_aff_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_union_pw_multi_aff_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of UnionPwMultiAff")
    
        return UnionPwMultiAff(_data=data)

class UnionPwAffList(_ISLObjectBase):
    _base_name = 'union_pw_aff_list'

    def _get_ctx_data(self):
        return lib.isl_union_pw_aff_list_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_union_pw_aff_list_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_union_pw_aff_list_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of UnionPwAffList")
    
        return UnionPwAffList(_data=data)

class MultiUnionPwAff(_ISLObjectBase):
    _base_name = 'multi_union_pw_aff'

    def _get_ctx_data(self):
        return lib.isl_multi_union_pw_aff_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_multi_union_pw_aff_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_multi_union_pw_aff_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of MultiUnionPwAff")
    
        return MultiUnionPwAff(_data=data)

class Id(_ISLObjectBase):
    _base_name = 'id'

    def _get_ctx_data(self):
        return lib.isl_id_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_id_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_id_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Id")
    
        return Id(_data=data)

class MultiId(_ISLObjectBase):
    _base_name = 'multi_id'

    def _get_ctx_data(self):
        return lib.isl_multi_id_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_multi_id_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_multi_id_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of MultiId")
    
        return MultiId(_data=data)

class Constraint(_ISLObjectBase):
    _base_name = 'constraint'

    def _get_ctx_data(self):
        return lib.isl_constraint_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_constraint_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_constraint_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Constraint")
    
        return Constraint(_data=data)

class Space(_ISLObjectBase):
    _base_name = 'space'

    def _get_ctx_data(self):
        return lib.isl_space_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_space_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_space_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Space")
    
        return Space(_data=data)

class LocalSpace(_ISLObjectBase):
    _base_name = 'local_space'

    def _get_ctx_data(self):
        return lib.isl_local_space_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_local_space_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_local_space_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of LocalSpace")
    
        return LocalSpace(_data=data)

class BasicSet(_ISLObjectBase):
    _base_name = 'basic_set'

    def _get_ctx_data(self):
        return lib.isl_basic_set_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_basic_set_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_basic_set_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of BasicSet")
    
        return BasicSet(_data=data)

class BasicMap(_ISLObjectBase):
    _base_name = 'basic_map'

    def _get_ctx_data(self):
        return lib.isl_basic_map_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_basic_map_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_basic_map_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of BasicMap")
    
        return BasicMap(_data=data)

class Set(_ISLObjectBase):
    _base_name = 'set'

    def _get_ctx_data(self):
        return lib.isl_set_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_set_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_set_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Set")
    
        return Set(_data=data)

class Map(_ISLObjectBase):
    _base_name = 'map'

    def _get_ctx_data(self):
        return lib.isl_map_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_map_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_map_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Map")
    
        return Map(_data=data)

class UnionMap(_ISLObjectBase):
    _base_name = 'union_map'

    def _get_ctx_data(self):
        return lib.isl_union_map_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_union_map_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_union_map_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of UnionMap")
    
        return UnionMap(_data=data)

class UnionSet(_ISLObjectBase):
    _base_name = 'union_set'

    def _get_ctx_data(self):
        return lib.isl_union_set_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_union_set_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_union_set_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of UnionSet")
    
        return UnionSet(_data=data)

class Point(_ISLObjectBase):
    _base_name = 'point'

    def _get_ctx_data(self):
        return lib.isl_point_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_point_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_point_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Point")
    
        return Point(_data=data)

class Vertex(_ISLObjectBase):
    _base_name = 'vertex'

    def _get_ctx_data(self):
        return lib.isl_vertex_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_vertex_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_vertex_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Vertex")
    
        return Vertex(_data=data)

class Cell(_ISLObjectBase):
    _base_name = 'cell'

    def _get_ctx_data(self):
        return lib.isl_cell_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_cell_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_cell_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Cell")
    
        return Cell(_data=data)

class Vertices(_ISLObjectBase):
    _base_name = 'vertices'

    def _get_ctx_data(self):
        return lib.isl_vertices_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_vertices_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_vertices_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Vertices")
    
        return Vertices(_data=data)

class StrideInfo(_ISLObjectBase):
    _base_name = 'stride_info'

    def _get_ctx_data(self):
        return lib.isl_stride_info_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_stride_info_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_stride_info_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of StrideInfo")
    
        return StrideInfo(_data=data)

class QPolynomialFold(_ISLObjectBase):
    _base_name = 'qpolynomial_fold'

    def _get_ctx_data(self):
        return lib.isl_qpolynomial_fold_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_qpolynomial_fold_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_qpolynomial_fold_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of QPolynomialFold")
    
        return QPolynomialFold(_data=data)

class PwQPolynomialFold(_ISLObjectBase):
    _base_name = 'pw_qpolynomial_fold'

    def _get_ctx_data(self):
        return lib.isl_pw_qpolynomial_fold_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_pw_qpolynomial_fold_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_pw_qpolynomial_fold_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of PwQPolynomialFold")
    
        return PwQPolynomialFold(_data=data)

class UnionPwQPolynomialFold(_ISLObjectBase):
    _base_name = 'union_pw_qpolynomial_fold'

    def _get_ctx_data(self):
        return lib.isl_union_pw_qpolynomial_fold_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_union_pw_qpolynomial_fold_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_union_pw_qpolynomial_fold_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of UnionPwQPolynomialFold")
    
        return UnionPwQPolynomialFold(_data=data)

class UnionPwQPolynomial(_ISLObjectBase):
    _base_name = 'union_pw_qpolynomial'

    def _get_ctx_data(self):
        return lib.isl_union_pw_qpolynomial_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_union_pw_qpolynomial_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_union_pw_qpolynomial_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of UnionPwQPolynomial")
    
        return UnionPwQPolynomial(_data=data)

class QPolynomial(_ISLObjectBase):
    _base_name = 'qpolynomial'

    def _get_ctx_data(self):
        return lib.isl_qpolynomial_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_qpolynomial_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_qpolynomial_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of QPolynomial")
    
        return QPolynomial(_data=data)

class PwQPolynomial(_ISLObjectBase):
    _base_name = 'pw_qpolynomial'

    def _get_ctx_data(self):
        return lib.isl_pw_qpolynomial_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_pw_qpolynomial_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_pw_qpolynomial_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of PwQPolynomial")
    
        return PwQPolynomial(_data=data)

class Term(_ISLObjectBase):
    _base_name = 'term'

    def _get_ctx_data(self):
        return lib.isl_term_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_term_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_term_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Term")
    
        return Term(_data=data)

class Band(_ISLObjectBase):
    _base_name = 'band'

    def _get_ctx_data(self):
        return lib.isl_band_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_band_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_band_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Band")
    
        return Band(_data=data)

class ScheduleConstraints(_ISLObjectBase):
    _base_name = 'schedule_constraints'

    def _get_ctx_data(self):
        return lib.isl_schedule_constraints_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_schedule_constraints_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_schedule_constraints_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of ScheduleConstraints")
    
        return ScheduleConstraints(_data=data)

class ScheduleNode(_ISLObjectBase):
    _base_name = 'schedule_node'

    def _get_ctx_data(self):
        return lib.isl_schedule_node_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_schedule_node_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_schedule_node_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of ScheduleNode")
    
        return ScheduleNode(_data=data)

class Schedule(_ISLObjectBase):
    _base_name = 'schedule'

    def _get_ctx_data(self):
        return lib.isl_schedule_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_schedule_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_schedule_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Schedule")
    
        return Schedule(_data=data)

class AccessInfo(_ISLObjectBase):
    _base_name = 'access_info'

    def _get_ctx_data(self):
        return lib.isl_access_info_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_access_info_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

class Flow(_ISLObjectBase):
    _base_name = 'flow'

    def _get_ctx_data(self):
        return lib.isl_flow_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_flow_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_flow_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Flow")
    
        return Flow(_data=data)

class Restriction(_ISLObjectBase):
    _base_name = 'restriction'

    def _get_ctx_data(self):
        return lib.isl_restriction_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_restriction_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_restriction_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of Restriction")
    
        return Restriction(_data=data)

class UnionAccessInfo(_ISLObjectBase):
    _base_name = 'union_access_info'

    def _get_ctx_data(self):
        return lib.isl_union_access_info_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_union_access_info_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_union_access_info_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of UnionAccessInfo")
    
        return UnionAccessInfo(_data=data)

class UnionFlow(_ISLObjectBase):
    _base_name = 'union_flow'

    def _get_ctx_data(self):
        return lib.isl_union_flow_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_union_flow_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_union_flow_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of UnionFlow")
    
        return UnionFlow(_data=data)

class AstExpr(_ISLObjectBase):
    _base_name = 'ast_expr'

    def _get_ctx_data(self):
        return lib.isl_ast_expr_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_ast_expr_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_ast_expr_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of AstExpr")
    
        return AstExpr(_data=data)

class AstNode(_ISLObjectBase):
    _base_name = 'ast_node'

    def _get_ctx_data(self):
        return lib.isl_ast_node_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_ast_node_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_ast_node_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of AstNode")
    
        return AstNode(_data=data)

class AstPrintOptions(_ISLObjectBase):
    _base_name = 'ast_print_options'

    def _get_ctx_data(self):
        return lib.isl_ast_print_options_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_ast_print_options_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_ast_print_options_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of AstPrintOptions")
    
        return AstPrintOptions(_data=data)

class AstBuild(_ISLObjectBase):
    _base_name = 'ast_build'

    def _get_ctx_data(self):
        return lib.isl_ast_build_get_ctx(self.data)
    
    def __del__(self):
        if self.data is not None:
            lib.isl_ast_build_free(self.data)
            _deref_ctx(self._ctx_data, self._ctx_iptr)

    def _copy(self):
        assert self.data is not None
    
        data = lib.isl_ast_build_copy(self.data)
        if data == ffi.NULL:
            raise Error("failed to copy instance of AstBuild")
    
        return AstBuild(_data=data)


# }}}


# {{{ wrappers

def _add_methods():
    # {{{ ctx

    def alloc():
        'alloc()\n\n:return: :class:`Context`'


        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_alloc()
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ctx_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Context.alloc = staticmethod(alloc)

    Context._alloc_is_static = True

    def ref(self):
        'ref(self)\n\n:param self: :class:`Context`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_ref(self.data)
        finally:
            pass
        

    Context.ref = ref

    def deref(self):
        'deref(self)\n\n:param self: :class:`Context`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_deref(self.data)
        finally:
            pass
        

    Context.deref = deref

    def abort(self):
        'abort(self)\n\n:param self: :class:`Context`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_abort(self.data)
        finally:
            pass
        

    Context.abort = abort

    def resume(self):
        'resume(self)\n\n:param self: :class:`Context`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_resume(self.data)
        finally:
            pass
        

    Context.resume = resume

    def aborted(self):
        'aborted(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_aborted(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.aborted = aborted

    def set_max_operations(self, max_operations):
        'set_max_operations(self, max_operations)\n\n:param self: :class:`Context`\n:param max_operations: :class:`long`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for max_operations
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_set_max_operations(self.data, max_operations)
        finally:
            pass
        

    Context.set_max_operations = set_max_operations

    def get_max_operations(self):
        'get_max_operations(self)\n\n:param self: :class:`Context`\n:return: unsigned long'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_get_max_operations(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_max_operations = get_max_operations

    def reset_operations(self):
        'reset_operations(self)\n\n:param self: :class:`Context`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_reset_operations(self.data)
        finally:
            pass
        

    Context.reset_operations = reset_operations

    def last_error(self):
        'last_error(self)\n\n:param self: :class:`Context`\n:return: isl_error'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_last_error(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.last_error = last_error

    def last_error_msg(self):
        'last_error_msg(self)\n\n:param self: :class:`Context`\n:return: string'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_last_error_msg(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Context.last_error_msg = last_error_msg

    def last_error_file(self):
        'last_error_file(self)\n\n:param self: :class:`Context`\n:return: string'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_last_error_file(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Context.last_error_file = last_error_file

    def last_error_line(self):
        'last_error_line(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_last_error_line(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.last_error_line = last_error_line

    def reset_error(self):
        'reset_error(self)\n\n:param self: :class:`Context`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_reset_error(self.data)
        finally:
            pass
        

    Context.reset_error = reset_error

    def set_error(self, error):
        'set_error(self, error)\n\n:param self: :class:`Context`\n:param error: :class:`error`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for error
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ctx_set_error(self.data, error)
        finally:
            pass
        

    Context.set_error = set_error

    def set_schedule_max_coefficient(self, val):
        'set_schedule_max_coefficient(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_schedule_max_coefficient(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_schedule_max_coefficient\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_schedule_max_coefficient = set_schedule_max_coefficient

    def get_schedule_max_coefficient(self):
        'get_schedule_max_coefficient(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_schedule_max_coefficient(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_schedule_max_coefficient = get_schedule_max_coefficient

    def set_schedule_max_constant_term(self, val):
        'set_schedule_max_constant_term(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_schedule_max_constant_term(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_schedule_max_constant_term\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_schedule_max_constant_term = set_schedule_max_constant_term

    def get_schedule_max_constant_term(self):
        'get_schedule_max_constant_term(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_schedule_max_constant_term(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_schedule_max_constant_term = get_schedule_max_constant_term

    def set_schedule_maximize_band_depth(self, val):
        'set_schedule_maximize_band_depth(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_schedule_maximize_band_depth(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_schedule_maximize_band_depth\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_schedule_maximize_band_depth = set_schedule_maximize_band_depth

    def get_schedule_maximize_band_depth(self):
        'get_schedule_maximize_band_depth(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_schedule_maximize_band_depth(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_schedule_maximize_band_depth = get_schedule_maximize_band_depth

    def set_schedule_maximize_coincidence(self, val):
        'set_schedule_maximize_coincidence(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_schedule_maximize_coincidence(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_schedule_maximize_coincidence\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_schedule_maximize_coincidence = set_schedule_maximize_coincidence

    def get_schedule_maximize_coincidence(self):
        'get_schedule_maximize_coincidence(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_schedule_maximize_coincidence(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_schedule_maximize_coincidence = get_schedule_maximize_coincidence

    def set_schedule_outer_coincidence(self, val):
        'set_schedule_outer_coincidence(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_schedule_outer_coincidence(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_schedule_outer_coincidence\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_schedule_outer_coincidence = set_schedule_outer_coincidence

    def get_schedule_outer_coincidence(self):
        'get_schedule_outer_coincidence(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_schedule_outer_coincidence(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_schedule_outer_coincidence = get_schedule_outer_coincidence

    def set_schedule_split_scaled(self, val):
        'set_schedule_split_scaled(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_schedule_split_scaled(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_schedule_split_scaled\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_schedule_split_scaled = set_schedule_split_scaled

    def get_schedule_split_scaled(self):
        'get_schedule_split_scaled(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_schedule_split_scaled(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_schedule_split_scaled = get_schedule_split_scaled

    def set_schedule_treat_coalescing(self, val):
        'set_schedule_treat_coalescing(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_schedule_treat_coalescing(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_schedule_treat_coalescing\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_schedule_treat_coalescing = set_schedule_treat_coalescing

    def get_schedule_treat_coalescing(self):
        'get_schedule_treat_coalescing(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_schedule_treat_coalescing(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_schedule_treat_coalescing = get_schedule_treat_coalescing

    def set_schedule_separate_components(self, val):
        'set_schedule_separate_components(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_schedule_separate_components(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_schedule_separate_components\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_schedule_separate_components = set_schedule_separate_components

    def get_schedule_separate_components(self):
        'get_schedule_separate_components(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_schedule_separate_components(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_schedule_separate_components = get_schedule_separate_components

    def set_schedule_serialize_sccs(self, val):
        'set_schedule_serialize_sccs(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_schedule_serialize_sccs(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_schedule_serialize_sccs\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_schedule_serialize_sccs = set_schedule_serialize_sccs

    def get_schedule_serialize_sccs(self):
        'get_schedule_serialize_sccs(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_schedule_serialize_sccs(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_schedule_serialize_sccs = get_schedule_serialize_sccs

    def set_schedule_whole_component(self, val):
        'set_schedule_whole_component(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_schedule_whole_component(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_schedule_whole_component\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_schedule_whole_component = set_schedule_whole_component

    def get_schedule_whole_component(self):
        'get_schedule_whole_component(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_schedule_whole_component(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_schedule_whole_component = get_schedule_whole_component

    def set_schedule_carry_self_first(self, val):
        'set_schedule_carry_self_first(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_schedule_carry_self_first(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_schedule_carry_self_first\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_schedule_carry_self_first = set_schedule_carry_self_first

    def get_schedule_carry_self_first(self):
        'get_schedule_carry_self_first(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_schedule_carry_self_first(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_schedule_carry_self_first = get_schedule_carry_self_first

    def set_tile_scale_tile_loops(self, val):
        'set_tile_scale_tile_loops(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_tile_scale_tile_loops(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_tile_scale_tile_loops\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_tile_scale_tile_loops = set_tile_scale_tile_loops

    def get_tile_scale_tile_loops(self):
        'get_tile_scale_tile_loops(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_tile_scale_tile_loops(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_tile_scale_tile_loops = get_tile_scale_tile_loops

    def set_tile_shift_point_loops(self, val):
        'set_tile_shift_point_loops(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_tile_shift_point_loops(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_tile_shift_point_loops\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_tile_shift_point_loops = set_tile_shift_point_loops

    def get_tile_shift_point_loops(self):
        'get_tile_shift_point_loops(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_tile_shift_point_loops(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_tile_shift_point_loops = get_tile_shift_point_loops

    def set_bound(self, val):
        'set_bound(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_bound(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_bound\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_bound = set_bound

    def get_bound(self):
        'get_bound(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_bound(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_bound = get_bound

    def set_on_error(self, val):
        'set_on_error(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_on_error(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_on_error\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_on_error = set_on_error

    def get_on_error(self):
        'get_on_error(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_on_error(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_on_error = get_on_error

    def set_gbr_only_first(self, val):
        'set_gbr_only_first(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_gbr_only_first(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_gbr_only_first\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_gbr_only_first = set_gbr_only_first

    def get_gbr_only_first(self):
        'get_gbr_only_first(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_gbr_only_first(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_gbr_only_first = get_gbr_only_first

    def set_schedule_algorithm(self, val):
        'set_schedule_algorithm(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_schedule_algorithm(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_schedule_algorithm\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_schedule_algorithm = set_schedule_algorithm

    def get_schedule_algorithm(self):
        'get_schedule_algorithm(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_schedule_algorithm(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_schedule_algorithm = get_schedule_algorithm

    def set_pip_symmetry(self, val):
        'set_pip_symmetry(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_pip_symmetry(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_pip_symmetry\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_pip_symmetry = set_pip_symmetry

    def get_pip_symmetry(self):
        'get_pip_symmetry(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_pip_symmetry(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_pip_symmetry = get_pip_symmetry

    def set_coalesce_bounded_wrapping(self, val):
        'set_coalesce_bounded_wrapping(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_coalesce_bounded_wrapping(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_coalesce_bounded_wrapping\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_coalesce_bounded_wrapping = set_coalesce_bounded_wrapping

    def get_coalesce_bounded_wrapping(self):
        'get_coalesce_bounded_wrapping(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_coalesce_bounded_wrapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_coalesce_bounded_wrapping = get_coalesce_bounded_wrapping

    def set_coalesce_preserve_locals(self, val):
        'set_coalesce_preserve_locals(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_coalesce_preserve_locals(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_coalesce_preserve_locals\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_coalesce_preserve_locals = set_coalesce_preserve_locals

    def get_coalesce_preserve_locals(self):
        'get_coalesce_preserve_locals(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_coalesce_preserve_locals(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_coalesce_preserve_locals = get_coalesce_preserve_locals

    def set_ast_iterator_type(self, val):
        'set_ast_iterator_type(self, val)\n\n:param self: :class:`Context`\n:param val: string\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        _cstr_val = ffi.new("char[]", val.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_ast_iterator_type(self.data, _cstr_val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_ast_iterator_type\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_ast_iterator_type = set_ast_iterator_type

    def get_ast_iterator_type(self):
        'get_ast_iterator_type(self)\n\n:param self: :class:`Context`\n:return: string'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_ast_iterator_type(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Context.get_ast_iterator_type = get_ast_iterator_type

    def set_ast_always_print_block(self, val):
        'set_ast_always_print_block(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_ast_always_print_block(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_ast_always_print_block\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_ast_always_print_block = set_ast_always_print_block

    def get_ast_always_print_block(self):
        'get_ast_always_print_block(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_ast_always_print_block(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_ast_always_print_block = get_ast_always_print_block

    def set_ast_print_macro_once(self, val):
        'set_ast_print_macro_once(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_ast_print_macro_once(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_ast_print_macro_once\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_ast_print_macro_once = set_ast_print_macro_once

    def get_ast_print_macro_once(self):
        'get_ast_print_macro_once(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_ast_print_macro_once(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_ast_print_macro_once = get_ast_print_macro_once

    def set_ast_build_atomic_upper_bound(self, val):
        'set_ast_build_atomic_upper_bound(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_ast_build_atomic_upper_bound(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_ast_build_atomic_upper_bound\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_ast_build_atomic_upper_bound = set_ast_build_atomic_upper_bound

    def get_ast_build_atomic_upper_bound(self):
        'get_ast_build_atomic_upper_bound(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_ast_build_atomic_upper_bound(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_ast_build_atomic_upper_bound = get_ast_build_atomic_upper_bound

    def set_ast_build_prefer_pdiv(self, val):
        'set_ast_build_prefer_pdiv(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_ast_build_prefer_pdiv(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_ast_build_prefer_pdiv\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_ast_build_prefer_pdiv = set_ast_build_prefer_pdiv

    def get_ast_build_prefer_pdiv(self):
        'get_ast_build_prefer_pdiv(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_ast_build_prefer_pdiv(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_ast_build_prefer_pdiv = get_ast_build_prefer_pdiv

    def set_ast_build_detect_min_max(self, val):
        'set_ast_build_detect_min_max(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_ast_build_detect_min_max(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_ast_build_detect_min_max\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_ast_build_detect_min_max = set_ast_build_detect_min_max

    def get_ast_build_detect_min_max(self):
        'get_ast_build_detect_min_max(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_ast_build_detect_min_max(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_ast_build_detect_min_max = get_ast_build_detect_min_max

    def set_ast_build_exploit_nested_bounds(self, val):
        'set_ast_build_exploit_nested_bounds(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_ast_build_exploit_nested_bounds(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_ast_build_exploit_nested_bounds\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_ast_build_exploit_nested_bounds = set_ast_build_exploit_nested_bounds

    def get_ast_build_exploit_nested_bounds(self):
        'get_ast_build_exploit_nested_bounds(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_ast_build_exploit_nested_bounds(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_ast_build_exploit_nested_bounds = get_ast_build_exploit_nested_bounds

    def set_ast_build_group_coscheduled(self, val):
        'set_ast_build_group_coscheduled(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_ast_build_group_coscheduled(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_ast_build_group_coscheduled\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_ast_build_group_coscheduled = set_ast_build_group_coscheduled

    def get_ast_build_group_coscheduled(self):
        'get_ast_build_group_coscheduled(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_ast_build_group_coscheduled(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_ast_build_group_coscheduled = get_ast_build_group_coscheduled

    def set_ast_build_separation_bounds(self, val):
        'set_ast_build_separation_bounds(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_ast_build_separation_bounds(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_ast_build_separation_bounds\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_ast_build_separation_bounds = set_ast_build_separation_bounds

    def get_ast_build_separation_bounds(self):
        'get_ast_build_separation_bounds(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_ast_build_separation_bounds(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_ast_build_separation_bounds = get_ast_build_separation_bounds

    def set_ast_build_scale_strides(self, val):
        'set_ast_build_scale_strides(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_ast_build_scale_strides(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_ast_build_scale_strides\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_ast_build_scale_strides = set_ast_build_scale_strides

    def get_ast_build_scale_strides(self):
        'get_ast_build_scale_strides(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_ast_build_scale_strides(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_ast_build_scale_strides = get_ast_build_scale_strides

    def set_ast_build_allow_else(self, val):
        'set_ast_build_allow_else(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_ast_build_allow_else(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_ast_build_allow_else\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_ast_build_allow_else = set_ast_build_allow_else

    def get_ast_build_allow_else(self):
        'get_ast_build_allow_else(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_ast_build_allow_else(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_ast_build_allow_else = get_ast_build_allow_else

    def set_ast_build_allow_or(self, val):
        'set_ast_build_allow_or(self, val)\n\n:param self: :class:`Context`\n:param val: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_set_ast_build_allow_or(self.data, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_options_set_ast_build_allow_or\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Context.set_ast_build_allow_or = set_ast_build_allow_or

    def get_ast_build_allow_or(self):
        'get_ast_build_allow_or(self)\n\n:param self: :class:`Context`\n:return: int'

        if not isinstance(self, Context):
            raise IslTypeError("self is not a Context")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_options_get_ast_build_allow_or(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Context.get_ast_build_allow_or = get_ast_build_allow_or

    # }}}

    # {{{ id_list

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`IdList`\n:return: :class:`Context`'

        if not isinstance(self, IdList):
            raise IslTypeError("self is not a IdList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_list_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    IdList.get_ctx = get_ctx

    def from_id(el):
        'from_id(el)\n\n:param el: :class:`Id`\n:return: :class:`IdList`'

        if not isinstance(el, Id):
            raise IslTypeError("el is not a Id")
        _ctx_data = el._ctx_data
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_from_id(_copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else IdList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_list_from_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    IdList.from_id = staticmethod(from_id)

    IdList._from_id_is_static = True

    def alloc(ctx, n):
        'alloc(ctx, n)\n\n:param ctx: :class:`Context`\n:param n: :class:`int`\n:return: :class:`IdList`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_alloc(ctx.data, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else IdList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_list_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    IdList.alloc = staticmethod(alloc)

    IdList._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`IdList`\n:return: :class:`IdList`'

        if not isinstance(self, IdList):
            raise IslTypeError("self is not a IdList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else IdList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_list_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    IdList.copy = copy

    def add(self, el):
        'add(self, el)\n\n:param self: :class:`IdList`\n:param el: :class:`Id`\n:return: :class:`IdList`'

        if not isinstance(self, IdList):
            raise IslTypeError("self is not a IdList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(el, Id):
            raise IslTypeError("el is not a Id")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_add(_copy_self._release(), _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else IdList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_list_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    IdList.add = add

    def insert(self, pos, el):
        'insert(self, pos, el)\n\n:param self: :class:`IdList`\n:param pos: :class:`unsigned`\n:param el: :class:`Id`\n:return: :class:`IdList`'

        if not isinstance(self, IdList):
            raise IslTypeError("self is not a IdList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(el, Id):
            raise IslTypeError("el is not a Id")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_insert(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else IdList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_list_insert failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    IdList.insert = insert

    def drop(self, first, n):
        'drop(self, first, n)\n\n:param self: :class:`IdList`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`IdList`'

        if not isinstance(self, IdList):
            raise IslTypeError("self is not a IdList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_drop(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else IdList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_list_drop failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    IdList.drop = drop

    def concat(self, list2):
        'concat(self, list2)\n\n:param self: :class:`IdList`\n:param list2: :class:`IdList`\n:return: :class:`IdList`'

        if not isinstance(self, IdList):
            raise IslTypeError("self is not a IdList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, IdList):
            raise IslTypeError("list2 is not a IdList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_concat(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else IdList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_list_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    IdList.concat = concat

    def n_id(self):
        'n_id(self)\n\n:param self: :class:`IdList`\n:return: int'

        if not isinstance(self, IdList):
            raise IslTypeError("self is not a IdList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_n_id(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    IdList.n_id = n_id

    def get_id(self, index):
        'get_id(self, index)\n\n:param self: :class:`IdList`\n:param index: :class:`int`\n:return: :class:`Id`'

        if not isinstance(self, IdList):
            raise IslTypeError("self is not a IdList")
        _ctx_data = self._ctx_data
        
        # no argument processing for index
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_get_id(self.data, index)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_list_get_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    IdList.get_id = get_id

    def set_id(self, index, el):
        'set_id(self, index, el)\n\n:param self: :class:`IdList`\n:param index: :class:`int`\n:param el: :class:`Id`\n:return: :class:`IdList`'

        if not isinstance(self, IdList):
            raise IslTypeError("self is not a IdList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for index
        
        if not isinstance(el, Id):
            raise IslTypeError("el is not a Id")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_set_id(_copy_self._release(), index, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else IdList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_list_set_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    IdList.set_id = set_id

    def foreach(self, fn):
        'foreach(self, fn)\n\n:param self: :class:`IdList`\n:param fn: callback(el) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, IdList):
            raise IslTypeError("self is not a IdList")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = Id(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)(struct isl_id *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_foreach(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_id_list_foreach\" failed: %s" % _get_last_error_str(_ctx_data))
        

    IdList.foreach = foreach

    def map(self, fn):
        'map(self, fn)\n\n:param self: :class:`IdList`\n:param fn: callback(el) -> isl_id\n:return: :class:`IdList`'

        if not isinstance(self, IdList):
            raise IslTypeError("self is not a IdList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = Id(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, Id):
                    raise IslTypeError("return value is not a Id")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_id *(*fn)( isl_id *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_map(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else IdList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_list_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    IdList.map = map

    def sort(self, cmp):
        'sort(self, cmp)\n\n:param self: :class:`IdList`\n:param cmp: callback(a, b) -> int\n:return: :class:`IdList`'

        if not isinstance(self, IdList):
            raise IslTypeError("self is not a IdList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_cmp(a, b, user):
            try:
                _py_a = Id(_data=a)
                _py_b = Id(_data=b)
                _result = cmp(_py_a, _py_b)
                _py_a._release()
                _py_b._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_cmp = ffi.callback(" int (*cmp)(struct isl_id *a, struct isl_id *b,  void *user)")(_cb_wrapper_cmp)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_sort(_copy_self._release(), _cb_cmp, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else IdList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_list_sort failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    IdList.sort = sort

    def dump(self):
        'dump(self)\n\n:param self: :class:`IdList`\n:return: (nothing)'

        if not isinstance(self, IdList):
            raise IslTypeError("self is not a IdList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_list_dump(self.data)
        finally:
            pass
        

    IdList.dump = dump

    # }}}

    # {{{ val_list

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`ValList`\n:return: :class:`Context`'

        if not isinstance(self, ValList):
            raise IslTypeError("self is not a ValList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_list_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ValList.get_ctx = get_ctx

    def from_val(el):
        'from_val(el)\n\n:param el: :class:`Val`\n:return: :class:`ValList`'

        if not isinstance(el, Val):
            raise IslTypeError("el is not a Val")
        _ctx_data = el._ctx_data
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_from_val(_copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ValList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_list_from_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ValList.from_val = staticmethod(from_val)

    ValList._from_val_is_static = True

    def alloc(ctx, n):
        'alloc(ctx, n)\n\n:param ctx: :class:`Context`\n:param n: :class:`int`\n:return: :class:`ValList`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_alloc(ctx.data, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ValList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_list_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ValList.alloc = staticmethod(alloc)

    ValList._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`ValList`\n:return: :class:`ValList`'

        if not isinstance(self, ValList):
            raise IslTypeError("self is not a ValList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ValList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_list_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ValList.copy = copy

    def add(self, el):
        'add(self, el)\n\n:param self: :class:`ValList`\n:param el: :class:`Val`\n:return: :class:`ValList`'

        if not isinstance(self, ValList):
            raise IslTypeError("self is not a ValList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(el, Val):
            if _ctx_data != el._ctx_data:
                raise Error("mismatched context in el")
            _val_el = el._copy()
        elif isinstance(el, six.integer_types):
            _cdata_el = lib.isl_val_int_from_si(
                self._get_ctx_data(), el)
        
            if _cdata_el == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_el = Val(_data=_cdata_el)
        
        else:
            raise IslTypeError("el is a %s and cannot "
                "be cast to a Val" % type(el))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_add(_copy_self._release(), _val_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ValList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_list_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ValList.add = add

    def insert(self, pos, el):
        'insert(self, pos, el)\n\n:param self: :class:`ValList`\n:param pos: :class:`unsigned`\n:param el: :class:`Val`\n:return: :class:`ValList`'

        if not isinstance(self, ValList):
            raise IslTypeError("self is not a ValList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if isinstance(el, Val):
            if _ctx_data != el._ctx_data:
                raise Error("mismatched context in el")
            _val_el = el._copy()
        elif isinstance(el, six.integer_types):
            _cdata_el = lib.isl_val_int_from_si(
                self._get_ctx_data(), el)
        
            if _cdata_el == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_el = Val(_data=_cdata_el)
        
        else:
            raise IslTypeError("el is a %s and cannot "
                "be cast to a Val" % type(el))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_insert(_copy_self._release(), pos, _val_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ValList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_list_insert failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ValList.insert = insert

    def drop(self, first, n):
        'drop(self, first, n)\n\n:param self: :class:`ValList`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`ValList`'

        if not isinstance(self, ValList):
            raise IslTypeError("self is not a ValList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_drop(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ValList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_list_drop failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ValList.drop = drop

    def concat(self, list2):
        'concat(self, list2)\n\n:param self: :class:`ValList`\n:param list2: :class:`ValList`\n:return: :class:`ValList`'

        if not isinstance(self, ValList):
            raise IslTypeError("self is not a ValList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, ValList):
            raise IslTypeError("list2 is not a ValList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_concat(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ValList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_list_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ValList.concat = concat

    def n_val(self):
        'n_val(self)\n\n:param self: :class:`ValList`\n:return: int'

        if not isinstance(self, ValList):
            raise IslTypeError("self is not a ValList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_n_val(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    ValList.n_val = n_val

    def get_val(self, index):
        'get_val(self, index)\n\n:param self: :class:`ValList`\n:param index: :class:`int`\n:return: :class:`Val`'

        if not isinstance(self, ValList):
            raise IslTypeError("self is not a ValList")
        _ctx_data = self._ctx_data
        
        # no argument processing for index
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_get_val(self.data, index)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_list_get_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ValList.get_val = get_val

    def set_val(self, index, el):
        'set_val(self, index, el)\n\n:param self: :class:`ValList`\n:param index: :class:`int`\n:param el: :class:`Val`\n:return: :class:`ValList`'

        if not isinstance(self, ValList):
            raise IslTypeError("self is not a ValList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for index
        
        if isinstance(el, Val):
            if _ctx_data != el._ctx_data:
                raise Error("mismatched context in el")
            _val_el = el._copy()
        elif isinstance(el, six.integer_types):
            _cdata_el = lib.isl_val_int_from_si(
                self._get_ctx_data(), el)
        
            if _cdata_el == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_el = Val(_data=_cdata_el)
        
        else:
            raise IslTypeError("el is a %s and cannot "
                "be cast to a Val" % type(el))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_set_val(_copy_self._release(), index, _val_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ValList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_list_set_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ValList.set_val = set_val

    def foreach(self, fn):
        'foreach(self, fn)\n\n:param self: :class:`ValList`\n:param fn: callback(el) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, ValList):
            raise IslTypeError("self is not a ValList")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = Val(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)(struct isl_val *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_foreach(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_val_list_foreach\" failed: %s" % _get_last_error_str(_ctx_data))
        

    ValList.foreach = foreach

    def map(self, fn):
        'map(self, fn)\n\n:param self: :class:`ValList`\n:param fn: callback(el) -> isl_val\n:return: :class:`ValList`'

        if not isinstance(self, ValList):
            raise IslTypeError("self is not a ValList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = Val(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, Val):
                    raise IslTypeError("return value is not a Val")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_val *(*fn)( isl_val *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_map(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ValList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_list_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ValList.map = map

    def sort(self, cmp):
        'sort(self, cmp)\n\n:param self: :class:`ValList`\n:param cmp: callback(a, b) -> int\n:return: :class:`ValList`'

        if not isinstance(self, ValList):
            raise IslTypeError("self is not a ValList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_cmp(a, b, user):
            try:
                _py_a = Val(_data=a)
                _py_b = Val(_data=b)
                _result = cmp(_py_a, _py_b)
                _py_a._release()
                _py_b._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_cmp = ffi.callback(" int (*cmp)(struct isl_val *a, struct isl_val *b,  void *user)")(_cb_wrapper_cmp)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_sort(_copy_self._release(), _cb_cmp, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ValList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_list_sort failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ValList.sort = sort

    def dump(self):
        'dump(self)\n\n:param self: :class:`ValList`\n:return: (nothing)'

        if not isinstance(self, ValList):
            raise IslTypeError("self is not a ValList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_list_dump(self.data)
        finally:
            pass
        

    ValList.dump = dump

    # }}}

    # {{{ basic_set_list

    def intersect(self):
        'intersect(self)\n\n:param self: :class:`BasicSetList`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_intersect(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_intersect failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.intersect = intersect

    def coefficients(self):
        'coefficients(self)\n\n:param self: :class:`BasicSetList`\n:return: :class:`BasicSetList`'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_coefficients(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_coefficients failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.coefficients = coefficients

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`BasicSetList`\n:return: :class:`Context`'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.get_ctx = get_ctx

    def from_basic_set(el):
        'from_basic_set(el)\n\n:param el: :class:`BasicSet`\n:return: :class:`BasicSetList`'

        if not isinstance(el, BasicSet):
            raise IslTypeError("el is not a BasicSet")
        _ctx_data = el._ctx_data
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_from_basic_set(_copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_from_basic_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.from_basic_set = staticmethod(from_basic_set)

    BasicSetList._from_basic_set_is_static = True

    def alloc(ctx, n):
        'alloc(ctx, n)\n\n:param ctx: :class:`Context`\n:param n: :class:`int`\n:return: :class:`BasicSetList`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_alloc(ctx.data, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.alloc = staticmethod(alloc)

    BasicSetList._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`BasicSetList`\n:return: :class:`BasicSetList`'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.copy = copy

    def add(self, el):
        'add(self, el)\n\n:param self: :class:`BasicSetList`\n:param el: :class:`BasicSet`\n:return: :class:`BasicSetList`'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(el, BasicSet):
            raise IslTypeError("el is not a BasicSet")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_add(_copy_self._release(), _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.add = add

    def insert(self, pos, el):
        'insert(self, pos, el)\n\n:param self: :class:`BasicSetList`\n:param pos: :class:`unsigned`\n:param el: :class:`BasicSet`\n:return: :class:`BasicSetList`'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(el, BasicSet):
            raise IslTypeError("el is not a BasicSet")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_insert(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_insert failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.insert = insert

    def drop(self, first, n):
        'drop(self, first, n)\n\n:param self: :class:`BasicSetList`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicSetList`'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_drop(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_drop failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.drop = drop

    def concat(self, list2):
        'concat(self, list2)\n\n:param self: :class:`BasicSetList`\n:param list2: :class:`BasicSetList`\n:return: :class:`BasicSetList`'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, BasicSetList):
            raise IslTypeError("list2 is not a BasicSetList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_concat(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.concat = concat

    def n_basic_set(self):
        'n_basic_set(self)\n\n:param self: :class:`BasicSetList`\n:return: int'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_n_basic_set(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    BasicSetList.n_basic_set = n_basic_set

    def get_basic_set(self, index):
        'get_basic_set(self, index)\n\n:param self: :class:`BasicSetList`\n:param index: :class:`int`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        
        # no argument processing for index
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_get_basic_set(self.data, index)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_get_basic_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.get_basic_set = get_basic_set

    def set_basic_set(self, index, el):
        'set_basic_set(self, index, el)\n\n:param self: :class:`BasicSetList`\n:param index: :class:`int`\n:param el: :class:`BasicSet`\n:return: :class:`BasicSetList`'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for index
        
        if not isinstance(el, BasicSet):
            raise IslTypeError("el is not a BasicSet")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_set_basic_set(_copy_self._release(), index, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_set_basic_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.set_basic_set = set_basic_set

    def foreach(self, fn):
        'foreach(self, fn)\n\n:param self: :class:`BasicSetList`\n:param fn: callback(el) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = BasicSet(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)(struct isl_basic_set *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_foreach(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_basic_set_list_foreach\" failed: %s" % _get_last_error_str(_ctx_data))
        

    BasicSetList.foreach = foreach

    def map(self, fn):
        'map(self, fn)\n\n:param self: :class:`BasicSetList`\n:param fn: callback(el) -> isl_basic_set\n:return: :class:`BasicSetList`'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = BasicSet(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, BasicSet):
                    raise IslTypeError("return value is not a BasicSet")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_basic_set *(*fn)( isl_basic_set *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_map(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.map = map

    def sort(self, cmp):
        'sort(self, cmp)\n\n:param self: :class:`BasicSetList`\n:param cmp: callback(a, b) -> int\n:return: :class:`BasicSetList`'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_cmp(a, b, user):
            try:
                _py_a = BasicSet(_data=a)
                _py_b = BasicSet(_data=b)
                _result = cmp(_py_a, _py_b)
                _py_a._release()
                _py_b._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_cmp = ffi.callback(" int (*cmp)(struct isl_basic_set *a, struct isl_basic_set *b,  void *user)")(_cb_wrapper_cmp)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_sort(_copy_self._release(), _cb_cmp, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_list_sort failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSetList.sort = sort

    def dump(self):
        'dump(self)\n\n:param self: :class:`BasicSetList`\n:return: (nothing)'

        if not isinstance(self, BasicSetList):
            raise IslTypeError("self is not a BasicSetList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_list_dump(self.data)
        finally:
            pass
        

    BasicSetList.dump = dump

    # }}}

    # {{{ basic_map_list

    def intersect(self):
        'intersect(self)\n\n:param self: :class:`BasicMapList`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_intersect(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_list_intersect failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMapList.intersect = intersect

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`BasicMapList`\n:return: :class:`Context`'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_list_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMapList.get_ctx = get_ctx

    def from_basic_map(el):
        'from_basic_map(el)\n\n:param el: :class:`BasicMap`\n:return: :class:`BasicMapList`'

        if not isinstance(el, BasicMap):
            raise IslTypeError("el is not a BasicMap")
        _ctx_data = el._ctx_data
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_from_basic_map(_copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_list_from_basic_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMapList.from_basic_map = staticmethod(from_basic_map)

    BasicMapList._from_basic_map_is_static = True

    def alloc(ctx, n):
        'alloc(ctx, n)\n\n:param ctx: :class:`Context`\n:param n: :class:`int`\n:return: :class:`BasicMapList`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_alloc(ctx.data, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_list_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMapList.alloc = staticmethod(alloc)

    BasicMapList._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`BasicMapList`\n:return: :class:`BasicMapList`'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_list_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMapList.copy = copy

    def add(self, el):
        'add(self, el)\n\n:param self: :class:`BasicMapList`\n:param el: :class:`BasicMap`\n:return: :class:`BasicMapList`'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(el, BasicMap):
            raise IslTypeError("el is not a BasicMap")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_add(_copy_self._release(), _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_list_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMapList.add = add

    def insert(self, pos, el):
        'insert(self, pos, el)\n\n:param self: :class:`BasicMapList`\n:param pos: :class:`unsigned`\n:param el: :class:`BasicMap`\n:return: :class:`BasicMapList`'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(el, BasicMap):
            raise IslTypeError("el is not a BasicMap")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_insert(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_list_insert failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMapList.insert = insert

    def drop(self, first, n):
        'drop(self, first, n)\n\n:param self: :class:`BasicMapList`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicMapList`'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_drop(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_list_drop failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMapList.drop = drop

    def concat(self, list2):
        'concat(self, list2)\n\n:param self: :class:`BasicMapList`\n:param list2: :class:`BasicMapList`\n:return: :class:`BasicMapList`'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, BasicMapList):
            raise IslTypeError("list2 is not a BasicMapList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_concat(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_list_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMapList.concat = concat

    def n_basic_map(self):
        'n_basic_map(self)\n\n:param self: :class:`BasicMapList`\n:return: int'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_n_basic_map(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    BasicMapList.n_basic_map = n_basic_map

    def get_basic_map(self, index):
        'get_basic_map(self, index)\n\n:param self: :class:`BasicMapList`\n:param index: :class:`int`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        
        # no argument processing for index
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_get_basic_map(self.data, index)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_list_get_basic_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMapList.get_basic_map = get_basic_map

    def set_basic_map(self, index, el):
        'set_basic_map(self, index, el)\n\n:param self: :class:`BasicMapList`\n:param index: :class:`int`\n:param el: :class:`BasicMap`\n:return: :class:`BasicMapList`'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for index
        
        if not isinstance(el, BasicMap):
            raise IslTypeError("el is not a BasicMap")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_set_basic_map(_copy_self._release(), index, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_list_set_basic_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMapList.set_basic_map = set_basic_map

    def foreach(self, fn):
        'foreach(self, fn)\n\n:param self: :class:`BasicMapList`\n:param fn: callback(el) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = BasicMap(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)(struct isl_basic_map *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_foreach(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_basic_map_list_foreach\" failed: %s" % _get_last_error_str(_ctx_data))
        

    BasicMapList.foreach = foreach

    def map(self, fn):
        'map(self, fn)\n\n:param self: :class:`BasicMapList`\n:param fn: callback(el) -> isl_basic_map\n:return: :class:`BasicMapList`'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = BasicMap(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, BasicMap):
                    raise IslTypeError("return value is not a BasicMap")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_basic_map *(*fn)( isl_basic_map *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_map(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_list_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMapList.map = map

    def sort(self, cmp):
        'sort(self, cmp)\n\n:param self: :class:`BasicMapList`\n:param cmp: callback(a, b) -> int\n:return: :class:`BasicMapList`'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_cmp(a, b, user):
            try:
                _py_a = BasicMap(_data=a)
                _py_b = BasicMap(_data=b)
                _result = cmp(_py_a, _py_b)
                _py_a._release()
                _py_b._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_cmp = ffi.callback(" int (*cmp)(struct isl_basic_map *a, struct isl_basic_map *b,  void *user)")(_cb_wrapper_cmp)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_sort(_copy_self._release(), _cb_cmp, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_list_sort failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMapList.sort = sort

    def dump(self):
        'dump(self)\n\n:param self: :class:`BasicMapList`\n:return: (nothing)'

        if not isinstance(self, BasicMapList):
            raise IslTypeError("self is not a BasicMapList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_list_dump(self.data)
        finally:
            pass
        

    BasicMapList.dump = dump

    # }}}

    # {{{ set_list

    def union(self):
        'union(self)\n\n:param self: :class:`SetList`\n:return: :class:`Set`'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_union(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_list_union failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    SetList.union = union

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`SetList`\n:return: :class:`Context`'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_list_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    SetList.get_ctx = get_ctx

    def from_set(el):
        'from_set(el)\n\n:param el: :class:`Set`\n:return: :class:`SetList`'

        if isinstance(el, BasicSet):
            el = Set.from_basic_set(el)
        if not isinstance(el, Set):
            raise IslTypeError("el is not a Set")
        _ctx_data = el._ctx_data
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_from_set(_copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else SetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_list_from_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    SetList.from_set = staticmethod(from_set)

    SetList._from_set_is_static = True

    def alloc(ctx, n):
        'alloc(ctx, n)\n\n:param ctx: :class:`Context`\n:param n: :class:`int`\n:return: :class:`SetList`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_alloc(ctx.data, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else SetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_list_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    SetList.alloc = staticmethod(alloc)

    SetList._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`SetList`\n:return: :class:`SetList`'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else SetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_list_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    SetList.copy = copy

    def add(self, el):
        'add(self, el)\n\n:param self: :class:`SetList`\n:param el: :class:`Set`\n:return: :class:`SetList`'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(el, BasicSet):
            el = Set.from_basic_set(el)
        if not isinstance(el, Set):
            raise IslTypeError("el is not a Set")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_add(_copy_self._release(), _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else SetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_list_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    SetList.add = add

    def insert(self, pos, el):
        'insert(self, pos, el)\n\n:param self: :class:`SetList`\n:param pos: :class:`unsigned`\n:param el: :class:`Set`\n:return: :class:`SetList`'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if isinstance(el, BasicSet):
            el = Set.from_basic_set(el)
        if not isinstance(el, Set):
            raise IslTypeError("el is not a Set")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_insert(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else SetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_list_insert failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    SetList.insert = insert

    def drop(self, first, n):
        'drop(self, first, n)\n\n:param self: :class:`SetList`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`SetList`'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_drop(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else SetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_list_drop failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    SetList.drop = drop

    def concat(self, list2):
        'concat(self, list2)\n\n:param self: :class:`SetList`\n:param list2: :class:`SetList`\n:return: :class:`SetList`'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, SetList):
            raise IslTypeError("list2 is not a SetList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_concat(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else SetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_list_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    SetList.concat = concat

    def n_set(self):
        'n_set(self)\n\n:param self: :class:`SetList`\n:return: int'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_n_set(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    SetList.n_set = n_set

    def get_set(self, index):
        'get_set(self, index)\n\n:param self: :class:`SetList`\n:param index: :class:`int`\n:return: :class:`Set`'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        
        # no argument processing for index
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_get_set(self.data, index)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_list_get_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    SetList.get_set = get_set

    def set_set(self, index, el):
        'set_set(self, index, el)\n\n:param self: :class:`SetList`\n:param index: :class:`int`\n:param el: :class:`Set`\n:return: :class:`SetList`'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for index
        
        if isinstance(el, BasicSet):
            el = Set.from_basic_set(el)
        if not isinstance(el, Set):
            raise IslTypeError("el is not a Set")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_set_set(_copy_self._release(), index, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else SetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_list_set_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    SetList.set_set = set_set

    def foreach(self, fn):
        'foreach(self, fn)\n\n:param self: :class:`SetList`\n:param fn: callback(el) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = Set(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)(struct isl_set *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_foreach(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_set_list_foreach\" failed: %s" % _get_last_error_str(_ctx_data))
        

    SetList.foreach = foreach

    def map(self, fn):
        'map(self, fn)\n\n:param self: :class:`SetList`\n:param fn: callback(el) -> isl_set\n:return: :class:`SetList`'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = Set(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, Set):
                    raise IslTypeError("return value is not a Set")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_set *(*fn)( isl_set *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_map(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else SetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_list_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    SetList.map = map

    def sort(self, cmp):
        'sort(self, cmp)\n\n:param self: :class:`SetList`\n:param cmp: callback(a, b) -> int\n:return: :class:`SetList`'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_cmp(a, b, user):
            try:
                _py_a = Set(_data=a)
                _py_b = Set(_data=b)
                _result = cmp(_py_a, _py_b)
                _py_a._release()
                _py_b._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_cmp = ffi.callback(" int (*cmp)(struct isl_set *a, struct isl_set *b,  void *user)")(_cb_wrapper_cmp)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_sort(_copy_self._release(), _cb_cmp, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else SetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_list_sort failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    SetList.sort = sort

    def dump(self):
        'dump(self)\n\n:param self: :class:`SetList`\n:return: (nothing)'

        if not isinstance(self, SetList):
            raise IslTypeError("self is not a SetList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_list_dump(self.data)
        finally:
            pass
        

    SetList.dump = dump

    # }}}

    # {{{ map_list

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`MapList`\n:return: :class:`Context`'

        if not isinstance(self, MapList):
            raise IslTypeError("self is not a MapList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_list_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MapList.get_ctx = get_ctx

    def from_map(el):
        'from_map(el)\n\n:param el: :class:`Map`\n:return: :class:`MapList`'

        if isinstance(el, BasicMap):
            el = Map.from_basic_map(el)
        if not isinstance(el, Map):
            raise IslTypeError("el is not a Map")
        _ctx_data = el._ctx_data
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_from_map(_copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_list_from_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MapList.from_map = staticmethod(from_map)

    MapList._from_map_is_static = True

    def alloc(ctx, n):
        'alloc(ctx, n)\n\n:param ctx: :class:`Context`\n:param n: :class:`int`\n:return: :class:`MapList`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_alloc(ctx.data, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_list_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MapList.alloc = staticmethod(alloc)

    MapList._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`MapList`\n:return: :class:`MapList`'

        if not isinstance(self, MapList):
            raise IslTypeError("self is not a MapList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_list_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MapList.copy = copy

    def add(self, el):
        'add(self, el)\n\n:param self: :class:`MapList`\n:param el: :class:`Map`\n:return: :class:`MapList`'

        if not isinstance(self, MapList):
            raise IslTypeError("self is not a MapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(el, BasicMap):
            el = Map.from_basic_map(el)
        if not isinstance(el, Map):
            raise IslTypeError("el is not a Map")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_add(_copy_self._release(), _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_list_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MapList.add = add

    def insert(self, pos, el):
        'insert(self, pos, el)\n\n:param self: :class:`MapList`\n:param pos: :class:`unsigned`\n:param el: :class:`Map`\n:return: :class:`MapList`'

        if not isinstance(self, MapList):
            raise IslTypeError("self is not a MapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if isinstance(el, BasicMap):
            el = Map.from_basic_map(el)
        if not isinstance(el, Map):
            raise IslTypeError("el is not a Map")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_insert(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_list_insert failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MapList.insert = insert

    def drop(self, first, n):
        'drop(self, first, n)\n\n:param self: :class:`MapList`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`MapList`'

        if not isinstance(self, MapList):
            raise IslTypeError("self is not a MapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_drop(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_list_drop failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MapList.drop = drop

    def concat(self, list2):
        'concat(self, list2)\n\n:param self: :class:`MapList`\n:param list2: :class:`MapList`\n:return: :class:`MapList`'

        if not isinstance(self, MapList):
            raise IslTypeError("self is not a MapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, MapList):
            raise IslTypeError("list2 is not a MapList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_concat(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_list_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MapList.concat = concat

    def n_map(self):
        'n_map(self)\n\n:param self: :class:`MapList`\n:return: int'

        if not isinstance(self, MapList):
            raise IslTypeError("self is not a MapList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_n_map(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MapList.n_map = n_map

    def get_map(self, index):
        'get_map(self, index)\n\n:param self: :class:`MapList`\n:param index: :class:`int`\n:return: :class:`Map`'

        if not isinstance(self, MapList):
            raise IslTypeError("self is not a MapList")
        _ctx_data = self._ctx_data
        
        # no argument processing for index
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_get_map(self.data, index)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_list_get_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MapList.get_map = get_map

    def set_map(self, index, el):
        'set_map(self, index, el)\n\n:param self: :class:`MapList`\n:param index: :class:`int`\n:param el: :class:`Map`\n:return: :class:`MapList`'

        if not isinstance(self, MapList):
            raise IslTypeError("self is not a MapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for index
        
        if isinstance(el, BasicMap):
            el = Map.from_basic_map(el)
        if not isinstance(el, Map):
            raise IslTypeError("el is not a Map")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_set_map(_copy_self._release(), index, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_list_set_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MapList.set_map = set_map

    def foreach(self, fn):
        'foreach(self, fn)\n\n:param self: :class:`MapList`\n:param fn: callback(el) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, MapList):
            raise IslTypeError("self is not a MapList")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = Map(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)(struct isl_map *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_foreach(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_map_list_foreach\" failed: %s" % _get_last_error_str(_ctx_data))
        

    MapList.foreach = foreach

    def map(self, fn):
        'map(self, fn)\n\n:param self: :class:`MapList`\n:param fn: callback(el) -> isl_map\n:return: :class:`MapList`'

        if not isinstance(self, MapList):
            raise IslTypeError("self is not a MapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = Map(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, Map):
                    raise IslTypeError("return value is not a Map")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_map *(*fn)( isl_map *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_map(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_list_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MapList.map = map

    def sort(self, cmp):
        'sort(self, cmp)\n\n:param self: :class:`MapList`\n:param cmp: callback(a, b) -> int\n:return: :class:`MapList`'

        if not isinstance(self, MapList):
            raise IslTypeError("self is not a MapList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_cmp(a, b, user):
            try:
                _py_a = Map(_data=a)
                _py_b = Map(_data=b)
                _result = cmp(_py_a, _py_b)
                _py_a._release()
                _py_b._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_cmp = ffi.callback(" int (*cmp)(struct isl_map *a, struct isl_map *b,  void *user)")(_cb_wrapper_cmp)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_sort(_copy_self._release(), _cb_cmp, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_list_sort failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MapList.sort = sort

    def dump(self):
        'dump(self)\n\n:param self: :class:`MapList`\n:return: (nothing)'

        if not isinstance(self, MapList):
            raise IslTypeError("self is not a MapList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_list_dump(self.data)
        finally:
            pass
        

    MapList.dump = dump

    # }}}

    # {{{ union_set_list

    def union(self):
        'union(self)\n\n:param self: :class:`UnionSetList`\n:return: :class:`UnionSet`'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_union(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_list_union failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSetList.union = union

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`UnionSetList`\n:return: :class:`Context`'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_list_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSetList.get_ctx = get_ctx

    def from_union_set(el):
        'from_union_set(el)\n\n:param el: :class:`UnionSet`\n:return: :class:`UnionSetList`'

        if isinstance(el, BasicSet):
            el = Set.from_basic_set(el)
        if isinstance(el, Set):
            el = UnionSet.from_set(el)
        if not isinstance(el, UnionSet):
            raise IslTypeError("el is not a UnionSet")
        _ctx_data = el._ctx_data
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_from_union_set(_copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_list_from_union_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSetList.from_union_set = staticmethod(from_union_set)

    UnionSetList._from_union_set_is_static = True

    def alloc(ctx, n):
        'alloc(ctx, n)\n\n:param ctx: :class:`Context`\n:param n: :class:`int`\n:return: :class:`UnionSetList`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_alloc(ctx.data, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_list_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSetList.alloc = staticmethod(alloc)

    UnionSetList._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`UnionSetList`\n:return: :class:`UnionSetList`'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_list_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSetList.copy = copy

    def add(self, el):
        'add(self, el)\n\n:param self: :class:`UnionSetList`\n:param el: :class:`UnionSet`\n:return: :class:`UnionSetList`'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(el, BasicSet):
            el = Set.from_basic_set(el)
        if isinstance(el, Set):
            el = UnionSet.from_set(el)
        if not isinstance(el, UnionSet):
            raise IslTypeError("el is not a UnionSet")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_add(_copy_self._release(), _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_list_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSetList.add = add

    def insert(self, pos, el):
        'insert(self, pos, el)\n\n:param self: :class:`UnionSetList`\n:param pos: :class:`unsigned`\n:param el: :class:`UnionSet`\n:return: :class:`UnionSetList`'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if isinstance(el, BasicSet):
            el = Set.from_basic_set(el)
        if isinstance(el, Set):
            el = UnionSet.from_set(el)
        if not isinstance(el, UnionSet):
            raise IslTypeError("el is not a UnionSet")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_insert(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_list_insert failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSetList.insert = insert

    def drop(self, first, n):
        'drop(self, first, n)\n\n:param self: :class:`UnionSetList`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`UnionSetList`'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_drop(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_list_drop failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSetList.drop = drop

    def concat(self, list2):
        'concat(self, list2)\n\n:param self: :class:`UnionSetList`\n:param list2: :class:`UnionSetList`\n:return: :class:`UnionSetList`'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, UnionSetList):
            raise IslTypeError("list2 is not a UnionSetList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_concat(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_list_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSetList.concat = concat

    def n_union_set(self):
        'n_union_set(self)\n\n:param self: :class:`UnionSetList`\n:return: int'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_n_union_set(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionSetList.n_union_set = n_union_set

    def get_union_set(self, index):
        'get_union_set(self, index)\n\n:param self: :class:`UnionSetList`\n:param index: :class:`int`\n:return: :class:`UnionSet`'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        
        # no argument processing for index
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_get_union_set(self.data, index)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_list_get_union_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSetList.get_union_set = get_union_set

    def set_union_set(self, index, el):
        'set_union_set(self, index, el)\n\n:param self: :class:`UnionSetList`\n:param index: :class:`int`\n:param el: :class:`UnionSet`\n:return: :class:`UnionSetList`'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for index
        
        if isinstance(el, BasicSet):
            el = Set.from_basic_set(el)
        if isinstance(el, Set):
            el = UnionSet.from_set(el)
        if not isinstance(el, UnionSet):
            raise IslTypeError("el is not a UnionSet")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_set_union_set(_copy_self._release(), index, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_list_set_union_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSetList.set_union_set = set_union_set

    def foreach(self, fn):
        'foreach(self, fn)\n\n:param self: :class:`UnionSetList`\n:param fn: callback(el) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = UnionSet(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)(struct isl_union_set *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_foreach(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_union_set_list_foreach\" failed: %s" % _get_last_error_str(_ctx_data))
        

    UnionSetList.foreach = foreach

    def map(self, fn):
        'map(self, fn)\n\n:param self: :class:`UnionSetList`\n:param fn: callback(el) -> isl_union_set\n:return: :class:`UnionSetList`'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = UnionSet(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, UnionSet):
                    raise IslTypeError("return value is not a UnionSet")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_union_set *(*fn)( isl_union_set *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_map(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_list_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSetList.map = map

    def sort(self, cmp):
        'sort(self, cmp)\n\n:param self: :class:`UnionSetList`\n:param cmp: callback(a, b) -> int\n:return: :class:`UnionSetList`'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_cmp(a, b, user):
            try:
                _py_a = UnionSet(_data=a)
                _py_b = UnionSet(_data=b)
                _result = cmp(_py_a, _py_b)
                _py_a._release()
                _py_b._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_cmp = ffi.callback(" int (*cmp)(struct isl_union_set *a, struct isl_union_set *b,  void *user)")(_cb_wrapper_cmp)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_sort(_copy_self._release(), _cb_cmp, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_list_sort failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSetList.sort = sort

    def dump(self):
        'dump(self)\n\n:param self: :class:`UnionSetList`\n:return: (nothing)'

        if not isinstance(self, UnionSetList):
            raise IslTypeError("self is not a UnionSetList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_list_dump(self.data)
        finally:
            pass
        

    UnionSetList.dump = dump

    # }}}

    # {{{ constraint_list

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`ConstraintList`\n:return: :class:`Context`'

        if not isinstance(self, ConstraintList):
            raise IslTypeError("self is not a ConstraintList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_list_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ConstraintList.get_ctx = get_ctx

    def from_constraint(el):
        'from_constraint(el)\n\n:param el: :class:`Constraint`\n:return: :class:`ConstraintList`'

        if not isinstance(el, Constraint):
            raise IslTypeError("el is not a Constraint")
        _ctx_data = el._ctx_data
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_from_constraint(_copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ConstraintList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_list_from_constraint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ConstraintList.from_constraint = staticmethod(from_constraint)

    ConstraintList._from_constraint_is_static = True

    def alloc(ctx, n):
        'alloc(ctx, n)\n\n:param ctx: :class:`Context`\n:param n: :class:`int`\n:return: :class:`ConstraintList`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_alloc(ctx.data, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ConstraintList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_list_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ConstraintList.alloc = staticmethod(alloc)

    ConstraintList._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`ConstraintList`\n:return: :class:`ConstraintList`'

        if not isinstance(self, ConstraintList):
            raise IslTypeError("self is not a ConstraintList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ConstraintList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_list_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ConstraintList.copy = copy

    def add(self, el):
        'add(self, el)\n\n:param self: :class:`ConstraintList`\n:param el: :class:`Constraint`\n:return: :class:`ConstraintList`'

        if not isinstance(self, ConstraintList):
            raise IslTypeError("self is not a ConstraintList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(el, Constraint):
            raise IslTypeError("el is not a Constraint")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_add(_copy_self._release(), _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ConstraintList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_list_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ConstraintList.add = add

    def insert(self, pos, el):
        'insert(self, pos, el)\n\n:param self: :class:`ConstraintList`\n:param pos: :class:`unsigned`\n:param el: :class:`Constraint`\n:return: :class:`ConstraintList`'

        if not isinstance(self, ConstraintList):
            raise IslTypeError("self is not a ConstraintList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(el, Constraint):
            raise IslTypeError("el is not a Constraint")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_insert(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ConstraintList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_list_insert failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ConstraintList.insert = insert

    def drop(self, first, n):
        'drop(self, first, n)\n\n:param self: :class:`ConstraintList`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`ConstraintList`'

        if not isinstance(self, ConstraintList):
            raise IslTypeError("self is not a ConstraintList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_drop(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ConstraintList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_list_drop failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ConstraintList.drop = drop

    def concat(self, list2):
        'concat(self, list2)\n\n:param self: :class:`ConstraintList`\n:param list2: :class:`ConstraintList`\n:return: :class:`ConstraintList`'

        if not isinstance(self, ConstraintList):
            raise IslTypeError("self is not a ConstraintList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, ConstraintList):
            raise IslTypeError("list2 is not a ConstraintList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_concat(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ConstraintList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_list_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ConstraintList.concat = concat

    def n_constraint(self):
        'n_constraint(self)\n\n:param self: :class:`ConstraintList`\n:return: int'

        if not isinstance(self, ConstraintList):
            raise IslTypeError("self is not a ConstraintList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_n_constraint(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    ConstraintList.n_constraint = n_constraint

    def get_constraint(self, index):
        'get_constraint(self, index)\n\n:param self: :class:`ConstraintList`\n:param index: :class:`int`\n:return: :class:`Constraint`'

        if not isinstance(self, ConstraintList):
            raise IslTypeError("self is not a ConstraintList")
        _ctx_data = self._ctx_data
        
        # no argument processing for index
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_get_constraint(self.data, index)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Constraint(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_list_get_constraint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ConstraintList.get_constraint = get_constraint

    def set_constraint(self, index, el):
        'set_constraint(self, index, el)\n\n:param self: :class:`ConstraintList`\n:param index: :class:`int`\n:param el: :class:`Constraint`\n:return: :class:`ConstraintList`'

        if not isinstance(self, ConstraintList):
            raise IslTypeError("self is not a ConstraintList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for index
        
        if not isinstance(el, Constraint):
            raise IslTypeError("el is not a Constraint")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_set_constraint(_copy_self._release(), index, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ConstraintList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_list_set_constraint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ConstraintList.set_constraint = set_constraint

    def foreach(self, fn):
        'foreach(self, fn)\n\n:param self: :class:`ConstraintList`\n:param fn: callback(el) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, ConstraintList):
            raise IslTypeError("self is not a ConstraintList")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = Constraint(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)(struct isl_constraint *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_foreach(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_constraint_list_foreach\" failed: %s" % _get_last_error_str(_ctx_data))
        

    ConstraintList.foreach = foreach

    def map(self, fn):
        'map(self, fn)\n\n:param self: :class:`ConstraintList`\n:param fn: callback(el) -> isl_constraint\n:return: :class:`ConstraintList`'

        if not isinstance(self, ConstraintList):
            raise IslTypeError("self is not a ConstraintList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = Constraint(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, Constraint):
                    raise IslTypeError("return value is not a Constraint")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_constraint *(*fn)( isl_constraint *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_map(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ConstraintList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_list_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ConstraintList.map = map

    def sort(self, cmp):
        'sort(self, cmp)\n\n:param self: :class:`ConstraintList`\n:param cmp: callback(a, b) -> int\n:return: :class:`ConstraintList`'

        if not isinstance(self, ConstraintList):
            raise IslTypeError("self is not a ConstraintList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_cmp(a, b, user):
            try:
                _py_a = Constraint(_data=a)
                _py_b = Constraint(_data=b)
                _result = cmp(_py_a, _py_b)
                _py_a._release()
                _py_b._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_cmp = ffi.callback(" int (*cmp)(struct isl_constraint *a, struct isl_constraint *b,  void *user)")(_cb_wrapper_cmp)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_sort(_copy_self._release(), _cb_cmp, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ConstraintList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_list_sort failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ConstraintList.sort = sort

    def dump(self):
        'dump(self)\n\n:param self: :class:`ConstraintList`\n:return: (nothing)'

        if not isinstance(self, ConstraintList):
            raise IslTypeError("self is not a ConstraintList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_list_dump(self.data)
        finally:
            pass
        

    ConstraintList.dump = dump

    # }}}

    # {{{ aff_list

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`AffList`\n:return: :class:`Context`'

        if not isinstance(self, AffList):
            raise IslTypeError("self is not a AffList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_list_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AffList.get_ctx = get_ctx

    def from_aff(el):
        'from_aff(el)\n\n:param el: :class:`Aff`\n:return: :class:`AffList`'

        if not isinstance(el, Aff):
            raise IslTypeError("el is not a Aff")
        _ctx_data = el._ctx_data
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_from_aff(_copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_list_from_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AffList.from_aff = staticmethod(from_aff)

    AffList._from_aff_is_static = True

    def alloc(ctx, n):
        'alloc(ctx, n)\n\n:param ctx: :class:`Context`\n:param n: :class:`int`\n:return: :class:`AffList`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_alloc(ctx.data, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_list_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AffList.alloc = staticmethod(alloc)

    AffList._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`AffList`\n:return: :class:`AffList`'

        if not isinstance(self, AffList):
            raise IslTypeError("self is not a AffList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_list_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AffList.copy = copy

    def add(self, el):
        'add(self, el)\n\n:param self: :class:`AffList`\n:param el: :class:`Aff`\n:return: :class:`AffList`'

        if not isinstance(self, AffList):
            raise IslTypeError("self is not a AffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(el, Aff):
            raise IslTypeError("el is not a Aff")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_add(_copy_self._release(), _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_list_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AffList.add = add

    def insert(self, pos, el):
        'insert(self, pos, el)\n\n:param self: :class:`AffList`\n:param pos: :class:`unsigned`\n:param el: :class:`Aff`\n:return: :class:`AffList`'

        if not isinstance(self, AffList):
            raise IslTypeError("self is not a AffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(el, Aff):
            raise IslTypeError("el is not a Aff")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_insert(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_list_insert failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AffList.insert = insert

    def drop(self, first, n):
        'drop(self, first, n)\n\n:param self: :class:`AffList`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`AffList`'

        if not isinstance(self, AffList):
            raise IslTypeError("self is not a AffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_drop(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_list_drop failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AffList.drop = drop

    def concat(self, list2):
        'concat(self, list2)\n\n:param self: :class:`AffList`\n:param list2: :class:`AffList`\n:return: :class:`AffList`'

        if not isinstance(self, AffList):
            raise IslTypeError("self is not a AffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, AffList):
            raise IslTypeError("list2 is not a AffList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_concat(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_list_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AffList.concat = concat

    def n_aff(self):
        'n_aff(self)\n\n:param self: :class:`AffList`\n:return: int'

        if not isinstance(self, AffList):
            raise IslTypeError("self is not a AffList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_n_aff(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    AffList.n_aff = n_aff

    def get_aff(self, index):
        'get_aff(self, index)\n\n:param self: :class:`AffList`\n:param index: :class:`int`\n:return: :class:`Aff`'

        if not isinstance(self, AffList):
            raise IslTypeError("self is not a AffList")
        _ctx_data = self._ctx_data
        
        # no argument processing for index
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_get_aff(self.data, index)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_list_get_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AffList.get_aff = get_aff

    def set_aff(self, index, el):
        'set_aff(self, index, el)\n\n:param self: :class:`AffList`\n:param index: :class:`int`\n:param el: :class:`Aff`\n:return: :class:`AffList`'

        if not isinstance(self, AffList):
            raise IslTypeError("self is not a AffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for index
        
        if not isinstance(el, Aff):
            raise IslTypeError("el is not a Aff")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_set_aff(_copy_self._release(), index, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_list_set_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AffList.set_aff = set_aff

    def foreach(self, fn):
        'foreach(self, fn)\n\n:param self: :class:`AffList`\n:param fn: callback(el) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, AffList):
            raise IslTypeError("self is not a AffList")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = Aff(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)(struct isl_aff *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_foreach(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_aff_list_foreach\" failed: %s" % _get_last_error_str(_ctx_data))
        

    AffList.foreach = foreach

    def map(self, fn):
        'map(self, fn)\n\n:param self: :class:`AffList`\n:param fn: callback(el) -> isl_aff\n:return: :class:`AffList`'

        if not isinstance(self, AffList):
            raise IslTypeError("self is not a AffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = Aff(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, Aff):
                    raise IslTypeError("return value is not a Aff")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_aff *(*fn)( isl_aff *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_map(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_list_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AffList.map = map

    def sort(self, cmp):
        'sort(self, cmp)\n\n:param self: :class:`AffList`\n:param cmp: callback(a, b) -> int\n:return: :class:`AffList`'

        if not isinstance(self, AffList):
            raise IslTypeError("self is not a AffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_cmp(a, b, user):
            try:
                _py_a = Aff(_data=a)
                _py_b = Aff(_data=b)
                _result = cmp(_py_a, _py_b)
                _py_a._release()
                _py_b._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_cmp = ffi.callback(" int (*cmp)(struct isl_aff *a, struct isl_aff *b,  void *user)")(_cb_wrapper_cmp)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_sort(_copy_self._release(), _cb_cmp, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_list_sort failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AffList.sort = sort

    def dump(self):
        'dump(self)\n\n:param self: :class:`AffList`\n:return: (nothing)'

        if not isinstance(self, AffList):
            raise IslTypeError("self is not a AffList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_list_dump(self.data)
        finally:
            pass
        

    AffList.dump = dump

    # }}}

    # {{{ pw_aff_list

    def min(self):
        'min(self)\n\n:param self: :class:`PwAffList`\n:return: :class:`PwAff`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_min(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_min failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.min = min

    def max(self):
        'max(self)\n\n:param self: :class:`PwAffList`\n:return: :class:`PwAff`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_max(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_max failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.max = max

    def eq_set(self, list2):
        'eq_set(self, list2)\n\n:param self: :class:`PwAffList`\n:param list2: :class:`PwAffList`\n:return: :class:`Set`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, PwAffList):
            raise IslTypeError("list2 is not a PwAffList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_eq_set(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_eq_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.eq_set = eq_set

    def ne_set(self, list2):
        'ne_set(self, list2)\n\n:param self: :class:`PwAffList`\n:param list2: :class:`PwAffList`\n:return: :class:`Set`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, PwAffList):
            raise IslTypeError("list2 is not a PwAffList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_ne_set(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_ne_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.ne_set = ne_set

    def le_set(self, list2):
        'le_set(self, list2)\n\n:param self: :class:`PwAffList`\n:param list2: :class:`PwAffList`\n:return: :class:`Set`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, PwAffList):
            raise IslTypeError("list2 is not a PwAffList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_le_set(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_le_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.le_set = le_set

    def lt_set(self, list2):
        'lt_set(self, list2)\n\n:param self: :class:`PwAffList`\n:param list2: :class:`PwAffList`\n:return: :class:`Set`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, PwAffList):
            raise IslTypeError("list2 is not a PwAffList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_lt_set(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_lt_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.lt_set = lt_set

    def ge_set(self, list2):
        'ge_set(self, list2)\n\n:param self: :class:`PwAffList`\n:param list2: :class:`PwAffList`\n:return: :class:`Set`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, PwAffList):
            raise IslTypeError("list2 is not a PwAffList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_ge_set(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_ge_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.ge_set = ge_set

    def gt_set(self, list2):
        'gt_set(self, list2)\n\n:param self: :class:`PwAffList`\n:param list2: :class:`PwAffList`\n:return: :class:`Set`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, PwAffList):
            raise IslTypeError("list2 is not a PwAffList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_gt_set(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_gt_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.gt_set = gt_set

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`PwAffList`\n:return: :class:`Context`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.get_ctx = get_ctx

    def from_pw_aff(el):
        'from_pw_aff(el)\n\n:param el: :class:`PwAff`\n:return: :class:`PwAffList`'

        if isinstance(el, Aff):
            el = PwAff.from_aff(el)
        if not isinstance(el, PwAff):
            raise IslTypeError("el is not a PwAff")
        _ctx_data = el._ctx_data
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_from_pw_aff(_copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_from_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.from_pw_aff = staticmethod(from_pw_aff)

    PwAffList._from_pw_aff_is_static = True

    def alloc(ctx, n):
        'alloc(ctx, n)\n\n:param ctx: :class:`Context`\n:param n: :class:`int`\n:return: :class:`PwAffList`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_alloc(ctx.data, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.alloc = staticmethod(alloc)

    PwAffList._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`PwAffList`\n:return: :class:`PwAffList`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.copy = copy

    def add(self, el):
        'add(self, el)\n\n:param self: :class:`PwAffList`\n:param el: :class:`PwAff`\n:return: :class:`PwAffList`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(el, Aff):
            el = PwAff.from_aff(el)
        if not isinstance(el, PwAff):
            raise IslTypeError("el is not a PwAff")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_add(_copy_self._release(), _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.add = add

    def insert(self, pos, el):
        'insert(self, pos, el)\n\n:param self: :class:`PwAffList`\n:param pos: :class:`unsigned`\n:param el: :class:`PwAff`\n:return: :class:`PwAffList`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if isinstance(el, Aff):
            el = PwAff.from_aff(el)
        if not isinstance(el, PwAff):
            raise IslTypeError("el is not a PwAff")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_insert(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_insert failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.insert = insert

    def drop(self, first, n):
        'drop(self, first, n)\n\n:param self: :class:`PwAffList`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`PwAffList`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_drop(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_drop failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.drop = drop

    def concat(self, list2):
        'concat(self, list2)\n\n:param self: :class:`PwAffList`\n:param list2: :class:`PwAffList`\n:return: :class:`PwAffList`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, PwAffList):
            raise IslTypeError("list2 is not a PwAffList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_concat(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.concat = concat

    def n_pw_aff(self):
        'n_pw_aff(self)\n\n:param self: :class:`PwAffList`\n:return: int'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_n_pw_aff(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwAffList.n_pw_aff = n_pw_aff

    def get_pw_aff(self, index):
        'get_pw_aff(self, index)\n\n:param self: :class:`PwAffList`\n:param index: :class:`int`\n:return: :class:`PwAff`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        
        # no argument processing for index
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_get_pw_aff(self.data, index)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_get_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.get_pw_aff = get_pw_aff

    def set_pw_aff(self, index, el):
        'set_pw_aff(self, index, el)\n\n:param self: :class:`PwAffList`\n:param index: :class:`int`\n:param el: :class:`PwAff`\n:return: :class:`PwAffList`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for index
        
        if isinstance(el, Aff):
            el = PwAff.from_aff(el)
        if not isinstance(el, PwAff):
            raise IslTypeError("el is not a PwAff")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_set_pw_aff(_copy_self._release(), index, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_set_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.set_pw_aff = set_pw_aff

    def foreach(self, fn):
        'foreach(self, fn)\n\n:param self: :class:`PwAffList`\n:param fn: callback(el) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = PwAff(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)(struct isl_pw_aff *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_foreach(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_pw_aff_list_foreach\" failed: %s" % _get_last_error_str(_ctx_data))
        

    PwAffList.foreach = foreach

    def map(self, fn):
        'map(self, fn)\n\n:param self: :class:`PwAffList`\n:param fn: callback(el) -> isl_pw_aff\n:return: :class:`PwAffList`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = PwAff(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, PwAff):
                    raise IslTypeError("return value is not a PwAff")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_pw_aff *(*fn)( isl_pw_aff *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_map(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.map = map

    def sort(self, cmp):
        'sort(self, cmp)\n\n:param self: :class:`PwAffList`\n:param cmp: callback(a, b) -> int\n:return: :class:`PwAffList`'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_cmp(a, b, user):
            try:
                _py_a = PwAff(_data=a)
                _py_b = PwAff(_data=b)
                _result = cmp(_py_a, _py_b)
                _py_a._release()
                _py_b._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_cmp = ffi.callback(" int (*cmp)(struct isl_pw_aff *a, struct isl_pw_aff *b,  void *user)")(_cb_wrapper_cmp)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_sort(_copy_self._release(), _cb_cmp, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_list_sort failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAffList.sort = sort

    def dump(self):
        'dump(self)\n\n:param self: :class:`PwAffList`\n:return: (nothing)'

        if not isinstance(self, PwAffList):
            raise IslTypeError("self is not a PwAffList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_list_dump(self.data)
        finally:
            pass
        

    PwAffList.dump = dump

    # }}}

    # {{{ pw_multi_aff_list

    # }}}

    # {{{ ast_expr_list

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`AstExprList`\n:return: :class:`Context`'

        if not isinstance(self, AstExprList):
            raise IslTypeError("self is not a AstExprList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_list_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExprList.get_ctx = get_ctx

    def from_ast_expr(el):
        'from_ast_expr(el)\n\n:param el: :class:`AstExpr`\n:return: :class:`AstExprList`'

        if not isinstance(el, AstExpr):
            raise IslTypeError("el is not a AstExpr")
        _ctx_data = el._ctx_data
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_from_ast_expr(_copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExprList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_list_from_ast_expr failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExprList.from_ast_expr = staticmethod(from_ast_expr)

    AstExprList._from_ast_expr_is_static = True

    def alloc(ctx, n):
        'alloc(ctx, n)\n\n:param ctx: :class:`Context`\n:param n: :class:`int`\n:return: :class:`AstExprList`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_alloc(ctx.data, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExprList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_list_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExprList.alloc = staticmethod(alloc)

    AstExprList._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`AstExprList`\n:return: :class:`AstExprList`'

        if not isinstance(self, AstExprList):
            raise IslTypeError("self is not a AstExprList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExprList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_list_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExprList.copy = copy

    def add(self, el):
        'add(self, el)\n\n:param self: :class:`AstExprList`\n:param el: :class:`AstExpr`\n:return: :class:`AstExprList`'

        if not isinstance(self, AstExprList):
            raise IslTypeError("self is not a AstExprList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(el, AstExpr):
            raise IslTypeError("el is not a AstExpr")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_add(_copy_self._release(), _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExprList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_list_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExprList.add = add

    def insert(self, pos, el):
        'insert(self, pos, el)\n\n:param self: :class:`AstExprList`\n:param pos: :class:`unsigned`\n:param el: :class:`AstExpr`\n:return: :class:`AstExprList`'

        if not isinstance(self, AstExprList):
            raise IslTypeError("self is not a AstExprList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(el, AstExpr):
            raise IslTypeError("el is not a AstExpr")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_insert(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExprList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_list_insert failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExprList.insert = insert

    def drop(self, first, n):
        'drop(self, first, n)\n\n:param self: :class:`AstExprList`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`AstExprList`'

        if not isinstance(self, AstExprList):
            raise IslTypeError("self is not a AstExprList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_drop(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExprList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_list_drop failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExprList.drop = drop

    def concat(self, list2):
        'concat(self, list2)\n\n:param self: :class:`AstExprList`\n:param list2: :class:`AstExprList`\n:return: :class:`AstExprList`'

        if not isinstance(self, AstExprList):
            raise IslTypeError("self is not a AstExprList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, AstExprList):
            raise IslTypeError("list2 is not a AstExprList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_concat(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExprList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_list_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExprList.concat = concat

    def n_ast_expr(self):
        'n_ast_expr(self)\n\n:param self: :class:`AstExprList`\n:return: int'

        if not isinstance(self, AstExprList):
            raise IslTypeError("self is not a AstExprList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_n_ast_expr(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    AstExprList.n_ast_expr = n_ast_expr

    def get_ast_expr(self, index):
        'get_ast_expr(self, index)\n\n:param self: :class:`AstExprList`\n:param index: :class:`int`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExprList):
            raise IslTypeError("self is not a AstExprList")
        _ctx_data = self._ctx_data
        
        # no argument processing for index
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_get_ast_expr(self.data, index)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_list_get_ast_expr failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExprList.get_ast_expr = get_ast_expr

    def set_ast_expr(self, index, el):
        'set_ast_expr(self, index, el)\n\n:param self: :class:`AstExprList`\n:param index: :class:`int`\n:param el: :class:`AstExpr`\n:return: :class:`AstExprList`'

        if not isinstance(self, AstExprList):
            raise IslTypeError("self is not a AstExprList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for index
        
        if not isinstance(el, AstExpr):
            raise IslTypeError("el is not a AstExpr")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_set_ast_expr(_copy_self._release(), index, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExprList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_list_set_ast_expr failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExprList.set_ast_expr = set_ast_expr

    def foreach(self, fn):
        'foreach(self, fn)\n\n:param self: :class:`AstExprList`\n:param fn: callback(el) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, AstExprList):
            raise IslTypeError("self is not a AstExprList")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = AstExpr(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)(struct isl_ast_expr *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_foreach(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_ast_expr_list_foreach\" failed: %s" % _get_last_error_str(_ctx_data))
        

    AstExprList.foreach = foreach

    def map(self, fn):
        'map(self, fn)\n\n:param self: :class:`AstExprList`\n:param fn: callback(el) -> isl_ast_expr\n:return: :class:`AstExprList`'

        if not isinstance(self, AstExprList):
            raise IslTypeError("self is not a AstExprList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = AstExpr(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, AstExpr):
                    raise IslTypeError("return value is not a AstExpr")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_ast_expr *(*fn)( isl_ast_expr *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_map(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExprList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_list_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExprList.map = map

    def sort(self, cmp):
        'sort(self, cmp)\n\n:param self: :class:`AstExprList`\n:param cmp: callback(a, b) -> int\n:return: :class:`AstExprList`'

        if not isinstance(self, AstExprList):
            raise IslTypeError("self is not a AstExprList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_cmp(a, b, user):
            try:
                _py_a = AstExpr(_data=a)
                _py_b = AstExpr(_data=b)
                _result = cmp(_py_a, _py_b)
                _py_a._release()
                _py_b._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_cmp = ffi.callback(" int (*cmp)(struct isl_ast_expr *a, struct isl_ast_expr *b,  void *user)")(_cb_wrapper_cmp)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_sort(_copy_self._release(), _cb_cmp, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExprList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_list_sort failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExprList.sort = sort

    def dump(self):
        'dump(self)\n\n:param self: :class:`AstExprList`\n:return: (nothing)'

        if not isinstance(self, AstExprList):
            raise IslTypeError("self is not a AstExprList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_list_dump(self.data)
        finally:
            pass
        

    AstExprList.dump = dump

    # }}}

    # {{{ ast_node_list

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`AstNodeList`\n:return: :class:`Context`'

        if not isinstance(self, AstNodeList):
            raise IslTypeError("self is not a AstNodeList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_list_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNodeList.get_ctx = get_ctx

    def from_ast_node(el):
        'from_ast_node(el)\n\n:param el: :class:`AstNode`\n:return: :class:`AstNodeList`'

        if not isinstance(el, AstNode):
            raise IslTypeError("el is not a AstNode")
        _ctx_data = el._ctx_data
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_from_ast_node(_copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNodeList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_list_from_ast_node failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNodeList.from_ast_node = staticmethod(from_ast_node)

    AstNodeList._from_ast_node_is_static = True

    def alloc(ctx, n):
        'alloc(ctx, n)\n\n:param ctx: :class:`Context`\n:param n: :class:`int`\n:return: :class:`AstNodeList`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_alloc(ctx.data, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNodeList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_list_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNodeList.alloc = staticmethod(alloc)

    AstNodeList._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`AstNodeList`\n:return: :class:`AstNodeList`'

        if not isinstance(self, AstNodeList):
            raise IslTypeError("self is not a AstNodeList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNodeList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_list_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNodeList.copy = copy

    def add(self, el):
        'add(self, el)\n\n:param self: :class:`AstNodeList`\n:param el: :class:`AstNode`\n:return: :class:`AstNodeList`'

        if not isinstance(self, AstNodeList):
            raise IslTypeError("self is not a AstNodeList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(el, AstNode):
            raise IslTypeError("el is not a AstNode")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_add(_copy_self._release(), _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNodeList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_list_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNodeList.add = add

    def insert(self, pos, el):
        'insert(self, pos, el)\n\n:param self: :class:`AstNodeList`\n:param pos: :class:`unsigned`\n:param el: :class:`AstNode`\n:return: :class:`AstNodeList`'

        if not isinstance(self, AstNodeList):
            raise IslTypeError("self is not a AstNodeList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(el, AstNode):
            raise IslTypeError("el is not a AstNode")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_insert(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNodeList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_list_insert failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNodeList.insert = insert

    def drop(self, first, n):
        'drop(self, first, n)\n\n:param self: :class:`AstNodeList`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`AstNodeList`'

        if not isinstance(self, AstNodeList):
            raise IslTypeError("self is not a AstNodeList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_drop(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNodeList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_list_drop failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNodeList.drop = drop

    def concat(self, list2):
        'concat(self, list2)\n\n:param self: :class:`AstNodeList`\n:param list2: :class:`AstNodeList`\n:return: :class:`AstNodeList`'

        if not isinstance(self, AstNodeList):
            raise IslTypeError("self is not a AstNodeList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list2, AstNodeList):
            raise IslTypeError("list2 is not a AstNodeList")
        if _ctx_data != list2._ctx_data:
            raise Error("mismatched context in list2")
        _copy_list2 = list2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_concat(_copy_self._release(), _copy_list2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNodeList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_list_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNodeList.concat = concat

    def n_ast_node(self):
        'n_ast_node(self)\n\n:param self: :class:`AstNodeList`\n:return: int'

        if not isinstance(self, AstNodeList):
            raise IslTypeError("self is not a AstNodeList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_n_ast_node(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    AstNodeList.n_ast_node = n_ast_node

    def get_ast_node(self, index):
        'get_ast_node(self, index)\n\n:param self: :class:`AstNodeList`\n:param index: :class:`int`\n:return: :class:`AstNode`'

        if not isinstance(self, AstNodeList):
            raise IslTypeError("self is not a AstNodeList")
        _ctx_data = self._ctx_data
        
        # no argument processing for index
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_get_ast_node(self.data, index)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_list_get_ast_node failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNodeList.get_ast_node = get_ast_node

    def set_ast_node(self, index, el):
        'set_ast_node(self, index, el)\n\n:param self: :class:`AstNodeList`\n:param index: :class:`int`\n:param el: :class:`AstNode`\n:return: :class:`AstNodeList`'

        if not isinstance(self, AstNodeList):
            raise IslTypeError("self is not a AstNodeList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for index
        
        if not isinstance(el, AstNode):
            raise IslTypeError("el is not a AstNode")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_set_ast_node(_copy_self._release(), index, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNodeList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_list_set_ast_node failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNodeList.set_ast_node = set_ast_node

    def foreach(self, fn):
        'foreach(self, fn)\n\n:param self: :class:`AstNodeList`\n:param fn: callback(el) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, AstNodeList):
            raise IslTypeError("self is not a AstNodeList")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = AstNode(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)(struct isl_ast_node *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_foreach(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_ast_node_list_foreach\" failed: %s" % _get_last_error_str(_ctx_data))
        

    AstNodeList.foreach = foreach

    def map(self, fn):
        'map(self, fn)\n\n:param self: :class:`AstNodeList`\n:param fn: callback(el) -> isl_ast_node\n:return: :class:`AstNodeList`'

        if not isinstance(self, AstNodeList):
            raise IslTypeError("self is not a AstNodeList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(el, user):
            try:
                _py_el = AstNode(_data=el)
                _result = fn(_py_el)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, AstNode):
                    raise IslTypeError("return value is not a AstNode")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_ast_node *(*fn)( isl_ast_node *el,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_map(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNodeList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_list_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNodeList.map = map

    def sort(self, cmp):
        'sort(self, cmp)\n\n:param self: :class:`AstNodeList`\n:param cmp: callback(a, b) -> int\n:return: :class:`AstNodeList`'

        if not isinstance(self, AstNodeList):
            raise IslTypeError("self is not a AstNodeList")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_cmp(a, b, user):
            try:
                _py_a = AstNode(_data=a)
                _py_b = AstNode(_data=b)
                _result = cmp(_py_a, _py_b)
                _py_a._release()
                _py_b._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_cmp = ffi.callback(" int (*cmp)(struct isl_ast_node *a, struct isl_ast_node *b,  void *user)")(_cb_wrapper_cmp)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_sort(_copy_self._release(), _cb_cmp, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNodeList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_list_sort failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNodeList.sort = sort

    def dump(self):
        'dump(self)\n\n:param self: :class:`AstNodeList`\n:return: (nothing)'

        if not isinstance(self, AstNodeList):
            raise IslTypeError("self is not a AstNodeList")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_list_dump(self.data)
        finally:
            pass
        

    AstNodeList.dump = dump

    # }}}

    # {{{ pw_qpolynomial_list

    # }}}

    # {{{ pw_qpolynomial_fold_list

    # }}}

    # {{{ id_to_ast_expr

    # }}}

    # {{{ printer

    def print_id(self, id):
        'print_id(self, id)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param id: :class:`Id`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_id(self.data, id.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_id = print_id

    def print_multi_id(self, mi):
        'print_multi_id(self, mi)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param mi: :class:`MultiId`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(mi, MultiId):
            raise IslTypeError("mi is not a MultiId")
        if _ctx_data != mi._ctx_data:
            raise Error("mismatched context in mi")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_multi_id(self.data, mi.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_multi_id = print_multi_id

    def print_space(self, space):
        'print_space(self, space)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param space: :class:`Space`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        if _ctx_data != space._ctx_data:
            raise Error("mismatched context in space")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_space(self.data, space.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_space = print_space

    def print_basic_set(self, bset):
        'print_basic_set(self, bset)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param bset: :class:`BasicSet`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(bset, BasicSet):
            raise IslTypeError("bset is not a BasicSet")
        if _ctx_data != bset._ctx_data:
            raise Error("mismatched context in bset")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_basic_set(self.data, bset.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_basic_set = print_basic_set

    def print_set(self, map):
        'print_set(self, map)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param map: :class:`Set`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if isinstance(map, BasicSet):
            map = Set.from_basic_set(map)
        if not isinstance(map, Set):
            raise IslTypeError("map is not a Set")
        if _ctx_data != map._ctx_data:
            raise Error("mismatched context in map")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_set(self.data, map.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_set = print_set

    def print_basic_map(self, bmap):
        'print_basic_map(self, bmap)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param bmap: :class:`BasicMap`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(bmap, BasicMap):
            raise IslTypeError("bmap is not a BasicMap")
        if _ctx_data != bmap._ctx_data:
            raise Error("mismatched context in bmap")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_basic_map(self.data, bmap.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_basic_map = print_basic_map

    def print_map(self, map):
        'print_map(self, map)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param map: :class:`Map`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if isinstance(map, BasicMap):
            map = Map.from_basic_map(map)
        if not isinstance(map, Map):
            raise IslTypeError("map is not a Map")
        if _ctx_data != map._ctx_data:
            raise Error("mismatched context in map")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_map(self.data, map.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_map = print_map

    def print_local_space(self, ls):
        'print_local_space(self, ls)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param ls: :class:`LocalSpace`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if isinstance(ls, Space):
            ls = LocalSpace.from_space(ls)
        if not isinstance(ls, LocalSpace):
            raise IslTypeError("ls is not a LocalSpace")
        if _ctx_data != ls._ctx_data:
            raise Error("mismatched context in ls")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_local_space(self.data, ls.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_local_space = print_local_space

    def print_aff(self, aff):
        'print_aff(self, aff)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param aff: :class:`Aff`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(aff, Aff):
            raise IslTypeError("aff is not a Aff")
        if _ctx_data != aff._ctx_data:
            raise Error("mismatched context in aff")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_aff(self.data, aff.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_aff = print_aff

    def print_pw_aff(self, pwaff):
        'print_pw_aff(self, pwaff)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param pwaff: :class:`PwAff`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if isinstance(pwaff, Aff):
            pwaff = PwAff.from_aff(pwaff)
        if not isinstance(pwaff, PwAff):
            raise IslTypeError("pwaff is not a PwAff")
        if _ctx_data != pwaff._ctx_data:
            raise Error("mismatched context in pwaff")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_pw_aff(self.data, pwaff.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_pw_aff = print_pw_aff

    def print_multi_aff(self, maff):
        'print_multi_aff(self, maff)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param maff: :class:`MultiAff`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(maff, MultiAff):
            raise IslTypeError("maff is not a MultiAff")
        if _ctx_data != maff._ctx_data:
            raise Error("mismatched context in maff")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_multi_aff(self.data, maff.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_multi_aff = print_multi_aff

    def print_pw_multi_aff(self, pma):
        'print_pw_multi_aff(self, pma)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param pma: :class:`PwMultiAff`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_pw_multi_aff(self.data, pma.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_pw_multi_aff = print_pw_multi_aff

    def print_union_pw_multi_aff(self, upma):
        'print_union_pw_multi_aff(self, upma)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param upma: :class:`UnionPwMultiAff`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(upma, UnionPwMultiAff):
            raise IslTypeError("upma is not a UnionPwMultiAff")
        if _ctx_data != upma._ctx_data:
            raise Error("mismatched context in upma")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_union_pw_multi_aff(self.data, upma.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_union_pw_multi_aff = print_union_pw_multi_aff

    def print_multi_pw_aff(self, mpa):
        'print_multi_pw_aff(self, mpa)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param mpa: :class:`MultiPwAff`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(mpa, MultiPwAff):
            raise IslTypeError("mpa is not a MultiPwAff")
        if _ctx_data != mpa._ctx_data:
            raise Error("mismatched context in mpa")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_multi_pw_aff(self.data, mpa.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_multi_pw_aff = print_multi_pw_aff

    def print_union_pw_aff(self, upa):
        'print_union_pw_aff(self, upa)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param upa: :class:`UnionPwAff`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(upa, UnionPwAff):
            raise IslTypeError("upa is not a UnionPwAff")
        if _ctx_data != upa._ctx_data:
            raise Error("mismatched context in upa")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_union_pw_aff(self.data, upa.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_union_pw_aff = print_union_pw_aff

    def print_multi_union_pw_aff(self, mupa):
        'print_multi_union_pw_aff(self, mupa)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param mupa: :class:`MultiUnionPwAff`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(mupa, MultiUnionPwAff):
            raise IslTypeError("mupa is not a MultiUnionPwAff")
        if _ctx_data != mupa._ctx_data:
            raise Error("mismatched context in mupa")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_multi_union_pw_aff(self.data, mupa.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_multi_union_pw_aff = print_multi_union_pw_aff

    def print_qpolynomial(self, qp):
        'print_qpolynomial(self, qp)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param qp: :class:`QPolynomial`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(qp, QPolynomial):
            raise IslTypeError("qp is not a QPolynomial")
        if _ctx_data != qp._ctx_data:
            raise Error("mismatched context in qp")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_qpolynomial(self.data, qp.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_qpolynomial = print_qpolynomial

    def print_pw_qpolynomial(self, pwqp):
        'print_pw_qpolynomial(self, pwqp)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param pwqp: :class:`PwQPolynomial`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(pwqp, PwQPolynomial):
            raise IslTypeError("pwqp is not a PwQPolynomial")
        if _ctx_data != pwqp._ctx_data:
            raise Error("mismatched context in pwqp")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_pw_qpolynomial(self.data, pwqp.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_pw_qpolynomial = print_pw_qpolynomial

    def print_qpolynomial_fold(self, fold):
        'print_qpolynomial_fold(self, fold)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param fold: :class:`QPolynomialFold`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(fold, QPolynomialFold):
            raise IslTypeError("fold is not a QPolynomialFold")
        if _ctx_data != fold._ctx_data:
            raise Error("mismatched context in fold")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_qpolynomial_fold(self.data, fold.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_qpolynomial_fold = print_qpolynomial_fold

    def print_pw_qpolynomial_fold(self, pwf):
        'print_pw_qpolynomial_fold(self, pwf)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param pwf: :class:`PwQPolynomialFold`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(pwf, PwQPolynomialFold):
            raise IslTypeError("pwf is not a PwQPolynomialFold")
        if _ctx_data != pwf._ctx_data:
            raise Error("mismatched context in pwf")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_pw_qpolynomial_fold(self.data, pwf.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_pw_qpolynomial_fold = print_pw_qpolynomial_fold

    def print_union_pw_qpolynomial(self, upwqp):
        'print_union_pw_qpolynomial(self, upwqp)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param upwqp: :class:`UnionPwQPolynomial`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(upwqp, UnionPwQPolynomial):
            raise IslTypeError("upwqp is not a UnionPwQPolynomial")
        if _ctx_data != upwqp._ctx_data:
            raise Error("mismatched context in upwqp")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_union_pw_qpolynomial(self.data, upwqp.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_union_pw_qpolynomial = print_union_pw_qpolynomial

    def print_union_pw_qpolynomial_fold(self, upwf):
        'print_union_pw_qpolynomial_fold(self, upwf)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param upwf: :class:`UnionPwQPolynomialFold`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(upwf, UnionPwQPolynomialFold):
            raise IslTypeError("upwf is not a UnionPwQPolynomialFold")
        if _ctx_data != upwf._ctx_data:
            raise Error("mismatched context in upwf")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_union_pw_qpolynomial_fold(self.data, upwf.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_union_pw_qpolynomial_fold = print_union_pw_qpolynomial_fold

    def print_union_map(self, umap):
        'print_union_map(self, umap)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param umap: :class:`UnionMap`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if isinstance(umap, BasicMap):
            umap = Map.from_basic_map(umap)
        if isinstance(umap, Map):
            umap = UnionMap.from_map(umap)
        if not isinstance(umap, UnionMap):
            raise IslTypeError("umap is not a UnionMap")
        if _ctx_data != umap._ctx_data:
            raise Error("mismatched context in umap")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_union_map(self.data, umap.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_union_map = print_union_map

    def print_union_set(self, uset):
        'print_union_set(self, uset)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param uset: :class:`UnionSet`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_union_set(self.data, uset.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_union_set = print_union_set

    def to_str(ctx):
        'to_str(ctx)\n\n:param ctx: :class:`Context`\n:return: :class:`Printer`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_to_str(ctx.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Printer(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_printer_to_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Printer.to_str = staticmethod(to_str)

    Printer._to_str_is_static = True

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Printer`\n:return: :class:`Context`'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_printer_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Printer.get_ctx = get_ctx

    def get_str(self):
        'get_str(self)\n\n:param self: :class:`Printer`\n:return: string'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_get_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Printer.get_str = get_str

    def set_indent(self, indent):
        'set_indent(self, indent)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param indent: :class:`int`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        # no argument processing for indent
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_set_indent(self.data, indent)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.set_indent = set_indent

    def indent(self, indent):
        'indent(self, indent)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param indent: :class:`int`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        # no argument processing for indent
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_indent(self.data, indent)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.indent = indent

    def set_output_format(self, output_format):
        'set_output_format(self, output_format)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param output_format: :class:`int`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        # no argument processing for output_format
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_set_output_format(self.data, output_format)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.set_output_format = set_output_format

    def get_output_format(self):
        'get_output_format(self)\n\n:param self: :class:`Printer`\n:return: int'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_get_output_format(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Printer.get_output_format = get_output_format

    def set_yaml_style(self, yaml_style):
        'set_yaml_style(self, yaml_style)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param yaml_style: :class:`int`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        # no argument processing for yaml_style
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_set_yaml_style(self.data, yaml_style)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.set_yaml_style = set_yaml_style

    def get_yaml_style(self):
        'get_yaml_style(self)\n\n:param self: :class:`Printer`\n:return: int'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_get_yaml_style(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Printer.get_yaml_style = get_yaml_style

    def set_indent_prefix(self, prefix):
        'set_indent_prefix(self, prefix)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param prefix: string\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        _cstr_prefix = ffi.new("char[]", prefix.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_set_indent_prefix(self.data, _cstr_prefix)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.set_indent_prefix = set_indent_prefix

    def set_prefix(self, prefix):
        'set_prefix(self, prefix)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param prefix: string\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        _cstr_prefix = ffi.new("char[]", prefix.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_set_prefix(self.data, _cstr_prefix)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.set_prefix = set_prefix

    def set_suffix(self, suffix):
        'set_suffix(self, suffix)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param suffix: string\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        _cstr_suffix = ffi.new("char[]", suffix.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_set_suffix(self.data, _cstr_suffix)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.set_suffix = set_suffix

    def set_isl_int_width(self, width):
        'set_isl_int_width(self, width)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param width: :class:`int`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        # no argument processing for width
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_set_isl_int_width(self.data, width)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.set_isl_int_width = set_isl_int_width

    def has_note(self, id):
        'has_note(self, id)\n\n:param self: :class:`Printer`\n:param id: :class:`Id`\n:return: bool'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_has_note(self.data, id.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_printer_has_note\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Printer.has_note = has_note

    def get_note(self, id):
        'get_note(self, id)\n\n:param self: :class:`Printer`\n:param id: :class:`Id`\n:return: :class:`Id`'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_get_note(self.data, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_printer_get_note failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Printer.get_note = get_note

    def set_note(self, id, note):
        'set_note(self, id, note)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param id: :class:`Id`\n:param note: :class:`Id`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        
        if not isinstance(note, Id):
            raise IslTypeError("note is not a Id")
        if _ctx_data != note._ctx_data:
            raise Error("mismatched context in note")
        _copy_note = note._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_set_note(self.data, _copy_id._release(), _copy_note._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.set_note = set_note

    def start_line(self):
        'start_line(self)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_start_line(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.start_line = start_line

    def end_line(self):
        'end_line(self)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_end_line(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.end_line = end_line

    def print_double(self, d):
        'print_double(self, d)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param d: :class:`double`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        # no argument processing for d
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_double(self.data, d)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_double = print_double

    def print_int(self, i):
        'print_int(self, i)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param i: :class:`int`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        # no argument processing for i
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_int(self.data, i)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_int = print_int

    def print_str(self, s):
        'print_str(self, s)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param s: string\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_str(self.data, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_str = print_str

    def yaml_start_mapping(self):
        'yaml_start_mapping(self)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_yaml_start_mapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.yaml_start_mapping = yaml_start_mapping

    def yaml_end_mapping(self):
        'yaml_end_mapping(self)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_yaml_end_mapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.yaml_end_mapping = yaml_end_mapping

    def yaml_start_sequence(self):
        'yaml_start_sequence(self)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_yaml_start_sequence(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.yaml_start_sequence = yaml_start_sequence

    def yaml_end_sequence(self):
        'yaml_end_sequence(self)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_yaml_end_sequence(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.yaml_end_sequence = yaml_end_sequence

    def yaml_next(self):
        'yaml_next(self)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_yaml_next(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.yaml_next = yaml_next

    def flush(self):
        'flush(self)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_flush(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.flush = flush

    def print_point(self, pnt):
        'print_point(self, pnt)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param pnt: :class:`Point`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(pnt, Point):
            raise IslTypeError("pnt is not a Point")
        if _ctx_data != pnt._ctx_data:
            raise Error("mismatched context in pnt")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_point(self.data, pnt.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_point = print_point

    def print_constraint(self, c):
        'print_constraint(self, c)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param c: :class:`Constraint`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(c, Constraint):
            raise IslTypeError("c is not a Constraint")
        if _ctx_data != c._ctx_data:
            raise Error("mismatched context in c")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_constraint(self.data, c.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_constraint = print_constraint

    def print_val(self, v):
        'print_val(self, v)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param v: :class:`Val`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_val(self.data, _val_v.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_val = print_val

    def print_multi_val(self, mv):
        'print_multi_val(self, mv)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param mv: :class:`MultiVal`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_multi_val(self.data, mv.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_multi_val = print_multi_val

    def print_vec(self, vec):
        'print_vec(self, vec)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param vec: :class:`Vec`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(vec, Vec):
            raise IslTypeError("vec is not a Vec")
        if _ctx_data != vec._ctx_data:
            raise Error("mismatched context in vec")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_vec(self.data, vec.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_vec = print_vec

    def print_schedule_constraints(self, sc):
        'print_schedule_constraints(self, sc)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param sc: :class:`ScheduleConstraints`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(sc, ScheduleConstraints):
            raise IslTypeError("sc is not a ScheduleConstraints")
        if _ctx_data != sc._ctx_data:
            raise Error("mismatched context in sc")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_schedule_constraints(self.data, sc.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_schedule_constraints = print_schedule_constraints

    def print_schedule(self, schedule):
        'print_schedule(self, schedule)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param schedule: :class:`Schedule`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(schedule, Schedule):
            raise IslTypeError("schedule is not a Schedule")
        if _ctx_data != schedule._ctx_data:
            raise Error("mismatched context in schedule")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_schedule(self.data, schedule.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_schedule = print_schedule

    def print_schedule_node(self, node):
        'print_schedule_node(self, node)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param node: :class:`ScheduleNode`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(node, ScheduleNode):
            raise IslTypeError("node is not a ScheduleNode")
        if _ctx_data != node._ctx_data:
            raise Error("mismatched context in node")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_schedule_node(self.data, node.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_schedule_node = print_schedule_node

    def print_union_access_info(self, access):
        'print_union_access_info(self, access)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param access: :class:`UnionAccessInfo`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(access, UnionAccessInfo):
            raise IslTypeError("access is not a UnionAccessInfo")
        if _ctx_data != access._ctx_data:
            raise Error("mismatched context in access")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_union_access_info(self.data, access.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_union_access_info = print_union_access_info

    def print_union_flow(self, flow):
        'print_union_flow(self, flow)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param flow: :class:`UnionFlow`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(flow, UnionFlow):
            raise IslTypeError("flow is not a UnionFlow")
        if _ctx_data != flow._ctx_data:
            raise Error("mismatched context in flow")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_union_flow(self.data, flow.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_union_flow = print_union_flow

    def print_ast_expr(self, expr):
        'print_ast_expr(self, expr)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param expr: :class:`AstExpr`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(expr, AstExpr):
            raise IslTypeError("expr is not a AstExpr")
        if _ctx_data != expr._ctx_data:
            raise Error("mismatched context in expr")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_ast_expr(self.data, expr.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_ast_expr = print_ast_expr

    def print_ast_node(self, node):
        'print_ast_node(self, node)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param node: :class:`AstNode`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(node, AstNode):
            raise IslTypeError("node is not a AstNode")
        if _ctx_data != node._ctx_data:
            raise Error("mismatched context in node")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_ast_node(self.data, node.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_ast_node = print_ast_node

    def print_id_list(self, list):
        'print_id_list(self, list)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param list: :class:`IdList`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(list, IdList):
            raise IslTypeError("list is not a IdList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_id_list(self.data, list.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_id_list = print_id_list

    def print_val_list(self, list):
        'print_val_list(self, list)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param list: :class:`ValList`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(list, ValList):
            raise IslTypeError("list is not a ValList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_val_list(self.data, list.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_val_list = print_val_list

    def print_aff_list(self, list):
        'print_aff_list(self, list)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param list: :class:`AffList`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(list, AffList):
            raise IslTypeError("list is not a AffList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_aff_list(self.data, list.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_aff_list = print_aff_list

    def print_pw_aff_list(self, list):
        'print_pw_aff_list(self, list)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param list: :class:`PwAffList`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(list, PwAffList):
            raise IslTypeError("list is not a PwAffList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_pw_aff_list(self.data, list.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_pw_aff_list = print_pw_aff_list

    def print_constraint_list(self, list):
        'print_constraint_list(self, list)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param list: :class:`ConstraintList`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(list, ConstraintList):
            raise IslTypeError("list is not a ConstraintList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_constraint_list(self.data, list.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_constraint_list = print_constraint_list

    def print_basic_set_list(self, list):
        'print_basic_set_list(self, list)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param list: :class:`BasicSetList`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(list, BasicSetList):
            raise IslTypeError("list is not a BasicSetList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_basic_set_list(self.data, list.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_basic_set_list = print_basic_set_list

    def print_basic_map_list(self, list):
        'print_basic_map_list(self, list)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param list: :class:`BasicMapList`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(list, BasicMapList):
            raise IslTypeError("list is not a BasicMapList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_basic_map_list(self.data, list.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_basic_map_list = print_basic_map_list

    def print_set_list(self, list):
        'print_set_list(self, list)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param list: :class:`SetList`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(list, SetList):
            raise IslTypeError("list is not a SetList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_set_list(self.data, list.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_set_list = print_set_list

    def print_map_list(self, list):
        'print_map_list(self, list)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param list: :class:`MapList`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(list, MapList):
            raise IslTypeError("list is not a MapList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_map_list(self.data, list.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_map_list = print_map_list

    def print_union_set_list(self, list):
        'print_union_set_list(self, list)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param list: :class:`UnionSetList`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(list, UnionSetList):
            raise IslTypeError("list is not a UnionSetList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_union_set_list(self.data, list.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_union_set_list = print_union_set_list

    def print_ast_expr_list(self, list):
        'print_ast_expr_list(self, list)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param list: :class:`AstExprList`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(list, AstExprList):
            raise IslTypeError("list is not a AstExprList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_ast_expr_list(self.data, list.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_ast_expr_list = print_ast_expr_list

    def print_ast_node_list(self, list):
        'print_ast_node_list(self, list)\n\n:param self: :class:`Printer` (:ref:`becomes invalid <auto-invalidation>`)\n:param list: :class:`AstNodeList`\n:return: :class:`Printer` (self)'

        if not isinstance(self, Printer):
            raise IslTypeError("self is not a Printer")
        _ctx_data = self._ctx_data
        
        if not isinstance(list, AstNodeList):
            raise IslTypeError("list is not a AstNodeList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_printer_print_ast_node_list(self.data, list.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            self._reset(_result)
            pass
        
        return self

    Printer.print_ast_node_list = print_ast_node_list

    # }}}

    # {{{ val

    def zero(ctx):
        'zero(ctx)\n\n:param ctx: :class:`Context`\n:return: :class:`Val`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_zero(ctx.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_zero failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.zero = staticmethod(zero)

    Val._zero_is_static = True

    def one(ctx):
        'one(ctx)\n\n:param ctx: :class:`Context`\n:return: :class:`Val`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_one(ctx.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_one failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.one = staticmethod(one)

    Val._one_is_static = True

    def negone(ctx):
        'negone(ctx)\n\n:param ctx: :class:`Context`\n:return: :class:`Val`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_negone(ctx.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_negone failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.negone = staticmethod(negone)

    Val._negone_is_static = True

    def nan(ctx):
        'nan(ctx)\n\n:param ctx: :class:`Context`\n:return: :class:`Val`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_nan(ctx.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_nan failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.nan = staticmethod(nan)

    Val._nan_is_static = True

    def infty(ctx):
        'infty(ctx)\n\n:param ctx: :class:`Context`\n:return: :class:`Val`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_infty(ctx.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_infty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.infty = staticmethod(infty)

    Val._infty_is_static = True

    def neginfty(ctx):
        'neginfty(ctx)\n\n:param ctx: :class:`Context`\n:return: :class:`Val`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_neginfty(ctx.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_neginfty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.neginfty = staticmethod(neginfty)

    Val._neginfty_is_static = True

    def int_from_si(ctx, i):
        'int_from_si(ctx, i)\n\n:param ctx: :class:`Context`\n:param i: :class:`long`\n:return: :class:`Val`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for i
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_int_from_si(ctx.data, i)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_int_from_si failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.int_from_si = staticmethod(int_from_si)

    Val._int_from_si_is_static = True

    def int_from_ui(ctx, u):
        'int_from_ui(ctx, u)\n\n:param ctx: :class:`Context`\n:param u: :class:`long`\n:return: :class:`Val`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for u
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_int_from_ui(ctx.data, u)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_int_from_ui failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.int_from_ui = staticmethod(int_from_ui)

    Val._int_from_ui_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.copy = copy

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Val`\n:return: :class:`Context`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.get_ctx = get_ctx

    def get_hash(self):
        'get_hash(self)\n\n:param self: :class:`Val`\n:return: uint32_t'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_get_hash(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Val.get_hash = get_hash

    def get_num_si(self):
        'get_num_si(self)\n\n:param self: :class:`Val`\n:return: long'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_get_num_si(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Val.get_num_si = get_num_si

    def get_den_val(self):
        'get_den_val(self)\n\n:param self: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_get_den_val(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_get_den_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.get_den_val = get_den_val

    def get_d(self):
        'get_d(self)\n\n:param self: :class:`Val`\n:return: double'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_get_d(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Val.get_d = get_d

    def n_abs_num_chunks(self, size):
        'n_abs_num_chunks(self, size)\n\n:param self: :class:`Val`\n:param size: :class:`size_t`\n:return: isl_size'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        
        # no argument processing for size
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_n_abs_num_chunks(self.data, size)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Val.n_abs_num_chunks = n_abs_num_chunks

    def set_si(self, i):
        'set_si(self, i)\n\n:param self: :class:`Val`\n:param i: :class:`long`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for i
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_set_si(_copy_self._release(), i)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_set_si failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.set_si = set_si

    def abs(self):
        'abs(self)\n\n:param self: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_abs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_abs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.abs = abs

    def neg(self):
        'neg(self)\n\n:param self: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.neg = neg

    def inv(self):
        'inv(self)\n\n:param self: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_inv(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_inv failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.inv = inv

    def floor(self):
        'floor(self)\n\n:param self: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_floor(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_floor failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.floor = floor

    def ceil(self):
        'ceil(self)\n\n:param self: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_ceil(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_ceil failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.ceil = ceil

    def trunc(self):
        'trunc(self)\n\n:param self: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_trunc(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_trunc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.trunc = trunc

    def two_exp(self):
        'two_exp(self)\n\n:param self: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_2exp(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_2exp failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.two_exp = two_exp

    def pow2(self):
        'pow2(self)\n\n:param self: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_pow2(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_pow2 failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.pow2 = pow2

    def min(self, v2):
        'min(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_min(_copy_self._release(), _val_v2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_min failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.min = min

    def max(self, v2):
        'max(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_max(_copy_self._release(), _val_v2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_max failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.max = max

    def add(self, v2):
        'add(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_add(_copy_self._release(), _val_v2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.add = add

    def sub(self, v2):
        'sub(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_sub(_copy_self._release(), _val_v2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.sub = sub

    def mul(self, v2):
        'mul(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_mul(_copy_self._release(), _val_v2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_mul failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.mul = mul

    def div(self, v2):
        'div(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_div(_copy_self._release(), _val_v2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_div failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.div = div

    def mod(self, v2):
        'mod(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_mod(_copy_self._release(), _val_v2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_mod failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.mod = mod

    def gcd(self, v2):
        'gcd(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: :class:`Val`'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_gcd(_copy_self._release(), _val_v2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_gcd failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.gcd = gcd

    def gcdext(self, v2):
        'gcdext(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: (:class:`Val`, x (:class:`Val`), y (:class:`Val`))'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        
        _retptr_x = ffi.new("isl_val **")
        
        _retptr_y = ffi.new("isl_val **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_gcdext(_copy_self._release(), _val_v2._release(), _retptr_x, _retptr_y)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_x == ffi.NULL:
                _ret_x = None
            else:
                _ret_x = Val(_data=_retptr_x[0])
            if _retptr_y == ffi.NULL:
                _ret_y = None
            else:
                _ret_y = Val(_data=_retptr_y[0])
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_gcdext failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_x, _ret_y

    Val.gcdext = gcdext

    def sgn(self):
        'sgn(self)\n\n:param self: :class:`Val`\n:return: int'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_sgn(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Val.sgn = sgn

    def is_zero(self):
        'is_zero(self)\n\n:param self: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_is_zero(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_is_zero\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.is_zero = is_zero

    def is_one(self):
        'is_one(self)\n\n:param self: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_is_one(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_is_one\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.is_one = is_one

    def is_negone(self):
        'is_negone(self)\n\n:param self: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_is_negone(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_is_negone\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.is_negone = is_negone

    def is_nonneg(self):
        'is_nonneg(self)\n\n:param self: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_is_nonneg(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_is_nonneg\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.is_nonneg = is_nonneg

    def is_nonpos(self):
        'is_nonpos(self)\n\n:param self: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_is_nonpos(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_is_nonpos\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.is_nonpos = is_nonpos

    def is_pos(self):
        'is_pos(self)\n\n:param self: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_is_pos(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_is_pos\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.is_pos = is_pos

    def is_neg(self):
        'is_neg(self)\n\n:param self: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_is_neg(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_is_neg\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.is_neg = is_neg

    def is_int(self):
        'is_int(self)\n\n:param self: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_is_int(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_is_int\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.is_int = is_int

    def is_rat(self):
        'is_rat(self)\n\n:param self: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_is_rat(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_is_rat\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.is_rat = is_rat

    def is_nan(self):
        'is_nan(self)\n\n:param self: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_is_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_is_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.is_nan = is_nan

    def is_infty(self):
        'is_infty(self)\n\n:param self: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_is_infty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_is_infty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.is_infty = is_infty

    def is_neginfty(self):
        'is_neginfty(self)\n\n:param self: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_is_neginfty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_is_neginfty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.is_neginfty = is_neginfty

    def cmp_si(self, i):
        'cmp_si(self, i)\n\n:param self: :class:`Val`\n:param i: :class:`long`\n:return: int'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        
        # no argument processing for i
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_cmp_si(self.data, i)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Val.cmp_si = cmp_si

    def lt(self, v2):
        'lt(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_lt(self.data, _val_v2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_lt\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.lt = lt

    def le(self, v2):
        'le(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_le(self.data, _val_v2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_le\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.le = le

    def gt(self, v2):
        'gt(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_gt(self.data, _val_v2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_gt\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.gt = gt

    def ge(self, v2):
        'ge(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_ge(self.data, _val_v2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_ge\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.ge = ge

    def eq(self, v2):
        'eq(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_eq(self.data, _val_v2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_eq\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.eq = eq

    def ne(self, v2):
        'ne(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_ne(self.data, _val_v2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_ne\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.ne = ne

    def abs_eq(self, v2):
        'abs_eq(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_abs_eq(self.data, _val_v2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_abs_eq\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.abs_eq = abs_eq

    def is_divisible_by(self, v2):
        'is_divisible_by(self, v2)\n\n:param self: :class:`Val`\n:param v2: :class:`Val`\n:return: bool'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        
        if isinstance(v2, Val):
            if _ctx_data != v2._ctx_data:
                raise Error("mismatched context in v2")
            _val_v2 = v2._copy()
        elif isinstance(v2, six.integer_types):
            _cdata_v2 = lib.isl_val_int_from_si(
                self._get_ctx_data(), v2)
        
            if _cdata_v2 == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v2 = Val(_data=_cdata_v2)
        
        else:
            raise IslTypeError("v2 is a %s and cannot "
                "be cast to a Val" % type(v2))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_is_divisible_by(self.data, _val_v2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_val_is_divisible_by\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Val.is_divisible_by = is_divisible_by

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`Val`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_val_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Val.read_from_str = staticmethod(read_from_str)

    Val._read_from_str_is_static = True

    def dump(self):
        'dump(self)\n\n:param self: :class:`Val`\n:return: (nothing)'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_dump(self.data)
        finally:
            pass
        

    Val.dump = dump

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`Val`\n:return: string'

        if not isinstance(self, Val):
            raise IslTypeError("self is not a Val")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_val_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Val.to_str = to_str

    # }}}

    # {{{ multi_val

    def add_val(self, v):
        'add_val(self, v)\n\n:param self: :class:`MultiVal`\n:param v: :class:`Val`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_add_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_add_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.add_val = add_val

    def mod_val(self, v):
        'mod_val(self, v)\n\n:param self: :class:`MultiVal`\n:param v: :class:`Val`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_mod_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_mod_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.mod_val = mod_val

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`MultiVal`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.read_from_str = staticmethod(read_from_str)

    MultiVal._read_from_str_is_static = True

    def dump(self):
        'dump(self)\n\n:param self: :class:`MultiVal`\n:return: (nothing)'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_dump(self.data)
        finally:
            pass
        

    MultiVal.dump = dump

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`MultiVal`\n:return: string'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    MultiVal.to_str = to_str

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`MultiVal`\n:param type: :class:`dim_type`\n:return: unsigned'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiVal.dim = dim

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`MultiVal`\n:return: :class:`Context`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.get_ctx = get_ctx

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`MultiVal`\n:return: :class:`Space`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.get_space = get_space

    def get_domain_space(self):
        'get_domain_space(self)\n\n:param self: :class:`MultiVal`\n:return: :class:`Space`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_get_domain_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_get_domain_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.get_domain_space = get_domain_space

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`MultiVal`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiVal.find_dim_by_name = find_dim_by_name

    def from_val_list(space, list):
        'from_val_list(space, list)\n\n:param space: :class:`Space`\n:param list: :class:`ValList`\n:return: :class:`MultiVal`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        
        if not isinstance(list, ValList):
            raise IslTypeError("list is not a ValList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        _copy_list = list._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_from_val_list(_copy_space._release(), _copy_list._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_from_val_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.from_val_list = staticmethod(from_val_list)

    MultiVal._from_val_list_is_static = True

    def zero(space):
        'zero(space)\n\n:param space: :class:`Space`\n:return: :class:`MultiVal`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_zero(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_zero failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.zero = staticmethod(zero)

    MultiVal._zero_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.copy = copy

    def plain_is_equal(self, multi2):
        'plain_is_equal(self, multi2)\n\n:param self: :class:`MultiVal`\n:param multi2: :class:`MultiVal`\n:return: bool'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        
        if not isinstance(multi2, MultiVal):
            raise IslTypeError("multi2 is not a MultiVal")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_plain_is_equal(self.data, multi2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_val_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiVal.plain_is_equal = plain_is_equal

    def involves_nan(self):
        'involves_nan(self)\n\n:param self: :class:`MultiVal`\n:return: bool'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_involves_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_val_involves_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiVal.involves_nan = involves_nan

    def find_dim_by_id(self, type, id):
        'find_dim_by_id(self, type, id)\n\n:param self: :class:`MultiVal`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: int'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_find_dim_by_id(self.data, type, id.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiVal.find_dim_by_id = find_dim_by_id

    def get_dim_id(self, type, pos):
        'get_dim_id(self, type, pos)\n\n:param self: :class:`MultiVal`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Id`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_get_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_get_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.get_dim_id = get_dim_id

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`MultiVal`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.set_dim_name = set_dim_name

    def set_dim_id(self, type, pos, id):
        'set_dim_id(self, type, pos, id)\n\n:param self: :class:`MultiVal`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param id: :class:`Id`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_set_dim_id(_copy_self._release(), type, pos, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_set_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.set_dim_id = set_dim_id

    def get_tuple_name(self, type):
        'get_tuple_name(self, type)\n\n:param self: :class:`MultiVal`\n:param type: :class:`dim_type`\n:return: string'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_get_tuple_name(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    MultiVal.get_tuple_name = get_tuple_name

    def has_tuple_id(self, type):
        'has_tuple_id(self, type)\n\n:param self: :class:`MultiVal`\n:param type: :class:`dim_type`\n:return: bool'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_has_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_val_has_tuple_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiVal.has_tuple_id = has_tuple_id

    def get_tuple_id(self, type):
        'get_tuple_id(self, type)\n\n:param self: :class:`MultiVal`\n:param type: :class:`dim_type`\n:return: :class:`Id`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_get_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_get_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.get_tuple_id = get_tuple_id

    def set_tuple_name(self, type, s):
        'set_tuple_name(self, type, s)\n\n:param self: :class:`MultiVal`\n:param type: :class:`dim_type`\n:param s: string\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_set_tuple_name(_copy_self._release(), type, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_set_tuple_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.set_tuple_name = set_tuple_name

    def set_tuple_id(self, type, id):
        'set_tuple_id(self, type, id)\n\n:param self: :class:`MultiVal`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_set_tuple_id(_copy_self._release(), type, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_set_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.set_tuple_id = set_tuple_id

    def reset_tuple_id(self, type):
        'reset_tuple_id(self, type)\n\n:param self: :class:`MultiVal`\n:param type: :class:`dim_type`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_reset_tuple_id(_copy_self._release(), type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_reset_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.reset_tuple_id = reset_tuple_id

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.reset_user = reset_user

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`MultiVal`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.drop_dims = drop_dims

    def get_val(self, pos):
        'get_val(self, pos)\n\n:param self: :class:`MultiVal`\n:param pos: :class:`int`\n:return: :class:`Val`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_get_val(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_get_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.get_val = get_val

    def set_val(self, pos, el):
        'set_val(self, pos, el)\n\n:param self: :class:`MultiVal`\n:param pos: :class:`int`\n:param el: :class:`Val`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if isinstance(el, Val):
            if _ctx_data != el._ctx_data:
                raise Error("mismatched context in el")
            _val_el = el._copy()
        elif isinstance(el, six.integer_types):
            _cdata_el = lib.isl_val_int_from_si(
                self._get_ctx_data(), el)
        
            if _cdata_el == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_el = Val(_data=_cdata_el)
        
        else:
            raise IslTypeError("el is a %s and cannot "
                "be cast to a Val" % type(el))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_set_val(_copy_self._release(), pos, _val_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_set_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.set_val = set_val

    def range_splice(self, pos, multi2):
        'range_splice(self, pos, multi2)\n\n:param self: :class:`MultiVal`\n:param pos: :class:`unsigned`\n:param multi2: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(multi2, MultiVal):
            raise IslTypeError("multi2 is not a MultiVal")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_range_splice(_copy_self._release(), pos, _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_range_splice failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.range_splice = range_splice

    def flatten_range(self):
        'flatten_range(self)\n\n:param self: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_flatten_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_flatten_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.flatten_range = flatten_range

    def flat_range_product(self, multi2):
        'flat_range_product(self, multi2)\n\n:param self: :class:`MultiVal`\n:param multi2: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiVal):
            raise IslTypeError("multi2 is not a MultiVal")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_flat_range_product(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_flat_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.flat_range_product = flat_range_product

    def range_product(self, multi2):
        'range_product(self, multi2)\n\n:param self: :class:`MultiVal`\n:param multi2: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiVal):
            raise IslTypeError("multi2 is not a MultiVal")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_range_product(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.range_product = range_product

    def factor_range(self):
        'factor_range(self)\n\n:param self: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.factor_range = factor_range

    def range_is_wrapping(self):
        'range_is_wrapping(self)\n\n:param self: :class:`MultiVal`\n:return: bool'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_range_is_wrapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_val_range_is_wrapping\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiVal.range_is_wrapping = range_is_wrapping

    def range_factor_domain(self):
        'range_factor_domain(self)\n\n:param self: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_range_factor_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_range_factor_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.range_factor_domain = range_factor_domain

    def range_factor_range(self):
        'range_factor_range(self)\n\n:param self: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_range_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_range_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.range_factor_range = range_factor_range

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`MultiVal`\n:param v: :class:`Val`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.scale_val = scale_val

    def scale_down_val(self, v):
        'scale_down_val(self, v)\n\n:param self: :class:`MultiVal`\n:param v: :class:`Val`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_scale_down_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.scale_down_val = scale_down_val

    def scale_multi_val(self, mv):
        'scale_multi_val(self, mv)\n\n:param self: :class:`MultiVal`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_scale_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_scale_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.scale_multi_val = scale_multi_val

    def scale_down_multi_val(self, mv):
        'scale_down_multi_val(self, mv)\n\n:param self: :class:`MultiVal`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_scale_down_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_scale_down_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.scale_down_multi_val = scale_down_multi_val

    def mod_multi_val(self, mv):
        'mod_multi_val(self, mv)\n\n:param self: :class:`MultiVal`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_mod_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_mod_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.mod_multi_val = mod_multi_val

    def add(self, multi2):
        'add(self, multi2)\n\n:param self: :class:`MultiVal`\n:param multi2: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiVal):
            raise IslTypeError("multi2 is not a MultiVal")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_add(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.add = add

    def sub(self, multi2):
        'sub(self, multi2)\n\n:param self: :class:`MultiVal`\n:param multi2: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiVal):
            raise IslTypeError("multi2 is not a MultiVal")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_sub(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.sub = sub

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`MultiVal`\n:param model: :class:`Space`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.align_params = align_params

    def from_range(self):
        'from_range(self)\n\n:param self: :class:`MultiVal`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiVal):
            raise IslTypeError("self is not a MultiVal")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_val_from_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_val_from_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiVal.from_range = from_range

    # }}}

    # {{{ vec

    def alloc(ctx, size):
        'alloc(ctx, size)\n\n:param ctx: :class:`Context`\n:param size: :class:`unsigned`\n:return: :class:`Vec`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for size
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_alloc(ctx.data, size)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.alloc = staticmethod(alloc)

    Vec._alloc_is_static = True

    def zero(ctx, size):
        'zero(ctx, size)\n\n:param ctx: :class:`Context`\n:param size: :class:`unsigned`\n:return: :class:`Vec`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for size
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_zero(ctx.data, size)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_zero failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.zero = staticmethod(zero)

    Vec._zero_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`Vec`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.copy = copy

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Vec`\n:return: :class:`Context`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.get_ctx = get_ctx

    def size(self):
        'size(self)\n\n:param self: :class:`Vec`\n:return: isl_size'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_size(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Vec.__len__ = size

    def get_element_val(self, pos):
        'get_element_val(self, pos)\n\n:param self: :class:`Vec`\n:param pos: :class:`int`\n:return: :class:`Val`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_get_element_val(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_get_element_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.get_element_val = get_element_val

    def set_element_val(self, pos, v):
        'set_element_val(self, pos, v)\n\n:param self: :class:`Vec`\n:param pos: :class:`int`\n:param v: :class:`Val`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_set_element_val(_copy_self._release(), pos, _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_set_element_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.set_element_val = set_element_val

    def is_equal(self, vec2):
        'is_equal(self, vec2)\n\n:param self: :class:`Vec`\n:param vec2: :class:`Vec`\n:return: bool'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        
        if not isinstance(vec2, Vec):
            raise IslTypeError("vec2 is not a Vec")
        if _ctx_data != vec2._ctx_data:
            raise Error("mismatched context in vec2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_is_equal(self.data, vec2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_vec_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Vec.is_equal = is_equal

    def cmp_element(self, vec2, pos):
        'cmp_element(self, vec2, pos)\n\n:param self: :class:`Vec`\n:param vec2: :class:`Vec`\n:param pos: :class:`int`\n:return: int'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        
        if not isinstance(vec2, Vec):
            raise IslTypeError("vec2 is not a Vec")
        if _ctx_data != vec2._ctx_data:
            raise Error("mismatched context in vec2")
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_cmp_element(self.data, vec2.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Vec.cmp_element = cmp_element

    def dump(self):
        'dump(self)\n\n:param self: :class:`Vec`\n:return: (nothing)'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_dump(self.data)
        finally:
            pass
        

    Vec.dump = dump

    def ceil(self):
        'ceil(self)\n\n:param self: :class:`Vec`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_ceil(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_ceil failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.ceil = ceil

    def set_val(self, v):
        'set_val(self, v)\n\n:param self: :class:`Vec`\n:param v: :class:`Val`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_set_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_set_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.set_val = set_val

    def clr(self):
        'clr(self)\n\n:param self: :class:`Vec`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_clr(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_clr failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.clr = clr

    def neg(self):
        'neg(self)\n\n:param self: :class:`Vec`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.neg = neg

    def add(self, vec2):
        'add(self, vec2)\n\n:param self: :class:`Vec`\n:param vec2: :class:`Vec`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(vec2, Vec):
            raise IslTypeError("vec2 is not a Vec")
        if _ctx_data != vec2._ctx_data:
            raise Error("mismatched context in vec2")
        _copy_vec2 = vec2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_add(_copy_self._release(), _copy_vec2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.add = add

    def extend(self, size):
        'extend(self, size)\n\n:param self: :class:`Vec`\n:param size: :class:`unsigned`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for size
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_extend(_copy_self._release(), size)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_extend failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.extend = extend

    def zero_extend(self, size):
        'zero_extend(self, size)\n\n:param self: :class:`Vec`\n:param size: :class:`unsigned`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for size
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_zero_extend(_copy_self._release(), size)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_zero_extend failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.zero_extend = zero_extend

    def concat(self, vec2):
        'concat(self, vec2)\n\n:param self: :class:`Vec`\n:param vec2: :class:`Vec`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(vec2, Vec):
            raise IslTypeError("vec2 is not a Vec")
        if _ctx_data != vec2._ctx_data:
            raise Error("mismatched context in vec2")
        _copy_vec2 = vec2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_concat(_copy_self._release(), _copy_vec2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.concat = concat

    def sort(self):
        'sort(self)\n\n:param self: :class:`Vec`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_sort(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_sort failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.sort = sort

    def drop_els(self, pos, n):
        'drop_els(self, pos, n)\n\n:param self: :class:`Vec`\n:param pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_drop_els(_copy_self._release(), pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_drop_els failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.drop_els = drop_els

    def add_els(self, n):
        'add_els(self, n)\n\n:param self: :class:`Vec`\n:param n: :class:`unsigned`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_add_els(_copy_self._release(), n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_add_els failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.add_els = add_els

    def insert_els(self, pos, n):
        'insert_els(self, pos, n)\n\n:param self: :class:`Vec`\n:param pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_insert_els(_copy_self._release(), pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_insert_els failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.insert_els = insert_els

    def insert_zero_els(self, pos, n):
        'insert_zero_els(self, pos, n)\n\n:param self: :class:`Vec`\n:param pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_insert_zero_els(_copy_self._release(), pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_insert_zero_els failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.insert_zero_els = insert_zero_els

    def move_els(self, dst_col, src_col, n):
        'move_els(self, dst_col, src_col, n)\n\n:param self: :class:`Vec`\n:param dst_col: :class:`unsigned`\n:param src_col: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_col
        
        # no argument processing for src_col
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_move_els(_copy_self._release(), dst_col, src_col, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_move_els failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.move_els = move_els

    def mat_product(self, mat):
        'mat_product(self, mat)\n\n:param self: :class:`Vec`\n:param mat: :class:`Mat`\n:return: :class:`Vec`'

        if not isinstance(self, Vec):
            raise IslTypeError("self is not a Vec")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mat, Mat):
            raise IslTypeError("mat is not a Mat")
        if _ctx_data != mat._ctx_data:
            raise Error("mismatched context in mat")
        _copy_mat = mat._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vec_mat_product(_copy_self._release(), _copy_mat._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vec_mat_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vec.mat_product = mat_product

    # }}}

    # {{{ mat

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Mat`\n:return: :class:`Context`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.get_ctx = get_ctx

    def alloc(ctx, n_row, n_col):
        'alloc(ctx, n_row, n_col)\n\n:param ctx: :class:`Context`\n:param n_row: :class:`unsigned`\n:param n_col: :class:`unsigned`\n:return: :class:`Mat`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for n_row
        
        # no argument processing for n_col
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_alloc(ctx.data, n_row, n_col)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.alloc = staticmethod(alloc)

    Mat._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`Mat`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.copy = copy

    def rows(self):
        'rows(self)\n\n:param self: :class:`Mat`\n:return: isl_size'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_rows(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Mat.rows = rows

    def cols(self):
        'cols(self)\n\n:param self: :class:`Mat`\n:return: isl_size'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_cols(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Mat.cols = cols

    def get_element_val(self, row, col):
        'get_element_val(self, row, col)\n\n:param self: :class:`Mat`\n:param row: :class:`int`\n:param col: :class:`int`\n:return: :class:`Val`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        
        # no argument processing for row
        
        # no argument processing for col
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_get_element_val(self.data, row, col)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_get_element_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.get_element_val = get_element_val

    def set_element_val(self, row, col, v):
        'set_element_val(self, row, col, v)\n\n:param self: :class:`Mat`\n:param row: :class:`int`\n:param col: :class:`int`\n:param v: :class:`Val`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for row
        
        # no argument processing for col
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_set_element_val(_copy_self._release(), row, col, _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_set_element_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.set_element_val = set_element_val

    def swap_cols(self, i, j):
        'swap_cols(self, i, j)\n\n:param self: :class:`Mat`\n:param i: :class:`unsigned`\n:param j: :class:`unsigned`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for i
        
        # no argument processing for j
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_swap_cols(_copy_self._release(), i, j)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_swap_cols failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.swap_cols = swap_cols

    def swap_rows(self, i, j):
        'swap_rows(self, i, j)\n\n:param self: :class:`Mat`\n:param i: :class:`unsigned`\n:param j: :class:`unsigned`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for i
        
        # no argument processing for j
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_swap_rows(_copy_self._release(), i, j)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_swap_rows failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.swap_rows = swap_rows

    def vec_product(self, vec):
        'vec_product(self, vec)\n\n:param self: :class:`Mat`\n:param vec: :class:`Vec`\n:return: :class:`Vec`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(vec, Vec):
            raise IslTypeError("vec is not a Vec")
        if _ctx_data != vec._ctx_data:
            raise Error("mismatched context in vec")
        _copy_vec = vec._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_vec_product(_copy_self._release(), _copy_vec._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_vec_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.vec_product = vec_product

    def vec_inverse_product(self, vec):
        'vec_inverse_product(self, vec)\n\n:param self: :class:`Mat`\n:param vec: :class:`Vec`\n:return: :class:`Vec`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(vec, Vec):
            raise IslTypeError("vec is not a Vec")
        if _ctx_data != vec._ctx_data:
            raise Error("mismatched context in vec")
        _copy_vec = vec._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_vec_inverse_product(_copy_self._release(), _copy_vec._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vec(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_vec_inverse_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.vec_inverse_product = vec_inverse_product

    def aff_direct_sum(self, right):
        'aff_direct_sum(self, right)\n\n:param self: :class:`Mat`\n:param right: :class:`Mat`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(right, Mat):
            raise IslTypeError("right is not a Mat")
        if _ctx_data != right._ctx_data:
            raise Error("mismatched context in right")
        _copy_right = right._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_aff_direct_sum(_copy_self._release(), _copy_right._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_aff_direct_sum failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.aff_direct_sum = aff_direct_sum

    def diagonal(self, mat2):
        'diagonal(self, mat2)\n\n:param self: :class:`Mat`\n:param mat2: :class:`Mat`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mat2, Mat):
            raise IslTypeError("mat2 is not a Mat")
        if _ctx_data != mat2._ctx_data:
            raise Error("mismatched context in mat2")
        _copy_mat2 = mat2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_diagonal(_copy_self._release(), _copy_mat2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_diagonal failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.diagonal = diagonal

    def left_hermite(self, neg):
        'left_hermite(self, neg)\n\n:param self: :class:`Mat`\n:param neg: :class:`int`\n:return: (:class:`Mat`, U (:class:`Mat`), Q (:class:`Mat`))'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for neg
        
        _retptr_U = ffi.new("isl_mat **")
        
        _retptr_Q = ffi.new("isl_mat **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_left_hermite(_copy_self._release(), neg, _retptr_U, _retptr_Q)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_U == ffi.NULL:
                _ret_U = None
            else:
                _ret_U = Mat(_data=_retptr_U[0])
            if _retptr_Q == ffi.NULL:
                _ret_Q = None
            else:
                _ret_Q = Mat(_data=_retptr_Q[0])
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_left_hermite failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_U, _ret_Q

    Mat.left_hermite = left_hermite

    def lin_to_aff(self):
        'lin_to_aff(self)\n\n:param self: :class:`Mat`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_lin_to_aff(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_lin_to_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.lin_to_aff = lin_to_aff

    def inverse_product(self, right):
        'inverse_product(self, right)\n\n:param self: :class:`Mat`\n:param right: :class:`Mat`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(right, Mat):
            raise IslTypeError("right is not a Mat")
        if _ctx_data != right._ctx_data:
            raise Error("mismatched context in right")
        _copy_right = right._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_inverse_product(_copy_self._release(), _copy_right._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_inverse_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.inverse_product = inverse_product

    def product(self, right):
        'product(self, right)\n\n:param self: :class:`Mat`\n:param right: :class:`Mat`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(right, Mat):
            raise IslTypeError("right is not a Mat")
        if _ctx_data != right._ctx_data:
            raise Error("mismatched context in right")
        _copy_right = right._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_product(_copy_self._release(), _copy_right._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.product = product

    def transpose(self):
        'transpose(self)\n\n:param self: :class:`Mat`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_transpose(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_transpose failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.transpose = transpose

    def right_inverse(self):
        'right_inverse(self)\n\n:param self: :class:`Mat`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_right_inverse(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_right_inverse failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.right_inverse = right_inverse

    def right_kernel(self):
        'right_kernel(self)\n\n:param self: :class:`Mat`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_right_kernel(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_right_kernel failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.right_kernel = right_kernel

    def normalize(self):
        'normalize(self)\n\n:param self: :class:`Mat`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_normalize(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_normalize failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.normalize = normalize

    def normalize_row(self, row):
        'normalize_row(self, row)\n\n:param self: :class:`Mat`\n:param row: :class:`int`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for row
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_normalize_row(_copy_self._release(), row)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_normalize_row failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.normalize_row = normalize_row

    def drop_cols(self, col, n):
        'drop_cols(self, col, n)\n\n:param self: :class:`Mat`\n:param col: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for col
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_drop_cols(_copy_self._release(), col, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_drop_cols failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.drop_cols = drop_cols

    def drop_rows(self, row, n):
        'drop_rows(self, row, n)\n\n:param self: :class:`Mat`\n:param row: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for row
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_drop_rows(_copy_self._release(), row, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_drop_rows failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.drop_rows = drop_rows

    def insert_cols(self, col, n):
        'insert_cols(self, col, n)\n\n:param self: :class:`Mat`\n:param col: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for col
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_insert_cols(_copy_self._release(), col, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_insert_cols failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.insert_cols = insert_cols

    def insert_rows(self, row, n):
        'insert_rows(self, row, n)\n\n:param self: :class:`Mat`\n:param row: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for row
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_insert_rows(_copy_self._release(), row, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_insert_rows failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.insert_rows = insert_rows

    def move_cols(self, dst_col, src_col, n):
        'move_cols(self, dst_col, src_col, n)\n\n:param self: :class:`Mat`\n:param dst_col: :class:`unsigned`\n:param src_col: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_col
        
        # no argument processing for src_col
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_move_cols(_copy_self._release(), dst_col, src_col, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_move_cols failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.move_cols = move_cols

    def add_rows(self, n):
        'add_rows(self, n)\n\n:param self: :class:`Mat`\n:param n: :class:`unsigned`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_add_rows(_copy_self._release(), n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_add_rows failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.add_rows = add_rows

    def insert_zero_cols(self, first, n):
        'insert_zero_cols(self, first, n)\n\n:param self: :class:`Mat`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_insert_zero_cols(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_insert_zero_cols failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.insert_zero_cols = insert_zero_cols

    def add_zero_cols(self, n):
        'add_zero_cols(self, n)\n\n:param self: :class:`Mat`\n:param n: :class:`unsigned`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_add_zero_cols(_copy_self._release(), n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_add_zero_cols failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.add_zero_cols = add_zero_cols

    def insert_zero_rows(self, row, n):
        'insert_zero_rows(self, row, n)\n\n:param self: :class:`Mat`\n:param row: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for row
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_insert_zero_rows(_copy_self._release(), row, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_insert_zero_rows failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.insert_zero_rows = insert_zero_rows

    def add_zero_rows(self, n):
        'add_zero_rows(self, n)\n\n:param self: :class:`Mat`\n:param n: :class:`unsigned`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_add_zero_rows(_copy_self._release(), n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_add_zero_rows failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.add_zero_rows = add_zero_rows

    def col_add(self, dst_col, src_col):
        'col_add(self, dst_col, src_col)\n\n:param self: :class:`Mat`\n:param dst_col: :class:`int`\n:param src_col: :class:`int`\n:return: (nothing)'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        
        # no argument processing for dst_col
        
        # no argument processing for src_col
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_col_add(self.data, dst_col, src_col)
        finally:
            pass
        

    Mat.col_add = col_add

    def unimodular_complete(self, row):
        'unimodular_complete(self, row)\n\n:param self: :class:`Mat`\n:param row: :class:`int`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for row
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_unimodular_complete(_copy_self._release(), row)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_unimodular_complete failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.unimodular_complete = unimodular_complete

    def row_basis(self):
        'row_basis(self)\n\n:param self: :class:`Mat`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_row_basis(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_row_basis failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.row_basis = row_basis

    def row_basis_extension(self, mat2):
        'row_basis_extension(self, mat2)\n\n:param self: :class:`Mat`\n:param mat2: :class:`Mat`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mat2, Mat):
            raise IslTypeError("mat2 is not a Mat")
        if _ctx_data != mat2._ctx_data:
            raise Error("mismatched context in mat2")
        _copy_mat2 = mat2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_row_basis_extension(_copy_self._release(), _copy_mat2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_row_basis_extension failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.row_basis_extension = row_basis_extension

    def from_row_vec(vec):
        'from_row_vec(vec)\n\n:param vec: :class:`Vec`\n:return: :class:`Mat`'

        if not isinstance(vec, Vec):
            raise IslTypeError("vec is not a Vec")
        _ctx_data = vec._ctx_data
        _copy_vec = vec._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_from_row_vec(_copy_vec._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_from_row_vec failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.from_row_vec = staticmethod(from_row_vec)

    Mat._from_row_vec_is_static = True

    def concat(self, bot):
        'concat(self, bot)\n\n:param self: :class:`Mat`\n:param bot: :class:`Mat`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bot, Mat):
            raise IslTypeError("bot is not a Mat")
        if _ctx_data != bot._ctx_data:
            raise Error("mismatched context in bot")
        _copy_bot = bot._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_concat(_copy_self._release(), _copy_bot._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.concat = concat

    def vec_concat(self, bot):
        'vec_concat(self, bot)\n\n:param self: :class:`Mat`\n:param bot: :class:`Vec`\n:return: :class:`Mat`'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bot, Vec):
            raise IslTypeError("bot is not a Vec")
        if _ctx_data != bot._ctx_data:
            raise Error("mismatched context in bot")
        _copy_bot = bot._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_vec_concat(_copy_self._release(), _copy_bot._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_mat_vec_concat failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Mat.vec_concat = vec_concat

    def is_equal(self, mat2):
        'is_equal(self, mat2)\n\n:param self: :class:`Mat`\n:param mat2: :class:`Mat`\n:return: bool'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        
        if not isinstance(mat2, Mat):
            raise IslTypeError("mat2 is not a Mat")
        if _ctx_data != mat2._ctx_data:
            raise Error("mismatched context in mat2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_is_equal(self.data, mat2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_mat_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Mat.is_equal = is_equal

    def has_linearly_independent_rows(self, mat2):
        'has_linearly_independent_rows(self, mat2)\n\n:param self: :class:`Mat`\n:param mat2: :class:`Mat`\n:return: bool'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        
        if not isinstance(mat2, Mat):
            raise IslTypeError("mat2 is not a Mat")
        if _ctx_data != mat2._ctx_data:
            raise Error("mismatched context in mat2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_has_linearly_independent_rows(self.data, mat2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_mat_has_linearly_independent_rows\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Mat.has_linearly_independent_rows = has_linearly_independent_rows

    def rank(self):
        'rank(self)\n\n:param self: :class:`Mat`\n:return: isl_size'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_rank(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Mat.rank = rank

    def initial_non_zero_cols(self):
        'initial_non_zero_cols(self)\n\n:param self: :class:`Mat`\n:return: int'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_initial_non_zero_cols(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Mat.initial_non_zero_cols = initial_non_zero_cols

    def dump(self):
        'dump(self)\n\n:param self: :class:`Mat`\n:return: (nothing)'

        if not isinstance(self, Mat):
            raise IslTypeError("self is not a Mat")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_mat_dump(self.data)
        finally:
            pass
        

    Mat.dump = dump

    # }}}

    # {{{ fixed_box

    # }}}

    # {{{ aff

    def zero_on_domain(ls):
        'zero_on_domain(ls)\n\n:param ls: :class:`LocalSpace`\n:return: :class:`Aff`'

        if isinstance(ls, Space):
            ls = LocalSpace.from_space(ls)
        if not isinstance(ls, LocalSpace):
            raise IslTypeError("ls is not a LocalSpace")
        _ctx_data = ls._ctx_data
        _copy_ls = ls._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_zero_on_domain(_copy_ls._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_zero_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.zero_on_domain = staticmethod(zero_on_domain)

    Aff._zero_on_domain_is_static = True

    def val_on_domain(ls, val):
        'val_on_domain(ls, val)\n\n:param ls: :class:`LocalSpace`\n:param val: :class:`Val`\n:return: :class:`Aff`'

        if isinstance(ls, Space):
            ls = LocalSpace.from_space(ls)
        if not isinstance(ls, LocalSpace):
            raise IslTypeError("ls is not a LocalSpace")
        _ctx_data = ls._ctx_data
        _copy_ls = ls._copy()
        
        if isinstance(val, Val):
            if _ctx_data != val._ctx_data:
                raise Error("mismatched context in val")
            _val_val = val._copy()
        elif isinstance(val, six.integer_types):
            _cdata_val = lib.isl_val_int_from_si(
                ls._get_ctx_data(), val)
        
            if _cdata_val == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_val = Val(_data=_cdata_val)
        
        else:
            raise IslTypeError("val is a %s and cannot "
                "be cast to a Val" % type(val))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_val_on_domain(_copy_ls._release(), _val_val._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_val_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.val_on_domain = staticmethod(val_on_domain)

    Aff._val_on_domain_is_static = True

    def var_on_domain(ls, type, pos):
        'var_on_domain(ls, type, pos)\n\n:param ls: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Aff`'

        if isinstance(ls, Space):
            ls = LocalSpace.from_space(ls)
        if not isinstance(ls, LocalSpace):
            raise IslTypeError("ls is not a LocalSpace")
        _ctx_data = ls._ctx_data
        _copy_ls = ls._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_var_on_domain(_copy_ls._release(), type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_var_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.var_on_domain = staticmethod(var_on_domain)

    Aff._var_on_domain_is_static = True

    def nan_on_domain(ls):
        'nan_on_domain(ls)\n\n:param ls: :class:`LocalSpace`\n:return: :class:`Aff`'

        if isinstance(ls, Space):
            ls = LocalSpace.from_space(ls)
        if not isinstance(ls, LocalSpace):
            raise IslTypeError("ls is not a LocalSpace")
        _ctx_data = ls._ctx_data
        _copy_ls = ls._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_nan_on_domain(_copy_ls._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_nan_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.nan_on_domain = staticmethod(nan_on_domain)

    Aff._nan_on_domain_is_static = True

    def param_on_domain_space_id(space, id):
        'param_on_domain_space_id(space, id)\n\n:param space: :class:`Space`\n:param id: :class:`Id`\n:return: :class:`Aff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_param_on_domain_space_id(_copy_space._release(), _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_param_on_domain_space_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.param_on_domain_space_id = staticmethod(param_on_domain_space_id)

    Aff._param_on_domain_space_id_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`Aff`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.copy = copy

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Aff`\n:return: :class:`Context`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.get_ctx = get_ctx

    def get_hash(self):
        'get_hash(self)\n\n:param self: :class:`Aff`\n:return: uint32_t'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_get_hash(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Aff.get_hash = get_hash

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Aff.dim = dim

    def involves_dims(self, type, first, n):
        'involves_dims(self, type, first, n)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: bool'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_involves_dims(self.data, type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_aff_involves_dims\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Aff.involves_dims = involves_dims

    def get_domain_space(self):
        'get_domain_space(self)\n\n:param self: :class:`Aff`\n:return: :class:`Space`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_get_domain_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_get_domain_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.get_domain_space = get_domain_space

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`Aff`\n:return: :class:`Space`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.get_space = get_space

    def get_domain_local_space(self):
        'get_domain_local_space(self)\n\n:param self: :class:`Aff`\n:return: :class:`LocalSpace`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_get_domain_local_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_get_domain_local_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.get_domain_local_space = get_domain_local_space

    def get_local_space(self):
        'get_local_space(self)\n\n:param self: :class:`Aff`\n:return: :class:`LocalSpace`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_get_local_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_get_local_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.get_local_space = get_local_space

    def get_dim_name(self, type, pos):
        'get_dim_name(self, type, pos)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: string'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_get_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Aff.get_dim_name = get_dim_name

    def get_constant_val(self):
        'get_constant_val(self)\n\n:param self: :class:`Aff`\n:return: :class:`Val`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_get_constant_val(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_get_constant_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.get_constant_val = get_constant_val

    def get_coefficient_val(self, type, pos):
        'get_coefficient_val(self, type, pos)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:param pos: :class:`int`\n:return: :class:`Val`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_get_coefficient_val(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_get_coefficient_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.get_coefficient_val = get_coefficient_val

    def coefficient_sgn(self, type, pos):
        'coefficient_sgn(self, type, pos)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:param pos: :class:`int`\n:return: int'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_coefficient_sgn(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Aff.coefficient_sgn = coefficient_sgn

    def get_denominator_val(self):
        'get_denominator_val(self)\n\n:param self: :class:`Aff`\n:return: :class:`Val`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_get_denominator_val(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_get_denominator_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.get_denominator_val = get_denominator_val

    def set_constant_val(self, v):
        'set_constant_val(self, v)\n\n:param self: :class:`Aff`\n:param v: :class:`Val`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_set_constant_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_set_constant_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.set_constant_val = set_constant_val

    def set_coefficient_val(self, type, pos, v):
        'set_coefficient_val(self, type, pos, v)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:param pos: :class:`int`\n:param v: :class:`Val`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_set_coefficient_val(_copy_self._release(), type, pos, _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_set_coefficient_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.set_coefficient_val = set_coefficient_val

    def add_constant_val(self, v):
        'add_constant_val(self, v)\n\n:param self: :class:`Aff`\n:param v: :class:`Val`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_add_constant_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_add_constant_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.add_constant_val = add_constant_val

    def add_constant_num_si(self, v):
        'add_constant_num_si(self, v)\n\n:param self: :class:`Aff`\n:param v: :class:`int`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for v
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_add_constant_num_si(_copy_self._release(), v)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_add_constant_num_si failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.add_constant_num_si = add_constant_num_si

    def add_coefficient_val(self, type, pos, v):
        'add_coefficient_val(self, type, pos, v)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:param pos: :class:`int`\n:param v: :class:`Val`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_add_coefficient_val(_copy_self._release(), type, pos, _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_add_coefficient_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.add_coefficient_val = add_coefficient_val

    def is_cst(self):
        'is_cst(self)\n\n:param self: :class:`Aff`\n:return: bool'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_is_cst(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_aff_is_cst\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Aff.is_cst = is_cst

    def set_tuple_id(self, type, id):
        'set_tuple_id(self, type, id)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_set_tuple_id(_copy_self._release(), type, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_set_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.set_tuple_id = set_tuple_id

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.set_dim_name = set_dim_name

    def set_dim_id(self, type, pos, id):
        'set_dim_id(self, type, pos, id)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param id: :class:`Id`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_set_dim_id(_copy_self._release(), type, pos, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_set_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.set_dim_id = set_dim_id

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Aff.find_dim_by_name = find_dim_by_name

    def plain_is_equal(self, aff2):
        'plain_is_equal(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: bool'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_plain_is_equal(self.data, aff2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_aff_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Aff.plain_is_equal = plain_is_equal

    def plain_is_zero(self):
        'plain_is_zero(self)\n\n:param self: :class:`Aff`\n:return: bool'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_plain_is_zero(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_aff_plain_is_zero\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Aff.plain_is_zero = plain_is_zero

    def is_nan(self):
        'is_nan(self)\n\n:param self: :class:`Aff`\n:return: bool'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_is_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_aff_is_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Aff.is_nan = is_nan

    def get_div(self, pos):
        'get_div(self, pos)\n\n:param self: :class:`Aff`\n:param pos: :class:`int`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_get_div(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_get_div failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.get_div = get_div

    def from_range(self):
        'from_range(self)\n\n:param self: :class:`Aff`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_from_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_from_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.from_range = from_range

    def neg(self):
        'neg(self)\n\n:param self: :class:`Aff`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.neg = neg

    def ceil(self):
        'ceil(self)\n\n:param self: :class:`Aff`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_ceil(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_ceil failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.ceil = ceil

    def floor(self):
        'floor(self)\n\n:param self: :class:`Aff`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_floor(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_floor failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.floor = floor

    def mod_val(self, mod):
        'mod_val(self, mod)\n\n:param self: :class:`Aff`\n:param mod: :class:`Val`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(mod, Val):
            if _ctx_data != mod._ctx_data:
                raise Error("mismatched context in mod")
            _val_mod = mod._copy()
        elif isinstance(mod, six.integer_types):
            _cdata_mod = lib.isl_val_int_from_si(
                self._get_ctx_data(), mod)
        
            if _cdata_mod == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_mod = Val(_data=_cdata_mod)
        
        else:
            raise IslTypeError("mod is a %s and cannot "
                "be cast to a Val" % type(mod))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_mod_val(_copy_self._release(), _val_mod._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_mod_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.mod_val = mod_val

    def mul(self, aff2):
        'mul(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_mul(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_mul failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.mul = mul

    def div(self, aff2):
        'div(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_div(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_div failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.div = div

    def add(self, aff2):
        'add(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_add(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.add = add

    def sub(self, aff2):
        'sub(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_sub(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.sub = sub

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`Aff`\n:param v: :class:`Val`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.scale_val = scale_val

    def scale_down_val(self, v):
        'scale_down_val(self, v)\n\n:param self: :class:`Aff`\n:param v: :class:`Val`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_scale_down_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.scale_down_val = scale_down_val

    def insert_dims(self, type, first, n):
        'insert_dims(self, type, first, n)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_insert_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_insert_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.insert_dims = insert_dims

    def add_dims(self, type, n):
        'add_dims(self, type, n)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:param n: :class:`unsigned`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_add_dims(_copy_self._release(), type, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_add_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.add_dims = add_dims

    def move_dims(self, dst_type, dst_pos, src_type, src_pos, n):
        'move_dims(self, dst_type, dst_pos, src_type, src_pos, n)\n\n:param self: :class:`Aff`\n:param dst_type: :class:`dim_type`\n:param dst_pos: :class:`unsigned`\n:param src_type: :class:`dim_type`\n:param src_pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_type
        
        # no argument processing for dst_pos
        
        # no argument processing for src_type
        
        # no argument processing for src_pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_move_dims(_copy_self._release(), dst_type, dst_pos, src_type, src_pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_move_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.move_dims = move_dims

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`Aff`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.drop_dims = drop_dims

    def project_domain_on_params(self):
        'project_domain_on_params(self)\n\n:param self: :class:`Aff`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_project_domain_on_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_project_domain_on_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.project_domain_on_params = project_domain_on_params

    def unbind_params_insert_domain(self, domain):
        'unbind_params_insert_domain(self, domain)\n\n:param self: :class:`Aff`\n:param domain: :class:`MultiId`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(domain, MultiId):
            raise IslTypeError("domain is not a MultiId")
        if _ctx_data != domain._ctx_data:
            raise Error("mismatched context in domain")
        _copy_domain = domain._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_unbind_params_insert_domain(_copy_self._release(), _copy_domain._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_unbind_params_insert_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.unbind_params_insert_domain = unbind_params_insert_domain

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`Aff`\n:param model: :class:`Space`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.align_params = align_params

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`Aff`\n:param context: :class:`Set`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.gist = gist

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`Aff`\n:param context: :class:`Set`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.gist_params = gist_params

    def eval(self, pnt):
        'eval(self, pnt)\n\n:param self: :class:`Aff`\n:param pnt: :class:`Point`\n:return: :class:`Val`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pnt, Point):
            raise IslTypeError("pnt is not a Point")
        if _ctx_data != pnt._ctx_data:
            raise Error("mismatched context in pnt")
        _copy_pnt = pnt._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_eval(_copy_self._release(), _copy_pnt._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_eval failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.eval = eval

    def pullback_aff(self, aff2):
        'pullback_aff(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_pullback_aff(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_pullback_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.pullback_aff = pullback_aff

    def pullback_multi_aff(self, ma):
        'pullback_multi_aff(self, ma)\n\n:param self: :class:`Aff`\n:param ma: :class:`MultiAff`\n:return: :class:`Aff`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_pullback_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_pullback_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.pullback_multi_aff = pullback_multi_aff

    def zero_basic_set(self):
        'zero_basic_set(self)\n\n:param self: :class:`Aff`\n:return: :class:`BasicSet`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_zero_basic_set(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_zero_basic_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.zero_basic_set = zero_basic_set

    def neg_basic_set(self):
        'neg_basic_set(self)\n\n:param self: :class:`Aff`\n:return: :class:`BasicSet`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_neg_basic_set(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_neg_basic_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.neg_basic_set = neg_basic_set

    def eq_basic_set(self, aff2):
        'eq_basic_set(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`BasicSet`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_eq_basic_set(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_eq_basic_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.eq_basic_set = eq_basic_set

    def eq_set(self, aff2):
        'eq_set(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`Set`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_eq_set(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_eq_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.eq_set = eq_set

    def ne_set(self, aff2):
        'ne_set(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`Set`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_ne_set(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_ne_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.ne_set = ne_set

    def le_basic_set(self, aff2):
        'le_basic_set(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`BasicSet`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_le_basic_set(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_le_basic_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.le_basic_set = le_basic_set

    def le_set(self, aff2):
        'le_set(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`Set`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_le_set(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_le_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.le_set = le_set

    def lt_basic_set(self, aff2):
        'lt_basic_set(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`BasicSet`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_lt_basic_set(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_lt_basic_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.lt_basic_set = lt_basic_set

    def lt_set(self, aff2):
        'lt_set(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`Set`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_lt_set(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_lt_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.lt_set = lt_set

    def ge_basic_set(self, aff2):
        'ge_basic_set(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`BasicSet`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_ge_basic_set(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_ge_basic_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.ge_basic_set = ge_basic_set

    def ge_set(self, aff2):
        'ge_set(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`Set`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_ge_set(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_ge_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.ge_set = ge_set

    def gt_basic_set(self, aff2):
        'gt_basic_set(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`BasicSet`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_gt_basic_set(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_gt_basic_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.gt_basic_set = gt_basic_set

    def gt_set(self, aff2):
        'gt_set(self, aff2)\n\n:param self: :class:`Aff`\n:param aff2: :class:`Aff`\n:return: :class:`Set`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff2, Aff):
            raise IslTypeError("aff2 is not a Aff")
        if _ctx_data != aff2._ctx_data:
            raise Error("mismatched context in aff2")
        _copy_aff2 = aff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_gt_set(_copy_self._release(), _copy_aff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_gt_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.gt_set = gt_set

    def bind_id(self, id):
        'bind_id(self, id)\n\n:param self: :class:`Aff`\n:param id: :class:`Id`\n:return: :class:`BasicSet`'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_bind_id(_copy_self._release(), _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_bind_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.bind_id = bind_id

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`Aff`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_aff_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Aff.read_from_str = staticmethod(read_from_str)

    Aff._read_from_str_is_static = True

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`Aff`\n:return: string'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Aff.to_str = to_str

    def dump(self):
        'dump(self)\n\n:param self: :class:`Aff`\n:return: (nothing)'

        if not isinstance(self, Aff):
            raise IslTypeError("self is not a Aff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_aff_dump(self.data)
        finally:
            pass
        

    Aff.dump = dump

    # }}}

    # {{{ pw_aff

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`PwAff`\n:return: :class:`Context`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.get_ctx = get_ctx

    def get_hash(self):
        'get_hash(self)\n\n:param self: :class:`PwAff`\n:return: uint32_t'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_get_hash(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwAff.get_hash = get_hash

    def get_domain_space(self):
        'get_domain_space(self)\n\n:param self: :class:`PwAff`\n:return: :class:`Space`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_get_domain_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_get_domain_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.get_domain_space = get_domain_space

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`PwAff`\n:return: :class:`Space`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.get_space = get_space

    def from_aff(aff):
        'from_aff(aff)\n\n:param aff: :class:`Aff`\n:return: :class:`PwAff`'

        if not isinstance(aff, Aff):
            raise IslTypeError("aff is not a Aff")
        _ctx_data = aff._ctx_data
        _copy_aff = aff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_from_aff(_copy_aff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_from_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.from_aff = staticmethod(from_aff)

    PwAff._from_aff_is_static = True

    def empty(dim):
        'empty(dim)\n\n:param dim: :class:`Space`\n:return: :class:`PwAff`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_empty(_copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_empty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.empty = staticmethod(empty)

    PwAff._empty_is_static = True

    def alloc(set, aff):
        'alloc(set, aff)\n\n:param set: :class:`Set`\n:param aff: :class:`Aff`\n:return: :class:`PwAff`'

        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        _ctx_data = set._ctx_data
        _copy_set = set._copy()
        
        if not isinstance(aff, Aff):
            raise IslTypeError("aff is not a Aff")
        if _ctx_data != aff._ctx_data:
            raise Error("mismatched context in aff")
        _copy_aff = aff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_alloc(_copy_set._release(), _copy_aff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.alloc = staticmethod(alloc)

    PwAff._alloc_is_static = True

    def zero_on_domain(ls):
        'zero_on_domain(ls)\n\n:param ls: :class:`LocalSpace`\n:return: :class:`PwAff`'

        if isinstance(ls, Space):
            ls = LocalSpace.from_space(ls)
        if not isinstance(ls, LocalSpace):
            raise IslTypeError("ls is not a LocalSpace")
        _ctx_data = ls._ctx_data
        _copy_ls = ls._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_zero_on_domain(_copy_ls._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_zero_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.zero_on_domain = staticmethod(zero_on_domain)

    PwAff._zero_on_domain_is_static = True

    def var_on_domain(ls, type, pos):
        'var_on_domain(ls, type, pos)\n\n:param ls: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`PwAff`'

        if isinstance(ls, Space):
            ls = LocalSpace.from_space(ls)
        if not isinstance(ls, LocalSpace):
            raise IslTypeError("ls is not a LocalSpace")
        _ctx_data = ls._ctx_data
        _copy_ls = ls._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_var_on_domain(_copy_ls._release(), type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_var_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.var_on_domain = staticmethod(var_on_domain)

    PwAff._var_on_domain_is_static = True

    def nan_on_domain(ls):
        'nan_on_domain(ls)\n\n:param ls: :class:`LocalSpace`\n:return: :class:`PwAff`'

        if isinstance(ls, Space):
            ls = LocalSpace.from_space(ls)
        if not isinstance(ls, LocalSpace):
            raise IslTypeError("ls is not a LocalSpace")
        _ctx_data = ls._ctx_data
        _copy_ls = ls._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_nan_on_domain(_copy_ls._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_nan_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.nan_on_domain = staticmethod(nan_on_domain)

    PwAff._nan_on_domain_is_static = True

    def val_on_domain(domain, v):
        'val_on_domain(domain, v)\n\n:param domain: :class:`Set`\n:param v: :class:`Val`\n:return: :class:`PwAff`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if not isinstance(domain, Set):
            raise IslTypeError("domain is not a Set")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                domain._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_val_on_domain(_copy_domain._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_val_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.val_on_domain = staticmethod(val_on_domain)

    PwAff._val_on_domain_is_static = True

    def get_dim_name(self, type, pos):
        'get_dim_name(self, type, pos)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: string'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_get_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    PwAff.get_dim_name = get_dim_name

    def has_dim_id(self, type, pos):
        'has_dim_id(self, type, pos)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_has_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_aff_has_dim_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwAff.has_dim_id = has_dim_id

    def get_dim_id(self, type, pos):
        'get_dim_id(self, type, pos)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Id`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_get_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_get_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.get_dim_id = get_dim_id

    def set_dim_id(self, type, pos, id):
        'set_dim_id(self, type, pos, id)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param id: :class:`Id`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_set_dim_id(_copy_self._release(), type, pos, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_set_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.set_dim_id = set_dim_id

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwAff.find_dim_by_name = find_dim_by_name

    def is_empty(self):
        'is_empty(self)\n\n:param self: :class:`PwAff`\n:return: bool'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_is_empty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_aff_is_empty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwAff.is_empty = is_empty

    def involves_nan(self):
        'involves_nan(self)\n\n:param self: :class:`PwAff`\n:return: bool'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_involves_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_aff_involves_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwAff.involves_nan = involves_nan

    def plain_cmp(self, pa2):
        'plain_cmp(self, pa2)\n\n:param self: :class:`PwAff`\n:param pa2: :class:`PwAff`\n:return: int'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        
        if isinstance(pa2, Aff):
            pa2 = PwAff.from_aff(pa2)
        if not isinstance(pa2, PwAff):
            raise IslTypeError("pa2 is not a PwAff")
        if _ctx_data != pa2._ctx_data:
            raise Error("mismatched context in pa2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_plain_cmp(self.data, pa2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwAff.plain_cmp = plain_cmp

    def plain_is_equal(self, pwaff2):
        'plain_is_equal(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: bool'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_plain_is_equal(self.data, pwaff2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_aff_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwAff.plain_is_equal = plain_is_equal

    def is_equal(self, pa2):
        'is_equal(self, pa2)\n\n:param self: :class:`PwAff`\n:param pa2: :class:`PwAff`\n:return: bool'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        
        if isinstance(pa2, Aff):
            pa2 = PwAff.from_aff(pa2)
        if not isinstance(pa2, PwAff):
            raise IslTypeError("pa2 is not a PwAff")
        if _ctx_data != pa2._ctx_data:
            raise Error("mismatched context in pa2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_is_equal(self.data, pa2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_aff_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwAff.is_equal = is_equal

    def union_min(self, pwaff2):
        'union_min(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_union_min(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_union_min failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.union_min = union_min

    def union_max(self, pwaff2):
        'union_max(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_union_max(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_union_max failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.union_max = union_max

    def union_add(self, pwaff2):
        'union_add(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_union_add(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_union_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.union_add = union_add

    def copy(self):
        'copy(self)\n\n:param self: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.copy = copy

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:return: isl_size'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwAff.dim = dim

    def involves_param_id(self, id):
        'involves_param_id(self, id)\n\n:param self: :class:`PwAff`\n:param id: :class:`Id`\n:return: bool'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_involves_param_id(self.data, id.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_aff_involves_param_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwAff.involves_param_id = involves_param_id

    def involves_dims(self, type, first, n):
        'involves_dims(self, type, first, n)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: bool'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_involves_dims(self.data, type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_aff_involves_dims\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwAff.involves_dims = involves_dims

    def is_cst(self):
        'is_cst(self)\n\n:param self: :class:`PwAff`\n:return: bool'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_is_cst(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_aff_is_cst\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwAff.is_cst = is_cst

    def project_domain_on_params(self):
        'project_domain_on_params(self)\n\n:param self: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_project_domain_on_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_project_domain_on_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.project_domain_on_params = project_domain_on_params

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`PwAff`\n:param model: :class:`Space`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.align_params = align_params

    def drop_unused_params(self):
        'drop_unused_params(self)\n\n:param self: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_drop_unused_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_drop_unused_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.drop_unused_params = drop_unused_params

    def has_tuple_id(self, type):
        'has_tuple_id(self, type)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:return: bool'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_has_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_aff_has_tuple_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwAff.has_tuple_id = has_tuple_id

    def get_tuple_id(self, type):
        'get_tuple_id(self, type)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:return: :class:`Id`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_get_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_get_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.get_tuple_id = get_tuple_id

    def set_tuple_id(self, type, id):
        'set_tuple_id(self, type, id)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_set_tuple_id(_copy_self._release(), type, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_set_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.set_tuple_id = set_tuple_id

    def reset_tuple_id(self, type):
        'reset_tuple_id(self, type)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_reset_tuple_id(_copy_self._release(), type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_reset_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.reset_tuple_id = reset_tuple_id

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.reset_user = reset_user

    def params(self):
        'params(self)\n\n:param self: :class:`PwAff`\n:return: :class:`Set`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.params = params

    def domain(self):
        'domain(self)\n\n:param self: :class:`PwAff`\n:return: :class:`Set`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.domain = domain

    def from_range(self):
        'from_range(self)\n\n:param self: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_from_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_from_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.from_range = from_range

    def min(self, pwaff2):
        'min(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_min(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_min failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.min = min

    def max(self, pwaff2):
        'max(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_max(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_max failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.max = max

    def mul(self, pwaff2):
        'mul(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_mul(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_mul failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.mul = mul

    def div(self, pa2):
        'div(self, pa2)\n\n:param self: :class:`PwAff`\n:param pa2: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pa2, Aff):
            pa2 = PwAff.from_aff(pa2)
        if not isinstance(pa2, PwAff):
            raise IslTypeError("pa2 is not a PwAff")
        if _ctx_data != pa2._ctx_data:
            raise Error("mismatched context in pa2")
        _copy_pa2 = pa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_div(_copy_self._release(), _copy_pa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_div failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.div = div

    def add(self, pwaff2):
        'add(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_add(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.add = add

    def sub(self, pwaff2):
        'sub(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_sub(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.sub = sub

    def neg(self):
        'neg(self)\n\n:param self: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.neg = neg

    def ceil(self):
        'ceil(self)\n\n:param self: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_ceil(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_ceil failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.ceil = ceil

    def floor(self):
        'floor(self)\n\n:param self: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_floor(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_floor failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.floor = floor

    def mod_val(self, mod):
        'mod_val(self, mod)\n\n:param self: :class:`PwAff`\n:param mod: :class:`Val`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(mod, Val):
            if _ctx_data != mod._ctx_data:
                raise Error("mismatched context in mod")
            _val_mod = mod._copy()
        elif isinstance(mod, six.integer_types):
            _cdata_mod = lib.isl_val_int_from_si(
                self._get_ctx_data(), mod)
        
            if _cdata_mod == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_mod = Val(_data=_cdata_mod)
        
        else:
            raise IslTypeError("mod is a %s and cannot "
                "be cast to a Val" % type(mod))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_mod_val(_copy_self._release(), _val_mod._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_mod_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.mod_val = mod_val

    def tdiv_q(self, pa2):
        'tdiv_q(self, pa2)\n\n:param self: :class:`PwAff`\n:param pa2: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pa2, Aff):
            pa2 = PwAff.from_aff(pa2)
        if not isinstance(pa2, PwAff):
            raise IslTypeError("pa2 is not a PwAff")
        if _ctx_data != pa2._ctx_data:
            raise Error("mismatched context in pa2")
        _copy_pa2 = pa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_tdiv_q(_copy_self._release(), _copy_pa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_tdiv_q failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.tdiv_q = tdiv_q

    def tdiv_r(self, pa2):
        'tdiv_r(self, pa2)\n\n:param self: :class:`PwAff`\n:param pa2: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pa2, Aff):
            pa2 = PwAff.from_aff(pa2)
        if not isinstance(pa2, PwAff):
            raise IslTypeError("pa2 is not a PwAff")
        if _ctx_data != pa2._ctx_data:
            raise Error("mismatched context in pa2")
        _copy_pa2 = pa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_tdiv_r(_copy_self._release(), _copy_pa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_tdiv_r failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.tdiv_r = tdiv_r

    def intersect_params(self, set):
        'intersect_params(self, set)\n\n:param self: :class:`PwAff`\n:param set: :class:`Set`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_intersect_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.intersect_params = intersect_params

    def intersect_domain(self, set):
        'intersect_domain(self, set)\n\n:param self: :class:`PwAff`\n:param set: :class:`Set`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_intersect_domain(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.intersect_domain = intersect_domain

    def subtract_domain(self, set):
        'subtract_domain(self, set)\n\n:param self: :class:`PwAff`\n:param set: :class:`Set`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_subtract_domain(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_subtract_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.subtract_domain = subtract_domain

    def cond(self, pwaff_true, pwaff_false):
        'cond(self, pwaff_true, pwaff_false)\n\n:param self: :class:`PwAff`\n:param pwaff_true: :class:`PwAff`\n:param pwaff_false: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff_true, Aff):
            pwaff_true = PwAff.from_aff(pwaff_true)
        if not isinstance(pwaff_true, PwAff):
            raise IslTypeError("pwaff_true is not a PwAff")
        if _ctx_data != pwaff_true._ctx_data:
            raise Error("mismatched context in pwaff_true")
        _copy_pwaff_true = pwaff_true._copy()
        
        if isinstance(pwaff_false, Aff):
            pwaff_false = PwAff.from_aff(pwaff_false)
        if not isinstance(pwaff_false, PwAff):
            raise IslTypeError("pwaff_false is not a PwAff")
        if _ctx_data != pwaff_false._ctx_data:
            raise Error("mismatched context in pwaff_false")
        _copy_pwaff_false = pwaff_false._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_cond(_copy_self._release(), _copy_pwaff_true._release(), _copy_pwaff_false._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_cond failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.cond = cond

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`PwAff`\n:param v: :class:`Val`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.scale_val = scale_val

    def scale_down_val(self, f):
        'scale_down_val(self, f)\n\n:param self: :class:`PwAff`\n:param f: :class:`Val`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(f, Val):
            if _ctx_data != f._ctx_data:
                raise Error("mismatched context in f")
            _val_f = f._copy()
        elif isinstance(f, six.integer_types):
            _cdata_f = lib.isl_val_int_from_si(
                self._get_ctx_data(), f)
        
            if _cdata_f == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_f = Val(_data=_cdata_f)
        
        else:
            raise IslTypeError("f is a %s and cannot "
                "be cast to a Val" % type(f))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_scale_down_val(_copy_self._release(), _val_f._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.scale_down_val = scale_down_val

    def insert_dims(self, type, first, n):
        'insert_dims(self, type, first, n)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_insert_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_insert_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.insert_dims = insert_dims

    def add_dims(self, type, n):
        'add_dims(self, type, n)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:param n: :class:`unsigned`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_add_dims(_copy_self._release(), type, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_add_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.add_dims = add_dims

    def move_dims(self, dst_type, dst_pos, src_type, src_pos, n):
        'move_dims(self, dst_type, dst_pos, src_type, src_pos, n)\n\n:param self: :class:`PwAff`\n:param dst_type: :class:`dim_type`\n:param dst_pos: :class:`unsigned`\n:param src_type: :class:`dim_type`\n:param src_pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_type
        
        # no argument processing for dst_pos
        
        # no argument processing for src_type
        
        # no argument processing for src_pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_move_dims(_copy_self._release(), dst_type, dst_pos, src_type, src_pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_move_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.move_dims = move_dims

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`PwAff`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.drop_dims = drop_dims

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`PwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.coalesce = coalesce

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`PwAff`\n:param context: :class:`Set`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.gist = gist

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`PwAff`\n:param context: :class:`Set`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.gist_params = gist_params

    def eval(self, pnt):
        'eval(self, pnt)\n\n:param self: :class:`PwAff`\n:param pnt: :class:`Point`\n:return: :class:`Val`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pnt, Point):
            raise IslTypeError("pnt is not a Point")
        if _ctx_data != pnt._ctx_data:
            raise Error("mismatched context in pnt")
        _copy_pnt = pnt._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_eval(_copy_self._release(), _copy_pnt._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_eval failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.eval = eval

    def pullback_multi_aff(self, ma):
        'pullback_multi_aff(self, ma)\n\n:param self: :class:`PwAff`\n:param ma: :class:`MultiAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_pullback_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_pullback_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.pullback_multi_aff = pullback_multi_aff

    def pullback_pw_multi_aff(self, pma):
        'pullback_pw_multi_aff(self, pma)\n\n:param self: :class:`PwAff`\n:param pma: :class:`PwMultiAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_pullback_pw_multi_aff(_copy_self._release(), _copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_pullback_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.pullback_pw_multi_aff = pullback_pw_multi_aff

    def pullback_multi_pw_aff(self, mpa):
        'pullback_multi_pw_aff(self, mpa)\n\n:param self: :class:`PwAff`\n:param mpa: :class:`MultiPwAff`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mpa, MultiPwAff):
            raise IslTypeError("mpa is not a MultiPwAff")
        if _ctx_data != mpa._ctx_data:
            raise Error("mismatched context in mpa")
        _copy_mpa = mpa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_pullback_multi_pw_aff(_copy_self._release(), _copy_mpa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_pullback_multi_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.pullback_multi_pw_aff = pullback_multi_pw_aff

    def n_piece(self):
        'n_piece(self)\n\n:param self: :class:`PwAff`\n:return: isl_size'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_n_piece(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwAff.n_piece = n_piece

    def foreach_piece(self, fn):
        'foreach_piece(self, fn)\n\n:param self: :class:`PwAff`\n:param fn: callback(set, aff) -> isl_stat\n:return: (nothing)'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(set, aff, user):
            try:
                _py_set = Set(_data=set)
                _py_aff = Aff(_data=aff)
                _result = fn(_py_set, _py_aff)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_set *set,  isl_aff *aff,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_foreach_piece(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_pw_aff_foreach_piece\" failed: %s" % _get_last_error_str(_ctx_data))
        

    PwAff.foreach_piece = foreach_piece

    def pos_set(self):
        'pos_set(self)\n\n:param self: :class:`PwAff`\n:return: :class:`Set`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_pos_set(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_pos_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.pos_set = pos_set

    def nonneg_set(self):
        'nonneg_set(self)\n\n:param self: :class:`PwAff`\n:return: :class:`Set`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_nonneg_set(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_nonneg_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.nonneg_set = nonneg_set

    def zero_set(self):
        'zero_set(self)\n\n:param self: :class:`PwAff`\n:return: :class:`Set`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_zero_set(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_zero_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.zero_set = zero_set

    def non_zero_set(self):
        'non_zero_set(self)\n\n:param self: :class:`PwAff`\n:return: :class:`Set`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_non_zero_set(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_non_zero_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.non_zero_set = non_zero_set

    def eq_set(self, pwaff2):
        'eq_set(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`Set`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_eq_set(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_eq_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.eq_set = eq_set

    def ne_set(self, pwaff2):
        'ne_set(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`Set`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_ne_set(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_ne_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.ne_set = ne_set

    def le_set(self, pwaff2):
        'le_set(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`Set`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_le_set(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_le_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.le_set = le_set

    def lt_set(self, pwaff2):
        'lt_set(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`Set`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_lt_set(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_lt_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.lt_set = lt_set

    def ge_set(self, pwaff2):
        'ge_set(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`Set`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_ge_set(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_ge_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.ge_set = ge_set

    def gt_set(self, pwaff2):
        'gt_set(self, pwaff2)\n\n:param self: :class:`PwAff`\n:param pwaff2: :class:`PwAff`\n:return: :class:`Set`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pwaff2, Aff):
            pwaff2 = PwAff.from_aff(pwaff2)
        if not isinstance(pwaff2, PwAff):
            raise IslTypeError("pwaff2 is not a PwAff")
        if _ctx_data != pwaff2._ctx_data:
            raise Error("mismatched context in pwaff2")
        _copy_pwaff2 = pwaff2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_gt_set(_copy_self._release(), _copy_pwaff2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_gt_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.gt_set = gt_set

    def eq_map(self, pa2):
        'eq_map(self, pa2)\n\n:param self: :class:`PwAff`\n:param pa2: :class:`PwAff`\n:return: :class:`Map`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pa2, Aff):
            pa2 = PwAff.from_aff(pa2)
        if not isinstance(pa2, PwAff):
            raise IslTypeError("pa2 is not a PwAff")
        if _ctx_data != pa2._ctx_data:
            raise Error("mismatched context in pa2")
        _copy_pa2 = pa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_eq_map(_copy_self._release(), _copy_pa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_eq_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.eq_map = eq_map

    def lt_map(self, pa2):
        'lt_map(self, pa2)\n\n:param self: :class:`PwAff`\n:param pa2: :class:`PwAff`\n:return: :class:`Map`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pa2, Aff):
            pa2 = PwAff.from_aff(pa2)
        if not isinstance(pa2, PwAff):
            raise IslTypeError("pa2 is not a PwAff")
        if _ctx_data != pa2._ctx_data:
            raise Error("mismatched context in pa2")
        _copy_pa2 = pa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_lt_map(_copy_self._release(), _copy_pa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_lt_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.lt_map = lt_map

    def gt_map(self, pa2):
        'gt_map(self, pa2)\n\n:param self: :class:`PwAff`\n:param pa2: :class:`PwAff`\n:return: :class:`Map`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pa2, Aff):
            pa2 = PwAff.from_aff(pa2)
        if not isinstance(pa2, PwAff):
            raise IslTypeError("pa2 is not a PwAff")
        if _ctx_data != pa2._ctx_data:
            raise Error("mismatched context in pa2")
        _copy_pa2 = pa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_gt_map(_copy_self._release(), _copy_pa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_gt_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.gt_map = gt_map

    def bind_domain(self, tuple):
        'bind_domain(self, tuple)\n\n:param self: :class:`PwAff`\n:param tuple: :class:`MultiId`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(tuple, MultiId):
            raise IslTypeError("tuple is not a MultiId")
        if _ctx_data != tuple._ctx_data:
            raise Error("mismatched context in tuple")
        _copy_tuple = tuple._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_bind_domain(_copy_self._release(), _copy_tuple._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_bind_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.bind_domain = bind_domain

    def bind_domain_wrapped_domain(self, tuple):
        'bind_domain_wrapped_domain(self, tuple)\n\n:param self: :class:`PwAff`\n:param tuple: :class:`MultiId`\n:return: :class:`PwAff`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(tuple, MultiId):
            raise IslTypeError("tuple is not a MultiId")
        if _ctx_data != tuple._ctx_data:
            raise Error("mismatched context in tuple")
        _copy_tuple = tuple._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_bind_domain_wrapped_domain(_copy_self._release(), _copy_tuple._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_bind_domain_wrapped_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.bind_domain_wrapped_domain = bind_domain_wrapped_domain

    def bind_id(self, id):
        'bind_id(self, id)\n\n:param self: :class:`PwAff`\n:param id: :class:`Id`\n:return: :class:`Set`'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_bind_id(_copy_self._release(), _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_bind_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.bind_id = bind_id

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`PwAff`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_aff_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwAff.read_from_str = staticmethod(read_from_str)

    PwAff._read_from_str_is_static = True

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`PwAff`\n:return: string'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    PwAff.to_str = to_str

    def dump(self):
        'dump(self)\n\n:param self: :class:`PwAff`\n:return: (nothing)'

        if isinstance(self, Aff):
            self = PwAff.from_aff(self)
        if not isinstance(self, PwAff):
            raise IslTypeError("self is not a PwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_aff_dump(self.data)
        finally:
            pass
        

    PwAff.dump = dump

    # }}}

    # {{{ union_pw_aff

    def param_on_domain_id(domain, id):
        'param_on_domain_id(domain, id)\n\n:param domain: :class:`UnionSet`\n:param id: :class:`Id`\n:return: :class:`UnionPwAff`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if isinstance(domain, Set):
            domain = UnionSet.from_set(domain)
        if not isinstance(domain, UnionSet):
            raise IslTypeError("domain is not a UnionSet")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_param_on_domain_id(_copy_domain._release(), _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_param_on_domain_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.param_on_domain_id = staticmethod(param_on_domain_id)

    UnionPwAff._param_on_domain_id_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`UnionPwAff`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.copy = copy

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`UnionPwAff`\n:return: :class:`Context`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.get_ctx = get_ctx

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`UnionPwAff`\n:return: :class:`Space`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.get_space = get_space

    def get_pw_aff_list(self):
        'get_pw_aff_list(self)\n\n:param self: :class:`UnionPwAff`\n:return: :class:`PwAffList`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_get_pw_aff_list(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_get_pw_aff_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.get_pw_aff_list = get_pw_aff_list

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`UnionPwAff`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionPwAff.dim = dim

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`UnionPwAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.set_dim_name = set_dim_name

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`UnionPwAff`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionPwAff.find_dim_by_name = find_dim_by_name

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`UnionPwAff`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.drop_dims = drop_dims

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`UnionPwAff`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.reset_user = reset_user

    def empty(space):
        'empty(space)\n\n:param space: :class:`Space`\n:return: :class:`UnionPwAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_empty(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_empty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.empty = staticmethod(empty)

    UnionPwAff._empty_is_static = True

    def from_pw_aff(pa):
        'from_pw_aff(pa)\n\n:param pa: :class:`PwAff`\n:return: :class:`UnionPwAff`'

        if isinstance(pa, Aff):
            pa = PwAff.from_aff(pa)
        if not isinstance(pa, PwAff):
            raise IslTypeError("pa is not a PwAff")
        _ctx_data = pa._ctx_data
        _copy_pa = pa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_from_pw_aff(_copy_pa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_from_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.from_pw_aff = staticmethod(from_pw_aff)

    UnionPwAff._from_pw_aff_is_static = True

    def val_on_domain(domain, v):
        'val_on_domain(domain, v)\n\n:param domain: :class:`UnionSet`\n:param v: :class:`Val`\n:return: :class:`UnionPwAff`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if isinstance(domain, Set):
            domain = UnionSet.from_set(domain)
        if not isinstance(domain, UnionSet):
            raise IslTypeError("domain is not a UnionSet")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                domain._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_val_on_domain(_copy_domain._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_val_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.val_on_domain = staticmethod(val_on_domain)

    UnionPwAff._val_on_domain_is_static = True

    def aff_on_domain(domain, aff):
        'aff_on_domain(domain, aff)\n\n:param domain: :class:`UnionSet`\n:param aff: :class:`Aff`\n:return: :class:`UnionPwAff`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if isinstance(domain, Set):
            domain = UnionSet.from_set(domain)
        if not isinstance(domain, UnionSet):
            raise IslTypeError("domain is not a UnionSet")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        if not isinstance(aff, Aff):
            raise IslTypeError("aff is not a Aff")
        if _ctx_data != aff._ctx_data:
            raise Error("mismatched context in aff")
        _copy_aff = aff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_aff_on_domain(_copy_domain._release(), _copy_aff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_aff_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.aff_on_domain = staticmethod(aff_on_domain)

    UnionPwAff._aff_on_domain_is_static = True

    def pw_aff_on_domain(domain, pa):
        'pw_aff_on_domain(domain, pa)\n\n:param domain: :class:`UnionSet`\n:param pa: :class:`PwAff`\n:return: :class:`UnionPwAff`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if isinstance(domain, Set):
            domain = UnionSet.from_set(domain)
        if not isinstance(domain, UnionSet):
            raise IslTypeError("domain is not a UnionSet")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        if isinstance(pa, Aff):
            pa = PwAff.from_aff(pa)
        if not isinstance(pa, PwAff):
            raise IslTypeError("pa is not a PwAff")
        if _ctx_data != pa._ctx_data:
            raise Error("mismatched context in pa")
        _copy_pa = pa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_pw_aff_on_domain(_copy_domain._release(), _copy_pa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_pw_aff_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.pw_aff_on_domain = staticmethod(pw_aff_on_domain)

    UnionPwAff._pw_aff_on_domain_is_static = True

    def add_pw_aff(self, pa):
        'add_pw_aff(self, pa)\n\n:param self: :class:`UnionPwAff`\n:param pa: :class:`PwAff`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pa, Aff):
            pa = PwAff.from_aff(pa)
        if not isinstance(pa, PwAff):
            raise IslTypeError("pa is not a PwAff")
        if _ctx_data != pa._ctx_data:
            raise Error("mismatched context in pa")
        _copy_pa = pa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_add_pw_aff(_copy_self._release(), _copy_pa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_add_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.add_pw_aff = add_pw_aff

    def n_pw_aff(self):
        'n_pw_aff(self)\n\n:param self: :class:`UnionPwAff`\n:return: isl_size'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_n_pw_aff(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionPwAff.n_pw_aff = n_pw_aff

    def foreach_pw_aff(self, fn):
        'foreach_pw_aff(self, fn)\n\n:param self: :class:`UnionPwAff`\n:param fn: callback(pa) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(pa, user):
            try:
                _py_pa = PwAff(_data=pa)
                _result = fn(_py_pa)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_pw_aff *pa,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_foreach_pw_aff(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_union_pw_aff_foreach_pw_aff\" failed: %s" % _get_last_error_str(_ctx_data))
        

    UnionPwAff.foreach_pw_aff = foreach_pw_aff

    def extract_pw_aff(self, space):
        'extract_pw_aff(self, space)\n\n:param self: :class:`UnionPwAff`\n:param space: :class:`Space`\n:return: :class:`PwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        if _ctx_data != space._ctx_data:
            raise Error("mismatched context in space")
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_extract_pw_aff(self.data, _copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_extract_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.extract_pw_aff = extract_pw_aff

    def involves_nan(self):
        'involves_nan(self)\n\n:param self: :class:`UnionPwAff`\n:return: bool'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_involves_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_pw_aff_involves_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionPwAff.involves_nan = involves_nan

    def plain_is_equal(self, upa2):
        'plain_is_equal(self, upa2)\n\n:param self: :class:`UnionPwAff`\n:param upa2: :class:`UnionPwAff`\n:return: bool'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(upa2, UnionPwAff):
            raise IslTypeError("upa2 is not a UnionPwAff")
        if _ctx_data != upa2._ctx_data:
            raise Error("mismatched context in upa2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_plain_is_equal(self.data, upa2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_pw_aff_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionPwAff.plain_is_equal = plain_is_equal

    def domain(self):
        'domain(self)\n\n:param self: :class:`UnionPwAff`\n:return: :class:`UnionSet`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.domain = domain

    def neg(self):
        'neg(self)\n\n:param self: :class:`UnionPwAff`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.neg = neg

    def add(self, upa2):
        'add(self, upa2)\n\n:param self: :class:`UnionPwAff`\n:param upa2: :class:`UnionPwAff`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upa2, UnionPwAff):
            raise IslTypeError("upa2 is not a UnionPwAff")
        if _ctx_data != upa2._ctx_data:
            raise Error("mismatched context in upa2")
        _copy_upa2 = upa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_add(_copy_self._release(), _copy_upa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.add = add

    def union_add(self, upa2):
        'union_add(self, upa2)\n\n:param self: :class:`UnionPwAff`\n:param upa2: :class:`UnionPwAff`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upa2, UnionPwAff):
            raise IslTypeError("upa2 is not a UnionPwAff")
        if _ctx_data != upa2._ctx_data:
            raise Error("mismatched context in upa2")
        _copy_upa2 = upa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_union_add(_copy_self._release(), _copy_upa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_union_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.union_add = union_add

    def sub(self, upa2):
        'sub(self, upa2)\n\n:param self: :class:`UnionPwAff`\n:param upa2: :class:`UnionPwAff`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upa2, UnionPwAff):
            raise IslTypeError("upa2 is not a UnionPwAff")
        if _ctx_data != upa2._ctx_data:
            raise Error("mismatched context in upa2")
        _copy_upa2 = upa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_sub(_copy_self._release(), _copy_upa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.sub = sub

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`UnionPwAff`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.coalesce = coalesce

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`UnionPwAff`\n:param context: :class:`UnionSet`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if isinstance(context, Set):
            context = UnionSet.from_set(context)
        if not isinstance(context, UnionSet):
            raise IslTypeError("context is not a UnionSet")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.gist = gist

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`UnionPwAff`\n:param context: :class:`Set`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.gist_params = gist_params

    def pullback_union_pw_multi_aff(self, upma):
        'pullback_union_pw_multi_aff(self, upma)\n\n:param self: :class:`UnionPwAff`\n:param upma: :class:`UnionPwMultiAff`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upma, UnionPwMultiAff):
            raise IslTypeError("upma is not a UnionPwMultiAff")
        if _ctx_data != upma._ctx_data:
            raise Error("mismatched context in upma")
        _copy_upma = upma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_pullback_union_pw_multi_aff(_copy_self._release(), _copy_upma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_pullback_union_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.pullback_union_pw_multi_aff = pullback_union_pw_multi_aff

    def floor(self):
        'floor(self)\n\n:param self: :class:`UnionPwAff`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_floor(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_floor failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.floor = floor

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`UnionPwAff`\n:param v: :class:`Val`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.scale_val = scale_val

    def scale_down_val(self, v):
        'scale_down_val(self, v)\n\n:param self: :class:`UnionPwAff`\n:param v: :class:`Val`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_scale_down_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.scale_down_val = scale_down_val

    def mod_val(self, f):
        'mod_val(self, f)\n\n:param self: :class:`UnionPwAff`\n:param f: :class:`Val`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(f, Val):
            if _ctx_data != f._ctx_data:
                raise Error("mismatched context in f")
            _val_f = f._copy()
        elif isinstance(f, six.integer_types):
            _cdata_f = lib.isl_val_int_from_si(
                self._get_ctx_data(), f)
        
            if _cdata_f == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_f = Val(_data=_cdata_f)
        
        else:
            raise IslTypeError("f is a %s and cannot "
                "be cast to a Val" % type(f))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_mod_val(_copy_self._release(), _val_f._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_mod_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.mod_val = mod_val

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`UnionPwAff`\n:param model: :class:`Space`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.align_params = align_params

    def intersect_params(self, set):
        'intersect_params(self, set)\n\n:param self: :class:`UnionPwAff`\n:param set: :class:`Set`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_intersect_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.intersect_params = intersect_params

    def intersect_domain(self, uset):
        'intersect_domain(self, uset)\n\n:param self: :class:`UnionPwAff`\n:param uset: :class:`UnionSet`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_intersect_domain(_copy_self._release(), _copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.intersect_domain = intersect_domain

    def subtract_domain(self, uset):
        'subtract_domain(self, uset)\n\n:param self: :class:`UnionPwAff`\n:param uset: :class:`UnionSet`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_subtract_domain(_copy_self._release(), _copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_subtract_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.subtract_domain = subtract_domain

    def zero_union_set(self):
        'zero_union_set(self)\n\n:param self: :class:`UnionPwAff`\n:return: :class:`UnionSet`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_zero_union_set(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_zero_union_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.zero_union_set = zero_union_set

    def bind_id(self, id):
        'bind_id(self, id)\n\n:param self: :class:`UnionPwAff`\n:param id: :class:`Id`\n:return: :class:`UnionSet`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_bind_id(_copy_self._release(), _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_bind_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.bind_id = bind_id

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`UnionPwAff`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.read_from_str = staticmethod(read_from_str)

    UnionPwAff._read_from_str_is_static = True

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`UnionPwAff`\n:return: string'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    UnionPwAff.to_str = to_str

    def dump(self):
        'dump(self)\n\n:param self: :class:`UnionPwAff`\n:return: (nothing)'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_dump(self.data)
        finally:
            pass
        

    UnionPwAff.dump = dump

    def min_val(self):
        'min_val(self)\n\n:param self: :class:`UnionPwAff`\n:return: :class:`Val`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_min_val(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_min_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.min_val = min_val

    def max_val(self):
        'max_val(self)\n\n:param self: :class:`UnionPwAff`\n:return: :class:`Val`'

        if not isinstance(self, UnionPwAff):
            raise IslTypeError("self is not a UnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_aff_max_val(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_aff_max_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwAff.max_val = max_val

    # }}}

    # {{{ multi_aff

    def from_aff(aff):
        'from_aff(aff)\n\n:param aff: :class:`Aff`\n:return: :class:`MultiAff`'

        if not isinstance(aff, Aff):
            raise IslTypeError("aff is not a Aff")
        _ctx_data = aff._ctx_data
        _copy_aff = aff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_from_aff(_copy_aff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_from_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.from_aff = staticmethod(from_aff)

    MultiAff._from_aff_is_static = True

    def domain_map(space):
        'domain_map(space)\n\n:param space: :class:`Space`\n:return: :class:`MultiAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_domain_map(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_domain_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.domain_map = staticmethod(domain_map)

    MultiAff._domain_map_is_static = True

    def range_map(space):
        'range_map(space)\n\n:param space: :class:`Space`\n:return: :class:`MultiAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_range_map(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_range_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.range_map = staticmethod(range_map)

    MultiAff._range_map_is_static = True

    def project_out_map(space, type, first, n):
        'project_out_map(space, type, first, n)\n\n:param space: :class:`Space`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`MultiAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_project_out_map(_copy_space._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_project_out_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.project_out_map = staticmethod(project_out_map)

    MultiAff._project_out_map_is_static = True

    def multi_val_on_space(space, mv):
        'multi_val_on_space(space, mv)\n\n:param space: :class:`Space`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_multi_val_on_space(_copy_space._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_multi_val_on_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.multi_val_on_space = staticmethod(multi_val_on_space)

    MultiAff._multi_val_on_space_is_static = True

    def floor(self):
        'floor(self)\n\n:param self: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_floor(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_floor failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.floor = floor

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`MultiAff`\n:param context: :class:`Set`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.gist_params = gist_params

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`MultiAff`\n:param context: :class:`Set`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.gist = gist

    def lift(self):
        'lift(self)\n\n:param self: :class:`MultiAff`\n:return: (:class:`MultiAff`, ls (:class:`LocalSpace`))'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        _retptr_ls = ffi.new("isl_local_space **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_lift(_copy_self._release(), _retptr_ls)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_ls == ffi.NULL:
                _ret_ls = None
            else:
                _ret_ls = LocalSpace(_data=_retptr_ls[0])
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_lift failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_ls

    MultiAff.lift = lift

    def pullback_multi_aff(self, ma2):
        'pullback_multi_aff(self, ma2)\n\n:param self: :class:`MultiAff`\n:param ma2: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma2, MultiAff):
            raise IslTypeError("ma2 is not a MultiAff")
        if _ctx_data != ma2._ctx_data:
            raise Error("mismatched context in ma2")
        _copy_ma2 = ma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_pullback_multi_aff(_copy_self._release(), _copy_ma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_pullback_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.pullback_multi_aff = pullback_multi_aff

    def move_dims(self, dst_type, dst_pos, src_type, src_pos, n):
        'move_dims(self, dst_type, dst_pos, src_type, src_pos, n)\n\n:param self: :class:`MultiAff`\n:param dst_type: :class:`dim_type`\n:param dst_pos: :class:`unsigned`\n:param src_type: :class:`dim_type`\n:param src_pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_type
        
        # no argument processing for dst_pos
        
        # no argument processing for src_type
        
        # no argument processing for src_pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_move_dims(_copy_self._release(), dst_type, dst_pos, src_type, src_pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_move_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.move_dims = move_dims

    def lex_lt_set(self, ma2):
        'lex_lt_set(self, ma2)\n\n:param self: :class:`MultiAff`\n:param ma2: :class:`MultiAff`\n:return: :class:`Set`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma2, MultiAff):
            raise IslTypeError("ma2 is not a MultiAff")
        if _ctx_data != ma2._ctx_data:
            raise Error("mismatched context in ma2")
        _copy_ma2 = ma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_lex_lt_set(_copy_self._release(), _copy_ma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_lex_lt_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.lex_lt_set = lex_lt_set

    def lex_le_set(self, ma2):
        'lex_le_set(self, ma2)\n\n:param self: :class:`MultiAff`\n:param ma2: :class:`MultiAff`\n:return: :class:`Set`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma2, MultiAff):
            raise IslTypeError("ma2 is not a MultiAff")
        if _ctx_data != ma2._ctx_data:
            raise Error("mismatched context in ma2")
        _copy_ma2 = ma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_lex_le_set(_copy_self._release(), _copy_ma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_lex_le_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.lex_le_set = lex_le_set

    def lex_gt_set(self, ma2):
        'lex_gt_set(self, ma2)\n\n:param self: :class:`MultiAff`\n:param ma2: :class:`MultiAff`\n:return: :class:`Set`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma2, MultiAff):
            raise IslTypeError("ma2 is not a MultiAff")
        if _ctx_data != ma2._ctx_data:
            raise Error("mismatched context in ma2")
        _copy_ma2 = ma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_lex_gt_set(_copy_self._release(), _copy_ma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_lex_gt_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.lex_gt_set = lex_gt_set

    def lex_ge_set(self, ma2):
        'lex_ge_set(self, ma2)\n\n:param self: :class:`MultiAff`\n:param ma2: :class:`MultiAff`\n:return: :class:`Set`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma2, MultiAff):
            raise IslTypeError("ma2 is not a MultiAff")
        if _ctx_data != ma2._ctx_data:
            raise Error("mismatched context in ma2")
        _copy_ma2 = ma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_lex_ge_set(_copy_self._release(), _copy_ma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_lex_ge_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.lex_ge_set = lex_ge_set

    def bind(self, tuple):
        'bind(self, tuple)\n\n:param self: :class:`MultiAff`\n:param tuple: :class:`MultiId`\n:return: :class:`BasicSet`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(tuple, MultiId):
            raise IslTypeError("tuple is not a MultiId")
        if _ctx_data != tuple._ctx_data:
            raise Error("mismatched context in tuple")
        _copy_tuple = tuple._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_bind(_copy_self._release(), _copy_tuple._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_bind failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.bind = bind

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`MultiAff`\n:return: string'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    MultiAff.to_str = to_str

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`MultiAff`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.read_from_str = staticmethod(read_from_str)

    MultiAff._read_from_str_is_static = True

    def dump(self):
        'dump(self)\n\n:param self: :class:`MultiAff`\n:return: (nothing)'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_dump(self.data)
        finally:
            pass
        

    MultiAff.dump = dump

    def flatten_domain(self):
        'flatten_domain(self)\n\n:param self: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_flatten_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_flatten_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.flatten_domain = flatten_domain

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`MultiAff`\n:param type: :class:`dim_type`\n:return: unsigned'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiAff.dim = dim

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`MultiAff`\n:return: :class:`Context`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.get_ctx = get_ctx

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`MultiAff`\n:return: :class:`Space`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.get_space = get_space

    def get_domain_space(self):
        'get_domain_space(self)\n\n:param self: :class:`MultiAff`\n:return: :class:`Space`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_get_domain_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_get_domain_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.get_domain_space = get_domain_space

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`MultiAff`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiAff.find_dim_by_name = find_dim_by_name

    def from_aff_list(space, list):
        'from_aff_list(space, list)\n\n:param space: :class:`Space`\n:param list: :class:`AffList`\n:return: :class:`MultiAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        
        if not isinstance(list, AffList):
            raise IslTypeError("list is not a AffList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        _copy_list = list._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_from_aff_list(_copy_space._release(), _copy_list._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_from_aff_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.from_aff_list = staticmethod(from_aff_list)

    MultiAff._from_aff_list_is_static = True

    def zero(space):
        'zero(space)\n\n:param space: :class:`Space`\n:return: :class:`MultiAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_zero(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_zero failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.zero = staticmethod(zero)

    MultiAff._zero_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.copy = copy

    def plain_is_equal(self, multi2):
        'plain_is_equal(self, multi2)\n\n:param self: :class:`MultiAff`\n:param multi2: :class:`MultiAff`\n:return: bool'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(multi2, MultiAff):
            raise IslTypeError("multi2 is not a MultiAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_plain_is_equal(self.data, multi2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_aff_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiAff.plain_is_equal = plain_is_equal

    def involves_nan(self):
        'involves_nan(self)\n\n:param self: :class:`MultiAff`\n:return: bool'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_involves_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_aff_involves_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiAff.involves_nan = involves_nan

    def find_dim_by_id(self, type, id):
        'find_dim_by_id(self, type, id)\n\n:param self: :class:`MultiAff`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: int'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_find_dim_by_id(self.data, type, id.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiAff.find_dim_by_id = find_dim_by_id

    def get_dim_id(self, type, pos):
        'get_dim_id(self, type, pos)\n\n:param self: :class:`MultiAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Id`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_get_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_get_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.get_dim_id = get_dim_id

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`MultiAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.set_dim_name = set_dim_name

    def set_dim_id(self, type, pos, id):
        'set_dim_id(self, type, pos, id)\n\n:param self: :class:`MultiAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param id: :class:`Id`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_set_dim_id(_copy_self._release(), type, pos, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_set_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.set_dim_id = set_dim_id

    def get_tuple_name(self, type):
        'get_tuple_name(self, type)\n\n:param self: :class:`MultiAff`\n:param type: :class:`dim_type`\n:return: string'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_get_tuple_name(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    MultiAff.get_tuple_name = get_tuple_name

    def has_tuple_id(self, type):
        'has_tuple_id(self, type)\n\n:param self: :class:`MultiAff`\n:param type: :class:`dim_type`\n:return: bool'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_has_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_aff_has_tuple_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiAff.has_tuple_id = has_tuple_id

    def get_tuple_id(self, type):
        'get_tuple_id(self, type)\n\n:param self: :class:`MultiAff`\n:param type: :class:`dim_type`\n:return: :class:`Id`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_get_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_get_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.get_tuple_id = get_tuple_id

    def set_tuple_name(self, type, s):
        'set_tuple_name(self, type, s)\n\n:param self: :class:`MultiAff`\n:param type: :class:`dim_type`\n:param s: string\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_set_tuple_name(_copy_self._release(), type, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_set_tuple_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.set_tuple_name = set_tuple_name

    def set_tuple_id(self, type, id):
        'set_tuple_id(self, type, id)\n\n:param self: :class:`MultiAff`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_set_tuple_id(_copy_self._release(), type, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_set_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.set_tuple_id = set_tuple_id

    def reset_tuple_id(self, type):
        'reset_tuple_id(self, type)\n\n:param self: :class:`MultiAff`\n:param type: :class:`dim_type`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_reset_tuple_id(_copy_self._release(), type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_reset_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.reset_tuple_id = reset_tuple_id

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.reset_user = reset_user

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`MultiAff`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.drop_dims = drop_dims

    def get_aff(self, pos):
        'get_aff(self, pos)\n\n:param self: :class:`MultiAff`\n:param pos: :class:`int`\n:return: :class:`Aff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_get_aff(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_get_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.get_aff = get_aff

    def set_aff(self, pos, el):
        'set_aff(self, pos, el)\n\n:param self: :class:`MultiAff`\n:param pos: :class:`int`\n:param el: :class:`Aff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(el, Aff):
            raise IslTypeError("el is not a Aff")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_set_aff(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_set_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.set_aff = set_aff

    def range_splice(self, pos, multi2):
        'range_splice(self, pos, multi2)\n\n:param self: :class:`MultiAff`\n:param pos: :class:`unsigned`\n:param multi2: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(multi2, MultiAff):
            raise IslTypeError("multi2 is not a MultiAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_range_splice(_copy_self._release(), pos, _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_range_splice failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.range_splice = range_splice

    def flatten_range(self):
        'flatten_range(self)\n\n:param self: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_flatten_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_flatten_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.flatten_range = flatten_range

    def flat_range_product(self, multi2):
        'flat_range_product(self, multi2)\n\n:param self: :class:`MultiAff`\n:param multi2: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiAff):
            raise IslTypeError("multi2 is not a MultiAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_flat_range_product(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_flat_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.flat_range_product = flat_range_product

    def range_product(self, multi2):
        'range_product(self, multi2)\n\n:param self: :class:`MultiAff`\n:param multi2: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiAff):
            raise IslTypeError("multi2 is not a MultiAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_range_product(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.range_product = range_product

    def factor_range(self):
        'factor_range(self)\n\n:param self: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.factor_range = factor_range

    def range_is_wrapping(self):
        'range_is_wrapping(self)\n\n:param self: :class:`MultiAff`\n:return: bool'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_range_is_wrapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_aff_range_is_wrapping\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiAff.range_is_wrapping = range_is_wrapping

    def range_factor_domain(self):
        'range_factor_domain(self)\n\n:param self: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_range_factor_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_range_factor_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.range_factor_domain = range_factor_domain

    def range_factor_range(self):
        'range_factor_range(self)\n\n:param self: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_range_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_range_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.range_factor_range = range_factor_range

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`MultiAff`\n:param v: :class:`Val`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.scale_val = scale_val

    def scale_down_val(self, v):
        'scale_down_val(self, v)\n\n:param self: :class:`MultiAff`\n:param v: :class:`Val`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_scale_down_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.scale_down_val = scale_down_val

    def scale_multi_val(self, mv):
        'scale_multi_val(self, mv)\n\n:param self: :class:`MultiAff`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_scale_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_scale_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.scale_multi_val = scale_multi_val

    def scale_down_multi_val(self, mv):
        'scale_down_multi_val(self, mv)\n\n:param self: :class:`MultiAff`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_scale_down_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_scale_down_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.scale_down_multi_val = scale_down_multi_val

    def mod_multi_val(self, mv):
        'mod_multi_val(self, mv)\n\n:param self: :class:`MultiAff`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_mod_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_mod_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.mod_multi_val = mod_multi_val

    def add(self, multi2):
        'add(self, multi2)\n\n:param self: :class:`MultiAff`\n:param multi2: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiAff):
            raise IslTypeError("multi2 is not a MultiAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_add(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.add = add

    def sub(self, multi2):
        'sub(self, multi2)\n\n:param self: :class:`MultiAff`\n:param multi2: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiAff):
            raise IslTypeError("multi2 is not a MultiAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_sub(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.sub = sub

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`MultiAff`\n:param model: :class:`Space`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.align_params = align_params

    def from_range(self):
        'from_range(self)\n\n:param self: :class:`MultiAff`\n:return: :class:`MultiAff`'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_from_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_aff_from_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiAff.from_range = from_range

    def plain_cmp(self, multi2):
        'plain_cmp(self, multi2)\n\n:param self: :class:`MultiAff`\n:param multi2: :class:`MultiAff`\n:return: int'

        if not isinstance(self, MultiAff):
            raise IslTypeError("self is not a MultiAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(multi2, MultiAff):
            raise IslTypeError("multi2 is not a MultiAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_aff_plain_cmp(self.data, multi2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiAff.plain_cmp = plain_cmp

    # }}}

    # {{{ multi_pw_aff

    def get_hash(self):
        'get_hash(self)\n\n:param self: :class:`MultiPwAff`\n:return: uint32_t'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_get_hash(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiPwAff.get_hash = get_hash

    def from_multi_aff(ma):
        'from_multi_aff(ma)\n\n:param ma: :class:`MultiAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        _ctx_data = ma._ctx_data
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_from_multi_aff(_copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_from_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.from_multi_aff = staticmethod(from_multi_aff)

    MultiPwAff._from_multi_aff_is_static = True

    def from_pw_aff(pa):
        'from_pw_aff(pa)\n\n:param pa: :class:`PwAff`\n:return: :class:`MultiPwAff`'

        if isinstance(pa, Aff):
            pa = PwAff.from_aff(pa)
        if not isinstance(pa, PwAff):
            raise IslTypeError("pa is not a PwAff")
        _ctx_data = pa._ctx_data
        _copy_pa = pa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_from_pw_aff(_copy_pa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_from_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.from_pw_aff = staticmethod(from_pw_aff)

    MultiPwAff._from_pw_aff_is_static = True

    def domain(self):
        'domain(self)\n\n:param self: :class:`MultiPwAff`\n:return: :class:`Set`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.domain = domain

    def intersect_params(self, set):
        'intersect_params(self, set)\n\n:param self: :class:`MultiPwAff`\n:param set: :class:`Set`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_intersect_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.intersect_params = intersect_params

    def intersect_domain(self, domain):
        'intersect_domain(self, domain)\n\n:param self: :class:`MultiPwAff`\n:param domain: :class:`Set`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if not isinstance(domain, Set):
            raise IslTypeError("domain is not a Set")
        if _ctx_data != domain._ctx_data:
            raise Error("mismatched context in domain")
        _copy_domain = domain._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_intersect_domain(_copy_self._release(), _copy_domain._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.intersect_domain = intersect_domain

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.coalesce = coalesce

    def gist(self, set):
        'gist(self, set)\n\n:param self: :class:`MultiPwAff`\n:param set: :class:`Set`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_gist(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.gist = gist

    def gist_params(self, set):
        'gist_params(self, set)\n\n:param self: :class:`MultiPwAff`\n:param set: :class:`Set`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_gist_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.gist_params = gist_params

    def is_cst(self):
        'is_cst(self)\n\n:param self: :class:`MultiPwAff`\n:return: bool'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_is_cst(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_pw_aff_is_cst\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiPwAff.is_cst = is_cst

    def is_equal(self, mpa2):
        'is_equal(self, mpa2)\n\n:param self: :class:`MultiPwAff`\n:param mpa2: :class:`MultiPwAff`\n:return: bool'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(mpa2, MultiPwAff):
            raise IslTypeError("mpa2 is not a MultiPwAff")
        if _ctx_data != mpa2._ctx_data:
            raise Error("mismatched context in mpa2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_is_equal(self.data, mpa2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_pw_aff_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiPwAff.is_equal = is_equal

    def pullback_multi_aff(self, ma):
        'pullback_multi_aff(self, ma)\n\n:param self: :class:`MultiPwAff`\n:param ma: :class:`MultiAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_pullback_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_pullback_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.pullback_multi_aff = pullback_multi_aff

    def pullback_pw_multi_aff(self, pma):
        'pullback_pw_multi_aff(self, pma)\n\n:param self: :class:`MultiPwAff`\n:param pma: :class:`PwMultiAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_pullback_pw_multi_aff(_copy_self._release(), _copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_pullback_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.pullback_pw_multi_aff = pullback_pw_multi_aff

    def pullback_multi_pw_aff(self, mpa2):
        'pullback_multi_pw_aff(self, mpa2)\n\n:param self: :class:`MultiPwAff`\n:param mpa2: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mpa2, MultiPwAff):
            raise IslTypeError("mpa2 is not a MultiPwAff")
        if _ctx_data != mpa2._ctx_data:
            raise Error("mismatched context in mpa2")
        _copy_mpa2 = mpa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_pullback_multi_pw_aff(_copy_self._release(), _copy_mpa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_pullback_multi_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.pullback_multi_pw_aff = pullback_multi_pw_aff

    def move_dims(self, dst_type, dst_pos, src_type, src_pos, n):
        'move_dims(self, dst_type, dst_pos, src_type, src_pos, n)\n\n:param self: :class:`MultiPwAff`\n:param dst_type: :class:`dim_type`\n:param dst_pos: :class:`unsigned`\n:param src_type: :class:`dim_type`\n:param src_pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_type
        
        # no argument processing for dst_pos
        
        # no argument processing for src_type
        
        # no argument processing for src_pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_move_dims(_copy_self._release(), dst_type, dst_pos, src_type, src_pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_move_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.move_dims = move_dims

    def from_pw_multi_aff(pma):
        'from_pw_multi_aff(pma)\n\n:param pma: :class:`PwMultiAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        _ctx_data = pma._ctx_data
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_from_pw_multi_aff(_copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_from_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.from_pw_multi_aff = staticmethod(from_pw_multi_aff)

    MultiPwAff._from_pw_multi_aff_is_static = True

    def eq_map(self, mpa2):
        'eq_map(self, mpa2)\n\n:param self: :class:`MultiPwAff`\n:param mpa2: :class:`MultiPwAff`\n:return: :class:`Map`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mpa2, MultiPwAff):
            raise IslTypeError("mpa2 is not a MultiPwAff")
        if _ctx_data != mpa2._ctx_data:
            raise Error("mismatched context in mpa2")
        _copy_mpa2 = mpa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_eq_map(_copy_self._release(), _copy_mpa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_eq_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.eq_map = eq_map

    def lex_lt_map(self, mpa2):
        'lex_lt_map(self, mpa2)\n\n:param self: :class:`MultiPwAff`\n:param mpa2: :class:`MultiPwAff`\n:return: :class:`Map`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mpa2, MultiPwAff):
            raise IslTypeError("mpa2 is not a MultiPwAff")
        if _ctx_data != mpa2._ctx_data:
            raise Error("mismatched context in mpa2")
        _copy_mpa2 = mpa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_lex_lt_map(_copy_self._release(), _copy_mpa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_lex_lt_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.lex_lt_map = lex_lt_map

    def lex_gt_map(self, mpa2):
        'lex_gt_map(self, mpa2)\n\n:param self: :class:`MultiPwAff`\n:param mpa2: :class:`MultiPwAff`\n:return: :class:`Map`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mpa2, MultiPwAff):
            raise IslTypeError("mpa2 is not a MultiPwAff")
        if _ctx_data != mpa2._ctx_data:
            raise Error("mismatched context in mpa2")
        _copy_mpa2 = mpa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_lex_gt_map(_copy_self._release(), _copy_mpa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_lex_gt_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.lex_gt_map = lex_gt_map

    def bind(self, tuple):
        'bind(self, tuple)\n\n:param self: :class:`MultiPwAff`\n:param tuple: :class:`MultiId`\n:return: :class:`Set`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(tuple, MultiId):
            raise IslTypeError("tuple is not a MultiId")
        if _ctx_data != tuple._ctx_data:
            raise Error("mismatched context in tuple")
        _copy_tuple = tuple._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_bind(_copy_self._release(), _copy_tuple._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_bind failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.bind = bind

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`MultiPwAff`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.read_from_str = staticmethod(read_from_str)

    MultiPwAff._read_from_str_is_static = True

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`MultiPwAff`\n:return: string'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    MultiPwAff.to_str = to_str

    def dump(self):
        'dump(self)\n\n:param self: :class:`MultiPwAff`\n:return: (nothing)'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_dump(self.data)
        finally:
            pass
        

    MultiPwAff.dump = dump

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`MultiPwAff`\n:param type: :class:`dim_type`\n:return: unsigned'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiPwAff.dim = dim

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`MultiPwAff`\n:return: :class:`Context`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.get_ctx = get_ctx

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`MultiPwAff`\n:return: :class:`Space`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.get_space = get_space

    def get_domain_space(self):
        'get_domain_space(self)\n\n:param self: :class:`MultiPwAff`\n:return: :class:`Space`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_get_domain_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_get_domain_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.get_domain_space = get_domain_space

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`MultiPwAff`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiPwAff.find_dim_by_name = find_dim_by_name

    def from_pw_aff_list(space, list):
        'from_pw_aff_list(space, list)\n\n:param space: :class:`Space`\n:param list: :class:`PwAffList`\n:return: :class:`MultiPwAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        
        if not isinstance(list, PwAffList):
            raise IslTypeError("list is not a PwAffList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        _copy_list = list._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_from_pw_aff_list(_copy_space._release(), _copy_list._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_from_pw_aff_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.from_pw_aff_list = staticmethod(from_pw_aff_list)

    MultiPwAff._from_pw_aff_list_is_static = True

    def zero(space):
        'zero(space)\n\n:param space: :class:`Space`\n:return: :class:`MultiPwAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_zero(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_zero failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.zero = staticmethod(zero)

    MultiPwAff._zero_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.copy = copy

    def plain_is_equal(self, multi2):
        'plain_is_equal(self, multi2)\n\n:param self: :class:`MultiPwAff`\n:param multi2: :class:`MultiPwAff`\n:return: bool'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(multi2, MultiPwAff):
            raise IslTypeError("multi2 is not a MultiPwAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_plain_is_equal(self.data, multi2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_pw_aff_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiPwAff.plain_is_equal = plain_is_equal

    def involves_nan(self):
        'involves_nan(self)\n\n:param self: :class:`MultiPwAff`\n:return: bool'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_involves_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_pw_aff_involves_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiPwAff.involves_nan = involves_nan

    def find_dim_by_id(self, type, id):
        'find_dim_by_id(self, type, id)\n\n:param self: :class:`MultiPwAff`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: int'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_find_dim_by_id(self.data, type, id.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiPwAff.find_dim_by_id = find_dim_by_id

    def get_dim_id(self, type, pos):
        'get_dim_id(self, type, pos)\n\n:param self: :class:`MultiPwAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Id`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_get_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_get_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.get_dim_id = get_dim_id

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`MultiPwAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.set_dim_name = set_dim_name

    def set_dim_id(self, type, pos, id):
        'set_dim_id(self, type, pos, id)\n\n:param self: :class:`MultiPwAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param id: :class:`Id`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_set_dim_id(_copy_self._release(), type, pos, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_set_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.set_dim_id = set_dim_id

    def get_tuple_name(self, type):
        'get_tuple_name(self, type)\n\n:param self: :class:`MultiPwAff`\n:param type: :class:`dim_type`\n:return: string'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_get_tuple_name(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    MultiPwAff.get_tuple_name = get_tuple_name

    def has_tuple_id(self, type):
        'has_tuple_id(self, type)\n\n:param self: :class:`MultiPwAff`\n:param type: :class:`dim_type`\n:return: bool'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_has_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_pw_aff_has_tuple_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiPwAff.has_tuple_id = has_tuple_id

    def get_tuple_id(self, type):
        'get_tuple_id(self, type)\n\n:param self: :class:`MultiPwAff`\n:param type: :class:`dim_type`\n:return: :class:`Id`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_get_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_get_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.get_tuple_id = get_tuple_id

    def set_tuple_name(self, type, s):
        'set_tuple_name(self, type, s)\n\n:param self: :class:`MultiPwAff`\n:param type: :class:`dim_type`\n:param s: string\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_set_tuple_name(_copy_self._release(), type, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_set_tuple_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.set_tuple_name = set_tuple_name

    def set_tuple_id(self, type, id):
        'set_tuple_id(self, type, id)\n\n:param self: :class:`MultiPwAff`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_set_tuple_id(_copy_self._release(), type, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_set_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.set_tuple_id = set_tuple_id

    def reset_tuple_id(self, type):
        'reset_tuple_id(self, type)\n\n:param self: :class:`MultiPwAff`\n:param type: :class:`dim_type`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_reset_tuple_id(_copy_self._release(), type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_reset_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.reset_tuple_id = reset_tuple_id

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.reset_user = reset_user

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`MultiPwAff`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.drop_dims = drop_dims

    def get_pw_aff(self, pos):
        'get_pw_aff(self, pos)\n\n:param self: :class:`MultiPwAff`\n:param pos: :class:`int`\n:return: :class:`PwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_get_pw_aff(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_get_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.get_pw_aff = get_pw_aff

    def set_pw_aff(self, pos, el):
        'set_pw_aff(self, pos, el)\n\n:param self: :class:`MultiPwAff`\n:param pos: :class:`int`\n:param el: :class:`PwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if isinstance(el, Aff):
            el = PwAff.from_aff(el)
        if not isinstance(el, PwAff):
            raise IslTypeError("el is not a PwAff")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_set_pw_aff(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_set_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.set_pw_aff = set_pw_aff

    def range_splice(self, pos, multi2):
        'range_splice(self, pos, multi2)\n\n:param self: :class:`MultiPwAff`\n:param pos: :class:`unsigned`\n:param multi2: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(multi2, MultiPwAff):
            raise IslTypeError("multi2 is not a MultiPwAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_range_splice(_copy_self._release(), pos, _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_range_splice failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.range_splice = range_splice

    def flatten_range(self):
        'flatten_range(self)\n\n:param self: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_flatten_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_flatten_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.flatten_range = flatten_range

    def flat_range_product(self, multi2):
        'flat_range_product(self, multi2)\n\n:param self: :class:`MultiPwAff`\n:param multi2: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiPwAff):
            raise IslTypeError("multi2 is not a MultiPwAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_flat_range_product(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_flat_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.flat_range_product = flat_range_product

    def range_product(self, multi2):
        'range_product(self, multi2)\n\n:param self: :class:`MultiPwAff`\n:param multi2: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiPwAff):
            raise IslTypeError("multi2 is not a MultiPwAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_range_product(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.range_product = range_product

    def factor_range(self):
        'factor_range(self)\n\n:param self: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.factor_range = factor_range

    def range_is_wrapping(self):
        'range_is_wrapping(self)\n\n:param self: :class:`MultiPwAff`\n:return: bool'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_range_is_wrapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_pw_aff_range_is_wrapping\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiPwAff.range_is_wrapping = range_is_wrapping

    def range_factor_domain(self):
        'range_factor_domain(self)\n\n:param self: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_range_factor_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_range_factor_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.range_factor_domain = range_factor_domain

    def range_factor_range(self):
        'range_factor_range(self)\n\n:param self: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_range_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_range_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.range_factor_range = range_factor_range

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`MultiPwAff`\n:param v: :class:`Val`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.scale_val = scale_val

    def scale_down_val(self, v):
        'scale_down_val(self, v)\n\n:param self: :class:`MultiPwAff`\n:param v: :class:`Val`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_scale_down_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.scale_down_val = scale_down_val

    def scale_multi_val(self, mv):
        'scale_multi_val(self, mv)\n\n:param self: :class:`MultiPwAff`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_scale_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_scale_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.scale_multi_val = scale_multi_val

    def scale_down_multi_val(self, mv):
        'scale_down_multi_val(self, mv)\n\n:param self: :class:`MultiPwAff`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_scale_down_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_scale_down_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.scale_down_multi_val = scale_down_multi_val

    def mod_multi_val(self, mv):
        'mod_multi_val(self, mv)\n\n:param self: :class:`MultiPwAff`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_mod_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_mod_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.mod_multi_val = mod_multi_val

    def add(self, multi2):
        'add(self, multi2)\n\n:param self: :class:`MultiPwAff`\n:param multi2: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiPwAff):
            raise IslTypeError("multi2 is not a MultiPwAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_add(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.add = add

    def sub(self, multi2):
        'sub(self, multi2)\n\n:param self: :class:`MultiPwAff`\n:param multi2: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiPwAff):
            raise IslTypeError("multi2 is not a MultiPwAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_sub(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.sub = sub

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`MultiPwAff`\n:param model: :class:`Space`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.align_params = align_params

    def from_range(self):
        'from_range(self)\n\n:param self: :class:`MultiPwAff`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiPwAff):
            raise IslTypeError("self is not a MultiPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_pw_aff_from_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_pw_aff_from_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiPwAff.from_range = from_range

    # }}}

    # {{{ pw_multi_aff

    def zero(space):
        'zero(space)\n\n:param space: :class:`Space`\n:return: :class:`PwMultiAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_zero(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_zero failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.zero = staticmethod(zero)

    PwMultiAff._zero_is_static = True

    def identity(space):
        'identity(space)\n\n:param space: :class:`Space`\n:return: :class:`PwMultiAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_identity(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_identity failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.identity = staticmethod(identity)

    PwMultiAff._identity_is_static = True

    def range_map(space):
        'range_map(space)\n\n:param space: :class:`Space`\n:return: :class:`PwMultiAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_range_map(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_range_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.range_map = staticmethod(range_map)

    PwMultiAff._range_map_is_static = True

    def project_out_map(space, type, first, n):
        'project_out_map(space, type, first, n)\n\n:param space: :class:`Space`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`PwMultiAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_project_out_map(_copy_space._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_project_out_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.project_out_map = staticmethod(project_out_map)

    PwMultiAff._project_out_map_is_static = True

    def from_multi_aff(ma):
        'from_multi_aff(ma)\n\n:param ma: :class:`MultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        _ctx_data = ma._ctx_data
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_from_multi_aff(_copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_from_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.from_multi_aff = staticmethod(from_multi_aff)

    PwMultiAff._from_multi_aff_is_static = True

    def from_pw_aff(pa):
        'from_pw_aff(pa)\n\n:param pa: :class:`PwAff`\n:return: :class:`PwMultiAff`'

        if isinstance(pa, Aff):
            pa = PwAff.from_aff(pa)
        if not isinstance(pa, PwAff):
            raise IslTypeError("pa is not a PwAff")
        _ctx_data = pa._ctx_data
        _copy_pa = pa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_from_pw_aff(_copy_pa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_from_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.from_pw_aff = staticmethod(from_pw_aff)

    PwMultiAff._from_pw_aff_is_static = True

    def alloc(set, maff):
        'alloc(set, maff)\n\n:param set: :class:`Set`\n:param maff: :class:`MultiAff`\n:return: :class:`PwMultiAff`'

        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        _ctx_data = set._ctx_data
        _copy_set = set._copy()
        
        if not isinstance(maff, MultiAff):
            raise IslTypeError("maff is not a MultiAff")
        if _ctx_data != maff._ctx_data:
            raise Error("mismatched context in maff")
        _copy_maff = maff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_alloc(_copy_set._release(), _copy_maff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.alloc = staticmethod(alloc)

    PwMultiAff._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.copy = copy

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwMultiAff.dim = dim

    def involves_param_id(self, id):
        'involves_param_id(self, id)\n\n:param self: :class:`PwMultiAff`\n:param id: :class:`Id`\n:return: bool'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_involves_param_id(self.data, id.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_multi_aff_involves_param_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwMultiAff.involves_param_id = involves_param_id

    def involves_dims(self, type, first, n):
        'involves_dims(self, type, first, n)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: bool'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_involves_dims(self.data, type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_multi_aff_involves_dims\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwMultiAff.involves_dims = involves_dims

    def get_pw_aff(self, pos):
        'get_pw_aff(self, pos)\n\n:param self: :class:`PwMultiAff`\n:param pos: :class:`int`\n:return: :class:`PwAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_get_pw_aff(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_get_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.get_pw_aff = get_pw_aff

    def set_pw_aff(self, pos, pa):
        'set_pw_aff(self, pos, pa)\n\n:param self: :class:`PwMultiAff`\n:param pos: :class:`unsigned`\n:param pa: :class:`PwAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if isinstance(pa, Aff):
            pa = PwAff.from_aff(pa)
        if not isinstance(pa, PwAff):
            raise IslTypeError("pa is not a PwAff")
        if _ctx_data != pa._ctx_data:
            raise Error("mismatched context in pa")
        _copy_pa = pa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_set_pw_aff(_copy_self._release(), pos, _copy_pa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_set_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.set_pw_aff = set_pw_aff

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`PwMultiAff`\n:return: :class:`Context`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.get_ctx = get_ctx

    def get_domain_space(self):
        'get_domain_space(self)\n\n:param self: :class:`PwMultiAff`\n:return: :class:`Space`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_get_domain_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_get_domain_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.get_domain_space = get_domain_space

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`PwMultiAff`\n:return: :class:`Space`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.get_space = get_space

    def has_tuple_name(self, type):
        'has_tuple_name(self, type)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:return: bool'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_has_tuple_name(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_multi_aff_has_tuple_name\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwMultiAff.has_tuple_name = has_tuple_name

    def get_tuple_name(self, type):
        'get_tuple_name(self, type)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:return: string'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_get_tuple_name(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    PwMultiAff.get_tuple_name = get_tuple_name

    def get_tuple_id(self, type):
        'get_tuple_id(self, type)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:return: :class:`Id`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_get_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_get_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.get_tuple_id = get_tuple_id

    def has_tuple_id(self, type):
        'has_tuple_id(self, type)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:return: bool'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_has_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_multi_aff_has_tuple_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwMultiAff.has_tuple_id = has_tuple_id

    def set_tuple_id(self, type, id):
        'set_tuple_id(self, type, id)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_set_tuple_id(_copy_self._release(), type, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_set_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.set_tuple_id = set_tuple_id

    def reset_tuple_id(self, type):
        'reset_tuple_id(self, type)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_reset_tuple_id(_copy_self._release(), type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_reset_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.reset_tuple_id = reset_tuple_id

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.reset_user = reset_user

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwMultiAff.find_dim_by_name = find_dim_by_name

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.drop_dims = drop_dims

    def domain(self):
        'domain(self)\n\n:param self: :class:`PwMultiAff`\n:return: :class:`Set`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.domain = domain

    def empty(space):
        'empty(space)\n\n:param space: :class:`Space`\n:return: :class:`PwMultiAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_empty(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_empty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.empty = staticmethod(empty)

    PwMultiAff._empty_is_static = True

    def from_domain(set):
        'from_domain(set)\n\n:param set: :class:`Set`\n:return: :class:`PwMultiAff`'

        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        _ctx_data = set._ctx_data
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_from_domain(_copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_from_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.from_domain = staticmethod(from_domain)

    PwMultiAff._from_domain_is_static = True

    def multi_val_on_domain(domain, mv):
        'multi_val_on_domain(domain, mv)\n\n:param domain: :class:`Set`\n:param mv: :class:`MultiVal`\n:return: :class:`PwMultiAff`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if not isinstance(domain, Set):
            raise IslTypeError("domain is not a Set")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_multi_val_on_domain(_copy_domain._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_multi_val_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.multi_val_on_domain = staticmethod(multi_val_on_domain)

    PwMultiAff._multi_val_on_domain_is_static = True

    def get_dim_name(self, type, pos):
        'get_dim_name(self, type, pos)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: string'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_get_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    PwMultiAff.get_dim_name = get_dim_name

    def get_dim_id(self, type, pos):
        'get_dim_id(self, type, pos)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Id`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_get_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_get_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.get_dim_id = get_dim_id

    def set_dim_id(self, type, pos, id):
        'set_dim_id(self, type, pos, id)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param id: :class:`Id`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_set_dim_id(_copy_self._release(), type, pos, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_set_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.set_dim_id = set_dim_id

    def involves_nan(self):
        'involves_nan(self)\n\n:param self: :class:`PwMultiAff`\n:return: bool'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_involves_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_multi_aff_involves_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwMultiAff.involves_nan = involves_nan

    def plain_is_equal(self, pma2):
        'plain_is_equal(self, pma2)\n\n:param self: :class:`PwMultiAff`\n:param pma2: :class:`PwMultiAff`\n:return: bool'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(pma2, PwMultiAff):
            raise IslTypeError("pma2 is not a PwMultiAff")
        if _ctx_data != pma2._ctx_data:
            raise Error("mismatched context in pma2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_plain_is_equal(self.data, pma2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_multi_aff_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwMultiAff.plain_is_equal = plain_is_equal

    def is_equal(self, pma2):
        'is_equal(self, pma2)\n\n:param self: :class:`PwMultiAff`\n:param pma2: :class:`PwMultiAff`\n:return: bool'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(pma2, PwMultiAff):
            raise IslTypeError("pma2 is not a PwMultiAff")
        if _ctx_data != pma2._ctx_data:
            raise Error("mismatched context in pma2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_is_equal(self.data, pma2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_multi_aff_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwMultiAff.is_equal = is_equal

    def fix_si(self, type, pos, value):
        'fix_si(self, type, pos, value)\n\n:param self: :class:`PwMultiAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param value: :class:`int`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        # no argument processing for value
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_fix_si(_copy_self._release(), type, pos, value)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_fix_si failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.fix_si = fix_si

    def union_add(self, pma2):
        'union_add(self, pma2)\n\n:param self: :class:`PwMultiAff`\n:param pma2: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma2, PwMultiAff):
            raise IslTypeError("pma2 is not a PwMultiAff")
        if _ctx_data != pma2._ctx_data:
            raise Error("mismatched context in pma2")
        _copy_pma2 = pma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_union_add(_copy_self._release(), _copy_pma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_union_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.union_add = union_add

    def neg(self):
        'neg(self)\n\n:param self: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.neg = neg

    def add(self, pma2):
        'add(self, pma2)\n\n:param self: :class:`PwMultiAff`\n:param pma2: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma2, PwMultiAff):
            raise IslTypeError("pma2 is not a PwMultiAff")
        if _ctx_data != pma2._ctx_data:
            raise Error("mismatched context in pma2")
        _copy_pma2 = pma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_add(_copy_self._release(), _copy_pma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.add = add

    def sub(self, pma2):
        'sub(self, pma2)\n\n:param self: :class:`PwMultiAff`\n:param pma2: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma2, PwMultiAff):
            raise IslTypeError("pma2 is not a PwMultiAff")
        if _ctx_data != pma2._ctx_data:
            raise Error("mismatched context in pma2")
        _copy_pma2 = pma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_sub(_copy_self._release(), _copy_pma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.sub = sub

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`PwMultiAff`\n:param v: :class:`Val`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.scale_val = scale_val

    def scale_down_val(self, v):
        'scale_down_val(self, v)\n\n:param self: :class:`PwMultiAff`\n:param v: :class:`Val`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_scale_down_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.scale_down_val = scale_down_val

    def scale_multi_val(self, mv):
        'scale_multi_val(self, mv)\n\n:param self: :class:`PwMultiAff`\n:param mv: :class:`MultiVal`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_scale_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_scale_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.scale_multi_val = scale_multi_val

    def union_lexmin(self, pma2):
        'union_lexmin(self, pma2)\n\n:param self: :class:`PwMultiAff`\n:param pma2: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma2, PwMultiAff):
            raise IslTypeError("pma2 is not a PwMultiAff")
        if _ctx_data != pma2._ctx_data:
            raise Error("mismatched context in pma2")
        _copy_pma2 = pma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_union_lexmin(_copy_self._release(), _copy_pma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_union_lexmin failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.union_lexmin = union_lexmin

    def union_lexmax(self, pma2):
        'union_lexmax(self, pma2)\n\n:param self: :class:`PwMultiAff`\n:param pma2: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma2, PwMultiAff):
            raise IslTypeError("pma2 is not a PwMultiAff")
        if _ctx_data != pma2._ctx_data:
            raise Error("mismatched context in pma2")
        _copy_pma2 = pma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_union_lexmax(_copy_self._release(), _copy_pma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_union_lexmax failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.union_lexmax = union_lexmax

    def range_product(self, pma2):
        'range_product(self, pma2)\n\n:param self: :class:`PwMultiAff`\n:param pma2: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma2, PwMultiAff):
            raise IslTypeError("pma2 is not a PwMultiAff")
        if _ctx_data != pma2._ctx_data:
            raise Error("mismatched context in pma2")
        _copy_pma2 = pma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_range_product(_copy_self._release(), _copy_pma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.range_product = range_product

    def flat_range_product(self, pma2):
        'flat_range_product(self, pma2)\n\n:param self: :class:`PwMultiAff`\n:param pma2: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma2, PwMultiAff):
            raise IslTypeError("pma2 is not a PwMultiAff")
        if _ctx_data != pma2._ctx_data:
            raise Error("mismatched context in pma2")
        _copy_pma2 = pma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_flat_range_product(_copy_self._release(), _copy_pma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_flat_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.flat_range_product = flat_range_product

    def product(self, pma2):
        'product(self, pma2)\n\n:param self: :class:`PwMultiAff`\n:param pma2: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma2, PwMultiAff):
            raise IslTypeError("pma2 is not a PwMultiAff")
        if _ctx_data != pma2._ctx_data:
            raise Error("mismatched context in pma2")
        _copy_pma2 = pma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_product(_copy_self._release(), _copy_pma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.product = product

    def intersect_params(self, set):
        'intersect_params(self, set)\n\n:param self: :class:`PwMultiAff`\n:param set: :class:`Set`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_intersect_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.intersect_params = intersect_params

    def intersect_domain(self, set):
        'intersect_domain(self, set)\n\n:param self: :class:`PwMultiAff`\n:param set: :class:`Set`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_intersect_domain(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.intersect_domain = intersect_domain

    def subtract_domain(self, set):
        'subtract_domain(self, set)\n\n:param self: :class:`PwMultiAff`\n:param set: :class:`Set`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_subtract_domain(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_subtract_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.subtract_domain = subtract_domain

    def project_domain_on_params(self):
        'project_domain_on_params(self)\n\n:param self: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_project_domain_on_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_project_domain_on_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.project_domain_on_params = project_domain_on_params

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`PwMultiAff`\n:param model: :class:`Space`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.align_params = align_params

    def drop_unused_params(self):
        'drop_unused_params(self)\n\n:param self: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_drop_unused_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_drop_unused_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.drop_unused_params = drop_unused_params

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.coalesce = coalesce

    def gist_params(self, set):
        'gist_params(self, set)\n\n:param self: :class:`PwMultiAff`\n:param set: :class:`Set`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_gist_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.gist_params = gist_params

    def gist(self, set):
        'gist(self, set)\n\n:param self: :class:`PwMultiAff`\n:param set: :class:`Set`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_gist(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.gist = gist

    def pullback_multi_aff(self, ma):
        'pullback_multi_aff(self, ma)\n\n:param self: :class:`PwMultiAff`\n:param ma: :class:`MultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_pullback_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_pullback_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.pullback_multi_aff = pullback_multi_aff

    def pullback_pw_multi_aff(self, pma2):
        'pullback_pw_multi_aff(self, pma2)\n\n:param self: :class:`PwMultiAff`\n:param pma2: :class:`PwMultiAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma2, PwMultiAff):
            raise IslTypeError("pma2 is not a PwMultiAff")
        if _ctx_data != pma2._ctx_data:
            raise Error("mismatched context in pma2")
        _copy_pma2 = pma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_pullback_pw_multi_aff(_copy_self._release(), _copy_pma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_pullback_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.pullback_pw_multi_aff = pullback_pw_multi_aff

    def n_piece(self):
        'n_piece(self)\n\n:param self: :class:`PwMultiAff`\n:return: isl_size'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_n_piece(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwMultiAff.n_piece = n_piece

    def foreach_piece(self, fn):
        'foreach_piece(self, fn)\n\n:param self: :class:`PwMultiAff`\n:param fn: callback(set, maff) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(set, maff, user):
            try:
                _py_set = Set(_data=set)
                _py_maff = MultiAff(_data=maff)
                _result = fn(_py_set, _py_maff)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_set *set,  isl_multi_aff *maff,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_foreach_piece(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_pw_multi_aff_foreach_piece\" failed: %s" % _get_last_error_str(_ctx_data))
        

    PwMultiAff.foreach_piece = foreach_piece

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`PwMultiAff`\n:return: string'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    PwMultiAff.to_str = to_str

    def from_set(set):
        'from_set(set)\n\n:param set: :class:`Set`\n:return: :class:`PwMultiAff`'

        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        _ctx_data = set._ctx_data
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_from_set(_copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_from_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.from_set = staticmethod(from_set)

    PwMultiAff._from_set_is_static = True

    def from_map(map):
        'from_map(map)\n\n:param map: :class:`Map`\n:return: :class:`PwMultiAff`'

        if isinstance(map, BasicMap):
            map = Map.from_basic_map(map)
        if not isinstance(map, Map):
            raise IslTypeError("map is not a Map")
        _ctx_data = map._ctx_data
        _copy_map = map._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_from_map(_copy_map._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_from_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.from_map = staticmethod(from_map)

    PwMultiAff._from_map_is_static = True

    def bind_domain(self, tuple):
        'bind_domain(self, tuple)\n\n:param self: :class:`PwMultiAff`\n:param tuple: :class:`MultiId`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(tuple, MultiId):
            raise IslTypeError("tuple is not a MultiId")
        if _ctx_data != tuple._ctx_data:
            raise Error("mismatched context in tuple")
        _copy_tuple = tuple._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_bind_domain(_copy_self._release(), _copy_tuple._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_bind_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.bind_domain = bind_domain

    def bind_domain_wrapped_domain(self, tuple):
        'bind_domain_wrapped_domain(self, tuple)\n\n:param self: :class:`PwMultiAff`\n:param tuple: :class:`MultiId`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(tuple, MultiId):
            raise IslTypeError("tuple is not a MultiId")
        if _ctx_data != tuple._ctx_data:
            raise Error("mismatched context in tuple")
        _copy_tuple = tuple._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_bind_domain_wrapped_domain(_copy_self._release(), _copy_tuple._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_bind_domain_wrapped_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.bind_domain_wrapped_domain = bind_domain_wrapped_domain

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`PwMultiAff`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.read_from_str = staticmethod(read_from_str)

    PwMultiAff._read_from_str_is_static = True

    def dump(self):
        'dump(self)\n\n:param self: :class:`PwMultiAff`\n:return: (nothing)'

        if not isinstance(self, PwMultiAff):
            raise IslTypeError("self is not a PwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_dump(self.data)
        finally:
            pass
        

    PwMultiAff.dump = dump

    def from_multi_pw_aff(mpa):
        'from_multi_pw_aff(mpa)\n\n:param mpa: :class:`MultiPwAff`\n:return: :class:`PwMultiAff`'

        if not isinstance(mpa, MultiPwAff):
            raise IslTypeError("mpa is not a MultiPwAff")
        _ctx_data = mpa._ctx_data
        _copy_mpa = mpa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_multi_aff_from_multi_pw_aff(_copy_mpa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_multi_aff_from_multi_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwMultiAff.from_multi_pw_aff = staticmethod(from_multi_pw_aff)

    PwMultiAff._from_multi_pw_aff_is_static = True

    # }}}

    # {{{ union_pw_multi_aff

    def empty(space):
        'empty(space)\n\n:param space: :class:`Space`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_empty(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_empty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.empty = staticmethod(empty)

    UnionPwMultiAff._empty_is_static = True

    def from_aff(aff):
        'from_aff(aff)\n\n:param aff: :class:`Aff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(aff, Aff):
            raise IslTypeError("aff is not a Aff")
        _ctx_data = aff._ctx_data
        _copy_aff = aff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_from_aff(_copy_aff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_from_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.from_aff = staticmethod(from_aff)

    UnionPwMultiAff._from_aff_is_static = True

    def from_pw_multi_aff(pma):
        'from_pw_multi_aff(pma)\n\n:param pma: :class:`PwMultiAff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        _ctx_data = pma._ctx_data
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_from_pw_multi_aff(_copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_from_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.from_pw_multi_aff = staticmethod(from_pw_multi_aff)

    UnionPwMultiAff._from_pw_multi_aff_is_static = True

    def from_domain(uset):
        'from_domain(uset)\n\n:param uset: :class:`UnionSet`\n:return: :class:`UnionPwMultiAff`'

        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        _ctx_data = uset._ctx_data
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_from_domain(_copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_from_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.from_domain = staticmethod(from_domain)

    UnionPwMultiAff._from_domain_is_static = True

    def multi_val_on_domain(domain, mv):
        'multi_val_on_domain(domain, mv)\n\n:param domain: :class:`UnionSet`\n:param mv: :class:`MultiVal`\n:return: :class:`UnionPwMultiAff`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if isinstance(domain, Set):
            domain = UnionSet.from_set(domain)
        if not isinstance(domain, UnionSet):
            raise IslTypeError("domain is not a UnionSet")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_multi_val_on_domain(_copy_domain._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_multi_val_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.multi_val_on_domain = staticmethod(multi_val_on_domain)

    UnionPwMultiAff._multi_val_on_domain_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`UnionPwMultiAff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.copy = copy

    def get_union_pw_aff(self, pos):
        'get_union_pw_aff(self, pos)\n\n:param self: :class:`UnionPwMultiAff`\n:param pos: :class:`int`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_get_union_pw_aff(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_get_union_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.get_union_pw_aff = get_union_pw_aff

    def add_pw_multi_aff(self, pma):
        'add_pw_multi_aff(self, pma)\n\n:param self: :class:`UnionPwMultiAff`\n:param pma: :class:`PwMultiAff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_add_pw_multi_aff(_copy_self._release(), _copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_add_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.add_pw_multi_aff = add_pw_multi_aff

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`UnionPwMultiAff`\n:return: :class:`Context`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.get_ctx = get_ctx

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`UnionPwMultiAff`\n:return: :class:`Space`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.get_space = get_space

    def get_pw_multi_aff_list(self):
        'get_pw_multi_aff_list(self)\n\n:param self: :class:`UnionPwMultiAff`\n:return: :class:`PwMultiAffList`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_get_pw_multi_aff_list(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAffList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_get_pw_multi_aff_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.get_pw_multi_aff_list = get_pw_multi_aff_list

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`UnionPwMultiAff`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionPwMultiAff.dim = dim

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`UnionPwMultiAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.set_dim_name = set_dim_name

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`UnionPwMultiAff`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionPwMultiAff.find_dim_by_name = find_dim_by_name

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`UnionPwMultiAff`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.drop_dims = drop_dims

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`UnionPwMultiAff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.reset_user = reset_user

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`UnionPwMultiAff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.coalesce = coalesce

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`UnionPwMultiAff`\n:param context: :class:`Set`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.gist_params = gist_params

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`UnionPwMultiAff`\n:param context: :class:`UnionSet`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if isinstance(context, Set):
            context = UnionSet.from_set(context)
        if not isinstance(context, UnionSet):
            raise IslTypeError("context is not a UnionSet")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.gist = gist

    def pullback_union_pw_multi_aff(self, upma2):
        'pullback_union_pw_multi_aff(self, upma2)\n\n:param self: :class:`UnionPwMultiAff`\n:param upma2: :class:`UnionPwMultiAff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upma2, UnionPwMultiAff):
            raise IslTypeError("upma2 is not a UnionPwMultiAff")
        if _ctx_data != upma2._ctx_data:
            raise Error("mismatched context in upma2")
        _copy_upma2 = upma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_pullback_union_pw_multi_aff(_copy_self._release(), _copy_upma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_pullback_union_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.pullback_union_pw_multi_aff = pullback_union_pw_multi_aff

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`UnionPwMultiAff`\n:param model: :class:`Space`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.align_params = align_params

    def n_pw_multi_aff(self):
        'n_pw_multi_aff(self)\n\n:param self: :class:`UnionPwMultiAff`\n:return: isl_size'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_n_pw_multi_aff(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionPwMultiAff.n_pw_multi_aff = n_pw_multi_aff

    def foreach_pw_multi_aff(self, fn):
        'foreach_pw_multi_aff(self, fn)\n\n:param self: :class:`UnionPwMultiAff`\n:param fn: callback(pma) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(pma, user):
            try:
                _py_pma = PwMultiAff(_data=pma)
                _result = fn(_py_pma)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_pw_multi_aff *pma,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_foreach_pw_multi_aff(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_union_pw_multi_aff_foreach_pw_multi_aff\" failed: %s" % _get_last_error_str(_ctx_data))
        

    UnionPwMultiAff.foreach_pw_multi_aff = foreach_pw_multi_aff

    def extract_pw_multi_aff(self, space):
        'extract_pw_multi_aff(self, space)\n\n:param self: :class:`UnionPwMultiAff`\n:param space: :class:`Space`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        if _ctx_data != space._ctx_data:
            raise Error("mismatched context in space")
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_extract_pw_multi_aff(self.data, _copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_extract_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.extract_pw_multi_aff = extract_pw_multi_aff

    def involves_nan(self):
        'involves_nan(self)\n\n:param self: :class:`UnionPwMultiAff`\n:return: bool'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_involves_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_pw_multi_aff_involves_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionPwMultiAff.involves_nan = involves_nan

    def plain_is_equal(self, upma2):
        'plain_is_equal(self, upma2)\n\n:param self: :class:`UnionPwMultiAff`\n:param upma2: :class:`UnionPwMultiAff`\n:return: bool'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(upma2, UnionPwMultiAff):
            raise IslTypeError("upma2 is not a UnionPwMultiAff")
        if _ctx_data != upma2._ctx_data:
            raise Error("mismatched context in upma2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_plain_is_equal(self.data, upma2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_pw_multi_aff_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionPwMultiAff.plain_is_equal = plain_is_equal

    def domain(self):
        'domain(self)\n\n:param self: :class:`UnionPwMultiAff`\n:return: :class:`UnionSet`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.domain = domain

    def neg(self):
        'neg(self)\n\n:param self: :class:`UnionPwMultiAff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.neg = neg

    def add(self, upma2):
        'add(self, upma2)\n\n:param self: :class:`UnionPwMultiAff`\n:param upma2: :class:`UnionPwMultiAff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upma2, UnionPwMultiAff):
            raise IslTypeError("upma2 is not a UnionPwMultiAff")
        if _ctx_data != upma2._ctx_data:
            raise Error("mismatched context in upma2")
        _copy_upma2 = upma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_add(_copy_self._release(), _copy_upma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.add = add

    def union_add(self, upma2):
        'union_add(self, upma2)\n\n:param self: :class:`UnionPwMultiAff`\n:param upma2: :class:`UnionPwMultiAff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upma2, UnionPwMultiAff):
            raise IslTypeError("upma2 is not a UnionPwMultiAff")
        if _ctx_data != upma2._ctx_data:
            raise Error("mismatched context in upma2")
        _copy_upma2 = upma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_union_add(_copy_self._release(), _copy_upma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_union_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.union_add = union_add

    def sub(self, upma2):
        'sub(self, upma2)\n\n:param self: :class:`UnionPwMultiAff`\n:param upma2: :class:`UnionPwMultiAff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upma2, UnionPwMultiAff):
            raise IslTypeError("upma2 is not a UnionPwMultiAff")
        if _ctx_data != upma2._ctx_data:
            raise Error("mismatched context in upma2")
        _copy_upma2 = upma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_sub(_copy_self._release(), _copy_upma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.sub = sub

    def scale_val(self, val):
        'scale_val(self, val)\n\n:param self: :class:`UnionPwMultiAff`\n:param val: :class:`Val`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(val, Val):
            if _ctx_data != val._ctx_data:
                raise Error("mismatched context in val")
            _val_val = val._copy()
        elif isinstance(val, six.integer_types):
            _cdata_val = lib.isl_val_int_from_si(
                self._get_ctx_data(), val)
        
            if _cdata_val == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_val = Val(_data=_cdata_val)
        
        else:
            raise IslTypeError("val is a %s and cannot "
                "be cast to a Val" % type(val))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_scale_val(_copy_self._release(), _val_val._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.scale_val = scale_val

    def scale_down_val(self, val):
        'scale_down_val(self, val)\n\n:param self: :class:`UnionPwMultiAff`\n:param val: :class:`Val`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(val, Val):
            if _ctx_data != val._ctx_data:
                raise Error("mismatched context in val")
            _val_val = val._copy()
        elif isinstance(val, six.integer_types):
            _cdata_val = lib.isl_val_int_from_si(
                self._get_ctx_data(), val)
        
            if _cdata_val == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_val = Val(_data=_cdata_val)
        
        else:
            raise IslTypeError("val is a %s and cannot "
                "be cast to a Val" % type(val))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_scale_down_val(_copy_self._release(), _val_val._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.scale_down_val = scale_down_val

    def scale_multi_val(self, mv):
        'scale_multi_val(self, mv)\n\n:param self: :class:`UnionPwMultiAff`\n:param mv: :class:`MultiVal`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_scale_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_scale_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.scale_multi_val = scale_multi_val

    def flat_range_product(self, upma2):
        'flat_range_product(self, upma2)\n\n:param self: :class:`UnionPwMultiAff`\n:param upma2: :class:`UnionPwMultiAff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upma2, UnionPwMultiAff):
            raise IslTypeError("upma2 is not a UnionPwMultiAff")
        if _ctx_data != upma2._ctx_data:
            raise Error("mismatched context in upma2")
        _copy_upma2 = upma2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_flat_range_product(_copy_self._release(), _copy_upma2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_flat_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.flat_range_product = flat_range_product

    def intersect_params(self, set):
        'intersect_params(self, set)\n\n:param self: :class:`UnionPwMultiAff`\n:param set: :class:`Set`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_intersect_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.intersect_params = intersect_params

    def intersect_domain(self, uset):
        'intersect_domain(self, uset)\n\n:param self: :class:`UnionPwMultiAff`\n:param uset: :class:`UnionSet`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_intersect_domain(_copy_self._release(), _copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.intersect_domain = intersect_domain

    def subtract_domain(self, uset):
        'subtract_domain(self, uset)\n\n:param self: :class:`UnionPwMultiAff`\n:param uset: :class:`UnionSet`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_subtract_domain(_copy_self._release(), _copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_subtract_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.subtract_domain = subtract_domain

    def from_union_set(uset):
        'from_union_set(uset)\n\n:param uset: :class:`UnionSet`\n:return: :class:`UnionPwMultiAff`'

        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        _ctx_data = uset._ctx_data
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_from_union_set(_copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_from_union_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.from_union_set = staticmethod(from_union_set)

    UnionPwMultiAff._from_union_set_is_static = True

    def from_union_map(umap):
        'from_union_map(umap)\n\n:param umap: :class:`UnionMap`\n:return: :class:`UnionPwMultiAff`'

        if isinstance(umap, BasicMap):
            umap = Map.from_basic_map(umap)
        if isinstance(umap, Map):
            umap = UnionMap.from_map(umap)
        if not isinstance(umap, UnionMap):
            raise IslTypeError("umap is not a UnionMap")
        _ctx_data = umap._ctx_data
        _copy_umap = umap._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_from_union_map(_copy_umap._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_from_union_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.from_union_map = staticmethod(from_union_map)

    UnionPwMultiAff._from_union_map_is_static = True

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.read_from_str = staticmethod(read_from_str)

    UnionPwMultiAff._read_from_str_is_static = True

    def dump(self):
        'dump(self)\n\n:param self: :class:`UnionPwMultiAff`\n:return: (nothing)'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_dump(self.data)
        finally:
            pass
        

    UnionPwMultiAff.dump = dump

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`UnionPwMultiAff`\n:return: string'

        if not isinstance(self, UnionPwMultiAff):
            raise IslTypeError("self is not a UnionPwMultiAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    UnionPwMultiAff.to_str = to_str

    def from_union_pw_aff(upa):
        'from_union_pw_aff(upa)\n\n:param upa: :class:`UnionPwAff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(upa, UnionPwAff):
            raise IslTypeError("upa is not a UnionPwAff")
        _ctx_data = upa._ctx_data
        _copy_upa = upa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_from_union_pw_aff(_copy_upa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_from_union_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.from_union_pw_aff = staticmethod(from_union_pw_aff)

    UnionPwMultiAff._from_union_pw_aff_is_static = True

    def from_multi_union_pw_aff(mupa):
        'from_multi_union_pw_aff(mupa)\n\n:param mupa: :class:`MultiUnionPwAff`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(mupa, MultiUnionPwAff):
            raise IslTypeError("mupa is not a MultiUnionPwAff")
        _ctx_data = mupa._ctx_data
        _copy_mupa = mupa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_multi_aff_from_multi_union_pw_aff(_copy_mupa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_multi_aff_from_multi_union_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwMultiAff.from_multi_union_pw_aff = staticmethod(from_multi_union_pw_aff)

    UnionPwMultiAff._from_multi_union_pw_aff_is_static = True

    # }}}

    # {{{ union_pw_aff_list

    # }}}

    # {{{ multi_union_pw_aff

    def from_multi_aff(ma):
        'from_multi_aff(ma)\n\n:param ma: :class:`MultiAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        _ctx_data = ma._ctx_data
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_from_multi_aff(_copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_from_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.from_multi_aff = staticmethod(from_multi_aff)

    MultiUnionPwAff._from_multi_aff_is_static = True

    def from_union_pw_aff(upa):
        'from_union_pw_aff(upa)\n\n:param upa: :class:`UnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(upa, UnionPwAff):
            raise IslTypeError("upa is not a UnionPwAff")
        _ctx_data = upa._ctx_data
        _copy_upa = upa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_from_union_pw_aff(_copy_upa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_from_union_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.from_union_pw_aff = staticmethod(from_union_pw_aff)

    MultiUnionPwAff._from_union_pw_aff_is_static = True

    def from_multi_pw_aff(mpa):
        'from_multi_pw_aff(mpa)\n\n:param mpa: :class:`MultiPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(mpa, MultiPwAff):
            raise IslTypeError("mpa is not a MultiPwAff")
        _ctx_data = mpa._ctx_data
        _copy_mpa = mpa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_from_multi_pw_aff(_copy_mpa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_from_multi_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.from_multi_pw_aff = staticmethod(from_multi_pw_aff)

    MultiUnionPwAff._from_multi_pw_aff_is_static = True

    def multi_val_on_domain(domain, mv):
        'multi_val_on_domain(domain, mv)\n\n:param domain: :class:`UnionSet`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiUnionPwAff`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if isinstance(domain, Set):
            domain = UnionSet.from_set(domain)
        if not isinstance(domain, UnionSet):
            raise IslTypeError("domain is not a UnionSet")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_multi_val_on_domain(_copy_domain._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_multi_val_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.multi_val_on_domain = staticmethod(multi_val_on_domain)

    MultiUnionPwAff._multi_val_on_domain_is_static = True

    def multi_aff_on_domain(domain, ma):
        'multi_aff_on_domain(domain, ma)\n\n:param domain: :class:`UnionSet`\n:param ma: :class:`MultiAff`\n:return: :class:`MultiUnionPwAff`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if isinstance(domain, Set):
            domain = UnionSet.from_set(domain)
        if not isinstance(domain, UnionSet):
            raise IslTypeError("domain is not a UnionSet")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_multi_aff_on_domain(_copy_domain._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_multi_aff_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.multi_aff_on_domain = staticmethod(multi_aff_on_domain)

    MultiUnionPwAff._multi_aff_on_domain_is_static = True

    def pw_multi_aff_on_domain(domain, pma):
        'pw_multi_aff_on_domain(domain, pma)\n\n:param domain: :class:`UnionSet`\n:param pma: :class:`PwMultiAff`\n:return: :class:`MultiUnionPwAff`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if isinstance(domain, Set):
            domain = UnionSet.from_set(domain)
        if not isinstance(domain, UnionSet):
            raise IslTypeError("domain is not a UnionSet")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_pw_multi_aff_on_domain(_copy_domain._release(), _copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_pw_multi_aff_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.pw_multi_aff_on_domain = staticmethod(pw_multi_aff_on_domain)

    MultiUnionPwAff._pw_multi_aff_on_domain_is_static = True

    def floor(self):
        'floor(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_floor(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_floor failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.floor = floor

    def intersect_domain(self, uset):
        'intersect_domain(self, uset)\n\n:param self: :class:`MultiUnionPwAff`\n:param uset: :class:`UnionSet`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_intersect_domain(_copy_self._release(), _copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.intersect_domain = intersect_domain

    def intersect_params(self, params):
        'intersect_params(self, params)\n\n:param self: :class:`MultiUnionPwAff`\n:param params: :class:`Set`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(params, BasicSet):
            params = Set.from_basic_set(params)
        if not isinstance(params, Set):
            raise IslTypeError("params is not a Set")
        if _ctx_data != params._ctx_data:
            raise Error("mismatched context in params")
        _copy_params = params._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_intersect_params(_copy_self._release(), _copy_params._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.intersect_params = intersect_params

    def intersect_range(self, set):
        'intersect_range(self, set)\n\n:param self: :class:`MultiUnionPwAff`\n:param set: :class:`Set`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_intersect_range(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_intersect_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.intersect_range = intersect_range

    def domain(self):
        'domain(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`UnionSet`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.domain = domain

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.coalesce = coalesce

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`MultiUnionPwAff`\n:param context: :class:`UnionSet`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if isinstance(context, Set):
            context = UnionSet.from_set(context)
        if not isinstance(context, UnionSet):
            raise IslTypeError("context is not a UnionSet")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.gist = gist

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`MultiUnionPwAff`\n:param context: :class:`Set`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.gist_params = gist_params

    def apply_aff(self, aff):
        'apply_aff(self, aff)\n\n:param self: :class:`MultiUnionPwAff`\n:param aff: :class:`Aff`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(aff, Aff):
            raise IslTypeError("aff is not a Aff")
        if _ctx_data != aff._ctx_data:
            raise Error("mismatched context in aff")
        _copy_aff = aff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_apply_aff(_copy_self._release(), _copy_aff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_apply_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.apply_aff = apply_aff

    def apply_multi_aff(self, ma):
        'apply_multi_aff(self, ma)\n\n:param self: :class:`MultiUnionPwAff`\n:param ma: :class:`MultiAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_apply_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_apply_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.apply_multi_aff = apply_multi_aff

    def apply_pw_aff(self, pa):
        'apply_pw_aff(self, pa)\n\n:param self: :class:`MultiUnionPwAff`\n:param pa: :class:`PwAff`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(pa, Aff):
            pa = PwAff.from_aff(pa)
        if not isinstance(pa, PwAff):
            raise IslTypeError("pa is not a PwAff")
        if _ctx_data != pa._ctx_data:
            raise Error("mismatched context in pa")
        _copy_pa = pa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_apply_pw_aff(_copy_self._release(), _copy_pa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_apply_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.apply_pw_aff = apply_pw_aff

    def apply_pw_multi_aff(self, pma):
        'apply_pw_multi_aff(self, pma)\n\n:param self: :class:`MultiUnionPwAff`\n:param pma: :class:`PwMultiAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_apply_pw_multi_aff(_copy_self._release(), _copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_apply_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.apply_pw_multi_aff = apply_pw_multi_aff

    def pullback_union_pw_multi_aff(self, upma):
        'pullback_union_pw_multi_aff(self, upma)\n\n:param self: :class:`MultiUnionPwAff`\n:param upma: :class:`UnionPwMultiAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upma, UnionPwMultiAff):
            raise IslTypeError("upma is not a UnionPwMultiAff")
        if _ctx_data != upma._ctx_data:
            raise Error("mismatched context in upma")
        _copy_upma = upma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_pullback_union_pw_multi_aff(_copy_self._release(), _copy_upma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_pullback_union_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.pullback_union_pw_multi_aff = pullback_union_pw_multi_aff

    def union_add(self, mupa2):
        'union_add(self, mupa2)\n\n:param self: :class:`MultiUnionPwAff`\n:param mupa2: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mupa2, MultiUnionPwAff):
            raise IslTypeError("mupa2 is not a MultiUnionPwAff")
        if _ctx_data != mupa2._ctx_data:
            raise Error("mismatched context in mupa2")
        _copy_mupa2 = mupa2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_union_add(_copy_self._release(), _copy_mupa2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_union_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.union_add = union_add

    def from_union_pw_multi_aff(upma):
        'from_union_pw_multi_aff(upma)\n\n:param upma: :class:`UnionPwMultiAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(upma, UnionPwMultiAff):
            raise IslTypeError("upma is not a UnionPwMultiAff")
        _ctx_data = upma._ctx_data
        _copy_upma = upma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_from_union_pw_multi_aff(_copy_upma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_from_union_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.from_union_pw_multi_aff = staticmethod(from_union_pw_multi_aff)

    MultiUnionPwAff._from_union_pw_multi_aff_is_static = True

    def from_union_map(umap):
        'from_union_map(umap)\n\n:param umap: :class:`UnionMap`\n:return: :class:`MultiUnionPwAff`'

        if isinstance(umap, BasicMap):
            umap = Map.from_basic_map(umap)
        if isinstance(umap, Map):
            umap = UnionMap.from_map(umap)
        if not isinstance(umap, UnionMap):
            raise IslTypeError("umap is not a UnionMap")
        _ctx_data = umap._ctx_data
        _copy_umap = umap._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_from_union_map(_copy_umap._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_from_union_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.from_union_map = staticmethod(from_union_map)

    MultiUnionPwAff._from_union_map_is_static = True

    def zero_union_set(self):
        'zero_union_set(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`UnionSet`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_zero_union_set(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_zero_union_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.zero_union_set = zero_union_set

    def bind(self, tuple):
        'bind(self, tuple)\n\n:param self: :class:`MultiUnionPwAff`\n:param tuple: :class:`MultiId`\n:return: :class:`UnionSet`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(tuple, MultiId):
            raise IslTypeError("tuple is not a MultiId")
        if _ctx_data != tuple._ctx_data:
            raise Error("mismatched context in tuple")
        _copy_tuple = tuple._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_bind(_copy_self._release(), _copy_tuple._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_bind failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.bind = bind

    def extract_multi_pw_aff(self, space):
        'extract_multi_pw_aff(self, space)\n\n:param self: :class:`MultiUnionPwAff`\n:param space: :class:`Space`\n:return: :class:`MultiPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        if _ctx_data != space._ctx_data:
            raise Error("mismatched context in space")
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_extract_multi_pw_aff(self.data, _copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_extract_multi_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.extract_multi_pw_aff = extract_multi_pw_aff

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.read_from_str = staticmethod(read_from_str)

    MultiUnionPwAff._read_from_str_is_static = True

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: string'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    MultiUnionPwAff.to_str = to_str

    def dump(self):
        'dump(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: (nothing)'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_dump(self.data)
        finally:
            pass
        

    MultiUnionPwAff.dump = dump

    def min_multi_val(self):
        'min_multi_val(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_min_multi_val(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_min_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.min_multi_val = min_multi_val

    def max_multi_val(self):
        'max_multi_val(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`MultiVal`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_max_multi_val(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_max_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.max_multi_val = max_multi_val

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`MultiUnionPwAff`\n:param type: :class:`dim_type`\n:return: unsigned'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiUnionPwAff.dim = dim

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`Context`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.get_ctx = get_ctx

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`Space`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.get_space = get_space

    def get_domain_space(self):
        'get_domain_space(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`Space`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_get_domain_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_get_domain_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.get_domain_space = get_domain_space

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`MultiUnionPwAff`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiUnionPwAff.find_dim_by_name = find_dim_by_name

    def from_union_pw_aff_list(space, list):
        'from_union_pw_aff_list(space, list)\n\n:param space: :class:`Space`\n:param list: :class:`UnionPwAffList`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        
        if not isinstance(list, UnionPwAffList):
            raise IslTypeError("list is not a UnionPwAffList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        _copy_list = list._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_from_union_pw_aff_list(_copy_space._release(), _copy_list._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_from_union_pw_aff_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.from_union_pw_aff_list = staticmethod(from_union_pw_aff_list)

    MultiUnionPwAff._from_union_pw_aff_list_is_static = True

    def zero(space):
        'zero(space)\n\n:param space: :class:`Space`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_zero(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_zero failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.zero = staticmethod(zero)

    MultiUnionPwAff._zero_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.copy = copy

    def plain_is_equal(self, multi2):
        'plain_is_equal(self, multi2)\n\n:param self: :class:`MultiUnionPwAff`\n:param multi2: :class:`MultiUnionPwAff`\n:return: bool'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        
        if not isinstance(multi2, MultiUnionPwAff):
            raise IslTypeError("multi2 is not a MultiUnionPwAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_plain_is_equal(self.data, multi2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_union_pw_aff_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiUnionPwAff.plain_is_equal = plain_is_equal

    def involves_nan(self):
        'involves_nan(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: bool'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_involves_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_union_pw_aff_involves_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiUnionPwAff.involves_nan = involves_nan

    def find_dim_by_id(self, type, id):
        'find_dim_by_id(self, type, id)\n\n:param self: :class:`MultiUnionPwAff`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: int'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_find_dim_by_id(self.data, type, id.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    MultiUnionPwAff.find_dim_by_id = find_dim_by_id

    def get_dim_id(self, type, pos):
        'get_dim_id(self, type, pos)\n\n:param self: :class:`MultiUnionPwAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Id`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_get_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_get_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.get_dim_id = get_dim_id

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`MultiUnionPwAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.set_dim_name = set_dim_name

    def set_dim_id(self, type, pos, id):
        'set_dim_id(self, type, pos, id)\n\n:param self: :class:`MultiUnionPwAff`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param id: :class:`Id`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_set_dim_id(_copy_self._release(), type, pos, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_set_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.set_dim_id = set_dim_id

    def get_tuple_name(self, type):
        'get_tuple_name(self, type)\n\n:param self: :class:`MultiUnionPwAff`\n:param type: :class:`dim_type`\n:return: string'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_get_tuple_name(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    MultiUnionPwAff.get_tuple_name = get_tuple_name

    def has_tuple_id(self, type):
        'has_tuple_id(self, type)\n\n:param self: :class:`MultiUnionPwAff`\n:param type: :class:`dim_type`\n:return: bool'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_has_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_union_pw_aff_has_tuple_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiUnionPwAff.has_tuple_id = has_tuple_id

    def get_tuple_id(self, type):
        'get_tuple_id(self, type)\n\n:param self: :class:`MultiUnionPwAff`\n:param type: :class:`dim_type`\n:return: :class:`Id`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_get_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_get_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.get_tuple_id = get_tuple_id

    def set_tuple_name(self, type, s):
        'set_tuple_name(self, type, s)\n\n:param self: :class:`MultiUnionPwAff`\n:param type: :class:`dim_type`\n:param s: string\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_set_tuple_name(_copy_self._release(), type, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_set_tuple_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.set_tuple_name = set_tuple_name

    def set_tuple_id(self, type, id):
        'set_tuple_id(self, type, id)\n\n:param self: :class:`MultiUnionPwAff`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_set_tuple_id(_copy_self._release(), type, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_set_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.set_tuple_id = set_tuple_id

    def reset_tuple_id(self, type):
        'reset_tuple_id(self, type)\n\n:param self: :class:`MultiUnionPwAff`\n:param type: :class:`dim_type`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_reset_tuple_id(_copy_self._release(), type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_reset_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.reset_tuple_id = reset_tuple_id

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.reset_user = reset_user

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`MultiUnionPwAff`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.drop_dims = drop_dims

    def get_union_pw_aff(self, pos):
        'get_union_pw_aff(self, pos)\n\n:param self: :class:`MultiUnionPwAff`\n:param pos: :class:`int`\n:return: :class:`UnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_get_union_pw_aff(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_get_union_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.get_union_pw_aff = get_union_pw_aff

    def set_union_pw_aff(self, pos, el):
        'set_union_pw_aff(self, pos, el)\n\n:param self: :class:`MultiUnionPwAff`\n:param pos: :class:`int`\n:param el: :class:`UnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(el, UnionPwAff):
            raise IslTypeError("el is not a UnionPwAff")
        if _ctx_data != el._ctx_data:
            raise Error("mismatched context in el")
        _copy_el = el._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_set_union_pw_aff(_copy_self._release(), pos, _copy_el._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_set_union_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.set_union_pw_aff = set_union_pw_aff

    def range_splice(self, pos, multi2):
        'range_splice(self, pos, multi2)\n\n:param self: :class:`MultiUnionPwAff`\n:param pos: :class:`unsigned`\n:param multi2: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(multi2, MultiUnionPwAff):
            raise IslTypeError("multi2 is not a MultiUnionPwAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_range_splice(_copy_self._release(), pos, _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_range_splice failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.range_splice = range_splice

    def flatten_range(self):
        'flatten_range(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_flatten_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_flatten_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.flatten_range = flatten_range

    def flat_range_product(self, multi2):
        'flat_range_product(self, multi2)\n\n:param self: :class:`MultiUnionPwAff`\n:param multi2: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiUnionPwAff):
            raise IslTypeError("multi2 is not a MultiUnionPwAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_flat_range_product(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_flat_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.flat_range_product = flat_range_product

    def range_product(self, multi2):
        'range_product(self, multi2)\n\n:param self: :class:`MultiUnionPwAff`\n:param multi2: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiUnionPwAff):
            raise IslTypeError("multi2 is not a MultiUnionPwAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_range_product(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.range_product = range_product

    def factor_range(self):
        'factor_range(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.factor_range = factor_range

    def range_is_wrapping(self):
        'range_is_wrapping(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: bool'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_range_is_wrapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_multi_union_pw_aff_range_is_wrapping\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    MultiUnionPwAff.range_is_wrapping = range_is_wrapping

    def range_factor_domain(self):
        'range_factor_domain(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_range_factor_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_range_factor_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.range_factor_domain = range_factor_domain

    def range_factor_range(self):
        'range_factor_range(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_range_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_range_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.range_factor_range = range_factor_range

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`MultiUnionPwAff`\n:param v: :class:`Val`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.scale_val = scale_val

    def scale_down_val(self, v):
        'scale_down_val(self, v)\n\n:param self: :class:`MultiUnionPwAff`\n:param v: :class:`Val`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_scale_down_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.scale_down_val = scale_down_val

    def scale_multi_val(self, mv):
        'scale_multi_val(self, mv)\n\n:param self: :class:`MultiUnionPwAff`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_scale_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_scale_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.scale_multi_val = scale_multi_val

    def scale_down_multi_val(self, mv):
        'scale_down_multi_val(self, mv)\n\n:param self: :class:`MultiUnionPwAff`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_scale_down_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_scale_down_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.scale_down_multi_val = scale_down_multi_val

    def mod_multi_val(self, mv):
        'mod_multi_val(self, mv)\n\n:param self: :class:`MultiUnionPwAff`\n:param mv: :class:`MultiVal`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_mod_multi_val(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_mod_multi_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.mod_multi_val = mod_multi_val

    def add(self, multi2):
        'add(self, multi2)\n\n:param self: :class:`MultiUnionPwAff`\n:param multi2: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiUnionPwAff):
            raise IslTypeError("multi2 is not a MultiUnionPwAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_add(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.add = add

    def sub(self, multi2):
        'sub(self, multi2)\n\n:param self: :class:`MultiUnionPwAff`\n:param multi2: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(multi2, MultiUnionPwAff):
            raise IslTypeError("multi2 is not a MultiUnionPwAff")
        if _ctx_data != multi2._ctx_data:
            raise Error("mismatched context in multi2")
        _copy_multi2 = multi2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_sub(_copy_self._release(), _copy_multi2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.sub = sub

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`MultiUnionPwAff`\n:param model: :class:`Space`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.align_params = align_params

    def from_range(self):
        'from_range(self)\n\n:param self: :class:`MultiUnionPwAff`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, MultiUnionPwAff):
            raise IslTypeError("self is not a MultiUnionPwAff")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_union_pw_aff_from_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_union_pw_aff_from_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiUnionPwAff.from_range = from_range

    # }}}

    # {{{ id

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Id`\n:return: :class:`Context`'

        if not isinstance(self, Id):
            raise IslTypeError("self is not a Id")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Id.get_ctx = get_ctx

    def get_hash(self):
        'get_hash(self)\n\n:param self: :class:`Id`\n:return: uint32_t'

        if not isinstance(self, Id):
            raise IslTypeError("self is not a Id")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_get_hash(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Id.get_hash = get_hash

    def alloc(ctx, name, user):
        'alloc(ctx, name, user)\n\n:param ctx: :class:`Context`\n:param name: string\n:param user: None\n:return: :class:`Id`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_name = ffi.new("char[]", name.encode())
        
        if user is not None:
            raise Error("passing non-None arguments for 'user' "
                "is not yet supported")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_alloc(ctx.data, _cstr_name, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Id.alloc = staticmethod(alloc)

    Id._alloc_is_static = True

    def get_name(self):
        'get_name(self)\n\n:param self: :class:`Id`\n:return: string'

        if not isinstance(self, Id):
            raise IslTypeError("self is not a Id")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_get_name(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Id.get_name = get_name

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`Id`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_id_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Id.read_from_str = staticmethod(read_from_str)

    Id._read_from_str_is_static = True

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`Id`\n:return: string'

        if not isinstance(self, Id):
            raise IslTypeError("self is not a Id")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Id.to_str = to_str

    def dump(self):
        'dump(self)\n\n:param self: :class:`Id`\n:return: (nothing)'

        if not isinstance(self, Id):
            raise IslTypeError("self is not a Id")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_id_dump(self.data)
        finally:
            pass
        

    Id.dump = dump

    # }}}

    # {{{ multi_id

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`MultiId`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_id_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiId(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_multi_id_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    MultiId.read_from_str = staticmethod(read_from_str)

    MultiId._read_from_str_is_static = True

    def dump(self):
        'dump(self)\n\n:param self: :class:`MultiId`\n:return: (nothing)'

        if not isinstance(self, MultiId):
            raise IslTypeError("self is not a MultiId")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_id_dump(self.data)
        finally:
            pass
        

    MultiId.dump = dump

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`MultiId`\n:return: string'

        if not isinstance(self, MultiId):
            raise IslTypeError("self is not a MultiId")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_multi_id_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    MultiId.to_str = to_str

    # }}}

    # {{{ constraint

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Constraint`\n:return: :class:`Context`'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.get_ctx = get_ctx

    def alloc_equality(ls):
        'alloc_equality(ls)\n\n:param ls: :class:`LocalSpace`\n:return: :class:`Constraint`'

        if isinstance(ls, Space):
            ls = LocalSpace.from_space(ls)
        if not isinstance(ls, LocalSpace):
            raise IslTypeError("ls is not a LocalSpace")
        _ctx_data = ls._ctx_data
        _copy_ls = ls._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_alloc_equality(_copy_ls._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Constraint(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_alloc_equality failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.alloc_equality = staticmethod(alloc_equality)

    Constraint._alloc_equality_is_static = True

    def alloc_inequality(ls):
        'alloc_inequality(ls)\n\n:param ls: :class:`LocalSpace`\n:return: :class:`Constraint`'

        if isinstance(ls, Space):
            ls = LocalSpace.from_space(ls)
        if not isinstance(ls, LocalSpace):
            raise IslTypeError("ls is not a LocalSpace")
        _ctx_data = ls._ctx_data
        _copy_ls = ls._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_alloc_inequality(_copy_ls._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Constraint(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_alloc_inequality failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.alloc_inequality = staticmethod(alloc_inequality)

    Constraint._alloc_inequality_is_static = True

    def equality_alloc(ls):
        'equality_alloc(ls)\n\n:param ls: :class:`LocalSpace`\n:return: :class:`Constraint`'

        if isinstance(ls, Space):
            ls = LocalSpace.from_space(ls)
        if not isinstance(ls, LocalSpace):
            raise IslTypeError("ls is not a LocalSpace")
        _ctx_data = ls._ctx_data
        _copy_ls = ls._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_equality_alloc(_copy_ls._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Constraint(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_equality_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.equality_alloc = staticmethod(equality_alloc)

    Constraint._equality_alloc_is_static = True

    def inequality_alloc(ls):
        'inequality_alloc(ls)\n\n:param ls: :class:`LocalSpace`\n:return: :class:`Constraint`'

        if isinstance(ls, Space):
            ls = LocalSpace.from_space(ls)
        if not isinstance(ls, LocalSpace):
            raise IslTypeError("ls is not a LocalSpace")
        _ctx_data = ls._ctx_data
        _copy_ls = ls._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_inequality_alloc(_copy_ls._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Constraint(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_inequality_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.inequality_alloc = staticmethod(inequality_alloc)

    Constraint._inequality_alloc_is_static = True

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`Constraint`\n:return: :class:`Space`'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.get_space = get_space

    def get_local_space(self):
        'get_local_space(self)\n\n:param self: :class:`Constraint`\n:return: :class:`LocalSpace`'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_get_local_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_get_local_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.get_local_space = get_local_space

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`Constraint`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Constraint.dim = dim

    def involves_dims(self, type, first, n):
        'involves_dims(self, type, first, n)\n\n:param self: :class:`Constraint`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: bool'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_involves_dims(self.data, type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_constraint_involves_dims\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Constraint.involves_dims = involves_dims

    def get_dim_name(self, type, pos):
        'get_dim_name(self, type, pos)\n\n:param self: :class:`Constraint`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: string'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_get_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Constraint.get_dim_name = get_dim_name

    def get_constant_val(self):
        'get_constant_val(self)\n\n:param self: :class:`Constraint`\n:return: :class:`Val`'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_get_constant_val(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_get_constant_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.get_constant_val = get_constant_val

    def get_coefficient_val(self, type, pos):
        'get_coefficient_val(self, type, pos)\n\n:param self: :class:`Constraint`\n:param type: :class:`dim_type`\n:param pos: :class:`int`\n:return: :class:`Val`'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_get_coefficient_val(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_get_coefficient_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.get_coefficient_val = get_coefficient_val

    def set_constant_val(self, v):
        'set_constant_val(self, v)\n\n:param self: :class:`Constraint`\n:param v: :class:`Val`\n:return: :class:`Constraint`'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_set_constant_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Constraint(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_set_constant_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.set_constant_val = set_constant_val

    def set_coefficient_val(self, type, pos, v):
        'set_coefficient_val(self, type, pos, v)\n\n:param self: :class:`Constraint`\n:param type: :class:`dim_type`\n:param pos: :class:`int`\n:param v: :class:`Val`\n:return: :class:`Constraint`'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_set_coefficient_val(_copy_self._release(), type, pos, _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Constraint(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_set_coefficient_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.set_coefficient_val = set_coefficient_val

    def get_div(self, pos):
        'get_div(self, pos)\n\n:param self: :class:`Constraint`\n:param pos: :class:`int`\n:return: :class:`Aff`'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_get_div(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_get_div failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.get_div = get_div

    def is_equality(self):
        'is_equality(self)\n\n:param self: :class:`Constraint`\n:return: bool'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_is_equality(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_constraint_is_equality\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Constraint.is_equality = is_equality

    def is_div_constraint(self):
        'is_div_constraint(self)\n\n:param self: :class:`Constraint`\n:return: bool'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_is_div_constraint(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_constraint_is_div_constraint\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Constraint.is_div_constraint = is_div_constraint

    def is_lower_bound(self, type, pos):
        'is_lower_bound(self, type, pos)\n\n:param self: :class:`Constraint`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_is_lower_bound(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_constraint_is_lower_bound\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Constraint.is_lower_bound = is_lower_bound

    def is_upper_bound(self, type, pos):
        'is_upper_bound(self, type, pos)\n\n:param self: :class:`Constraint`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_is_upper_bound(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_constraint_is_upper_bound\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Constraint.is_upper_bound = is_upper_bound

    def get_bound(self, type, pos):
        'get_bound(self, type, pos)\n\n:param self: :class:`Constraint`\n:param type: :class:`dim_type`\n:param pos: :class:`int`\n:return: :class:`Aff`'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_get_bound(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_get_bound failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.get_bound = get_bound

    def get_aff(self):
        'get_aff(self)\n\n:param self: :class:`Constraint`\n:return: :class:`Aff`'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_get_aff(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_constraint_get_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.get_aff = get_aff

    def equality_from_aff(aff):
        'equality_from_aff(aff)\n\n:param aff: :class:`Aff`\n:return: :class:`Constraint`'

        if not isinstance(aff, Aff):
            raise IslTypeError("aff is not a Aff")
        _ctx_data = aff._ctx_data
        _copy_aff = aff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_equality_from_aff(_copy_aff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Constraint(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_equality_from_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.equality_from_aff = staticmethod(equality_from_aff)

    Constraint._equality_from_aff_is_static = True

    def inequality_from_aff(aff):
        'inequality_from_aff(aff)\n\n:param aff: :class:`Aff`\n:return: :class:`Constraint`'

        if not isinstance(aff, Aff):
            raise IslTypeError("aff is not a Aff")
        _ctx_data = aff._ctx_data
        _copy_aff = aff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_inequality_from_aff(_copy_aff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Constraint(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_inequality_from_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Constraint.inequality_from_aff = staticmethod(inequality_from_aff)

    Constraint._inequality_from_aff_is_static = True

    def plain_cmp(self, c2):
        'plain_cmp(self, c2)\n\n:param self: :class:`Constraint`\n:param c2: :class:`Constraint`\n:return: int'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        
        if not isinstance(c2, Constraint):
            raise IslTypeError("c2 is not a Constraint")
        if _ctx_data != c2._ctx_data:
            raise Error("mismatched context in c2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_plain_cmp(self.data, c2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Constraint.plain_cmp = plain_cmp

    def cmp_last_non_zero(self, c2):
        'cmp_last_non_zero(self, c2)\n\n:param self: :class:`Constraint`\n:param c2: :class:`Constraint`\n:return: int'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        
        if not isinstance(c2, Constraint):
            raise IslTypeError("c2 is not a Constraint")
        if _ctx_data != c2._ctx_data:
            raise Error("mismatched context in c2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_cmp_last_non_zero(self.data, c2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Constraint.cmp_last_non_zero = cmp_last_non_zero

    def dump(self):
        'dump(self)\n\n:param self: :class:`Constraint`\n:return: (nothing)'

        if not isinstance(self, Constraint):
            raise IslTypeError("self is not a Constraint")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_constraint_dump(self.data)
        finally:
            pass
        

    Constraint.dump = dump

    # }}}

    # {{{ space

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Space`\n:return: :class:`Context`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.get_ctx = get_ctx

    def unit(ctx):
        'unit(ctx)\n\n:param ctx: :class:`Context`\n:return: :class:`Space`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_unit(ctx.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_unit failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.unit = staticmethod(unit)

    Space._unit_is_static = True

    def alloc(ctx, nparam, n_in, n_out):
        'alloc(ctx, nparam, n_in, n_out)\n\n:param ctx: :class:`Context`\n:param nparam: :class:`unsigned`\n:param n_in: :class:`unsigned`\n:param n_out: :class:`unsigned`\n:return: :class:`Space`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for nparam
        
        # no argument processing for n_in
        
        # no argument processing for n_out
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_alloc(ctx.data, nparam, n_in, n_out)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.alloc = staticmethod(alloc)

    Space._alloc_is_static = True

    def set_alloc(ctx, nparam, dim):
        'set_alloc(ctx, nparam, dim)\n\n:param ctx: :class:`Context`\n:param nparam: :class:`unsigned`\n:param dim: :class:`unsigned`\n:return: :class:`Space`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for nparam
        
        # no argument processing for dim
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_set_alloc(ctx.data, nparam, dim)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_set_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.set_alloc = staticmethod(set_alloc)

    Space._set_alloc_is_static = True

    def params_alloc(ctx, nparam):
        'params_alloc(ctx, nparam)\n\n:param ctx: :class:`Context`\n:param nparam: :class:`unsigned`\n:return: :class:`Space`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        # no argument processing for nparam
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_params_alloc(ctx.data, nparam)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_params_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.params_alloc = staticmethod(params_alloc)

    Space._params_alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.copy = copy

    def is_params(self):
        'is_params(self)\n\n:param self: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_is_params(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_is_params\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.is_params = is_params

    def is_set(self):
        'is_set(self)\n\n:param self: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_is_set(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_is_set\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.is_set = is_set

    def is_map(self):
        'is_map(self)\n\n:param self: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_is_map(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_is_map\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.is_map = is_map

    def add_param_id(self, id):
        'add_param_id(self, id)\n\n:param self: :class:`Space`\n:param id: :class:`Id`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_add_param_id(_copy_self._release(), _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_add_param_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.add_param_id = add_param_id

    def set_tuple_name(self, type, s):
        'set_tuple_name(self, type, s)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:param s: string\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_set_tuple_name(_copy_self._release(), type, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_set_tuple_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.set_tuple_name = set_tuple_name

    def has_tuple_name(self, type):
        'has_tuple_name(self, type)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_has_tuple_name(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_has_tuple_name\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.has_tuple_name = has_tuple_name

    def get_tuple_name(self, type):
        'get_tuple_name(self, type)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:return: string'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_get_tuple_name(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Space.get_tuple_name = get_tuple_name

    def set_tuple_id(self, type, id):
        'set_tuple_id(self, type, id)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_set_tuple_id(_copy_self._release(), type, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_set_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.set_tuple_id = set_tuple_id

    def reset_tuple_id(self, type):
        'reset_tuple_id(self, type)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_reset_tuple_id(_copy_self._release(), type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_reset_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.reset_tuple_id = reset_tuple_id

    def has_tuple_id(self, type):
        'has_tuple_id(self, type)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_has_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_has_tuple_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.has_tuple_id = has_tuple_id

    def get_tuple_id(self, type):
        'get_tuple_id(self, type)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:return: :class:`Id`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_get_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_get_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.get_tuple_id = get_tuple_id

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.reset_user = reset_user

    def set_dim_id(self, type, pos, id):
        'set_dim_id(self, type, pos, id)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param id: :class:`Id`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_set_dim_id(_copy_self._release(), type, pos, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_set_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.set_dim_id = set_dim_id

    def has_dim_id(self, type, pos):
        'has_dim_id(self, type, pos)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_has_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_has_dim_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.has_dim_id = has_dim_id

    def get_dim_id(self, type, pos):
        'get_dim_id(self, type, pos)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Id`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_get_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_get_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.get_dim_id = get_dim_id

    def find_dim_by_id(self, type, id):
        'find_dim_by_id(self, type, id)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: int'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_find_dim_by_id(self.data, type, id.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Space.find_dim_by_id = find_dim_by_id

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Space.find_dim_by_name = find_dim_by_name

    def has_dim_name(self, type, pos):
        'has_dim_name(self, type, pos)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_has_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_has_dim_name\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.has_dim_name = has_dim_name

    def set_dim_name(self, type, pos, name):
        'set_dim_name(self, type, pos, name)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param name: string\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_set_dim_name(_copy_self._release(), type, pos, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.set_dim_name = set_dim_name

    def get_dim_name(self, type, pos):
        'get_dim_name(self, type, pos)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: string'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_get_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Space.get_dim_name = get_dim_name

    def extend(self, nparam, n_in, n_out):
        'extend(self, nparam, n_in, n_out)\n\n:param self: :class:`Space`\n:param nparam: :class:`unsigned`\n:param n_in: :class:`unsigned`\n:param n_out: :class:`unsigned`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for nparam
        
        # no argument processing for n_in
        
        # no argument processing for n_out
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_extend(_copy_self._release(), nparam, n_in, n_out)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_extend failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.extend = extend

    def add_dims(self, type, n):
        'add_dims(self, type, n)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:param n: :class:`unsigned`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_add_dims(_copy_self._release(), type, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_add_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.add_dims = add_dims

    def move_dims(self, dst_type, dst_pos, src_type, src_pos, n):
        'move_dims(self, dst_type, dst_pos, src_type, src_pos, n)\n\n:param self: :class:`Space`\n:param dst_type: :class:`dim_type`\n:param dst_pos: :class:`unsigned`\n:param src_type: :class:`dim_type`\n:param src_pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_type
        
        # no argument processing for dst_pos
        
        # no argument processing for src_type
        
        # no argument processing for src_pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_move_dims(_copy_self._release(), dst_type, dst_pos, src_type, src_pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_move_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.move_dims = move_dims

    def insert_dims(self, type, pos, n):
        'insert_dims(self, type, pos, n)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_insert_dims(_copy_self._release(), type, pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_insert_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.insert_dims = insert_dims

    def join(self, right):
        'join(self, right)\n\n:param self: :class:`Space`\n:param right: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(right, Space):
            raise IslTypeError("right is not a Space")
        if _ctx_data != right._ctx_data:
            raise Error("mismatched context in right")
        _copy_right = right._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_join(_copy_self._release(), _copy_right._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_join failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.join = join

    def product(self, right):
        'product(self, right)\n\n:param self: :class:`Space`\n:param right: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(right, Space):
            raise IslTypeError("right is not a Space")
        if _ctx_data != right._ctx_data:
            raise Error("mismatched context in right")
        _copy_right = right._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_product(_copy_self._release(), _copy_right._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.product = product

    def domain_product(self, right):
        'domain_product(self, right)\n\n:param self: :class:`Space`\n:param right: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(right, Space):
            raise IslTypeError("right is not a Space")
        if _ctx_data != right._ctx_data:
            raise Error("mismatched context in right")
        _copy_right = right._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_domain_product(_copy_self._release(), _copy_right._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_domain_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.domain_product = domain_product

    def range_product(self, right):
        'range_product(self, right)\n\n:param self: :class:`Space`\n:param right: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(right, Space):
            raise IslTypeError("right is not a Space")
        if _ctx_data != right._ctx_data:
            raise Error("mismatched context in right")
        _copy_right = right._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_range_product(_copy_self._release(), _copy_right._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.range_product = range_product

    def factor_domain(self):
        'factor_domain(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_factor_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_factor_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.factor_domain = factor_domain

    def factor_range(self):
        'factor_range(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.factor_range = factor_range

    def domain_factor_domain(self):
        'domain_factor_domain(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_domain_factor_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_domain_factor_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.domain_factor_domain = domain_factor_domain

    def domain_factor_range(self):
        'domain_factor_range(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_domain_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_domain_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.domain_factor_range = domain_factor_range

    def range_factor_domain(self):
        'range_factor_domain(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_range_factor_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_range_factor_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.range_factor_domain = range_factor_domain

    def range_factor_range(self):
        'range_factor_range(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_range_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_range_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.range_factor_range = range_factor_range

    def map_from_set(self):
        'map_from_set(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_map_from_set(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_map_from_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.map_from_set = map_from_set

    def map_from_domain_and_range(self, range):
        'map_from_domain_and_range(self, range)\n\n:param self: :class:`Space`\n:param range: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(range, Space):
            raise IslTypeError("range is not a Space")
        if _ctx_data != range._ctx_data:
            raise Error("mismatched context in range")
        _copy_range = range._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_map_from_domain_and_range(_copy_self._release(), _copy_range._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_map_from_domain_and_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.map_from_domain_and_range = map_from_domain_and_range

    def reverse(self):
        'reverse(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_reverse(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_reverse failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.reverse = reverse

    def drop_dims(self, type, first, num):
        'drop_dims(self, type, first, num)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param num: :class:`unsigned`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for num
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_drop_dims(_copy_self._release(), type, first, num)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.drop_dims = drop_dims

    def drop_inputs(self, first, n):
        'drop_inputs(self, first, n)\n\n:param self: :class:`Space`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_drop_inputs(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_drop_inputs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.drop_inputs = drop_inputs

    def drop_outputs(self, first, n):
        'drop_outputs(self, first, n)\n\n:param self: :class:`Space`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_drop_outputs(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_drop_outputs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.drop_outputs = drop_outputs

    def drop_all_params(self):
        'drop_all_params(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_drop_all_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_drop_all_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.drop_all_params = drop_all_params

    def domain(self):
        'domain(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.domain = domain

    def from_domain(self):
        'from_domain(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_from_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_from_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.from_domain = from_domain

    def range(self):
        'range(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.range = range

    def from_range(self):
        'from_range(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_from_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_from_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.from_range = from_range

    def domain_map(self):
        'domain_map(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_domain_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_domain_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.domain_map = domain_map

    def range_map(self):
        'range_map(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_range_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_range_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.range_map = range_map

    def params(self):
        'params(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.params = params

    def add_unnamed_tuple_ui(self, dim):
        'add_unnamed_tuple_ui(self, dim)\n\n:param self: :class:`Space`\n:param dim: :class:`unsigned`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dim
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_add_unnamed_tuple_ui(_copy_self._release(), dim)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_add_unnamed_tuple_ui failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.add_unnamed_tuple_ui = add_unnamed_tuple_ui

    def add_named_tuple_id_ui(self, tuple_id, dim):
        'add_named_tuple_id_ui(self, tuple_id, dim)\n\n:param self: :class:`Space`\n:param tuple_id: :class:`Id`\n:param dim: :class:`unsigned`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(tuple_id, Id):
            raise IslTypeError("tuple_id is not a Id")
        if _ctx_data != tuple_id._ctx_data:
            raise Error("mismatched context in tuple_id")
        _copy_tuple_id = tuple_id._copy()
        
        # no argument processing for dim
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_add_named_tuple_id_ui(_copy_self._release(), _copy_tuple_id._release(), dim)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_add_named_tuple_id_ui failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.add_named_tuple_id_ui = add_named_tuple_id_ui

    def set_from_params(self):
        'set_from_params(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_set_from_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_set_from_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.set_from_params = set_from_params

    def align_params(self, dim2):
        'align_params(self, dim2)\n\n:param self: :class:`Space`\n:param dim2: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(dim2, Space):
            raise IslTypeError("dim2 is not a Space")
        if _ctx_data != dim2._ctx_data:
            raise Error("mismatched context in dim2")
        _copy_dim2 = dim2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_align_params(_copy_self._release(), _copy_dim2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.align_params = align_params

    def is_wrapping(self):
        'is_wrapping(self)\n\n:param self: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_is_wrapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_is_wrapping\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.is_wrapping = is_wrapping

    def domain_is_wrapping(self):
        'domain_is_wrapping(self)\n\n:param self: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_domain_is_wrapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_domain_is_wrapping\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.domain_is_wrapping = domain_is_wrapping

    def range_is_wrapping(self):
        'range_is_wrapping(self)\n\n:param self: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_range_is_wrapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_range_is_wrapping\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.range_is_wrapping = range_is_wrapping

    def is_product(self):
        'is_product(self)\n\n:param self: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_is_product(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_is_product\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.is_product = is_product

    def wrap(self):
        'wrap(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_wrap(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_wrap failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.wrap = wrap

    def unwrap(self):
        'unwrap(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_unwrap(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_unwrap failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.unwrap = unwrap

    def can_zip(self):
        'can_zip(self)\n\n:param self: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_can_zip(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_can_zip\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.can_zip = can_zip

    def zip(self):
        'zip(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_zip(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_zip failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.zip = zip

    def can_curry(self):
        'can_curry(self)\n\n:param self: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_can_curry(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_can_curry\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.can_curry = can_curry

    def curry(self):
        'curry(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_curry(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_curry failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.curry = curry

    def can_range_curry(self):
        'can_range_curry(self)\n\n:param self: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_can_range_curry(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_can_range_curry\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.can_range_curry = can_range_curry

    def range_curry(self):
        'range_curry(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_range_curry(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_range_curry failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.range_curry = range_curry

    def can_uncurry(self):
        'can_uncurry(self)\n\n:param self: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_can_uncurry(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_can_uncurry\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.can_uncurry = can_uncurry

    def uncurry(self):
        'uncurry(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_uncurry(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_uncurry failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.uncurry = uncurry

    def is_domain(self, space2):
        'is_domain(self, space2)\n\n:param self: :class:`Space`\n:param space2: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        if not isinstance(space2, Space):
            raise IslTypeError("space2 is not a Space")
        if _ctx_data != space2._ctx_data:
            raise Error("mismatched context in space2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_is_domain(self.data, space2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_is_domain\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.is_domain = is_domain

    def is_range(self, space2):
        'is_range(self, space2)\n\n:param self: :class:`Space`\n:param space2: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        if not isinstance(space2, Space):
            raise IslTypeError("space2 is not a Space")
        if _ctx_data != space2._ctx_data:
            raise Error("mismatched context in space2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_is_range(self.data, space2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_is_range\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.is_range = is_range

    def is_equal(self, space2):
        'is_equal(self, space2)\n\n:param self: :class:`Space`\n:param space2: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        if not isinstance(space2, Space):
            raise IslTypeError("space2 is not a Space")
        if _ctx_data != space2._ctx_data:
            raise Error("mismatched context in space2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_is_equal(self.data, space2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.is_equal = is_equal

    def has_equal_params(self, space2):
        'has_equal_params(self, space2)\n\n:param self: :class:`Space`\n:param space2: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        if not isinstance(space2, Space):
            raise IslTypeError("space2 is not a Space")
        if _ctx_data != space2._ctx_data:
            raise Error("mismatched context in space2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_has_equal_params(self.data, space2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_has_equal_params\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.has_equal_params = has_equal_params

    def has_equal_tuples(self, space2):
        'has_equal_tuples(self, space2)\n\n:param self: :class:`Space`\n:param space2: :class:`Space`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        if not isinstance(space2, Space):
            raise IslTypeError("space2 is not a Space")
        if _ctx_data != space2._ctx_data:
            raise Error("mismatched context in space2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_has_equal_tuples(self.data, space2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_has_equal_tuples\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.has_equal_tuples = has_equal_tuples

    def tuple_is_equal(self, type1, space2, type2):
        'tuple_is_equal(self, type1, space2, type2)\n\n:param self: :class:`Space`\n:param type1: :class:`dim_type`\n:param space2: :class:`Space`\n:param type2: :class:`dim_type`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        # no argument processing for type1
        
        if not isinstance(space2, Space):
            raise IslTypeError("space2 is not a Space")
        if _ctx_data != space2._ctx_data:
            raise Error("mismatched context in space2")
        
        # no argument processing for type2
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_tuple_is_equal(self.data, type1, space2.data, type2)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_tuple_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.tuple_is_equal = tuple_is_equal

    def match(self, type1, space2, type2):
        'match(self, type1, space2, type2)\n\n:param self: :class:`Space`\n:param type1: :class:`dim_type`\n:param space2: :class:`Space`\n:param type2: :class:`dim_type`\n:return: bool'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        # no argument processing for type1
        
        if not isinstance(space2, Space):
            raise IslTypeError("space2 is not a Space")
        if _ctx_data != space2._ctx_data:
            raise Error("mismatched context in space2")
        
        # no argument processing for type2
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_match(self.data, type1, space2.data, type2)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_space_match\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Space.match = match

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`Space`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Space.dim = dim

    def flatten_domain(self):
        'flatten_domain(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_flatten_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_flatten_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.flatten_domain = flatten_domain

    def flatten_range(self):
        'flatten_range(self)\n\n:param self: :class:`Space`\n:return: :class:`Space`'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_flatten_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_space_flatten_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Space.flatten_range = flatten_range

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`Space`\n:return: string'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Space.to_str = to_str

    def dump(self):
        'dump(self)\n\n:param self: :class:`Space`\n:return: (nothing)'

        if not isinstance(self, Space):
            raise IslTypeError("self is not a Space")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_space_dump(self.data)
        finally:
            pass
        

    Space.dump = dump

    # }}}

    # {{{ local_space

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`LocalSpace`\n:return: :class:`Context`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.get_ctx = get_ctx

    def from_space(dim):
        'from_space(dim)\n\n:param dim: :class:`Space`\n:return: :class:`LocalSpace`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_from_space(_copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_from_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.from_space = staticmethod(from_space)

    LocalSpace._from_space_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`LocalSpace`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.copy = copy

    def is_params(self):
        'is_params(self)\n\n:param self: :class:`LocalSpace`\n:return: bool'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_is_params(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_local_space_is_params\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    LocalSpace.is_params = is_params

    def is_set(self):
        'is_set(self)\n\n:param self: :class:`LocalSpace`\n:return: bool'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_is_set(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_local_space_is_set\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    LocalSpace.is_set = is_set

    def set_tuple_id(self, type, id):
        'set_tuple_id(self, type, id)\n\n:param self: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_set_tuple_id(_copy_self._release(), type, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_set_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.set_tuple_id = set_tuple_id

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:return: isl_size'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    LocalSpace.dim = dim

    def has_dim_name(self, type, pos):
        'has_dim_name(self, type, pos)\n\n:param self: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_has_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_local_space_has_dim_name\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    LocalSpace.has_dim_name = has_dim_name

    def get_dim_name(self, type, pos):
        'get_dim_name(self, type, pos)\n\n:param self: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: string'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_get_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    LocalSpace.get_dim_name = get_dim_name

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.set_dim_name = set_dim_name

    def has_dim_id(self, type, pos):
        'has_dim_id(self, type, pos)\n\n:param self: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_has_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_local_space_has_dim_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    LocalSpace.has_dim_id = has_dim_id

    def get_dim_id(self, type, pos):
        'get_dim_id(self, type, pos)\n\n:param self: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Id`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_get_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_get_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.get_dim_id = get_dim_id

    def set_dim_id(self, type, pos, id):
        'set_dim_id(self, type, pos, id)\n\n:param self: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param id: :class:`Id`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_set_dim_id(_copy_self._release(), type, pos, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_set_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.set_dim_id = set_dim_id

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`LocalSpace`\n:return: :class:`Space`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.get_space = get_space

    def get_div(self, pos):
        'get_div(self, pos)\n\n:param self: :class:`LocalSpace`\n:param pos: :class:`int`\n:return: :class:`Aff`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_get_div(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_get_div failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.get_div = get_div

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    LocalSpace.find_dim_by_name = find_dim_by_name

    def domain(self):
        'domain(self)\n\n:param self: :class:`LocalSpace`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.domain = domain

    def range(self):
        'range(self)\n\n:param self: :class:`LocalSpace`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.range = range

    def from_domain(self):
        'from_domain(self)\n\n:param self: :class:`LocalSpace`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_from_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_from_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.from_domain = from_domain

    def add_dims(self, type, n):
        'add_dims(self, type, n)\n\n:param self: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:param n: :class:`unsigned`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_add_dims(_copy_self._release(), type, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_add_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.add_dims = add_dims

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.drop_dims = drop_dims

    def insert_dims(self, type, first, n):
        'insert_dims(self, type, first, n)\n\n:param self: :class:`LocalSpace`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_insert_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_insert_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.insert_dims = insert_dims

    def set_from_params(self):
        'set_from_params(self)\n\n:param self: :class:`LocalSpace`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_set_from_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_set_from_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.set_from_params = set_from_params

    def intersect(self, ls2):
        'intersect(self, ls2)\n\n:param self: :class:`LocalSpace`\n:param ls2: :class:`LocalSpace`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(ls2, Space):
            ls2 = LocalSpace.from_space(ls2)
        if not isinstance(ls2, LocalSpace):
            raise IslTypeError("ls2 is not a LocalSpace")
        if _ctx_data != ls2._ctx_data:
            raise Error("mismatched context in ls2")
        _copy_ls2 = ls2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_intersect(_copy_self._release(), _copy_ls2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_intersect failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.intersect = intersect

    def wrap(self):
        'wrap(self)\n\n:param self: :class:`LocalSpace`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_wrap(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_wrap failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.wrap = wrap

    def is_equal(self, ls2):
        'is_equal(self, ls2)\n\n:param self: :class:`LocalSpace`\n:param ls2: :class:`LocalSpace`\n:return: bool'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        
        if isinstance(ls2, Space):
            ls2 = LocalSpace.from_space(ls2)
        if not isinstance(ls2, LocalSpace):
            raise IslTypeError("ls2 is not a LocalSpace")
        if _ctx_data != ls2._ctx_data:
            raise Error("mismatched context in ls2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_is_equal(self.data, ls2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_local_space_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    LocalSpace.is_equal = is_equal

    def lifting(self):
        'lifting(self)\n\n:param self: :class:`LocalSpace`\n:return: :class:`BasicMap`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_lifting(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_lifting failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.lifting = lifting

    def flatten_domain(self):
        'flatten_domain(self)\n\n:param self: :class:`LocalSpace`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_flatten_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_flatten_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.flatten_domain = flatten_domain

    def flatten_range(self):
        'flatten_range(self)\n\n:param self: :class:`LocalSpace`\n:return: :class:`LocalSpace`'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_flatten_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_local_space_flatten_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    LocalSpace.flatten_range = flatten_range

    def dump(self):
        'dump(self)\n\n:param self: :class:`LocalSpace`\n:return: (nothing)'

        if isinstance(self, Space):
            self = LocalSpace.from_space(self)
        if not isinstance(self, LocalSpace):
            raise IslTypeError("self is not a LocalSpace")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_local_space_dump(self.data)
        finally:
            pass
        

    LocalSpace.dump = dump

    # }}}

    # {{{ basic_set

    def n_dim(self):
        'n_dim(self)\n\n:param self: :class:`BasicSet`\n:return: isl_size'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_n_dim(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    BasicSet.n_dim = n_dim

    def n_param(self):
        'n_param(self)\n\n:param self: :class:`BasicSet`\n:return: isl_size'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_n_param(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    BasicSet.n_param = n_param

    def total_dim(self):
        'total_dim(self)\n\n:param self: :class:`BasicSet`\n:return: isl_size'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_total_dim(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    BasicSet.total_dim = total_dim

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    BasicSet.dim = dim

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`Context`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.get_ctx = get_ctx

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`Space`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.get_space = get_space

    def get_div(self, pos):
        'get_div(self, pos)\n\n:param self: :class:`BasicSet`\n:param pos: :class:`int`\n:return: :class:`Aff`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_get_div(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_get_div failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.get_div = get_div

    def get_local_space(self):
        'get_local_space(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`LocalSpace`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_get_local_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_get_local_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.get_local_space = get_local_space

    def get_tuple_name(self):
        'get_tuple_name(self)\n\n:param self: :class:`BasicSet`\n:return: string'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_get_tuple_name(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    BasicSet.get_tuple_name = get_tuple_name

    def set_tuple_name(self, s):
        'set_tuple_name(self, s)\n\n:param self: :class:`BasicSet`\n:param s: string\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_set_tuple_name(_copy_self._release(), _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_set_tuple_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.set_tuple_name = set_tuple_name

    def get_dim_name(self, type, pos):
        'get_dim_name(self, type, pos)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: string'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_get_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    BasicSet.get_dim_name = get_dim_name

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.set_dim_name = set_dim_name

    def get_dim_id(self, type, pos):
        'get_dim_id(self, type, pos)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Id`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_get_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_get_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.get_dim_id = get_dim_id

    def set_tuple_id(self, id):
        'set_tuple_id(self, id)\n\n:param self: :class:`BasicSet`\n:param id: :class:`Id`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_set_tuple_id(_copy_self._release(), _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_set_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.set_tuple_id = set_tuple_id

    def is_rational(self):
        'is_rational(self)\n\n:param self: :class:`BasicSet`\n:return: int'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_is_rational(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    BasicSet.is_rational = is_rational

    def copy(self):
        'copy(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.copy = copy

    def empty(space):
        'empty(space)\n\n:param space: :class:`Space`\n:return: :class:`BasicSet`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_empty(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_empty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.empty = staticmethod(empty)

    BasicSet._empty_is_static = True

    def universe(space):
        'universe(space)\n\n:param space: :class:`Space`\n:return: :class:`BasicSet`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_universe(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_universe failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.universe = staticmethod(universe)

    BasicSet._universe_is_static = True

    def nat_universe(space):
        'nat_universe(space)\n\n:param space: :class:`Space`\n:return: :class:`BasicSet`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_nat_universe(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_nat_universe failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.nat_universe = staticmethod(nat_universe)

    BasicSet._nat_universe_is_static = True

    def positive_orthant(space):
        'positive_orthant(space)\n\n:param space: :class:`Space`\n:return: :class:`BasicSet`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_positive_orthant(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_positive_orthant failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.positive_orthant = staticmethod(positive_orthant)

    BasicSet._positive_orthant_is_static = True

    def intersect(self, bset2):
        'intersect(self, bset2)\n\n:param self: :class:`BasicSet`\n:param bset2: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bset2, BasicSet):
            raise IslTypeError("bset2 is not a BasicSet")
        if _ctx_data != bset2._ctx_data:
            raise Error("mismatched context in bset2")
        _copy_bset2 = bset2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_intersect(_copy_self._release(), _copy_bset2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_intersect failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.intersect = intersect

    def intersect_params(self, bset2):
        'intersect_params(self, bset2)\n\n:param self: :class:`BasicSet`\n:param bset2: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bset2, BasicSet):
            raise IslTypeError("bset2 is not a BasicSet")
        if _ctx_data != bset2._ctx_data:
            raise Error("mismatched context in bset2")
        _copy_bset2 = bset2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_intersect_params(_copy_self._release(), _copy_bset2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.intersect_params = intersect_params

    def apply(self, bmap):
        'apply(self, bmap)\n\n:param self: :class:`BasicSet`\n:param bmap: :class:`BasicMap`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bmap, BasicMap):
            raise IslTypeError("bmap is not a BasicMap")
        if _ctx_data != bmap._ctx_data:
            raise Error("mismatched context in bmap")
        _copy_bmap = bmap._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_apply(_copy_self._release(), _copy_bmap._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_apply failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.apply = apply

    def preimage_multi_aff(self, ma):
        'preimage_multi_aff(self, ma)\n\n:param self: :class:`BasicSet`\n:param ma: :class:`MultiAff`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_preimage_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_preimage_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.preimage_multi_aff = preimage_multi_aff

    def affine_hull(self):
        'affine_hull(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_affine_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_affine_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.affine_hull = affine_hull

    def remove_dims(self, type, first, n):
        'remove_dims(self, type, first, n)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_remove_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_remove_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.remove_dims = remove_dims

    def sample(self):
        'sample(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_sample(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_sample failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.sample = sample

    def detect_equalities(self):
        'detect_equalities(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_detect_equalities(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_detect_equalities failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.detect_equalities = detect_equalities

    def remove_redundancies(self):
        'remove_redundancies(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_remove_redundancies(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_remove_redundancies failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.remove_redundancies = remove_redundancies

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`BasicSet`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.read_from_str = staticmethod(read_from_str)

    BasicSet._read_from_str_is_static = True

    def dump(self):
        'dump(self)\n\n:param self: :class:`BasicSet`\n:return: (nothing)'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_dump(self.data)
        finally:
            pass
        

    BasicSet.dump = dump

    def fix_val(self, type, pos, v):
        'fix_val(self, type, pos, v)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param v: :class:`Val`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_fix_val(_copy_self._release(), type, pos, _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_fix_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.fix_val = fix_val

    def lower_bound_val(self, type, pos, value):
        'lower_bound_val(self, type, pos, value)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param value: :class:`Val`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if isinstance(value, Val):
            if _ctx_data != value._ctx_data:
                raise Error("mismatched context in value")
            _val_value = value._copy()
        elif isinstance(value, six.integer_types):
            _cdata_value = lib.isl_val_int_from_si(
                self._get_ctx_data(), value)
        
            if _cdata_value == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_value = Val(_data=_cdata_value)
        
        else:
            raise IslTypeError("value is a %s and cannot "
                "be cast to a Val" % type(value))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_lower_bound_val(_copy_self._release(), type, pos, _val_value._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_lower_bound_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.lower_bound_val = lower_bound_val

    def upper_bound_val(self, type, pos, value):
        'upper_bound_val(self, type, pos, value)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param value: :class:`Val`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if isinstance(value, Val):
            if _ctx_data != value._ctx_data:
                raise Error("mismatched context in value")
            _val_value = value._copy()
        elif isinstance(value, six.integer_types):
            _cdata_value = lib.isl_val_int_from_si(
                self._get_ctx_data(), value)
        
            if _cdata_value == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_value = Val(_data=_cdata_value)
        
        else:
            raise IslTypeError("value is a %s and cannot "
                "be cast to a Val" % type(value))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_upper_bound_val(_copy_self._release(), type, pos, _val_value._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_upper_bound_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.upper_bound_val = upper_bound_val

    def is_equal(self, bset2):
        'is_equal(self, bset2)\n\n:param self: :class:`BasicSet`\n:param bset2: :class:`BasicSet`\n:return: bool'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        if not isinstance(bset2, BasicSet):
            raise IslTypeError("bset2 is not a BasicSet")
        if _ctx_data != bset2._ctx_data:
            raise Error("mismatched context in bset2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_is_equal(self.data, bset2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_set_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicSet.is_equal = is_equal

    def is_disjoint(self, bset2):
        'is_disjoint(self, bset2)\n\n:param self: :class:`BasicSet`\n:param bset2: :class:`BasicSet`\n:return: bool'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        if not isinstance(bset2, BasicSet):
            raise IslTypeError("bset2 is not a BasicSet")
        if _ctx_data != bset2._ctx_data:
            raise Error("mismatched context in bset2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_is_disjoint(self.data, bset2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_set_is_disjoint\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicSet.is_disjoint = is_disjoint

    def partial_lexmin(self, dom):
        'partial_lexmin(self, dom)\n\n:param self: :class:`BasicSet`\n:param dom: :class:`BasicSet`\n:return: (:class:`Set`, empty (:class:`Set`))'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(dom, BasicSet):
            raise IslTypeError("dom is not a BasicSet")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        
        _retptr_empty = ffi.new("isl_set **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_partial_lexmin(_copy_self._release(), _copy_dom._release(), _retptr_empty)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_empty == ffi.NULL:
                _ret_empty = None
            else:
                _ret_empty = Set(_data=_retptr_empty[0])
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_partial_lexmin failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_empty

    BasicSet.partial_lexmin = partial_lexmin

    def partial_lexmax(self, dom):
        'partial_lexmax(self, dom)\n\n:param self: :class:`BasicSet`\n:param dom: :class:`BasicSet`\n:return: (:class:`Set`, empty (:class:`Set`))'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(dom, BasicSet):
            raise IslTypeError("dom is not a BasicSet")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        
        _retptr_empty = ffi.new("isl_set **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_partial_lexmax(_copy_self._release(), _copy_dom._release(), _retptr_empty)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_empty == ffi.NULL:
                _ret_empty = None
            else:
                _ret_empty = Set(_data=_retptr_empty[0])
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_partial_lexmax failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_empty

    BasicSet.partial_lexmax = partial_lexmax

    def lexmin(self):
        'lexmin(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`Set`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_lexmin(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_lexmin failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.lexmin = lexmin

    def lexmax(self):
        'lexmax(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`Set`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_lexmax(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_lexmax failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.lexmax = lexmax

    def partial_lexmin_pw_multi_aff(self, dom):
        'partial_lexmin_pw_multi_aff(self, dom)\n\n:param self: :class:`BasicSet`\n:param dom: :class:`BasicSet`\n:return: (:class:`PwMultiAff`, empty (:class:`Set`))'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(dom, BasicSet):
            raise IslTypeError("dom is not a BasicSet")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        
        _retptr_empty = ffi.new("isl_set **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_partial_lexmin_pw_multi_aff(_copy_self._release(), _copy_dom._release(), _retptr_empty)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_empty == ffi.NULL:
                _ret_empty = None
            else:
                _ret_empty = Set(_data=_retptr_empty[0])
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_partial_lexmin_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_empty

    BasicSet.partial_lexmin_pw_multi_aff = partial_lexmin_pw_multi_aff

    def partial_lexmax_pw_multi_aff(self, dom):
        'partial_lexmax_pw_multi_aff(self, dom)\n\n:param self: :class:`BasicSet`\n:param dom: :class:`BasicSet`\n:return: (:class:`PwMultiAff`, empty (:class:`Set`))'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(dom, BasicSet):
            raise IslTypeError("dom is not a BasicSet")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        
        _retptr_empty = ffi.new("isl_set **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_partial_lexmax_pw_multi_aff(_copy_self._release(), _copy_dom._release(), _retptr_empty)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_empty == ffi.NULL:
                _ret_empty = None
            else:
                _ret_empty = Set(_data=_retptr_empty[0])
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_partial_lexmax_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_empty

    BasicSet.partial_lexmax_pw_multi_aff = partial_lexmax_pw_multi_aff

    def union(self, bset2):
        'union(self, bset2)\n\n:param self: :class:`BasicSet`\n:param bset2: :class:`BasicSet`\n:return: :class:`Set`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bset2, BasicSet):
            raise IslTypeError("bset2 is not a BasicSet")
        if _ctx_data != bset2._ctx_data:
            raise Error("mismatched context in bset2")
        _copy_bset2 = bset2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_union(_copy_self._release(), _copy_bset2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_union failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.union = union

    def compare_at(self, bset2, pos):
        'compare_at(self, bset2, pos)\n\n:param self: :class:`BasicSet`\n:param bset2: :class:`BasicSet`\n:param pos: :class:`int`\n:return: int'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        if not isinstance(bset2, BasicSet):
            raise IslTypeError("bset2 is not a BasicSet")
        if _ctx_data != bset2._ctx_data:
            raise Error("mismatched context in bset2")
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_compare_at(self.data, bset2.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    BasicSet.compare_at = compare_at

    def params(self):
        'params(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.params = params

    def from_params(self):
        'from_params(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_from_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_from_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.from_params = from_params

    def plain_is_universe(self):
        'plain_is_universe(self)\n\n:param self: :class:`BasicSet`\n:return: bool'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_plain_is_universe(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_set_plain_is_universe\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicSet.plain_is_universe = plain_is_universe

    def is_universe(self):
        'is_universe(self)\n\n:param self: :class:`BasicSet`\n:return: bool'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_is_universe(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_set_is_universe\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicSet.is_universe = is_universe

    def plain_is_empty(self):
        'plain_is_empty(self)\n\n:param self: :class:`BasicSet`\n:return: bool'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_plain_is_empty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_set_plain_is_empty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicSet.plain_is_empty = plain_is_empty

    def is_empty(self):
        'is_empty(self)\n\n:param self: :class:`BasicSet`\n:return: bool'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_is_empty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_set_is_empty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicSet.is_empty = is_empty

    def is_bounded(self):
        'is_bounded(self)\n\n:param self: :class:`BasicSet`\n:return: bool'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_is_bounded(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_set_is_bounded\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicSet.is_bounded = is_bounded

    def is_subset(self, bset2):
        'is_subset(self, bset2)\n\n:param self: :class:`BasicSet`\n:param bset2: :class:`BasicSet`\n:return: bool'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        if not isinstance(bset2, BasicSet):
            raise IslTypeError("bset2 is not a BasicSet")
        if _ctx_data != bset2._ctx_data:
            raise Error("mismatched context in bset2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_is_subset(self.data, bset2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_set_is_subset\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicSet.is_subset = is_subset

    def plain_is_equal(self, bset2):
        'plain_is_equal(self, bset2)\n\n:param self: :class:`BasicSet`\n:param bset2: :class:`BasicSet`\n:return: bool'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        if not isinstance(bset2, BasicSet):
            raise IslTypeError("bset2 is not a BasicSet")
        if _ctx_data != bset2._ctx_data:
            raise Error("mismatched context in bset2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_plain_is_equal(self.data, bset2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_set_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicSet.plain_is_equal = plain_is_equal

    def sample_point(self):
        'sample_point(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`Point`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_sample_point(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Point(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_sample_point failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.sample_point = sample_point

    def flat_product(self, bset2):
        'flat_product(self, bset2)\n\n:param self: :class:`BasicSet`\n:param bset2: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bset2, BasicSet):
            raise IslTypeError("bset2 is not a BasicSet")
        if _ctx_data != bset2._ctx_data:
            raise Error("mismatched context in bset2")
        _copy_bset2 = bset2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_flat_product(_copy_self._release(), _copy_bset2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_flat_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.flat_product = flat_product

    def insert_dims(self, type, pos, n):
        'insert_dims(self, type, pos, n)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_insert_dims(_copy_self._release(), type, pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_insert_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.insert_dims = insert_dims

    def add_dims(self, type, n):
        'add_dims(self, type, n)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param n: :class:`unsigned`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_add_dims(_copy_self._release(), type, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_add_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.add_dims = add_dims

    def move_dims(self, dst_type, dst_pos, src_type, src_pos, n):
        'move_dims(self, dst_type, dst_pos, src_type, src_pos, n)\n\n:param self: :class:`BasicSet`\n:param dst_type: :class:`dim_type`\n:param dst_pos: :class:`unsigned`\n:param src_type: :class:`dim_type`\n:param src_pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_type
        
        # no argument processing for dst_pos
        
        # no argument processing for src_type
        
        # no argument processing for src_pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_move_dims(_copy_self._release(), dst_type, dst_pos, src_type, src_pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_move_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.move_dims = move_dims

    def project_out(self, type, first, n):
        'project_out(self, type, first, n)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_project_out(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_project_out failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.project_out = project_out

    def remove_divs(self):
        'remove_divs(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_remove_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_remove_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.remove_divs = remove_divs

    def eliminate(self, type, first, n):
        'eliminate(self, type, first, n)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_eliminate(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_eliminate failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.eliminate = eliminate

    def remove_divs_involving_dims(self, type, first, n):
        'remove_divs_involving_dims(self, type, first, n)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_remove_divs_involving_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_remove_divs_involving_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.remove_divs_involving_dims = remove_divs_involving_dims

    def remove_unknown_divs(self):
        'remove_unknown_divs(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_remove_unknown_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_remove_unknown_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.remove_unknown_divs = remove_unknown_divs

    def drop_constraints_involving_dims(self, type, first, n):
        'drop_constraints_involving_dims(self, type, first, n)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_drop_constraints_involving_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_drop_constraints_involving_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.drop_constraints_involving_dims = drop_constraints_involving_dims

    def drop_constraints_not_involving_dims(self, type, first, n):
        'drop_constraints_not_involving_dims(self, type, first, n)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_drop_constraints_not_involving_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_drop_constraints_not_involving_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.drop_constraints_not_involving_dims = drop_constraints_not_involving_dims

    def involves_dims(self, type, first, n):
        'involves_dims(self, type, first, n)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: bool'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_involves_dims(self.data, type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_set_involves_dims\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicSet.involves_dims = involves_dims

    def neg(self):
        'neg(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.neg = neg

    def compute_divs(self):
        'compute_divs(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`Set`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_compute_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_compute_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.compute_divs = compute_divs

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`BasicSet`\n:param context: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(context, BasicSet):
            raise IslTypeError("context is not a BasicSet")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.gist = gist

    def from_point(pnt):
        'from_point(pnt)\n\n:param pnt: :class:`Point`\n:return: :class:`BasicSet`'

        if not isinstance(pnt, Point):
            raise IslTypeError("pnt is not a Point")
        _ctx_data = pnt._ctx_data
        _copy_pnt = pnt._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_from_point(_copy_pnt._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_from_point failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.from_point = staticmethod(from_point)

    BasicSet._from_point_is_static = True

    def box_from_points(pnt1, pnt2):
        'box_from_points(pnt1, pnt2)\n\n:param pnt1: :class:`Point`\n:param pnt2: :class:`Point`\n:return: :class:`BasicSet`'

        if not isinstance(pnt1, Point):
            raise IslTypeError("pnt1 is not a Point")
        _ctx_data = pnt1._ctx_data
        _copy_pnt1 = pnt1._copy()
        
        if not isinstance(pnt2, Point):
            raise IslTypeError("pnt2 is not a Point")
        if _ctx_data != pnt2._ctx_data:
            raise Error("mismatched context in pnt2")
        _copy_pnt2 = pnt2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_box_from_points(_copy_pnt1._release(), _copy_pnt2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_box_from_points failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.box_from_points = staticmethod(box_from_points)

    BasicSet._box_from_points_is_static = True

    def lift(self):
        'lift(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_lift(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_lift failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.lift = lift

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`BasicSet`\n:param model: :class:`Space`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.align_params = align_params

    def drop_unused_params(self):
        'drop_unused_params(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_drop_unused_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_drop_unused_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.drop_unused_params = drop_unused_params

    def equalities_matrix(self, c1, c2, c3, c4):
        'equalities_matrix(self, c1, c2, c3, c4)\n\n:param self: :class:`BasicSet`\n:param c1: :class:`dim_type`\n:param c2: :class:`dim_type`\n:param c3: :class:`dim_type`\n:param c4: :class:`dim_type`\n:return: :class:`Mat`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        # no argument processing for c1
        
        # no argument processing for c2
        
        # no argument processing for c3
        
        # no argument processing for c4
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_equalities_matrix(self.data, c1, c2, c3, c4)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_equalities_matrix failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.equalities_matrix = equalities_matrix

    def inequalities_matrix(self, c1, c2, c3, c4):
        'inequalities_matrix(self, c1, c2, c3, c4)\n\n:param self: :class:`BasicSet`\n:param c1: :class:`dim_type`\n:param c2: :class:`dim_type`\n:param c3: :class:`dim_type`\n:param c4: :class:`dim_type`\n:return: :class:`Mat`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        # no argument processing for c1
        
        # no argument processing for c2
        
        # no argument processing for c3
        
        # no argument processing for c4
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_inequalities_matrix(self.data, c1, c2, c3, c4)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_inequalities_matrix failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.inequalities_matrix = inequalities_matrix

    def from_constraint_matrices(dim, eq, ineq, c1, c2, c3, c4):
        'from_constraint_matrices(dim, eq, ineq, c1, c2, c3, c4)\n\n:param dim: :class:`Space`\n:param eq: :class:`Mat`\n:param ineq: :class:`Mat`\n:param c1: :class:`dim_type`\n:param c2: :class:`dim_type`\n:param c3: :class:`dim_type`\n:param c4: :class:`dim_type`\n:return: :class:`BasicSet`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        
        if not isinstance(eq, Mat):
            raise IslTypeError("eq is not a Mat")
        if _ctx_data != eq._ctx_data:
            raise Error("mismatched context in eq")
        _copy_eq = eq._copy()
        
        if not isinstance(ineq, Mat):
            raise IslTypeError("ineq is not a Mat")
        if _ctx_data != ineq._ctx_data:
            raise Error("mismatched context in ineq")
        _copy_ineq = ineq._copy()
        
        # no argument processing for c1
        
        # no argument processing for c2
        
        # no argument processing for c3
        
        # no argument processing for c4
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_from_constraint_matrices(_copy_dim._release(), _copy_eq._release(), _copy_ineq._release(), c1, c2, c3, c4)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_from_constraint_matrices failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.from_constraint_matrices = staticmethod(from_constraint_matrices)

    BasicSet._from_constraint_matrices_is_static = True

    def from_multi_aff(ma):
        'from_multi_aff(ma)\n\n:param ma: :class:`MultiAff`\n:return: :class:`BasicSet`'

        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        _ctx_data = ma._ctx_data
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_from_multi_aff(_copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_from_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.from_multi_aff = staticmethod(from_multi_aff)

    BasicSet._from_multi_aff_is_static = True

    def reduced_basis(self):
        'reduced_basis(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`Mat`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_reduced_basis(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_reduced_basis failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.reduced_basis = reduced_basis

    def coefficients(self):
        'coefficients(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_coefficients(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_coefficients failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.coefficients = coefficients

    def solutions(self):
        'solutions(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_solutions(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_solutions failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.solutions = solutions

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`BasicSet`\n:return: string'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    BasicSet.to_str = to_str

    def is_wrapping(self):
        'is_wrapping(self)\n\n:param self: :class:`BasicSet`\n:return: bool'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_is_wrapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_set_is_wrapping\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicSet.is_wrapping = is_wrapping

    def unwrap(self):
        'unwrap(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_unwrap(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_unwrap failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.unwrap = unwrap

    def flatten(self):
        'flatten(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_flatten(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_flatten failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.flatten = flatten

    def multiplicative_call(self, fn):
        'multiplicative_call(self, fn)\n\n:param self: :class:`BasicSet`\n:param fn: callback(bset) -> isl_pw_qpolynomial\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn():
            try:
                _result = fn()
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, PwQPolynomial):
                    raise IslTypeError("return value is not a PwQPolynomial")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_pw_qpolynomial *(*fn)( isl_basic_set *bset)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_multiplicative_call(_copy_self._release(), _cb_fn)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_multiplicative_call failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.multiplicative_call = multiplicative_call

    def compute_vertices(self):
        'compute_vertices(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`Vertices`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_compute_vertices(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Vertices(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_compute_vertices failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.compute_vertices = compute_vertices

    def n_constraint(self):
        'n_constraint(self)\n\n:param self: :class:`BasicSet`\n:return: isl_size'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_n_constraint(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    BasicSet.n_constraint = n_constraint

    def foreach_constraint(self, fn):
        'foreach_constraint(self, fn)\n\n:param self: :class:`BasicSet`\n:param fn: callback(c) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(c, user):
            try:
                _py_c = Constraint(_data=c)
                _result = fn(_py_c)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_constraint *c,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_foreach_constraint(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_basic_set_foreach_constraint\" failed: %s" % _get_last_error_str(_ctx_data))
        

    BasicSet.foreach_constraint = foreach_constraint

    def get_constraint_list(self):
        'get_constraint_list(self)\n\n:param self: :class:`BasicSet`\n:return: :class:`ConstraintList`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_get_constraint_list(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ConstraintList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_get_constraint_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.get_constraint_list = get_constraint_list

    def foreach_bound_pair(self, type, pos, fn):
        'foreach_bound_pair(self, type, pos, fn)\n\n:param self: :class:`BasicSet`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param fn: callback(lower, upper, bset) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        
        def _cb_wrapper_fn(lower, upper, bset, user):
            try:
                _py_lower = Constraint(_data=lower)
                _py_upper = Constraint(_data=upper)
                _py_bset = BasicSet(_data=bset)
                _result = fn(_py_lower, _py_upper, _py_bset)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_constraint *lower,  isl_constraint *upper,  isl_basic_set *bset,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_foreach_bound_pair(self.data, type, pos, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_basic_set_foreach_bound_pair\" failed: %s" % _get_last_error_str(_ctx_data))
        

    BasicSet.foreach_bound_pair = foreach_bound_pair

    def add_constraint(self, constraint):
        'add_constraint(self, constraint)\n\n:param self: :class:`BasicSet`\n:param constraint: :class:`Constraint`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(constraint, Constraint):
            raise IslTypeError("constraint is not a Constraint")
        if _ctx_data != constraint._ctx_data:
            raise Error("mismatched context in constraint")
        _copy_constraint = constraint._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_add_constraint(_copy_self._release(), _copy_constraint._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_add_constraint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.add_constraint = add_constraint

    def from_constraint(constraint):
        'from_constraint(constraint)\n\n:param constraint: :class:`Constraint`\n:return: :class:`BasicSet`'

        if not isinstance(constraint, Constraint):
            raise IslTypeError("constraint is not a Constraint")
        _ctx_data = constraint._ctx_data
        _copy_constraint = constraint._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_from_constraint(_copy_constraint._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_from_constraint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.from_constraint = staticmethod(from_constraint)

    BasicSet._from_constraint_is_static = True

    def max_val(self, obj):
        'max_val(self, obj)\n\n:param self: :class:`BasicSet`\n:param obj: :class:`Aff`\n:return: :class:`Val`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        
        if not isinstance(obj, Aff):
            raise IslTypeError("obj is not a Aff")
        if _ctx_data != obj._ctx_data:
            raise Error("mismatched context in obj")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_max_val(self.data, obj.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_max_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.max_val = max_val

    def dim_max_val(self, pos):
        'dim_max_val(self, pos)\n\n:param self: :class:`BasicSet`\n:param pos: :class:`int`\n:return: :class:`Val`'

        if not isinstance(self, BasicSet):
            raise IslTypeError("self is not a BasicSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_set_dim_max_val(_copy_self._release(), pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_set_dim_max_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicSet.dim_max_val = dim_max_val

    # }}}

    # {{{ basic_map

    def total_dim(self):
        'total_dim(self)\n\n:param self: :class:`BasicMap`\n:return: isl_size'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_total_dim(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    BasicMap.total_dim = total_dim

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    BasicMap.dim = dim

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`Context`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.get_ctx = get_ctx

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`Space`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.get_space = get_space

    def get_div(self, pos):
        'get_div(self, pos)\n\n:param self: :class:`BasicMap`\n:param pos: :class:`int`\n:return: :class:`Aff`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_get_div(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_get_div failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.get_div = get_div

    def get_local_space(self):
        'get_local_space(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`LocalSpace`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_get_local_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else LocalSpace(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_get_local_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.get_local_space = get_local_space

    def set_tuple_name(self, type, s):
        'set_tuple_name(self, type, s)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param s: string\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_set_tuple_name(_copy_self._release(), type, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_set_tuple_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.set_tuple_name = set_tuple_name

    def get_tuple_name(self, type):
        'get_tuple_name(self, type)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:return: string'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_get_tuple_name(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    BasicMap.get_tuple_name = get_tuple_name

    def get_dim_name(self, type, pos):
        'get_dim_name(self, type, pos)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: string'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_get_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    BasicMap.get_dim_name = get_dim_name

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.set_dim_name = set_dim_name

    def set_tuple_id(self, type, id):
        'set_tuple_id(self, type, id)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_set_tuple_id(_copy_self._release(), type, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_set_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.set_tuple_id = set_tuple_id

    def has_dim_id(self, type, pos):
        'has_dim_id(self, type, pos)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_has_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_has_dim_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.has_dim_id = has_dim_id

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    BasicMap.find_dim_by_name = find_dim_by_name

    def is_rational(self):
        'is_rational(self)\n\n:param self: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_is_rational(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_is_rational\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.is_rational = is_rational

    def identity(space):
        'identity(space)\n\n:param space: :class:`Space`\n:return: :class:`BasicMap`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_identity(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_identity failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.identity = staticmethod(identity)

    BasicMap._identity_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.copy = copy

    def equal(space, n_equal):
        'equal(space, n_equal)\n\n:param space: :class:`Space`\n:param n_equal: :class:`unsigned`\n:return: :class:`BasicMap`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        
        # no argument processing for n_equal
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_equal(_copy_space._release(), n_equal)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_equal failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.equal = staticmethod(equal)

    BasicMap._equal_is_static = True

    def less_at(space, pos):
        'less_at(space, pos)\n\n:param space: :class:`Space`\n:param pos: :class:`unsigned`\n:return: :class:`BasicMap`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_less_at(_copy_space._release(), pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_less_at failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.less_at = staticmethod(less_at)

    BasicMap._less_at_is_static = True

    def more_at(space, pos):
        'more_at(space, pos)\n\n:param space: :class:`Space`\n:param pos: :class:`unsigned`\n:return: :class:`BasicMap`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_more_at(_copy_space._release(), pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_more_at failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.more_at = staticmethod(more_at)

    BasicMap._more_at_is_static = True

    def empty(space):
        'empty(space)\n\n:param space: :class:`Space`\n:return: :class:`BasicMap`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_empty(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_empty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.empty = staticmethod(empty)

    BasicMap._empty_is_static = True

    def universe(space):
        'universe(space)\n\n:param space: :class:`Space`\n:return: :class:`BasicMap`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_universe(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_universe failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.universe = staticmethod(universe)

    BasicMap._universe_is_static = True

    def nat_universe(space):
        'nat_universe(space)\n\n:param space: :class:`Space`\n:return: :class:`BasicMap`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_nat_universe(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_nat_universe failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.nat_universe = staticmethod(nat_universe)

    BasicMap._nat_universe_is_static = True

    def remove_redundancies(self):
        'remove_redundancies(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_remove_redundancies(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_remove_redundancies failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.remove_redundancies = remove_redundancies

    def intersect_domain(self, bset):
        'intersect_domain(self, bset)\n\n:param self: :class:`BasicMap`\n:param bset: :class:`BasicSet`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bset, BasicSet):
            raise IslTypeError("bset is not a BasicSet")
        if _ctx_data != bset._ctx_data:
            raise Error("mismatched context in bset")
        _copy_bset = bset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_intersect_domain(_copy_self._release(), _copy_bset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.intersect_domain = intersect_domain

    def intersect_range(self, bset):
        'intersect_range(self, bset)\n\n:param self: :class:`BasicMap`\n:param bset: :class:`BasicSet`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bset, BasicSet):
            raise IslTypeError("bset is not a BasicSet")
        if _ctx_data != bset._ctx_data:
            raise Error("mismatched context in bset")
        _copy_bset = bset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_intersect_range(_copy_self._release(), _copy_bset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_intersect_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.intersect_range = intersect_range

    def intersect(self, bmap2):
        'intersect(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        _copy_bmap2 = bmap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_intersect(_copy_self._release(), _copy_bmap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_intersect failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.intersect = intersect

    def union(self, bmap2):
        'union(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: :class:`Map`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        _copy_bmap2 = bmap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_union(_copy_self._release(), _copy_bmap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_union failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.union = union

    def apply_domain(self, bmap2):
        'apply_domain(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        _copy_bmap2 = bmap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_apply_domain(_copy_self._release(), _copy_bmap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_apply_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.apply_domain = apply_domain

    def apply_range(self, bmap2):
        'apply_range(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        _copy_bmap2 = bmap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_apply_range(_copy_self._release(), _copy_bmap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_apply_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.apply_range = apply_range

    def affine_hull(self):
        'affine_hull(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_affine_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_affine_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.affine_hull = affine_hull

    def preimage_domain_multi_aff(self, ma):
        'preimage_domain_multi_aff(self, ma)\n\n:param self: :class:`BasicMap`\n:param ma: :class:`MultiAff`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_preimage_domain_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_preimage_domain_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.preimage_domain_multi_aff = preimage_domain_multi_aff

    def preimage_range_multi_aff(self, ma):
        'preimage_range_multi_aff(self, ma)\n\n:param self: :class:`BasicMap`\n:param ma: :class:`MultiAff`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_preimage_range_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_preimage_range_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.preimage_range_multi_aff = preimage_range_multi_aff

    def reverse(self):
        'reverse(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_reverse(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_reverse failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.reverse = reverse

    def domain(self):
        'domain(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.domain = domain

    def range(self):
        'range(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.range = range

    def domain_map(self):
        'domain_map(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_domain_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_domain_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.domain_map = domain_map

    def range_map(self):
        'range_map(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_range_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_range_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.range_map = range_map

    def remove_dims(self, type, first, n):
        'remove_dims(self, type, first, n)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_remove_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_remove_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.remove_dims = remove_dims

    def eliminate(self, type, first, n):
        'eliminate(self, type, first, n)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_eliminate(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_eliminate failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.eliminate = eliminate

    def sample(self):
        'sample(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_sample(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_sample failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.sample = sample

    def detect_equalities(self):
        'detect_equalities(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_detect_equalities(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_detect_equalities failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.detect_equalities = detect_equalities

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`BasicMap`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.read_from_str = staticmethod(read_from_str)

    BasicMap._read_from_str_is_static = True

    def dump(self):
        'dump(self)\n\n:param self: :class:`BasicMap`\n:return: (nothing)'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_dump(self.data)
        finally:
            pass
        

    BasicMap.dump = dump

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`BasicMap`\n:return: string'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    BasicMap.to_str = to_str

    def fix_val(self, type, pos, v):
        'fix_val(self, type, pos, v)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param v: :class:`Val`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_fix_val(_copy_self._release(), type, pos, _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_fix_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.fix_val = fix_val

    def lower_bound_si(self, type, pos, value):
        'lower_bound_si(self, type, pos, value)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param value: :class:`int`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        # no argument processing for value
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_lower_bound_si(_copy_self._release(), type, pos, value)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_lower_bound_si failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.lower_bound_si = lower_bound_si

    def upper_bound_si(self, type, pos, value):
        'upper_bound_si(self, type, pos, value)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param value: :class:`int`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        # no argument processing for value
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_upper_bound_si(_copy_self._release(), type, pos, value)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_upper_bound_si failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.upper_bound_si = upper_bound_si

    def sum(self, bmap2):
        'sum(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        _copy_bmap2 = bmap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_sum(_copy_self._release(), _copy_bmap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_sum failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.sum = sum

    def neg(self):
        'neg(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.neg = neg

    def is_equal(self, bmap2):
        'is_equal(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_is_equal(self.data, bmap2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.is_equal = is_equal

    def is_disjoint(self, bmap2):
        'is_disjoint(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_is_disjoint(self.data, bmap2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_is_disjoint\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.is_disjoint = is_disjoint

    def partial_lexmax(self, dom):
        'partial_lexmax(self, dom)\n\n:param self: :class:`BasicMap`\n:param dom: :class:`BasicSet`\n:return: (:class:`Map`, empty (:class:`Set`))'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(dom, BasicSet):
            raise IslTypeError("dom is not a BasicSet")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        
        _retptr_empty = ffi.new("isl_set **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_partial_lexmax(_copy_self._release(), _copy_dom._release(), _retptr_empty)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_empty == ffi.NULL:
                _ret_empty = None
            else:
                _ret_empty = Set(_data=_retptr_empty[0])
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_partial_lexmax failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_empty

    BasicMap.partial_lexmax = partial_lexmax

    def partial_lexmin(self, dom):
        'partial_lexmin(self, dom)\n\n:param self: :class:`BasicMap`\n:param dom: :class:`BasicSet`\n:return: (:class:`Map`, empty (:class:`Set`))'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(dom, BasicSet):
            raise IslTypeError("dom is not a BasicSet")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        
        _retptr_empty = ffi.new("isl_set **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_partial_lexmin(_copy_self._release(), _copy_dom._release(), _retptr_empty)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_empty == ffi.NULL:
                _ret_empty = None
            else:
                _ret_empty = Set(_data=_retptr_empty[0])
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_partial_lexmin failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_empty

    BasicMap.partial_lexmin = partial_lexmin

    def lexmin(self):
        'lexmin(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`Map`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_lexmin(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_lexmin failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.lexmin = lexmin

    def lexmax(self):
        'lexmax(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`Map`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_lexmax(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_lexmax failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.lexmax = lexmax

    def partial_lexmin_pw_multi_aff(self, dom):
        'partial_lexmin_pw_multi_aff(self, dom)\n\n:param self: :class:`BasicMap`\n:param dom: :class:`BasicSet`\n:return: (:class:`PwMultiAff`, empty (:class:`Set`))'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(dom, BasicSet):
            raise IslTypeError("dom is not a BasicSet")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        
        _retptr_empty = ffi.new("isl_set **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_partial_lexmin_pw_multi_aff(_copy_self._release(), _copy_dom._release(), _retptr_empty)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_empty == ffi.NULL:
                _ret_empty = None
            else:
                _ret_empty = Set(_data=_retptr_empty[0])
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_partial_lexmin_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_empty

    BasicMap.partial_lexmin_pw_multi_aff = partial_lexmin_pw_multi_aff

    def partial_lexmax_pw_multi_aff(self, dom):
        'partial_lexmax_pw_multi_aff(self, dom)\n\n:param self: :class:`BasicMap`\n:param dom: :class:`BasicSet`\n:return: (:class:`PwMultiAff`, empty (:class:`Set`))'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(dom, BasicSet):
            raise IslTypeError("dom is not a BasicSet")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        
        _retptr_empty = ffi.new("isl_set **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_partial_lexmax_pw_multi_aff(_copy_self._release(), _copy_dom._release(), _retptr_empty)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_empty == ffi.NULL:
                _ret_empty = None
            else:
                _ret_empty = Set(_data=_retptr_empty[0])
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_partial_lexmax_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_empty

    BasicMap.partial_lexmax_pw_multi_aff = partial_lexmax_pw_multi_aff

    def lexmin_pw_multi_aff(self):
        'lexmin_pw_multi_aff(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`PwMultiAff`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_lexmin_pw_multi_aff(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_lexmin_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.lexmin_pw_multi_aff = lexmin_pw_multi_aff

    def plain_get_val_if_fixed(self, type, pos):
        'plain_get_val_if_fixed(self, type, pos)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Val`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_plain_get_val_if_fixed(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_plain_get_val_if_fixed failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.plain_get_val_if_fixed = plain_get_val_if_fixed

    def image_is_bounded(self):
        'image_is_bounded(self)\n\n:param self: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_image_is_bounded(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_image_is_bounded\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.image_is_bounded = image_is_bounded

    def plain_is_universe(self):
        'plain_is_universe(self)\n\n:param self: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_plain_is_universe(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_plain_is_universe\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.plain_is_universe = plain_is_universe

    def is_universe(self):
        'is_universe(self)\n\n:param self: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_is_universe(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_is_universe\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.is_universe = is_universe

    def plain_is_empty(self):
        'plain_is_empty(self)\n\n:param self: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_plain_is_empty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_plain_is_empty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.plain_is_empty = plain_is_empty

    def is_empty(self):
        'is_empty(self)\n\n:param self: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_is_empty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_is_empty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.is_empty = is_empty

    def is_subset(self, bmap2):
        'is_subset(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_is_subset(self.data, bmap2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_is_subset\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.is_subset = is_subset

    def is_strict_subset(self, bmap2):
        'is_strict_subset(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_is_strict_subset(self.data, bmap2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_is_strict_subset\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.is_strict_subset = is_strict_subset

    def product(self, bmap2):
        'product(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        _copy_bmap2 = bmap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_product(_copy_self._release(), _copy_bmap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.product = product

    def domain_product(self, bmap2):
        'domain_product(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        _copy_bmap2 = bmap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_domain_product(_copy_self._release(), _copy_bmap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_domain_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.domain_product = domain_product

    def range_product(self, bmap2):
        'range_product(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        _copy_bmap2 = bmap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_range_product(_copy_self._release(), _copy_bmap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.range_product = range_product

    def flat_product(self, bmap2):
        'flat_product(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        _copy_bmap2 = bmap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_flat_product(_copy_self._release(), _copy_bmap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_flat_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.flat_product = flat_product

    def flat_range_product(self, bmap2):
        'flat_range_product(self, bmap2)\n\n:param self: :class:`BasicMap`\n:param bmap2: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(bmap2, BasicMap):
            raise IslTypeError("bmap2 is not a BasicMap")
        if _ctx_data != bmap2._ctx_data:
            raise Error("mismatched context in bmap2")
        _copy_bmap2 = bmap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_flat_range_product(_copy_self._release(), _copy_bmap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_flat_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.flat_range_product = flat_range_product

    def deltas(self):
        'deltas(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_deltas(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_deltas failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.deltas = deltas

    def deltas_map(self):
        'deltas_map(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_deltas_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_deltas_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.deltas_map = deltas_map

    def add_dims(self, type, n):
        'add_dims(self, type, n)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param n: :class:`unsigned`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_add_dims(_copy_self._release(), type, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_add_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.add_dims = add_dims

    def insert_dims(self, type, pos, n):
        'insert_dims(self, type, pos, n)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_insert_dims(_copy_self._release(), type, pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_insert_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.insert_dims = insert_dims

    def move_dims(self, dst_type, dst_pos, src_type, src_pos, n):
        'move_dims(self, dst_type, dst_pos, src_type, src_pos, n)\n\n:param self: :class:`BasicMap`\n:param dst_type: :class:`dim_type`\n:param dst_pos: :class:`unsigned`\n:param src_type: :class:`dim_type`\n:param src_pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_type
        
        # no argument processing for dst_pos
        
        # no argument processing for src_type
        
        # no argument processing for src_pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_move_dims(_copy_self._release(), dst_type, dst_pos, src_type, src_pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_move_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.move_dims = move_dims

    def project_out(self, type, first, n):
        'project_out(self, type, first, n)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_project_out(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_project_out failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.project_out = project_out

    def remove_divs(self):
        'remove_divs(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_remove_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_remove_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.remove_divs = remove_divs

    def remove_divs_involving_dims(self, type, first, n):
        'remove_divs_involving_dims(self, type, first, n)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_remove_divs_involving_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_remove_divs_involving_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.remove_divs_involving_dims = remove_divs_involving_dims

    def equate(self, type1, pos1, type2, pos2):
        'equate(self, type1, pos1, type2, pos2)\n\n:param self: :class:`BasicMap`\n:param type1: :class:`dim_type`\n:param pos1: :class:`int`\n:param type2: :class:`dim_type`\n:param pos2: :class:`int`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type1
        
        # no argument processing for pos1
        
        # no argument processing for type2
        
        # no argument processing for pos2
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_equate(_copy_self._release(), type1, pos1, type2, pos2)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_equate failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.equate = equate

    def order_ge(self, type1, pos1, type2, pos2):
        'order_ge(self, type1, pos1, type2, pos2)\n\n:param self: :class:`BasicMap`\n:param type1: :class:`dim_type`\n:param pos1: :class:`int`\n:param type2: :class:`dim_type`\n:param pos2: :class:`int`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type1
        
        # no argument processing for pos1
        
        # no argument processing for type2
        
        # no argument processing for pos2
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_order_ge(_copy_self._release(), type1, pos1, type2, pos2)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_order_ge failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.order_ge = order_ge

    def order_gt(self, type1, pos1, type2, pos2):
        'order_gt(self, type1, pos1, type2, pos2)\n\n:param self: :class:`BasicMap`\n:param type1: :class:`dim_type`\n:param pos1: :class:`int`\n:param type2: :class:`dim_type`\n:param pos2: :class:`int`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type1
        
        # no argument processing for pos1
        
        # no argument processing for type2
        
        # no argument processing for pos2
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_order_gt(_copy_self._release(), type1, pos1, type2, pos2)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_order_gt failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.order_gt = order_gt

    def wrap(self):
        'wrap(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicSet`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_wrap(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_wrap failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.wrap = wrap

    def flatten(self):
        'flatten(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_flatten(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_flatten failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.flatten = flatten

    def flatten_domain(self):
        'flatten_domain(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_flatten_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_flatten_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.flatten_domain = flatten_domain

    def flatten_range(self):
        'flatten_range(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_flatten_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_flatten_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.flatten_range = flatten_range

    def from_domain(bset):
        'from_domain(bset)\n\n:param bset: :class:`BasicSet`\n:return: :class:`BasicMap`'

        if not isinstance(bset, BasicSet):
            raise IslTypeError("bset is not a BasicSet")
        _ctx_data = bset._ctx_data
        _copy_bset = bset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_from_domain(_copy_bset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_from_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.from_domain = staticmethod(from_domain)

    BasicMap._from_domain_is_static = True

    def from_range(bset):
        'from_range(bset)\n\n:param bset: :class:`BasicSet`\n:return: :class:`BasicMap`'

        if not isinstance(bset, BasicSet):
            raise IslTypeError("bset is not a BasicSet")
        _ctx_data = bset._ctx_data
        _copy_bset = bset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_from_range(_copy_bset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_from_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.from_range = staticmethod(from_range)

    BasicMap._from_range_is_static = True

    def from_domain_and_range(domain, range):
        'from_domain_and_range(domain, range)\n\n:param domain: :class:`BasicSet`\n:param range: :class:`BasicSet`\n:return: :class:`BasicMap`'

        if not isinstance(domain, BasicSet):
            raise IslTypeError("domain is not a BasicSet")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        if not isinstance(range, BasicSet):
            raise IslTypeError("range is not a BasicSet")
        if _ctx_data != range._ctx_data:
            raise Error("mismatched context in range")
        _copy_range = range._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_from_domain_and_range(_copy_domain._release(), _copy_range._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_from_domain_and_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.from_domain_and_range = staticmethod(from_domain_and_range)

    BasicMap._from_domain_and_range_is_static = True

    def is_single_valued(self):
        'is_single_valued(self)\n\n:param self: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_is_single_valued(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_is_single_valued\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.is_single_valued = is_single_valued

    def can_zip(self):
        'can_zip(self)\n\n:param self: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_can_zip(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_can_zip\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.can_zip = can_zip

    def zip(self):
        'zip(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_zip(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_zip failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.zip = zip

    def can_curry(self):
        'can_curry(self)\n\n:param self: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_can_curry(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_can_curry\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.can_curry = can_curry

    def curry(self):
        'curry(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_curry(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_curry failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.curry = curry

    def can_uncurry(self):
        'can_uncurry(self)\n\n:param self: :class:`BasicMap`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_can_uncurry(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_can_uncurry\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.can_uncurry = can_uncurry

    def uncurry(self):
        'uncurry(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_uncurry(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_uncurry failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.uncurry = uncurry

    def compute_divs(self):
        'compute_divs(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`Map`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_compute_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_compute_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.compute_divs = compute_divs

    def drop_constraints_involving_dims(self, type, first, n):
        'drop_constraints_involving_dims(self, type, first, n)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_drop_constraints_involving_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_drop_constraints_involving_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.drop_constraints_involving_dims = drop_constraints_involving_dims

    def drop_constraints_not_involving_dims(self, type, first, n):
        'drop_constraints_not_involving_dims(self, type, first, n)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_drop_constraints_not_involving_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_drop_constraints_not_involving_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.drop_constraints_not_involving_dims = drop_constraints_not_involving_dims

    def involves_dims(self, type, first, n):
        'involves_dims(self, type, first, n)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: bool'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_involves_dims(self.data, type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_involves_dims\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    BasicMap.involves_dims = involves_dims

    def gist_domain(self, context):
        'gist_domain(self, context)\n\n:param self: :class:`BasicMap`\n:param context: :class:`BasicSet`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(context, BasicSet):
            raise IslTypeError("context is not a BasicSet")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_gist_domain(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_gist_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.gist_domain = gist_domain

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`BasicMap`\n:param context: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(context, BasicMap):
            raise IslTypeError("context is not a BasicMap")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.gist = gist

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`BasicMap`\n:param model: :class:`Space`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.align_params = align_params

    def drop_unused_params(self):
        'drop_unused_params(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_drop_unused_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_drop_unused_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.drop_unused_params = drop_unused_params

    def equalities_matrix(self, c1, c2, c3, c4, c5):
        'equalities_matrix(self, c1, c2, c3, c4, c5)\n\n:param self: :class:`BasicMap`\n:param c1: :class:`dim_type`\n:param c2: :class:`dim_type`\n:param c3: :class:`dim_type`\n:param c4: :class:`dim_type`\n:param c5: :class:`dim_type`\n:return: :class:`Mat`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for c1
        
        # no argument processing for c2
        
        # no argument processing for c3
        
        # no argument processing for c4
        
        # no argument processing for c5
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_equalities_matrix(self.data, c1, c2, c3, c4, c5)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_equalities_matrix failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.equalities_matrix = equalities_matrix

    def inequalities_matrix(self, c1, c2, c3, c4, c5):
        'inequalities_matrix(self, c1, c2, c3, c4, c5)\n\n:param self: :class:`BasicMap`\n:param c1: :class:`dim_type`\n:param c2: :class:`dim_type`\n:param c3: :class:`dim_type`\n:param c4: :class:`dim_type`\n:param c5: :class:`dim_type`\n:return: :class:`Mat`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for c1
        
        # no argument processing for c2
        
        # no argument processing for c3
        
        # no argument processing for c4
        
        # no argument processing for c5
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_inequalities_matrix(self.data, c1, c2, c3, c4, c5)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Mat(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_inequalities_matrix failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.inequalities_matrix = inequalities_matrix

    def from_constraint_matrices(dim, eq, ineq, c1, c2, c3, c4, c5):
        'from_constraint_matrices(dim, eq, ineq, c1, c2, c3, c4, c5)\n\n:param dim: :class:`Space`\n:param eq: :class:`Mat`\n:param ineq: :class:`Mat`\n:param c1: :class:`dim_type`\n:param c2: :class:`dim_type`\n:param c3: :class:`dim_type`\n:param c4: :class:`dim_type`\n:param c5: :class:`dim_type`\n:return: :class:`BasicMap`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        
        if not isinstance(eq, Mat):
            raise IslTypeError("eq is not a Mat")
        if _ctx_data != eq._ctx_data:
            raise Error("mismatched context in eq")
        _copy_eq = eq._copy()
        
        if not isinstance(ineq, Mat):
            raise IslTypeError("ineq is not a Mat")
        if _ctx_data != ineq._ctx_data:
            raise Error("mismatched context in ineq")
        _copy_ineq = ineq._copy()
        
        # no argument processing for c1
        
        # no argument processing for c2
        
        # no argument processing for c3
        
        # no argument processing for c4
        
        # no argument processing for c5
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_from_constraint_matrices(_copy_dim._release(), _copy_eq._release(), _copy_ineq._release(), c1, c2, c3, c4, c5)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_from_constraint_matrices failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.from_constraint_matrices = staticmethod(from_constraint_matrices)

    BasicMap._from_constraint_matrices_is_static = True

    def from_aff(aff):
        'from_aff(aff)\n\n:param aff: :class:`Aff`\n:return: :class:`BasicMap`'

        if not isinstance(aff, Aff):
            raise IslTypeError("aff is not a Aff")
        _ctx_data = aff._ctx_data
        _copy_aff = aff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_from_aff(_copy_aff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_from_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.from_aff = staticmethod(from_aff)

    BasicMap._from_aff_is_static = True

    def from_multi_aff(maff):
        'from_multi_aff(maff)\n\n:param maff: :class:`MultiAff`\n:return: :class:`BasicMap`'

        if not isinstance(maff, MultiAff):
            raise IslTypeError("maff is not a MultiAff")
        _ctx_data = maff._ctx_data
        _copy_maff = maff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_from_multi_aff(_copy_maff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_from_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.from_multi_aff = staticmethod(from_multi_aff)

    BasicMap._from_multi_aff_is_static = True

    def from_aff_list(domain_space, list):
        'from_aff_list(domain_space, list)\n\n:param domain_space: :class:`Space`\n:param list: :class:`AffList`\n:return: :class:`BasicMap`'

        if not isinstance(domain_space, Space):
            raise IslTypeError("domain_space is not a Space")
        _ctx_data = domain_space._ctx_data
        _copy_domain_space = domain_space._copy()
        
        if not isinstance(list, AffList):
            raise IslTypeError("list is not a AffList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        _copy_list = list._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_from_aff_list(_copy_domain_space._release(), _copy_list._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_from_aff_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.from_aff_list = staticmethod(from_aff_list)

    BasicMap._from_aff_list_is_static = True

    def from_qpolynomial(qp):
        'from_qpolynomial(qp)\n\n:param qp: :class:`QPolynomial`\n:return: :class:`BasicMap`'

        if not isinstance(qp, QPolynomial):
            raise IslTypeError("qp is not a QPolynomial")
        _ctx_data = qp._ctx_data
        _copy_qp = qp._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_from_qpolynomial(_copy_qp._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_from_qpolynomial failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.from_qpolynomial = staticmethod(from_qpolynomial)

    BasicMap._from_qpolynomial_is_static = True

    def n_constraint(self):
        'n_constraint(self)\n\n:param self: :class:`BasicMap`\n:return: isl_size'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_n_constraint(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    BasicMap.n_constraint = n_constraint

    def foreach_constraint(self, fn):
        'foreach_constraint(self, fn)\n\n:param self: :class:`BasicMap`\n:param fn: callback(c) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(c, user):
            try:
                _py_c = Constraint(_data=c)
                _result = fn(_py_c)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_constraint *c,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_foreach_constraint(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_basic_map_foreach_constraint\" failed: %s" % _get_last_error_str(_ctx_data))
        

    BasicMap.foreach_constraint = foreach_constraint

    def get_constraint_list(self):
        'get_constraint_list(self)\n\n:param self: :class:`BasicMap`\n:return: :class:`ConstraintList`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_get_constraint_list(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ConstraintList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_get_constraint_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.get_constraint_list = get_constraint_list

    def add_constraint(self, constraint):
        'add_constraint(self, constraint)\n\n:param self: :class:`BasicMap`\n:param constraint: :class:`Constraint`\n:return: :class:`BasicMap`'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(constraint, Constraint):
            raise IslTypeError("constraint is not a Constraint")
        if _ctx_data != constraint._ctx_data:
            raise Error("mismatched context in constraint")
        _copy_constraint = constraint._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_add_constraint(_copy_self._release(), _copy_constraint._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_add_constraint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.add_constraint = add_constraint

    def has_defining_equality(self, type, pos):
        'has_defining_equality(self, type, pos)\n\n:param self: :class:`BasicMap`\n:param type: :class:`dim_type`\n:param pos: :class:`int`\n:return: (bool, c (:class:`Constraint`))'

        if not isinstance(self, BasicMap):
            raise IslTypeError("self is not a BasicMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _retptr_c = ffi.new("isl_constraint **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_has_defining_equality(self.data, type, pos, _retptr_c)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_c == ffi.NULL:
                _ret_c = None
            else:
                _ret_c = Constraint(_data=_retptr_c[0])
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_basic_map_has_defining_equality\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true, _ret_c

    BasicMap.has_defining_equality = has_defining_equality

    def from_constraint(constraint):
        'from_constraint(constraint)\n\n:param constraint: :class:`Constraint`\n:return: :class:`BasicMap`'

        if not isinstance(constraint, Constraint):
            raise IslTypeError("constraint is not a Constraint")
        _ctx_data = constraint._ctx_data
        _copy_constraint = constraint._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_basic_map_from_constraint(_copy_constraint._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_basic_map_from_constraint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    BasicMap.from_constraint = staticmethod(from_constraint)

    BasicMap._from_constraint_is_static = True

    # }}}

    # {{{ set

    def n_dim(self):
        'n_dim(self)\n\n:param self: :class:`Set`\n:return: isl_size'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_n_dim(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Set.n_dim = n_dim

    def n_param(self):
        'n_param(self)\n\n:param self: :class:`Set`\n:return: isl_size'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_n_param(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Set.n_param = n_param

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:return: isl_size'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Set.dim = dim

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Set`\n:return: :class:`Context`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.get_ctx = get_ctx

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`Set`\n:return: :class:`Space`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.get_space = get_space

    def reset_space(self, dim):
        'reset_space(self, dim)\n\n:param self: :class:`Set`\n:param dim: :class:`Space`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        if _ctx_data != dim._ctx_data:
            raise Error("mismatched context in dim")
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_reset_space(_copy_self._release(), _copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_reset_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.reset_space = reset_space

    def has_tuple_name(self):
        'has_tuple_name(self)\n\n:param self: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_has_tuple_name(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_has_tuple_name\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.has_tuple_name = has_tuple_name

    def get_tuple_name(self):
        'get_tuple_name(self)\n\n:param self: :class:`Set`\n:return: string'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_get_tuple_name(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Set.get_tuple_name = get_tuple_name

    def set_tuple_name(self, s):
        'set_tuple_name(self, s)\n\n:param self: :class:`Set`\n:param s: string\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_set_tuple_name(_copy_self._release(), _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_set_tuple_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.set_tuple_name = set_tuple_name

    def has_dim_name(self, type, pos):
        'has_dim_name(self, type, pos)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_has_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_has_dim_name\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.has_dim_name = has_dim_name

    def get_dim_name(self, type, pos):
        'get_dim_name(self, type, pos)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: string'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_get_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Set.get_dim_name = get_dim_name

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.set_dim_name = set_dim_name

    def set_dim_id(self, type, pos, id):
        'set_dim_id(self, type, pos, id)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param id: :class:`Id`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_set_dim_id(_copy_self._release(), type, pos, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_set_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.set_dim_id = set_dim_id

    def has_dim_id(self, type, pos):
        'has_dim_id(self, type, pos)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_has_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_has_dim_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.has_dim_id = has_dim_id

    def get_dim_id(self, type, pos):
        'get_dim_id(self, type, pos)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Id`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_get_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_get_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.get_dim_id = get_dim_id

    def set_tuple_id(self, id):
        'set_tuple_id(self, id)\n\n:param self: :class:`Set`\n:param id: :class:`Id`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_set_tuple_id(_copy_self._release(), _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_set_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.set_tuple_id = set_tuple_id

    def reset_tuple_id(self):
        'reset_tuple_id(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_reset_tuple_id(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_reset_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.reset_tuple_id = reset_tuple_id

    def has_tuple_id(self):
        'has_tuple_id(self)\n\n:param self: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_has_tuple_id(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_has_tuple_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.has_tuple_id = has_tuple_id

    def get_tuple_id(self):
        'get_tuple_id(self)\n\n:param self: :class:`Set`\n:return: :class:`Id`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_get_tuple_id(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_get_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.get_tuple_id = get_tuple_id

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.reset_user = reset_user

    def find_dim_by_id(self, type, id):
        'find_dim_by_id(self, type, id)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: int'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_find_dim_by_id(self.data, type, id.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Set.find_dim_by_id = find_dim_by_id

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Set.find_dim_by_name = find_dim_by_name

    def remove_redundancies(self):
        'remove_redundancies(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_remove_redundancies(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_remove_redundancies failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.remove_redundancies = remove_redundancies

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`Set`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.read_from_str = staticmethod(read_from_str)

    Set._read_from_str_is_static = True

    def dump(self):
        'dump(self)\n\n:param self: :class:`Set`\n:return: (nothing)'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_dump(self.data)
        finally:
            pass
        

    Set.dump = dump

    def lower_bound_val(self, type, pos, value):
        'lower_bound_val(self, type, pos, value)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param value: :class:`Val`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if isinstance(value, Val):
            if _ctx_data != value._ctx_data:
                raise Error("mismatched context in value")
            _val_value = value._copy()
        elif isinstance(value, six.integer_types):
            _cdata_value = lib.isl_val_int_from_si(
                self._get_ctx_data(), value)
        
            if _cdata_value == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_value = Val(_data=_cdata_value)
        
        else:
            raise IslTypeError("value is a %s and cannot "
                "be cast to a Val" % type(value))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_lower_bound_val(_copy_self._release(), type, pos, _val_value._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_lower_bound_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.lower_bound_val = lower_bound_val

    def upper_bound_val(self, type, pos, value):
        'upper_bound_val(self, type, pos, value)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param value: :class:`Val`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if isinstance(value, Val):
            if _ctx_data != value._ctx_data:
                raise Error("mismatched context in value")
            _val_value = value._copy()
        elif isinstance(value, six.integer_types):
            _cdata_value = lib.isl_val_int_from_si(
                self._get_ctx_data(), value)
        
            if _cdata_value == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_value = Val(_data=_cdata_value)
        
        else:
            raise IslTypeError("value is a %s and cannot "
                "be cast to a Val" % type(value))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_upper_bound_val(_copy_self._release(), type, pos, _val_value._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_upper_bound_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.upper_bound_val = upper_bound_val

    def equate(self, type1, pos1, type2, pos2):
        'equate(self, type1, pos1, type2, pos2)\n\n:param self: :class:`Set`\n:param type1: :class:`dim_type`\n:param pos1: :class:`int`\n:param type2: :class:`dim_type`\n:param pos2: :class:`int`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type1
        
        # no argument processing for pos1
        
        # no argument processing for type2
        
        # no argument processing for pos2
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_equate(_copy_self._release(), type1, pos1, type2, pos2)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_equate failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.equate = equate

    def partial_lexmin(self, dom):
        'partial_lexmin(self, dom)\n\n:param self: :class:`Set`\n:param dom: :class:`Set`\n:return: (:class:`Set`, empty (:class:`Set`))'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(dom, BasicSet):
            dom = Set.from_basic_set(dom)
        if not isinstance(dom, Set):
            raise IslTypeError("dom is not a Set")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        
        _retptr_empty = ffi.new("isl_set **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_partial_lexmin(_copy_self._release(), _copy_dom._release(), _retptr_empty)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_empty == ffi.NULL:
                _ret_empty = None
            else:
                _ret_empty = Set(_data=_retptr_empty[0])
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_partial_lexmin failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_empty

    Set.partial_lexmin = partial_lexmin

    def partial_lexmax(self, dom):
        'partial_lexmax(self, dom)\n\n:param self: :class:`Set`\n:param dom: :class:`Set`\n:return: (:class:`Set`, empty (:class:`Set`))'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(dom, BasicSet):
            dom = Set.from_basic_set(dom)
        if not isinstance(dom, Set):
            raise IslTypeError("dom is not a Set")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        
        _retptr_empty = ffi.new("isl_set **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_partial_lexmax(_copy_self._release(), _copy_dom._release(), _retptr_empty)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_empty == ffi.NULL:
                _ret_empty = None
            else:
                _ret_empty = Set(_data=_retptr_empty[0])
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_partial_lexmax failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_empty

    Set.partial_lexmax = partial_lexmax

    def lexmin(self):
        'lexmin(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_lexmin(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_lexmin failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.lexmin = lexmin

    def lexmax(self):
        'lexmax(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_lexmax(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_lexmax failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.lexmax = lexmax

    def lexmin_pw_multi_aff(self):
        'lexmin_pw_multi_aff(self)\n\n:param self: :class:`Set`\n:return: :class:`PwMultiAff`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_lexmin_pw_multi_aff(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_lexmin_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.lexmin_pw_multi_aff = lexmin_pw_multi_aff

    def lexmax_pw_multi_aff(self):
        'lexmax_pw_multi_aff(self)\n\n:param self: :class:`Set`\n:return: :class:`PwMultiAff`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_lexmax_pw_multi_aff(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_lexmax_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.lexmax_pw_multi_aff = lexmax_pw_multi_aff

    def follows_at(self, set2, pos):
        'follows_at(self, set2, pos)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:param pos: :class:`int`\n:return: int'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_follows_at(self.data, set2.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Set.follows_at = follows_at

    def params(self):
        'params(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.params = params

    def from_params(self):
        'from_params(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_from_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_from_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.from_params = from_params

    def bind(self, tuple):
        'bind(self, tuple)\n\n:param self: :class:`Set`\n:param tuple: :class:`MultiId`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(tuple, MultiId):
            raise IslTypeError("tuple is not a MultiId")
        if _ctx_data != tuple._ctx_data:
            raise Error("mismatched context in tuple")
        _copy_tuple = tuple._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_bind(_copy_self._release(), _copy_tuple._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_bind failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.bind = bind

    def unbind_params(self, tuple):
        'unbind_params(self, tuple)\n\n:param self: :class:`Set`\n:param tuple: :class:`MultiId`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(tuple, MultiId):
            raise IslTypeError("tuple is not a MultiId")
        if _ctx_data != tuple._ctx_data:
            raise Error("mismatched context in tuple")
        _copy_tuple = tuple._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_unbind_params(_copy_self._release(), _copy_tuple._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_unbind_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.unbind_params = unbind_params

    def unbind_params_insert_domain(self, domain):
        'unbind_params_insert_domain(self, domain)\n\n:param self: :class:`Set`\n:param domain: :class:`MultiId`\n:return: :class:`Map`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(domain, MultiId):
            raise IslTypeError("domain is not a MultiId")
        if _ctx_data != domain._ctx_data:
            raise Error("mismatched context in domain")
        _copy_domain = domain._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_unbind_params_insert_domain(_copy_self._release(), _copy_domain._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_unbind_params_insert_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.unbind_params_insert_domain = unbind_params_insert_domain

    def empty(space):
        'empty(space)\n\n:param space: :class:`Space`\n:return: :class:`Set`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_empty(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_empty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.empty = staticmethod(empty)

    Set._empty_is_static = True

    def universe(space):
        'universe(space)\n\n:param space: :class:`Space`\n:return: :class:`Set`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_universe(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_universe failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.universe = staticmethod(universe)

    Set._universe_is_static = True

    def nat_universe(dim):
        'nat_universe(dim)\n\n:param dim: :class:`Space`\n:return: :class:`Set`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_nat_universe(_copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_nat_universe failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.nat_universe = staticmethod(nat_universe)

    Set._nat_universe_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.copy = copy

    def from_basic_set(bset):
        'from_basic_set(bset)\n\n:param bset: :class:`BasicSet`\n:return: :class:`Set`'

        if not isinstance(bset, BasicSet):
            raise IslTypeError("bset is not a BasicSet")
        _ctx_data = bset._ctx_data
        _copy_bset = bset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_from_basic_set(_copy_bset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_from_basic_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.from_basic_set = staticmethod(from_basic_set)

    Set._from_basic_set_is_static = True

    def sample(self):
        'sample(self)\n\n:param self: :class:`Set`\n:return: :class:`BasicSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_sample(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_sample failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.sample = sample

    def sample_point(self):
        'sample_point(self)\n\n:param self: :class:`Set`\n:return: :class:`Point`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_sample_point(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Point(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_sample_point failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.sample_point = sample_point

    def detect_equalities(self):
        'detect_equalities(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_detect_equalities(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_detect_equalities failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.detect_equalities = detect_equalities

    def affine_hull(self):
        'affine_hull(self)\n\n:param self: :class:`Set`\n:return: :class:`BasicSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_affine_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_affine_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.affine_hull = affine_hull

    def convex_hull(self):
        'convex_hull(self)\n\n:param self: :class:`Set`\n:return: :class:`BasicSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_convex_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_convex_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.convex_hull = convex_hull

    def polyhedral_hull(self):
        'polyhedral_hull(self)\n\n:param self: :class:`Set`\n:return: :class:`BasicSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_polyhedral_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_polyhedral_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.polyhedral_hull = polyhedral_hull

    def simple_hull(self):
        'simple_hull(self)\n\n:param self: :class:`Set`\n:return: :class:`BasicSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_simple_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_simple_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.simple_hull = simple_hull

    def unshifted_simple_hull(self):
        'unshifted_simple_hull(self)\n\n:param self: :class:`Set`\n:return: :class:`BasicSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_unshifted_simple_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_unshifted_simple_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.unshifted_simple_hull = unshifted_simple_hull

    def plain_unshifted_simple_hull(self):
        'plain_unshifted_simple_hull(self)\n\n:param self: :class:`Set`\n:return: :class:`BasicSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_plain_unshifted_simple_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_plain_unshifted_simple_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.plain_unshifted_simple_hull = plain_unshifted_simple_hull

    def unshifted_simple_hull_from_set_list(self, list):
        'unshifted_simple_hull_from_set_list(self, list)\n\n:param self: :class:`Set`\n:param list: :class:`SetList`\n:return: :class:`BasicSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list, SetList):
            raise IslTypeError("list is not a SetList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        _copy_list = list._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_unshifted_simple_hull_from_set_list(_copy_self._release(), _copy_list._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_unshifted_simple_hull_from_set_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.unshifted_simple_hull_from_set_list = unshifted_simple_hull_from_set_list

    def bounded_simple_hull(self):
        'bounded_simple_hull(self)\n\n:param self: :class:`Set`\n:return: :class:`BasicSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_bounded_simple_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_bounded_simple_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.bounded_simple_hull = bounded_simple_hull

    def union_disjoint(self, set2):
        'union_disjoint(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        _copy_set2 = set2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_union_disjoint(_copy_self._release(), _copy_set2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_union_disjoint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.union_disjoint = union_disjoint

    def union(self, set2):
        'union(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        _copy_set2 = set2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_union(_copy_self._release(), _copy_set2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_union failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.union = union

    def product(self, set2):
        'product(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        _copy_set2 = set2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_product(_copy_self._release(), _copy_set2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.product = product

    def flat_product(self, set2):
        'flat_product(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        _copy_set2 = set2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_flat_product(_copy_self._release(), _copy_set2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_flat_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.flat_product = flat_product

    def intersect(self, set2):
        'intersect(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        _copy_set2 = set2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_intersect(_copy_self._release(), _copy_set2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_intersect failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.intersect = intersect

    def intersect_params(self, params):
        'intersect_params(self, params)\n\n:param self: :class:`Set`\n:param params: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(params, BasicSet):
            params = Set.from_basic_set(params)
        if not isinstance(params, Set):
            raise IslTypeError("params is not a Set")
        if _ctx_data != params._ctx_data:
            raise Error("mismatched context in params")
        _copy_params = params._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_intersect_params(_copy_self._release(), _copy_params._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.intersect_params = intersect_params

    def subtract(self, set2):
        'subtract(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        _copy_set2 = set2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_subtract(_copy_self._release(), _copy_set2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_subtract failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.subtract = subtract

    def complement(self):
        'complement(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_complement(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_complement failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.complement = complement

    def apply(self, map):
        'apply(self, map)\n\n:param self: :class:`Set`\n:param map: :class:`Map`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map, BasicMap):
            map = Map.from_basic_map(map)
        if not isinstance(map, Map):
            raise IslTypeError("map is not a Map")
        if _ctx_data != map._ctx_data:
            raise Error("mismatched context in map")
        _copy_map = map._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_apply(_copy_self._release(), _copy_map._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_apply failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.apply = apply

    def preimage_multi_aff(self, ma):
        'preimage_multi_aff(self, ma)\n\n:param self: :class:`Set`\n:param ma: :class:`MultiAff`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_preimage_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_preimage_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.preimage_multi_aff = preimage_multi_aff

    def preimage_pw_multi_aff(self, pma):
        'preimage_pw_multi_aff(self, pma)\n\n:param self: :class:`Set`\n:param pma: :class:`PwMultiAff`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_preimage_pw_multi_aff(_copy_self._release(), _copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_preimage_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.preimage_pw_multi_aff = preimage_pw_multi_aff

    def preimage_multi_pw_aff(self, mpa):
        'preimage_multi_pw_aff(self, mpa)\n\n:param self: :class:`Set`\n:param mpa: :class:`MultiPwAff`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mpa, MultiPwAff):
            raise IslTypeError("mpa is not a MultiPwAff")
        if _ctx_data != mpa._ctx_data:
            raise Error("mismatched context in mpa")
        _copy_mpa = mpa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_preimage_multi_pw_aff(_copy_self._release(), _copy_mpa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_preimage_multi_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.preimage_multi_pw_aff = preimage_multi_pw_aff

    def fix_val(self, type, pos, v):
        'fix_val(self, type, pos, v)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param v: :class:`Val`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_fix_val(_copy_self._release(), type, pos, _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_fix_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.fix_val = fix_val

    def insert_dims(self, type, pos, n):
        'insert_dims(self, type, pos, n)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_insert_dims(_copy_self._release(), type, pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_insert_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.insert_dims = insert_dims

    def add_dims(self, type, n):
        'add_dims(self, type, n)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param n: :class:`unsigned`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_add_dims(_copy_self._release(), type, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_add_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.add_dims = add_dims

    def move_dims(self, dst_type, dst_pos, src_type, src_pos, n):
        'move_dims(self, dst_type, dst_pos, src_type, src_pos, n)\n\n:param self: :class:`Set`\n:param dst_type: :class:`dim_type`\n:param dst_pos: :class:`unsigned`\n:param src_type: :class:`dim_type`\n:param src_pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_type
        
        # no argument processing for dst_pos
        
        # no argument processing for src_type
        
        # no argument processing for src_pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_move_dims(_copy_self._release(), dst_type, dst_pos, src_type, src_pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_move_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.move_dims = move_dims

    def project_out(self, type, first, n):
        'project_out(self, type, first, n)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_project_out(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_project_out failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.project_out = project_out

    def project_onto_map(self, type, first, n):
        'project_onto_map(self, type, first, n)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_project_onto_map(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_project_onto_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.project_onto_map = project_onto_map

    def eliminate(self, type, first, n):
        'eliminate(self, type, first, n)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_eliminate(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_eliminate failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.eliminate = eliminate

    def eliminate_dims(self, first, n):
        'eliminate_dims(self, first, n)\n\n:param self: :class:`Set`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_eliminate_dims(_copy_self._release(), first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_eliminate_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.eliminate_dims = eliminate_dims

    def remove_dims(self, type, first, n):
        'remove_dims(self, type, first, n)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_remove_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_remove_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.remove_dims = remove_dims

    def remove_divs_involving_dims(self, type, first, n):
        'remove_divs_involving_dims(self, type, first, n)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_remove_divs_involving_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_remove_divs_involving_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.remove_divs_involving_dims = remove_divs_involving_dims

    def remove_unknown_divs(self):
        'remove_unknown_divs(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_remove_unknown_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_remove_unknown_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.remove_unknown_divs = remove_unknown_divs

    def remove_divs(self):
        'remove_divs(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_remove_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_remove_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.remove_divs = remove_divs

    def split_dims(self, type, first, n):
        'split_dims(self, type, first, n)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_split_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_split_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.split_dims = split_dims

    def drop_constraints_involving_dims(self, type, first, n):
        'drop_constraints_involving_dims(self, type, first, n)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_drop_constraints_involving_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_drop_constraints_involving_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.drop_constraints_involving_dims = drop_constraints_involving_dims

    def drop_constraints_not_involving_dims(self, type, first, n):
        'drop_constraints_not_involving_dims(self, type, first, n)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_drop_constraints_not_involving_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_drop_constraints_not_involving_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.drop_constraints_not_involving_dims = drop_constraints_not_involving_dims

    def involves_dims(self, type, first, n):
        'involves_dims(self, type, first, n)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_involves_dims(self.data, type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_involves_dims\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.involves_dims = involves_dims

    def plain_is_empty(self):
        'plain_is_empty(self)\n\n:param self: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_plain_is_empty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_plain_is_empty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.plain_is_empty = plain_is_empty

    def plain_is_universe(self):
        'plain_is_universe(self)\n\n:param self: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_plain_is_universe(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_plain_is_universe\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.plain_is_universe = plain_is_universe

    def is_params(self):
        'is_params(self)\n\n:param self: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_is_params(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_is_params\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.is_params = is_params

    def is_empty(self):
        'is_empty(self)\n\n:param self: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_is_empty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_is_empty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.is_empty = is_empty

    def is_bounded(self):
        'is_bounded(self)\n\n:param self: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_is_bounded(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_is_bounded\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.is_bounded = is_bounded

    def is_subset(self, set2):
        'is_subset(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_is_subset(self.data, set2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_is_subset\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.is_subset = is_subset

    def is_strict_subset(self, set2):
        'is_strict_subset(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_is_strict_subset(self.data, set2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_is_strict_subset\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.is_strict_subset = is_strict_subset

    def is_equal(self, set2):
        'is_equal(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_is_equal(self.data, set2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.is_equal = is_equal

    def is_disjoint(self, set2):
        'is_disjoint(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_is_disjoint(self.data, set2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_is_disjoint\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.is_disjoint = is_disjoint

    def is_singleton(self):
        'is_singleton(self)\n\n:param self: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_is_singleton(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_is_singleton\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.is_singleton = is_singleton

    def is_box(self):
        'is_box(self)\n\n:param self: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_is_box(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_is_box\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.is_box = is_box

    def has_equal_space(self, set2):
        'has_equal_space(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_has_equal_space(self.data, set2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_has_equal_space\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.has_equal_space = has_equal_space

    def sum(self, set2):
        'sum(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        _copy_set2 = set2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_sum(_copy_self._release(), _copy_set2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_sum failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.sum = sum

    def neg(self):
        'neg(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.neg = neg

    def make_disjoint(self):
        'make_disjoint(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_make_disjoint(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_make_disjoint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.make_disjoint = make_disjoint

    def compute_divs(self):
        'compute_divs(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_compute_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_compute_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.compute_divs = compute_divs

    def align_divs(self):
        'align_divs(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_align_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_align_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.align_divs = align_divs

    def plain_get_val_if_fixed(self, type, pos):
        'plain_get_val_if_fixed(self, type, pos)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Val`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_plain_get_val_if_fixed(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_plain_get_val_if_fixed failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.plain_get_val_if_fixed = plain_get_val_if_fixed

    def dim_is_bounded(self, type, pos):
        'dim_is_bounded(self, type, pos)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_dim_is_bounded(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_dim_is_bounded\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.dim_is_bounded = dim_is_bounded

    def dim_has_lower_bound(self, type, pos):
        'dim_has_lower_bound(self, type, pos)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_dim_has_lower_bound(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_dim_has_lower_bound\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.dim_has_lower_bound = dim_has_lower_bound

    def dim_has_upper_bound(self, type, pos):
        'dim_has_upper_bound(self, type, pos)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_dim_has_upper_bound(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_dim_has_upper_bound\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.dim_has_upper_bound = dim_has_upper_bound

    def dim_has_any_lower_bound(self, type, pos):
        'dim_has_any_lower_bound(self, type, pos)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_dim_has_any_lower_bound(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_dim_has_any_lower_bound\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.dim_has_any_lower_bound = dim_has_any_lower_bound

    def dim_has_any_upper_bound(self, type, pos):
        'dim_has_any_upper_bound(self, type, pos)\n\n:param self: :class:`Set`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_dim_has_any_upper_bound(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_dim_has_any_upper_bound\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.dim_has_any_upper_bound = dim_has_any_upper_bound

    def gist_basic_set(self, context):
        'gist_basic_set(self, context)\n\n:param self: :class:`Set`\n:param context: :class:`BasicSet`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(context, BasicSet):
            raise IslTypeError("context is not a BasicSet")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_gist_basic_set(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_gist_basic_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.gist_basic_set = gist_basic_set

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`Set`\n:param context: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.gist = gist

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`Set`\n:param context: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.gist_params = gist_params

    def dim_residue_class_val(self, pos):
        'dim_residue_class_val(self, pos)\n\n:param self: :class:`Set`\n:param pos: :class:`int`\n:return: (modulo (:class:`Val`), residue (:class:`Val`))'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        
        _retptr_modulo = ffi.new("isl_val **")
        
        _retptr_residue = ffi.new("isl_val **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_dim_residue_class_val(self.data, pos, _retptr_modulo, _retptr_residue)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_modulo == ffi.NULL:
                _ret_modulo = None
            else:
                _ret_modulo = Val(_data=_retptr_modulo[0])
            if _retptr_residue == ffi.NULL:
                _ret_residue = None
            else:
                _ret_residue = Val(_data=_retptr_residue[0])
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_set_dim_residue_class_val\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _ret_modulo, _ret_residue

    Set.dim_residue_class_val = dim_residue_class_val

    def get_stride_info(self, pos):
        'get_stride_info(self, pos)\n\n:param self: :class:`Set`\n:param pos: :class:`int`\n:return: :class:`StrideInfo`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_get_stride_info(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else StrideInfo(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_get_stride_info failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.get_stride_info = get_stride_info

    def get_stride(self, pos):
        'get_stride(self, pos)\n\n:param self: :class:`Set`\n:param pos: :class:`int`\n:return: :class:`Val`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_get_stride(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_get_stride failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.get_stride = get_stride

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.coalesce = coalesce

    def plain_cmp(self, set2):
        'plain_cmp(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: int'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_plain_cmp(self.data, set2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Set.plain_cmp = plain_cmp

    def plain_is_equal(self, set2):
        'plain_is_equal(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_plain_is_equal(self.data, set2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.plain_is_equal = plain_is_equal

    def plain_is_disjoint(self, set2):
        'plain_is_disjoint(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_plain_is_disjoint(self.data, set2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_plain_is_disjoint\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.plain_is_disjoint = plain_is_disjoint

    def n_basic_set(self):
        'n_basic_set(self)\n\n:param self: :class:`Set`\n:return: isl_size'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_n_basic_set(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Set.n_basic_set = n_basic_set

    def foreach_basic_set(self, fn):
        'foreach_basic_set(self, fn)\n\n:param self: :class:`Set`\n:param fn: callback(bset) -> isl_stat\n:return: (nothing)'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(bset, user):
            try:
                _py_bset = BasicSet(_data=bset)
                _result = fn(_py_bset)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_basic_set *bset,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_foreach_basic_set(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_set_foreach_basic_set\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Set.foreach_basic_set = foreach_basic_set

    def get_basic_set_list(self):
        'get_basic_set_list(self)\n\n:param self: :class:`Set`\n:return: :class:`BasicSetList`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_get_basic_set_list(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_get_basic_set_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.get_basic_set_list = get_basic_set_list

    def foreach_point(self, fn):
        'foreach_point(self, fn)\n\n:param self: :class:`Set`\n:param fn: callback(pnt) -> isl_stat\n:return: (nothing)'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(pnt, user):
            try:
                _py_pnt = Point(_data=pnt)
                _result = fn(_py_pnt)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_point *pnt,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_foreach_point(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_set_foreach_point\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Set.foreach_point = foreach_point

    def count_val(self):
        'count_val(self)\n\n:param self: :class:`Set`\n:return: :class:`Val`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_count_val(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_count_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.count_val = count_val

    def from_point(pnt):
        'from_point(pnt)\n\n:param pnt: :class:`Point`\n:return: :class:`Set`'

        if not isinstance(pnt, Point):
            raise IslTypeError("pnt is not a Point")
        _ctx_data = pnt._ctx_data
        _copy_pnt = pnt._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_from_point(_copy_pnt._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_from_point failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.from_point = staticmethod(from_point)

    Set._from_point_is_static = True

    def box_from_points(pnt1, pnt2):
        'box_from_points(pnt1, pnt2)\n\n:param pnt1: :class:`Point`\n:param pnt2: :class:`Point`\n:return: :class:`Set`'

        if not isinstance(pnt1, Point):
            raise IslTypeError("pnt1 is not a Point")
        _ctx_data = pnt1._ctx_data
        _copy_pnt1 = pnt1._copy()
        
        if not isinstance(pnt2, Point):
            raise IslTypeError("pnt2 is not a Point")
        if _ctx_data != pnt2._ctx_data:
            raise Error("mismatched context in pnt2")
        _copy_pnt2 = pnt2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_box_from_points(_copy_pnt1._release(), _copy_pnt2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_box_from_points failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.box_from_points = staticmethod(box_from_points)

    Set._box_from_points_is_static = True

    def lift(self):
        'lift(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_lift(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_lift failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.lift = lift

    def lex_le_set(self, set2):
        'lex_le_set(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        _copy_set2 = set2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_lex_le_set(_copy_self._release(), _copy_set2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_lex_le_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.lex_le_set = lex_le_set

    def lex_lt_set(self, set2):
        'lex_lt_set(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        _copy_set2 = set2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_lex_lt_set(_copy_self._release(), _copy_set2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_lex_lt_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.lex_lt_set = lex_lt_set

    def lex_ge_set(self, set2):
        'lex_ge_set(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        _copy_set2 = set2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_lex_ge_set(_copy_self._release(), _copy_set2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_lex_ge_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.lex_ge_set = lex_ge_set

    def lex_gt_set(self, set2):
        'lex_gt_set(self, set2)\n\n:param self: :class:`Set`\n:param set2: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set2, BasicSet):
            set2 = Set.from_basic_set(set2)
        if not isinstance(set2, Set):
            raise IslTypeError("set2 is not a Set")
        if _ctx_data != set2._ctx_data:
            raise Error("mismatched context in set2")
        _copy_set2 = set2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_lex_gt_set(_copy_self._release(), _copy_set2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_lex_gt_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.lex_gt_set = lex_gt_set

    def size(self):
        'size(self)\n\n:param self: :class:`Set`\n:return: int'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_size(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Set.__len__ = size

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`Set`\n:param model: :class:`Space`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.align_params = align_params

    def drop_unused_params(self):
        'drop_unused_params(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_drop_unused_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_drop_unused_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.drop_unused_params = drop_unused_params

    def from_multi_aff(ma):
        'from_multi_aff(ma)\n\n:param ma: :class:`MultiAff`\n:return: :class:`Set`'

        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        _ctx_data = ma._ctx_data
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_from_multi_aff(_copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_from_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.from_multi_aff = staticmethod(from_multi_aff)

    Set._from_multi_aff_is_static = True

    def coefficients(self):
        'coefficients(self)\n\n:param self: :class:`Set`\n:return: :class:`BasicSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_coefficients(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_coefficients failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.coefficients = coefficients

    def solutions(self):
        'solutions(self)\n\n:param self: :class:`Set`\n:return: :class:`BasicSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_solutions(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_solutions failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.solutions = solutions

    def dim_max(self, pos):
        'dim_max(self, pos)\n\n:param self: :class:`Set`\n:param pos: :class:`int`\n:return: :class:`PwAff`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_dim_max(_copy_self._release(), pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_dim_max failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.dim_max = dim_max

    def dim_min(self, pos):
        'dim_min(self, pos)\n\n:param self: :class:`Set`\n:param pos: :class:`int`\n:return: :class:`PwAff`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_dim_min(_copy_self._release(), pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_dim_min failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.dim_min = dim_min

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`Set`\n:return: string'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Set.to_str = to_str

    def identity(self):
        'identity(self)\n\n:param self: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_identity(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_identity failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.identity = identity

    def is_wrapping(self):
        'is_wrapping(self)\n\n:param self: :class:`Set`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_is_wrapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_set_is_wrapping\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Set.is_wrapping = is_wrapping

    def unwrap(self):
        'unwrap(self)\n\n:param self: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_unwrap(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_unwrap failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.unwrap = unwrap

    def flatten(self):
        'flatten(self)\n\n:param self: :class:`Set`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_flatten(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_flatten failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.flatten = flatten

    def flatten_map(self):
        'flatten_map(self)\n\n:param self: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_flatten_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_flatten_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.flatten_map = flatten_map

    def wrapped_domain_map(self):
        'wrapped_domain_map(self)\n\n:param self: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_wrapped_domain_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_wrapped_domain_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.wrapped_domain_map = wrapped_domain_map

    def indicator_function(self):
        'indicator_function(self)\n\n:param self: :class:`Set`\n:return: :class:`PwAff`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_indicator_function(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_indicator_function failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.indicator_function = indicator_function

    def from_pw_aff(pwaff):
        'from_pw_aff(pwaff)\n\n:param pwaff: :class:`PwAff`\n:return: :class:`Set`'

        if isinstance(pwaff, Aff):
            pwaff = PwAff.from_aff(pwaff)
        if not isinstance(pwaff, PwAff):
            raise IslTypeError("pwaff is not a PwAff")
        _ctx_data = pwaff._ctx_data
        _copy_pwaff = pwaff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_from_pw_aff(_copy_pwaff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_from_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.from_pw_aff = staticmethod(from_pw_aff)

    Set._from_pw_aff_is_static = True

    def from_pw_multi_aff(pma):
        'from_pw_multi_aff(pma)\n\n:param pma: :class:`PwMultiAff`\n:return: :class:`Set`'

        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        _ctx_data = pma._ctx_data
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_from_pw_multi_aff(_copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_from_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.from_pw_multi_aff = staticmethod(from_pw_multi_aff)

    Set._from_pw_multi_aff_is_static = True

    def from_multi_pw_aff(mpa):
        'from_multi_pw_aff(mpa)\n\n:param mpa: :class:`MultiPwAff`\n:return: :class:`Set`'

        if not isinstance(mpa, MultiPwAff):
            raise IslTypeError("mpa is not a MultiPwAff")
        _ctx_data = mpa._ctx_data
        _copy_mpa = mpa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_from_multi_pw_aff(_copy_mpa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_from_multi_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.from_multi_pw_aff = staticmethod(from_multi_pw_aff)

    Set._from_multi_pw_aff_is_static = True

    def from_union_set(uset):
        'from_union_set(uset)\n\n:param uset: :class:`UnionSet`\n:return: :class:`Set`'

        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        _ctx_data = uset._ctx_data
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_from_union_set(_copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_from_union_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.from_union_set = staticmethod(from_union_set)

    Set._from_union_set_is_static = True

    def add_constraint(self, constraint):
        'add_constraint(self, constraint)\n\n:param self: :class:`Set`\n:param constraint: :class:`Constraint`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(constraint, Constraint):
            raise IslTypeError("constraint is not a Constraint")
        if _ctx_data != constraint._ctx_data:
            raise Error("mismatched context in constraint")
        _copy_constraint = constraint._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_add_constraint(_copy_self._release(), _copy_constraint._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_add_constraint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.add_constraint = add_constraint

    def min_val(self, obj):
        'min_val(self, obj)\n\n:param self: :class:`Set`\n:param obj: :class:`Aff`\n:return: :class:`Val`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        if not isinstance(obj, Aff):
            raise IslTypeError("obj is not a Aff")
        if _ctx_data != obj._ctx_data:
            raise Error("mismatched context in obj")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_min_val(self.data, obj.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_min_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.min_val = min_val

    def max_val(self, obj):
        'max_val(self, obj)\n\n:param self: :class:`Set`\n:param obj: :class:`Aff`\n:return: :class:`Val`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if not isinstance(self, Set):
            raise IslTypeError("self is not a Set")
        _ctx_data = self._ctx_data
        
        if not isinstance(obj, Aff):
            raise IslTypeError("obj is not a Aff")
        if _ctx_data != obj._ctx_data:
            raise Error("mismatched context in obj")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_set_max_val(self.data, obj.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_set_max_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Set.max_val = max_val

    # }}}

    # {{{ map

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:return: isl_size'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Map.dim = dim

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Map`\n:return: :class:`Context`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.get_ctx = get_ctx

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`Map`\n:return: :class:`Space`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.get_space = get_space

    def has_tuple_name(self, type):
        'has_tuple_name(self, type)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_has_tuple_name(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_has_tuple_name\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.has_tuple_name = has_tuple_name

    def get_tuple_name(self, type):
        'get_tuple_name(self, type)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:return: string'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_get_tuple_name(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Map.get_tuple_name = get_tuple_name

    def set_tuple_name(self, type, s):
        'set_tuple_name(self, type, s)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param s: string\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_set_tuple_name(_copy_self._release(), type, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_set_tuple_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.set_tuple_name = set_tuple_name

    def has_dim_name(self, type, pos):
        'has_dim_name(self, type, pos)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_has_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_has_dim_name\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.has_dim_name = has_dim_name

    def get_dim_name(self, type, pos):
        'get_dim_name(self, type, pos)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: string'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_get_dim_name(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Map.get_dim_name = get_dim_name

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.set_dim_name = set_dim_name

    def set_dim_id(self, type, pos, id):
        'set_dim_id(self, type, pos, id)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param id: :class:`Id`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_set_dim_id(_copy_self._release(), type, pos, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_set_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.set_dim_id = set_dim_id

    def has_dim_id(self, type, pos):
        'has_dim_id(self, type, pos)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_has_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_has_dim_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.has_dim_id = has_dim_id

    def get_dim_id(self, type, pos):
        'get_dim_id(self, type, pos)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Id`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_get_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_get_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.get_dim_id = get_dim_id

    def set_tuple_id(self, type, id):
        'set_tuple_id(self, type, id)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_set_tuple_id(_copy_self._release(), type, _copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_set_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.set_tuple_id = set_tuple_id

    def reset_tuple_id(self, type):
        'reset_tuple_id(self, type)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_reset_tuple_id(_copy_self._release(), type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_reset_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.reset_tuple_id = reset_tuple_id

    def has_tuple_id(self, type):
        'has_tuple_id(self, type)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_has_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_has_tuple_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.has_tuple_id = has_tuple_id

    def get_tuple_id(self, type):
        'get_tuple_id(self, type)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:return: :class:`Id`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_get_tuple_id(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_get_tuple_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.get_tuple_id = get_tuple_id

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.reset_user = reset_user

    def find_dim_by_id(self, type, id):
        'find_dim_by_id(self, type, id)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param id: :class:`Id`\n:return: int'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_find_dim_by_id(self.data, type, id.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Map.find_dim_by_id = find_dim_by_id

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Map.find_dim_by_name = find_dim_by_name

    def remove_redundancies(self):
        'remove_redundancies(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_remove_redundancies(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_remove_redundancies failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.remove_redundancies = remove_redundancies

    def simple_hull(self):
        'simple_hull(self)\n\n:param self: :class:`Map`\n:return: :class:`BasicMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_simple_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_simple_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.simple_hull = simple_hull

    def unshifted_simple_hull(self):
        'unshifted_simple_hull(self)\n\n:param self: :class:`Map`\n:return: :class:`BasicMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_unshifted_simple_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_unshifted_simple_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.unshifted_simple_hull = unshifted_simple_hull

    def plain_unshifted_simple_hull(self):
        'plain_unshifted_simple_hull(self)\n\n:param self: :class:`Map`\n:return: :class:`BasicMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_plain_unshifted_simple_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_plain_unshifted_simple_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.plain_unshifted_simple_hull = plain_unshifted_simple_hull

    def unshifted_simple_hull_from_map_list(self, list):
        'unshifted_simple_hull_from_map_list(self, list)\n\n:param self: :class:`Map`\n:param list: :class:`MapList`\n:return: :class:`BasicMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(list, MapList):
            raise IslTypeError("list is not a MapList")
        if _ctx_data != list._ctx_data:
            raise Error("mismatched context in list")
        _copy_list = list._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_unshifted_simple_hull_from_map_list(_copy_self._release(), _copy_list._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_unshifted_simple_hull_from_map_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.unshifted_simple_hull_from_map_list = unshifted_simple_hull_from_map_list

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`Map`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.read_from_str = staticmethod(read_from_str)

    Map._read_from_str_is_static = True

    def dump(self):
        'dump(self)\n\n:param self: :class:`Map`\n:return: (nothing)'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_dump(self.data)
        finally:
            pass
        

    Map.dump = dump

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`Map`\n:return: string'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Map.to_str = to_str

    def sum(self, map2):
        'sum(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_sum(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_sum failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.sum = sum

    def neg(self):
        'neg(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.neg = neg

    def floordiv_val(self, d):
        'floordiv_val(self, d)\n\n:param self: :class:`Map`\n:param d: :class:`Val`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(d, Val):
            if _ctx_data != d._ctx_data:
                raise Error("mismatched context in d")
            _val_d = d._copy()
        elif isinstance(d, six.integer_types):
            _cdata_d = lib.isl_val_int_from_si(
                self._get_ctx_data(), d)
        
            if _cdata_d == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_d = Val(_data=_cdata_d)
        
        else:
            raise IslTypeError("d is a %s and cannot "
                "be cast to a Val" % type(d))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_floordiv_val(_copy_self._release(), _val_d._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_floordiv_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.floordiv_val = floordiv_val

    def partial_lexmax(self, dom):
        'partial_lexmax(self, dom)\n\n:param self: :class:`Map`\n:param dom: :class:`Set`\n:return: (:class:`Map`, empty (:class:`Set`))'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(dom, BasicSet):
            dom = Set.from_basic_set(dom)
        if not isinstance(dom, Set):
            raise IslTypeError("dom is not a Set")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        
        _retptr_empty = ffi.new("isl_set **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_partial_lexmax(_copy_self._release(), _copy_dom._release(), _retptr_empty)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_empty == ffi.NULL:
                _ret_empty = None
            else:
                _ret_empty = Set(_data=_retptr_empty[0])
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_partial_lexmax failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_empty

    Map.partial_lexmax = partial_lexmax

    def partial_lexmin(self, dom):
        'partial_lexmin(self, dom)\n\n:param self: :class:`Map`\n:param dom: :class:`Set`\n:return: (:class:`Map`, empty (:class:`Set`))'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(dom, BasicSet):
            dom = Set.from_basic_set(dom)
        if not isinstance(dom, Set):
            raise IslTypeError("dom is not a Set")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        
        _retptr_empty = ffi.new("isl_set **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_partial_lexmin(_copy_self._release(), _copy_dom._release(), _retptr_empty)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_empty == ffi.NULL:
                _ret_empty = None
            else:
                _ret_empty = Set(_data=_retptr_empty[0])
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_partial_lexmin failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _ret_empty

    Map.partial_lexmin = partial_lexmin

    def lexmin(self):
        'lexmin(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lexmin(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lexmin failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lexmin = lexmin

    def lexmax(self):
        'lexmax(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lexmax(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lexmax failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lexmax = lexmax

    def lexmin_pw_multi_aff(self):
        'lexmin_pw_multi_aff(self)\n\n:param self: :class:`Map`\n:return: :class:`PwMultiAff`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lexmin_pw_multi_aff(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lexmin_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lexmin_pw_multi_aff = lexmin_pw_multi_aff

    def lexmax_pw_multi_aff(self):
        'lexmax_pw_multi_aff(self)\n\n:param self: :class:`Map`\n:return: :class:`PwMultiAff`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lexmax_pw_multi_aff(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lexmax_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lexmax_pw_multi_aff = lexmax_pw_multi_aff

    def universe(space):
        'universe(space)\n\n:param space: :class:`Space`\n:return: :class:`Map`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_universe(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_universe failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.universe = staticmethod(universe)

    Map._universe_is_static = True

    def nat_universe(dim):
        'nat_universe(dim)\n\n:param dim: :class:`Space`\n:return: :class:`Map`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_nat_universe(_copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_nat_universe failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.nat_universe = staticmethod(nat_universe)

    Map._nat_universe_is_static = True

    def empty(space):
        'empty(space)\n\n:param space: :class:`Space`\n:return: :class:`Map`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_empty(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_empty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.empty = staticmethod(empty)

    Map._empty_is_static = True

    def identity(dim):
        'identity(dim)\n\n:param dim: :class:`Space`\n:return: :class:`Map`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_identity(_copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_identity failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.identity = staticmethod(identity)

    Map._identity_is_static = True

    def lex_lt_first(dim, n):
        'lex_lt_first(dim, n)\n\n:param dim: :class:`Space`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lex_lt_first(_copy_dim._release(), n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lex_lt_first failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lex_lt_first = staticmethod(lex_lt_first)

    Map._lex_lt_first_is_static = True

    def lex_le_first(dim, n):
        'lex_le_first(dim, n)\n\n:param dim: :class:`Space`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lex_le_first(_copy_dim._release(), n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lex_le_first failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lex_le_first = staticmethod(lex_le_first)

    Map._lex_le_first_is_static = True

    def lex_lt(set_dim):
        'lex_lt(set_dim)\n\n:param set_dim: :class:`Space`\n:return: :class:`Map`'

        if not isinstance(set_dim, Space):
            raise IslTypeError("set_dim is not a Space")
        _ctx_data = set_dim._ctx_data
        _copy_set_dim = set_dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lex_lt(_copy_set_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lex_lt failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lex_lt = staticmethod(lex_lt)

    Map._lex_lt_is_static = True

    def lex_le(set_dim):
        'lex_le(set_dim)\n\n:param set_dim: :class:`Space`\n:return: :class:`Map`'

        if not isinstance(set_dim, Space):
            raise IslTypeError("set_dim is not a Space")
        _ctx_data = set_dim._ctx_data
        _copy_set_dim = set_dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lex_le(_copy_set_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lex_le failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lex_le = staticmethod(lex_le)

    Map._lex_le_is_static = True

    def lex_gt_first(dim, n):
        'lex_gt_first(dim, n)\n\n:param dim: :class:`Space`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lex_gt_first(_copy_dim._release(), n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lex_gt_first failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lex_gt_first = staticmethod(lex_gt_first)

    Map._lex_gt_first_is_static = True

    def lex_ge_first(dim, n):
        'lex_ge_first(dim, n)\n\n:param dim: :class:`Space`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lex_ge_first(_copy_dim._release(), n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lex_ge_first failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lex_ge_first = staticmethod(lex_ge_first)

    Map._lex_ge_first_is_static = True

    def lex_gt(set_dim):
        'lex_gt(set_dim)\n\n:param set_dim: :class:`Space`\n:return: :class:`Map`'

        if not isinstance(set_dim, Space):
            raise IslTypeError("set_dim is not a Space")
        _ctx_data = set_dim._ctx_data
        _copy_set_dim = set_dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lex_gt(_copy_set_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lex_gt failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lex_gt = staticmethod(lex_gt)

    Map._lex_gt_is_static = True

    def lex_ge(set_dim):
        'lex_ge(set_dim)\n\n:param set_dim: :class:`Space`\n:return: :class:`Map`'

        if not isinstance(set_dim, Space):
            raise IslTypeError("set_dim is not a Space")
        _ctx_data = set_dim._ctx_data
        _copy_set_dim = set_dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lex_ge(_copy_set_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lex_ge failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lex_ge = staticmethod(lex_ge)

    Map._lex_ge_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.copy = copy

    def reverse(self):
        'reverse(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_reverse(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_reverse failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.reverse = reverse

    def union(self, map2):
        'union(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_union(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_union failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.union = union

    def union_disjoint(self, map2):
        'union_disjoint(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_union_disjoint(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_union_disjoint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.union_disjoint = union_disjoint

    def intersect_domain(self, set):
        'intersect_domain(self, set)\n\n:param self: :class:`Map`\n:param set: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_intersect_domain(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.intersect_domain = intersect_domain

    def intersect_range(self, set):
        'intersect_range(self, set)\n\n:param self: :class:`Map`\n:param set: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_intersect_range(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_intersect_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.intersect_range = intersect_range

    def intersect_domain_factor_range(self, factor):
        'intersect_domain_factor_range(self, factor)\n\n:param self: :class:`Map`\n:param factor: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(factor, BasicMap):
            factor = Map.from_basic_map(factor)
        if not isinstance(factor, Map):
            raise IslTypeError("factor is not a Map")
        if _ctx_data != factor._ctx_data:
            raise Error("mismatched context in factor")
        _copy_factor = factor._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_intersect_domain_factor_range(_copy_self._release(), _copy_factor._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_intersect_domain_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.intersect_domain_factor_range = intersect_domain_factor_range

    def intersect_range_factor_range(self, factor):
        'intersect_range_factor_range(self, factor)\n\n:param self: :class:`Map`\n:param factor: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(factor, BasicMap):
            factor = Map.from_basic_map(factor)
        if not isinstance(factor, Map):
            raise IslTypeError("factor is not a Map")
        if _ctx_data != factor._ctx_data:
            raise Error("mismatched context in factor")
        _copy_factor = factor._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_intersect_range_factor_range(_copy_self._release(), _copy_factor._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_intersect_range_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.intersect_range_factor_range = intersect_range_factor_range

    def apply_domain(self, map2):
        'apply_domain(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_apply_domain(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_apply_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.apply_domain = apply_domain

    def apply_range(self, map2):
        'apply_range(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_apply_range(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_apply_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.apply_range = apply_range

    def preimage_domain_multi_aff(self, ma):
        'preimage_domain_multi_aff(self, ma)\n\n:param self: :class:`Map`\n:param ma: :class:`MultiAff`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_preimage_domain_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_preimage_domain_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.preimage_domain_multi_aff = preimage_domain_multi_aff

    def preimage_range_multi_aff(self, ma):
        'preimage_range_multi_aff(self, ma)\n\n:param self: :class:`Map`\n:param ma: :class:`MultiAff`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_preimage_range_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_preimage_range_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.preimage_range_multi_aff = preimage_range_multi_aff

    def preimage_domain_pw_multi_aff(self, pma):
        'preimage_domain_pw_multi_aff(self, pma)\n\n:param self: :class:`Map`\n:param pma: :class:`PwMultiAff`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_preimage_domain_pw_multi_aff(_copy_self._release(), _copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_preimage_domain_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.preimage_domain_pw_multi_aff = preimage_domain_pw_multi_aff

    def preimage_range_pw_multi_aff(self, pma):
        'preimage_range_pw_multi_aff(self, pma)\n\n:param self: :class:`Map`\n:param pma: :class:`PwMultiAff`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_preimage_range_pw_multi_aff(_copy_self._release(), _copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_preimage_range_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.preimage_range_pw_multi_aff = preimage_range_pw_multi_aff

    def preimage_domain_multi_pw_aff(self, mpa):
        'preimage_domain_multi_pw_aff(self, mpa)\n\n:param self: :class:`Map`\n:param mpa: :class:`MultiPwAff`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mpa, MultiPwAff):
            raise IslTypeError("mpa is not a MultiPwAff")
        if _ctx_data != mpa._ctx_data:
            raise Error("mismatched context in mpa")
        _copy_mpa = mpa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_preimage_domain_multi_pw_aff(_copy_self._release(), _copy_mpa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_preimage_domain_multi_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.preimage_domain_multi_pw_aff = preimage_domain_multi_pw_aff

    def product(self, map2):
        'product(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_product(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.product = product

    def domain_product(self, map2):
        'domain_product(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_domain_product(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_domain_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.domain_product = domain_product

    def range_product(self, map2):
        'range_product(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_range_product(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.range_product = range_product

    def flat_product(self, map2):
        'flat_product(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_flat_product(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_flat_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.flat_product = flat_product

    def flat_domain_product(self, map2):
        'flat_domain_product(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_flat_domain_product(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_flat_domain_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.flat_domain_product = flat_domain_product

    def flat_range_product(self, map2):
        'flat_range_product(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_flat_range_product(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_flat_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.flat_range_product = flat_range_product

    def domain_is_wrapping(self):
        'domain_is_wrapping(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_domain_is_wrapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_domain_is_wrapping\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.domain_is_wrapping = domain_is_wrapping

    def range_is_wrapping(self):
        'range_is_wrapping(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_range_is_wrapping(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_range_is_wrapping\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.range_is_wrapping = range_is_wrapping

    def is_product(self):
        'is_product(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_is_product(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_is_product\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.is_product = is_product

    def factor_domain(self):
        'factor_domain(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_factor_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_factor_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.factor_domain = factor_domain

    def factor_range(self):
        'factor_range(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.factor_range = factor_range

    def domain_factor_domain(self):
        'domain_factor_domain(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_domain_factor_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_domain_factor_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.domain_factor_domain = domain_factor_domain

    def domain_factor_range(self):
        'domain_factor_range(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_domain_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_domain_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.domain_factor_range = domain_factor_range

    def range_factor_domain(self):
        'range_factor_domain(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_range_factor_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_range_factor_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.range_factor_domain = range_factor_domain

    def range_factor_range(self):
        'range_factor_range(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_range_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_range_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.range_factor_range = range_factor_range

    def intersect(self, map2):
        'intersect(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_intersect(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_intersect failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.intersect = intersect

    def intersect_params(self, params):
        'intersect_params(self, params)\n\n:param self: :class:`Map`\n:param params: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(params, BasicSet):
            params = Set.from_basic_set(params)
        if not isinstance(params, Set):
            raise IslTypeError("params is not a Set")
        if _ctx_data != params._ctx_data:
            raise Error("mismatched context in params")
        _copy_params = params._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_intersect_params(_copy_self._release(), _copy_params._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.intersect_params = intersect_params

    def subtract(self, map2):
        'subtract(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_subtract(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_subtract failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.subtract = subtract

    def subtract_domain(self, dom):
        'subtract_domain(self, dom)\n\n:param self: :class:`Map`\n:param dom: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(dom, BasicSet):
            dom = Set.from_basic_set(dom)
        if not isinstance(dom, Set):
            raise IslTypeError("dom is not a Set")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_subtract_domain(_copy_self._release(), _copy_dom._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_subtract_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.subtract_domain = subtract_domain

    def subtract_range(self, dom):
        'subtract_range(self, dom)\n\n:param self: :class:`Map`\n:param dom: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(dom, BasicSet):
            dom = Set.from_basic_set(dom)
        if not isinstance(dom, Set):
            raise IslTypeError("dom is not a Set")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_subtract_range(_copy_self._release(), _copy_dom._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_subtract_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.subtract_range = subtract_range

    def complement(self):
        'complement(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_complement(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_complement failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.complement = complement

    def fix_val(self, type, pos, v):
        'fix_val(self, type, pos, v)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param v: :class:`Val`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_fix_val(_copy_self._release(), type, pos, _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_fix_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.fix_val = fix_val

    def lower_bound_si(self, type, pos, value):
        'lower_bound_si(self, type, pos, value)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param value: :class:`int`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        # no argument processing for value
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lower_bound_si(_copy_self._release(), type, pos, value)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lower_bound_si failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lower_bound_si = lower_bound_si

    def upper_bound_si(self, type, pos, value):
        'upper_bound_si(self, type, pos, value)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param value: :class:`int`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        # no argument processing for value
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_upper_bound_si(_copy_self._release(), type, pos, value)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_upper_bound_si failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.upper_bound_si = upper_bound_si

    def deltas(self):
        'deltas(self)\n\n:param self: :class:`Map`\n:return: :class:`Set`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_deltas(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_deltas failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.deltas = deltas

    def deltas_map(self):
        'deltas_map(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_deltas_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_deltas_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.deltas_map = deltas_map

    def detect_equalities(self):
        'detect_equalities(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_detect_equalities(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_detect_equalities failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.detect_equalities = detect_equalities

    def affine_hull(self):
        'affine_hull(self)\n\n:param self: :class:`Map`\n:return: :class:`BasicMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_affine_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_affine_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.affine_hull = affine_hull

    def convex_hull(self):
        'convex_hull(self)\n\n:param self: :class:`Map`\n:return: :class:`BasicMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_convex_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_convex_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.convex_hull = convex_hull

    def polyhedral_hull(self):
        'polyhedral_hull(self)\n\n:param self: :class:`Map`\n:return: :class:`BasicMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_polyhedral_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_polyhedral_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.polyhedral_hull = polyhedral_hull

    def add_dims(self, type, n):
        'add_dims(self, type, n)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_add_dims(_copy_self._release(), type, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_add_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.add_dims = add_dims

    def insert_dims(self, type, pos, n):
        'insert_dims(self, type, pos, n)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_insert_dims(_copy_self._release(), type, pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_insert_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.insert_dims = insert_dims

    def move_dims(self, dst_type, dst_pos, src_type, src_pos, n):
        'move_dims(self, dst_type, dst_pos, src_type, src_pos, n)\n\n:param self: :class:`Map`\n:param dst_type: :class:`dim_type`\n:param dst_pos: :class:`unsigned`\n:param src_type: :class:`dim_type`\n:param src_pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_type
        
        # no argument processing for dst_pos
        
        # no argument processing for src_type
        
        # no argument processing for src_pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_move_dims(_copy_self._release(), dst_type, dst_pos, src_type, src_pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_move_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.move_dims = move_dims

    def project_out(self, type, first, n):
        'project_out(self, type, first, n)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_project_out(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_project_out failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.project_out = project_out

    def remove_unknown_divs(self):
        'remove_unknown_divs(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_remove_unknown_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_remove_unknown_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.remove_unknown_divs = remove_unknown_divs

    def remove_divs(self):
        'remove_divs(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_remove_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_remove_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.remove_divs = remove_divs

    def eliminate(self, type, first, n):
        'eliminate(self, type, first, n)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_eliminate(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_eliminate failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.eliminate = eliminate

    def remove_dims(self, type, first, n):
        'remove_dims(self, type, first, n)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_remove_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_remove_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.remove_dims = remove_dims

    def remove_divs_involving_dims(self, type, first, n):
        'remove_divs_involving_dims(self, type, first, n)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_remove_divs_involving_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_remove_divs_involving_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.remove_divs_involving_dims = remove_divs_involving_dims

    def order_ge(self, type1, pos1, type2, pos2):
        'order_ge(self, type1, pos1, type2, pos2)\n\n:param self: :class:`Map`\n:param type1: :class:`dim_type`\n:param pos1: :class:`int`\n:param type2: :class:`dim_type`\n:param pos2: :class:`int`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type1
        
        # no argument processing for pos1
        
        # no argument processing for type2
        
        # no argument processing for pos2
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_order_ge(_copy_self._release(), type1, pos1, type2, pos2)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_order_ge failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.order_ge = order_ge

    def order_le(self, type1, pos1, type2, pos2):
        'order_le(self, type1, pos1, type2, pos2)\n\n:param self: :class:`Map`\n:param type1: :class:`dim_type`\n:param pos1: :class:`int`\n:param type2: :class:`dim_type`\n:param pos2: :class:`int`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type1
        
        # no argument processing for pos1
        
        # no argument processing for type2
        
        # no argument processing for pos2
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_order_le(_copy_self._release(), type1, pos1, type2, pos2)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_order_le failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.order_le = order_le

    def equate(self, type1, pos1, type2, pos2):
        'equate(self, type1, pos1, type2, pos2)\n\n:param self: :class:`Map`\n:param type1: :class:`dim_type`\n:param pos1: :class:`int`\n:param type2: :class:`dim_type`\n:param pos2: :class:`int`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type1
        
        # no argument processing for pos1
        
        # no argument processing for type2
        
        # no argument processing for pos2
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_equate(_copy_self._release(), type1, pos1, type2, pos2)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_equate failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.equate = equate

    def oppose(self, type1, pos1, type2, pos2):
        'oppose(self, type1, pos1, type2, pos2)\n\n:param self: :class:`Map`\n:param type1: :class:`dim_type`\n:param pos1: :class:`int`\n:param type2: :class:`dim_type`\n:param pos2: :class:`int`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type1
        
        # no argument processing for pos1
        
        # no argument processing for type2
        
        # no argument processing for pos2
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_oppose(_copy_self._release(), type1, pos1, type2, pos2)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_oppose failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.oppose = oppose

    def order_lt(self, type1, pos1, type2, pos2):
        'order_lt(self, type1, pos1, type2, pos2)\n\n:param self: :class:`Map`\n:param type1: :class:`dim_type`\n:param pos1: :class:`int`\n:param type2: :class:`dim_type`\n:param pos2: :class:`int`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type1
        
        # no argument processing for pos1
        
        # no argument processing for type2
        
        # no argument processing for pos2
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_order_lt(_copy_self._release(), type1, pos1, type2, pos2)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_order_lt failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.order_lt = order_lt

    def order_gt(self, type1, pos1, type2, pos2):
        'order_gt(self, type1, pos1, type2, pos2)\n\n:param self: :class:`Map`\n:param type1: :class:`dim_type`\n:param pos1: :class:`int`\n:param type2: :class:`dim_type`\n:param pos2: :class:`int`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type1
        
        # no argument processing for pos1
        
        # no argument processing for type2
        
        # no argument processing for pos2
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_order_gt(_copy_self._release(), type1, pos1, type2, pos2)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_order_gt failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.order_gt = order_gt

    def wrap(self):
        'wrap(self)\n\n:param self: :class:`Map`\n:return: :class:`Set`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_wrap(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_wrap failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.wrap = wrap

    def flatten(self):
        'flatten(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_flatten(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_flatten failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.flatten = flatten

    def flatten_domain(self):
        'flatten_domain(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_flatten_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_flatten_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.flatten_domain = flatten_domain

    def flatten_range(self):
        'flatten_range(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_flatten_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_flatten_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.flatten_range = flatten_range

    def params(self):
        'params(self)\n\n:param self: :class:`Map`\n:return: :class:`Set`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.params = params

    def domain(self):
        'domain(self)\n\n:param self: :class:`Map`\n:return: :class:`Set`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.domain = domain

    def range(self):
        'range(self)\n\n:param self: :class:`Map`\n:return: :class:`Set`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.range = range

    def domain_map(self):
        'domain_map(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_domain_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_domain_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.domain_map = domain_map

    def range_map(self):
        'range_map(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_range_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_range_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.range_map = range_map

    def from_basic_map(bmap):
        'from_basic_map(bmap)\n\n:param bmap: :class:`BasicMap`\n:return: :class:`Map`'

        if not isinstance(bmap, BasicMap):
            raise IslTypeError("bmap is not a BasicMap")
        _ctx_data = bmap._ctx_data
        _copy_bmap = bmap._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_from_basic_map(_copy_bmap._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_from_basic_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.from_basic_map = staticmethod(from_basic_map)

    Map._from_basic_map_is_static = True

    def from_domain(set):
        'from_domain(set)\n\n:param set: :class:`Set`\n:return: :class:`Map`'

        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        _ctx_data = set._ctx_data
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_from_domain(_copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_from_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.from_domain = staticmethod(from_domain)

    Map._from_domain_is_static = True

    def from_range(set):
        'from_range(set)\n\n:param set: :class:`Set`\n:return: :class:`Map`'

        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        _ctx_data = set._ctx_data
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_from_range(_copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_from_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.from_range = staticmethod(from_range)

    Map._from_range_is_static = True

    def from_domain_and_range(domain, range):
        'from_domain_and_range(domain, range)\n\n:param domain: :class:`Set`\n:param range: :class:`Set`\n:return: :class:`Map`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if not isinstance(domain, Set):
            raise IslTypeError("domain is not a Set")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        if isinstance(range, BasicSet):
            range = Set.from_basic_set(range)
        if not isinstance(range, Set):
            raise IslTypeError("range is not a Set")
        if _ctx_data != range._ctx_data:
            raise Error("mismatched context in range")
        _copy_range = range._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_from_domain_and_range(_copy_domain._release(), _copy_range._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_from_domain_and_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.from_domain_and_range = staticmethod(from_domain_and_range)

    Map._from_domain_and_range_is_static = True

    def sample(self):
        'sample(self)\n\n:param self: :class:`Map`\n:return: :class:`BasicMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_sample(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_sample failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.sample = sample

    def bind_domain(self, tuple):
        'bind_domain(self, tuple)\n\n:param self: :class:`Map`\n:param tuple: :class:`MultiId`\n:return: :class:`Set`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(tuple, MultiId):
            raise IslTypeError("tuple is not a MultiId")
        if _ctx_data != tuple._ctx_data:
            raise Error("mismatched context in tuple")
        _copy_tuple = tuple._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_bind_domain(_copy_self._release(), _copy_tuple._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_bind_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.bind_domain = bind_domain

    def bind_range(self, tuple):
        'bind_range(self, tuple)\n\n:param self: :class:`Map`\n:param tuple: :class:`MultiId`\n:return: :class:`Set`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(tuple, MultiId):
            raise IslTypeError("tuple is not a MultiId")
        if _ctx_data != tuple._ctx_data:
            raise Error("mismatched context in tuple")
        _copy_tuple = tuple._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_bind_range(_copy_self._release(), _copy_tuple._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_bind_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.bind_range = bind_range

    def plain_is_empty(self):
        'plain_is_empty(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_plain_is_empty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_plain_is_empty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.plain_is_empty = plain_is_empty

    def plain_is_universe(self):
        'plain_is_universe(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_plain_is_universe(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_plain_is_universe\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.plain_is_universe = plain_is_universe

    def is_empty(self):
        'is_empty(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_is_empty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_is_empty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.is_empty = is_empty

    def is_subset(self, map2):
        'is_subset(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_is_subset(self.data, map2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_is_subset\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.is_subset = is_subset

    def is_strict_subset(self, map2):
        'is_strict_subset(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_is_strict_subset(self.data, map2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_is_strict_subset\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.is_strict_subset = is_strict_subset

    def is_equal(self, map2):
        'is_equal(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_is_equal(self.data, map2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.is_equal = is_equal

    def is_disjoint(self, map2):
        'is_disjoint(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_is_disjoint(self.data, map2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_is_disjoint\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.is_disjoint = is_disjoint

    def plain_is_single_valued(self):
        'plain_is_single_valued(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_plain_is_single_valued(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_plain_is_single_valued\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.plain_is_single_valued = plain_is_single_valued

    def is_single_valued(self):
        'is_single_valued(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_is_single_valued(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_is_single_valued\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.is_single_valued = is_single_valued

    def plain_is_injective(self):
        'plain_is_injective(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_plain_is_injective(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_plain_is_injective\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.plain_is_injective = plain_is_injective

    def is_injective(self):
        'is_injective(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_is_injective(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_is_injective\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.is_injective = is_injective

    def is_bijective(self):
        'is_bijective(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_is_bijective(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_is_bijective\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.is_bijective = is_bijective

    def is_identity(self):
        'is_identity(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_is_identity(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_is_identity\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.is_identity = is_identity

    def is_translation(self):
        'is_translation(self)\n\n:param self: :class:`Map`\n:return: int'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_is_translation(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Map.is_translation = is_translation

    def has_equal_space(self, map2):
        'has_equal_space(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_has_equal_space(self.data, map2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_has_equal_space\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.has_equal_space = has_equal_space

    def can_zip(self):
        'can_zip(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_can_zip(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_can_zip\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.can_zip = can_zip

    def zip(self):
        'zip(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_zip(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_zip failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.zip = zip

    def can_curry(self):
        'can_curry(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_can_curry(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_can_curry\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.can_curry = can_curry

    def curry(self):
        'curry(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_curry(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_curry failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.curry = curry

    def can_range_curry(self):
        'can_range_curry(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_can_range_curry(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_can_range_curry\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.can_range_curry = can_range_curry

    def range_curry(self):
        'range_curry(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_range_curry(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_range_curry failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.range_curry = range_curry

    def can_uncurry(self):
        'can_uncurry(self)\n\n:param self: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_can_uncurry(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_can_uncurry\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.can_uncurry = can_uncurry

    def uncurry(self):
        'uncurry(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_uncurry(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_uncurry failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.uncurry = uncurry

    def make_disjoint(self):
        'make_disjoint(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_make_disjoint(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_make_disjoint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.make_disjoint = make_disjoint

    def compute_divs(self):
        'compute_divs(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_compute_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_compute_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.compute_divs = compute_divs

    def align_divs(self):
        'align_divs(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_align_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_align_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.align_divs = align_divs

    def drop_constraints_involving_dims(self, type, first, n):
        'drop_constraints_involving_dims(self, type, first, n)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_drop_constraints_involving_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_drop_constraints_involving_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.drop_constraints_involving_dims = drop_constraints_involving_dims

    def drop_constraints_not_involving_dims(self, type, first, n):
        'drop_constraints_not_involving_dims(self, type, first, n)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_drop_constraints_not_involving_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_drop_constraints_not_involving_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.drop_constraints_not_involving_dims = drop_constraints_not_involving_dims

    def involves_dims(self, type, first, n):
        'involves_dims(self, type, first, n)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_involves_dims(self.data, type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_involves_dims\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.involves_dims = involves_dims

    def plain_get_val_if_fixed(self, type, pos):
        'plain_get_val_if_fixed(self, type, pos)\n\n:param self: :class:`Map`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Val`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_plain_get_val_if_fixed(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_plain_get_val_if_fixed failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.plain_get_val_if_fixed = plain_get_val_if_fixed

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`Map`\n:param context: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicMap):
            context = Map.from_basic_map(context)
        if not isinstance(context, Map):
            raise IslTypeError("context is not a Map")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.gist = gist

    def gist_domain(self, context):
        'gist_domain(self, context)\n\n:param self: :class:`Map`\n:param context: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_gist_domain(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_gist_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.gist_domain = gist_domain

    def gist_range(self, context):
        'gist_range(self, context)\n\n:param self: :class:`Map`\n:param context: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_gist_range(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_gist_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.gist_range = gist_range

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`Map`\n:param context: :class:`Set`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.gist_params = gist_params

    def gist_basic_map(self, context):
        'gist_basic_map(self, context)\n\n:param self: :class:`Map`\n:param context: :class:`BasicMap`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(context, BasicMap):
            raise IslTypeError("context is not a BasicMap")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_gist_basic_map(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_gist_basic_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.gist_basic_map = gist_basic_map

    def get_range_stride_info(self, pos):
        'get_range_stride_info(self, pos)\n\n:param self: :class:`Map`\n:param pos: :class:`int`\n:return: :class:`StrideInfo`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_get_range_stride_info(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else StrideInfo(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_get_range_stride_info failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.get_range_stride_info = get_range_stride_info

    def get_range_simple_fixed_box_hull(self):
        'get_range_simple_fixed_box_hull(self)\n\n:param self: :class:`Map`\n:return: :class:`FixedBox`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_get_range_simple_fixed_box_hull(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else FixedBox(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_get_range_simple_fixed_box_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.get_range_simple_fixed_box_hull = get_range_simple_fixed_box_hull

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.coalesce = coalesce

    def plain_is_equal(self, map2):
        'plain_is_equal(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_plain_is_equal(self.data, map2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_map_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Map.plain_is_equal = plain_is_equal

    def get_hash(self):
        'get_hash(self)\n\n:param self: :class:`Map`\n:return: uint32_t'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_get_hash(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Map.get_hash = get_hash

    def n_basic_map(self):
        'n_basic_map(self)\n\n:param self: :class:`Map`\n:return: isl_size'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_n_basic_map(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Map.n_basic_map = n_basic_map

    def foreach_basic_map(self, fn):
        'foreach_basic_map(self, fn)\n\n:param self: :class:`Map`\n:param fn: callback(bmap) -> isl_stat\n:return: (nothing)'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(bmap, user):
            try:
                _py_bmap = BasicMap(_data=bmap)
                _result = fn(_py_bmap)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_basic_map *bmap,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_foreach_basic_map(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_map_foreach_basic_map\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Map.foreach_basic_map = foreach_basic_map

    def get_basic_map_list(self):
        'get_basic_map_list(self)\n\n:param self: :class:`Map`\n:return: :class:`BasicMapList`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_get_basic_map_list(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_get_basic_map_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.get_basic_map_list = get_basic_map_list

    def fixed_power_val(self, exp):
        'fixed_power_val(self, exp)\n\n:param self: :class:`Map`\n:param exp: :class:`Val`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(exp, Val):
            if _ctx_data != exp._ctx_data:
                raise Error("mismatched context in exp")
            _val_exp = exp._copy()
        elif isinstance(exp, six.integer_types):
            _cdata_exp = lib.isl_val_int_from_si(
                self._get_ctx_data(), exp)
        
            if _cdata_exp == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_exp = Val(_data=_cdata_exp)
        
        else:
            raise IslTypeError("exp is a %s and cannot "
                "be cast to a Val" % type(exp))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_fixed_power_val(_copy_self._release(), _val_exp._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_fixed_power_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.fixed_power_val = fixed_power_val

    def lex_le_map(self, map2):
        'lex_le_map(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lex_le_map(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lex_le_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lex_le_map = lex_le_map

    def lex_lt_map(self, map2):
        'lex_lt_map(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lex_lt_map(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lex_lt_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lex_lt_map = lex_lt_map

    def lex_ge_map(self, map2):
        'lex_ge_map(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lex_ge_map(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lex_ge_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lex_ge_map = lex_ge_map

    def lex_gt_map(self, map2):
        'lex_gt_map(self, map2)\n\n:param self: :class:`Map`\n:param map2: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map2, BasicMap):
            map2 = Map.from_basic_map(map2)
        if not isinstance(map2, Map):
            raise IslTypeError("map2 is not a Map")
        if _ctx_data != map2._ctx_data:
            raise Error("mismatched context in map2")
        _copy_map2 = map2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_lex_gt_map(_copy_self._release(), _copy_map2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_lex_gt_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.lex_gt_map = lex_gt_map

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`Map`\n:param model: :class:`Space`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.align_params = align_params

    def drop_unused_params(self):
        'drop_unused_params(self)\n\n:param self: :class:`Map`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_drop_unused_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_drop_unused_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.drop_unused_params = drop_unused_params

    def from_aff(aff):
        'from_aff(aff)\n\n:param aff: :class:`Aff`\n:return: :class:`Map`'

        if not isinstance(aff, Aff):
            raise IslTypeError("aff is not a Aff")
        _ctx_data = aff._ctx_data
        _copy_aff = aff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_from_aff(_copy_aff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_from_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.from_aff = staticmethod(from_aff)

    Map._from_aff_is_static = True

    def from_multi_aff(maff):
        'from_multi_aff(maff)\n\n:param maff: :class:`MultiAff`\n:return: :class:`Map`'

        if not isinstance(maff, MultiAff):
            raise IslTypeError("maff is not a MultiAff")
        _ctx_data = maff._ctx_data
        _copy_maff = maff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_from_multi_aff(_copy_maff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_from_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.from_multi_aff = staticmethod(from_multi_aff)

    Map._from_multi_aff_is_static = True

    def dim_min(self, pos):
        'dim_min(self, pos)\n\n:param self: :class:`Map`\n:param pos: :class:`int`\n:return: :class:`PwAff`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_dim_min(_copy_self._release(), pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_dim_min failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.dim_min = dim_min

    def dim_max(self, pos):
        'dim_max(self, pos)\n\n:param self: :class:`Map`\n:param pos: :class:`int`\n:return: :class:`PwAff`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_dim_max(_copy_self._release(), pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_dim_max failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.dim_max = dim_max

    def from_pw_aff(pwaff):
        'from_pw_aff(pwaff)\n\n:param pwaff: :class:`PwAff`\n:return: :class:`Map`'

        if isinstance(pwaff, Aff):
            pwaff = PwAff.from_aff(pwaff)
        if not isinstance(pwaff, PwAff):
            raise IslTypeError("pwaff is not a PwAff")
        _ctx_data = pwaff._ctx_data
        _copy_pwaff = pwaff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_from_pw_aff(_copy_pwaff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_from_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.from_pw_aff = staticmethod(from_pw_aff)

    Map._from_pw_aff_is_static = True

    def from_pw_multi_aff(pma):
        'from_pw_multi_aff(pma)\n\n:param pma: :class:`PwMultiAff`\n:return: :class:`Map`'

        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        _ctx_data = pma._ctx_data
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_from_pw_multi_aff(_copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_from_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.from_pw_multi_aff = staticmethod(from_pw_multi_aff)

    Map._from_pw_multi_aff_is_static = True

    def from_multi_pw_aff(mpa):
        'from_multi_pw_aff(mpa)\n\n:param mpa: :class:`MultiPwAff`\n:return: :class:`Map`'

        if not isinstance(mpa, MultiPwAff):
            raise IslTypeError("mpa is not a MultiPwAff")
        _ctx_data = mpa._ctx_data
        _copy_mpa = mpa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_from_multi_pw_aff(_copy_mpa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_from_multi_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.from_multi_pw_aff = staticmethod(from_multi_pw_aff)

    Map._from_multi_pw_aff_is_static = True

    def from_union_map(umap):
        'from_union_map(umap)\n\n:param umap: :class:`UnionMap`\n:return: :class:`Map`'

        if isinstance(umap, BasicMap):
            umap = Map.from_basic_map(umap)
        if isinstance(umap, Map):
            umap = UnionMap.from_map(umap)
        if not isinstance(umap, UnionMap):
            raise IslTypeError("umap is not a UnionMap")
        _ctx_data = umap._ctx_data
        _copy_umap = umap._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_from_union_map(_copy_umap._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_from_union_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.from_union_map = staticmethod(from_union_map)

    Map._from_union_map_is_static = True

    def add_constraint(self, constraint):
        'add_constraint(self, constraint)\n\n:param self: :class:`Map`\n:param constraint: :class:`Constraint`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if not isinstance(self, Map):
            raise IslTypeError("self is not a Map")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(constraint, Constraint):
            raise IslTypeError("constraint is not a Constraint")
        if _ctx_data != constraint._ctx_data:
            raise Error("mismatched context in constraint")
        _copy_constraint = constraint._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_map_add_constraint(_copy_self._release(), _copy_constraint._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_map_add_constraint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Map.add_constraint = add_constraint

    # }}}

    # {{{ union_map

    def from_union_pw_multi_aff(upma):
        'from_union_pw_multi_aff(upma)\n\n:param upma: :class:`UnionPwMultiAff`\n:return: :class:`UnionMap`'

        if not isinstance(upma, UnionPwMultiAff):
            raise IslTypeError("upma is not a UnionPwMultiAff")
        _ctx_data = upma._ctx_data
        _copy_upma = upma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_from_union_pw_multi_aff(_copy_upma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_from_union_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.from_union_pw_multi_aff = staticmethod(from_union_pw_multi_aff)

    UnionMap._from_union_pw_multi_aff_is_static = True

    def from_union_pw_aff(upa):
        'from_union_pw_aff(upa)\n\n:param upa: :class:`UnionPwAff`\n:return: :class:`UnionMap`'

        if not isinstance(upa, UnionPwAff):
            raise IslTypeError("upa is not a UnionPwAff")
        _ctx_data = upa._ctx_data
        _copy_upa = upa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_from_union_pw_aff(_copy_upa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_from_union_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.from_union_pw_aff = staticmethod(from_union_pw_aff)

    UnionMap._from_union_pw_aff_is_static = True

    def from_multi_union_pw_aff(mupa):
        'from_multi_union_pw_aff(mupa)\n\n:param mupa: :class:`MultiUnionPwAff`\n:return: :class:`UnionMap`'

        if not isinstance(mupa, MultiUnionPwAff):
            raise IslTypeError("mupa is not a MultiUnionPwAff")
        _ctx_data = mupa._ctx_data
        _copy_mupa = mupa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_from_multi_union_pw_aff(_copy_mupa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_from_multi_union_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.from_multi_union_pw_aff = staticmethod(from_multi_union_pw_aff)

    UnionMap._from_multi_union_pw_aff_is_static = True

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`UnionMap`\n:param type: :class:`dim_type`\n:return: isl_size'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionMap.dim = dim

    def involves_dims(self, type, first, n):
        'involves_dims(self, type, first, n)\n\n:param self: :class:`UnionMap`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_involves_dims(self.data, type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_involves_dims\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.involves_dims = involves_dims

    def get_dim_id(self, type, pos):
        'get_dim_id(self, type, pos)\n\n:param self: :class:`UnionMap`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`Id`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_get_dim_id(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_get_dim_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.get_dim_id = get_dim_id

    def from_basic_map(bmap):
        'from_basic_map(bmap)\n\n:param bmap: :class:`BasicMap`\n:return: :class:`UnionMap`'

        if not isinstance(bmap, BasicMap):
            raise IslTypeError("bmap is not a BasicMap")
        _ctx_data = bmap._ctx_data
        _copy_bmap = bmap._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_from_basic_map(_copy_bmap._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_from_basic_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.from_basic_map = staticmethod(from_basic_map)

    UnionMap._from_basic_map_is_static = True

    def from_map(map):
        'from_map(map)\n\n:param map: :class:`Map`\n:return: :class:`UnionMap`'

        if isinstance(map, BasicMap):
            map = Map.from_basic_map(map)
        if not isinstance(map, Map):
            raise IslTypeError("map is not a Map")
        _ctx_data = map._ctx_data
        _copy_map = map._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_from_map(_copy_map._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_from_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.from_map = staticmethod(from_map)

    UnionMap._from_map_is_static = True

    def empty(space):
        'empty(space)\n\n:param space: :class:`Space`\n:return: :class:`UnionMap`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_empty(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_empty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.empty = staticmethod(empty)

    UnionMap._empty_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.copy = copy

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`Context`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.get_ctx = get_ctx

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`Space`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.get_space = get_space

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.reset_user = reset_user

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`UnionMap`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionMap.find_dim_by_name = find_dim_by_name

    def universe(self):
        'universe(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_universe(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_universe failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.universe = universe

    def params(self):
        'params(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`Set`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.params = params

    def domain(self):
        'domain(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.domain = domain

    def range(self):
        'range(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.range = range

    def domain_map(self):
        'domain_map(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_domain_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_domain_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.domain_map = domain_map

    def domain_map_union_pw_multi_aff(self):
        'domain_map_union_pw_multi_aff(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionPwMultiAff`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_domain_map_union_pw_multi_aff(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_domain_map_union_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.domain_map_union_pw_multi_aff = domain_map_union_pw_multi_aff

    def range_map(self):
        'range_map(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_range_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_range_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.range_map = range_map

    def from_domain(uset):
        'from_domain(uset)\n\n:param uset: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        _ctx_data = uset._ctx_data
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_from_domain(_copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_from_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.from_domain = staticmethod(from_domain)

    UnionMap._from_domain_is_static = True

    def from_range(uset):
        'from_range(uset)\n\n:param uset: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        _ctx_data = uset._ctx_data
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_from_range(_copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_from_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.from_range = staticmethod(from_range)

    UnionMap._from_range_is_static = True

    def affine_hull(self):
        'affine_hull(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_affine_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_affine_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.affine_hull = affine_hull

    def polyhedral_hull(self):
        'polyhedral_hull(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_polyhedral_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_polyhedral_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.polyhedral_hull = polyhedral_hull

    def remove_redundancies(self):
        'remove_redundancies(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_remove_redundancies(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_remove_redundancies failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.remove_redundancies = remove_redundancies

    def simple_hull(self):
        'simple_hull(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_simple_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_simple_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.simple_hull = simple_hull

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.coalesce = coalesce

    def compute_divs(self):
        'compute_divs(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_compute_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_compute_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.compute_divs = compute_divs

    def lexmin(self):
        'lexmin(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_lexmin(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_lexmin failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.lexmin = lexmin

    def lexmax(self):
        'lexmax(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_lexmax(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_lexmax failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.lexmax = lexmax

    def add_map(self, map):
        'add_map(self, map)\n\n:param self: :class:`UnionMap`\n:param map: :class:`Map`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(map, BasicMap):
            map = Map.from_basic_map(map)
        if not isinstance(map, Map):
            raise IslTypeError("map is not a Map")
        if _ctx_data != map._ctx_data:
            raise Error("mismatched context in map")
        _copy_map = map._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_add_map(_copy_self._release(), _copy_map._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_add_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.add_map = add_map

    def union(self, umap2):
        'union(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_union(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_union failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.union = union

    def subtract(self, umap2):
        'subtract(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_subtract(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_subtract failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.subtract = subtract

    def intersect(self, umap2):
        'intersect(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_intersect(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_intersect failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.intersect = intersect

    def intersect_params(self, set):
        'intersect_params(self, set)\n\n:param self: :class:`UnionMap`\n:param set: :class:`Set`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_intersect_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.intersect_params = intersect_params

    def product(self, umap2):
        'product(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_product(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.product = product

    def domain_product(self, umap2):
        'domain_product(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_domain_product(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_domain_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.domain_product = domain_product

    def flat_domain_product(self, umap2):
        'flat_domain_product(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_flat_domain_product(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_flat_domain_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.flat_domain_product = flat_domain_product

    def range_product(self, umap2):
        'range_product(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_range_product(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.range_product = range_product

    def flat_range_product(self, umap2):
        'flat_range_product(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_flat_range_product(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_flat_range_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.flat_range_product = flat_range_product

    def domain_factor_domain(self):
        'domain_factor_domain(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_domain_factor_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_domain_factor_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.domain_factor_domain = domain_factor_domain

    def domain_factor_range(self):
        'domain_factor_range(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_domain_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_domain_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.domain_factor_range = domain_factor_range

    def range_factor_domain(self):
        'range_factor_domain(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_range_factor_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_range_factor_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.range_factor_domain = range_factor_domain

    def range_factor_range(self):
        'range_factor_range(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_range_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_range_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.range_factor_range = range_factor_range

    def factor_domain(self):
        'factor_domain(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_factor_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_factor_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.factor_domain = factor_domain

    def factor_range(self):
        'factor_range(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_factor_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.factor_range = factor_range

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`UnionMap`\n:param context: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicMap):
            context = Map.from_basic_map(context)
        if isinstance(context, Map):
            context = UnionMap.from_map(context)
        if not isinstance(context, UnionMap):
            raise IslTypeError("context is not a UnionMap")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.gist = gist

    def gist_params(self, set):
        'gist_params(self, set)\n\n:param self: :class:`UnionMap`\n:param set: :class:`Set`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_gist_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.gist_params = gist_params

    def gist_domain(self, uset):
        'gist_domain(self, uset)\n\n:param self: :class:`UnionMap`\n:param uset: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_gist_domain(_copy_self._release(), _copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_gist_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.gist_domain = gist_domain

    def gist_range(self, uset):
        'gist_range(self, uset)\n\n:param self: :class:`UnionMap`\n:param uset: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_gist_range(_copy_self._release(), _copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_gist_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.gist_range = gist_range

    def intersect_domain(self, uset):
        'intersect_domain(self, uset)\n\n:param self: :class:`UnionMap`\n:param uset: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_intersect_domain(_copy_self._release(), _copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.intersect_domain = intersect_domain

    def intersect_range(self, uset):
        'intersect_range(self, uset)\n\n:param self: :class:`UnionMap`\n:param uset: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_intersect_range(_copy_self._release(), _copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_intersect_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.intersect_range = intersect_range

    def intersect_range_factor_range(self, factor):
        'intersect_range_factor_range(self, factor)\n\n:param self: :class:`UnionMap`\n:param factor: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(factor, BasicMap):
            factor = Map.from_basic_map(factor)
        if isinstance(factor, Map):
            factor = UnionMap.from_map(factor)
        if not isinstance(factor, UnionMap):
            raise IslTypeError("factor is not a UnionMap")
        if _ctx_data != factor._ctx_data:
            raise Error("mismatched context in factor")
        _copy_factor = factor._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_intersect_range_factor_range(_copy_self._release(), _copy_factor._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_intersect_range_factor_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.intersect_range_factor_range = intersect_range_factor_range

    def subtract_domain(self, dom):
        'subtract_domain(self, dom)\n\n:param self: :class:`UnionMap`\n:param dom: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(dom, BasicSet):
            dom = Set.from_basic_set(dom)
        if isinstance(dom, Set):
            dom = UnionSet.from_set(dom)
        if not isinstance(dom, UnionSet):
            raise IslTypeError("dom is not a UnionSet")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_subtract_domain(_copy_self._release(), _copy_dom._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_subtract_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.subtract_domain = subtract_domain

    def subtract_range(self, dom):
        'subtract_range(self, dom)\n\n:param self: :class:`UnionMap`\n:param dom: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(dom, BasicSet):
            dom = Set.from_basic_set(dom)
        if isinstance(dom, Set):
            dom = UnionSet.from_set(dom)
        if not isinstance(dom, UnionSet):
            raise IslTypeError("dom is not a UnionSet")
        if _ctx_data != dom._ctx_data:
            raise Error("mismatched context in dom")
        _copy_dom = dom._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_subtract_range(_copy_self._release(), _copy_dom._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_subtract_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.subtract_range = subtract_range

    def apply_domain(self, umap2):
        'apply_domain(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_apply_domain(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_apply_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.apply_domain = apply_domain

    def apply_range(self, umap2):
        'apply_range(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_apply_range(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_apply_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.apply_range = apply_range

    def preimage_domain_multi_aff(self, ma):
        'preimage_domain_multi_aff(self, ma)\n\n:param self: :class:`UnionMap`\n:param ma: :class:`MultiAff`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_preimage_domain_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_preimage_domain_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.preimage_domain_multi_aff = preimage_domain_multi_aff

    def preimage_range_multi_aff(self, ma):
        'preimage_range_multi_aff(self, ma)\n\n:param self: :class:`UnionMap`\n:param ma: :class:`MultiAff`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_preimage_range_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_preimage_range_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.preimage_range_multi_aff = preimage_range_multi_aff

    def preimage_domain_pw_multi_aff(self, pma):
        'preimage_domain_pw_multi_aff(self, pma)\n\n:param self: :class:`UnionMap`\n:param pma: :class:`PwMultiAff`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_preimage_domain_pw_multi_aff(_copy_self._release(), _copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_preimage_domain_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.preimage_domain_pw_multi_aff = preimage_domain_pw_multi_aff

    def preimage_range_pw_multi_aff(self, pma):
        'preimage_range_pw_multi_aff(self, pma)\n\n:param self: :class:`UnionMap`\n:param pma: :class:`PwMultiAff`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_preimage_range_pw_multi_aff(_copy_self._release(), _copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_preimage_range_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.preimage_range_pw_multi_aff = preimage_range_pw_multi_aff

    def preimage_domain_multi_pw_aff(self, mpa):
        'preimage_domain_multi_pw_aff(self, mpa)\n\n:param self: :class:`UnionMap`\n:param mpa: :class:`MultiPwAff`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mpa, MultiPwAff):
            raise IslTypeError("mpa is not a MultiPwAff")
        if _ctx_data != mpa._ctx_data:
            raise Error("mismatched context in mpa")
        _copy_mpa = mpa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_preimage_domain_multi_pw_aff(_copy_self._release(), _copy_mpa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_preimage_domain_multi_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.preimage_domain_multi_pw_aff = preimage_domain_multi_pw_aff

    def preimage_domain_union_pw_multi_aff(self, upma):
        'preimage_domain_union_pw_multi_aff(self, upma)\n\n:param self: :class:`UnionMap`\n:param upma: :class:`UnionPwMultiAff`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upma, UnionPwMultiAff):
            raise IslTypeError("upma is not a UnionPwMultiAff")
        if _ctx_data != upma._ctx_data:
            raise Error("mismatched context in upma")
        _copy_upma = upma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_preimage_domain_union_pw_multi_aff(_copy_self._release(), _copy_upma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_preimage_domain_union_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.preimage_domain_union_pw_multi_aff = preimage_domain_union_pw_multi_aff

    def preimage_range_union_pw_multi_aff(self, upma):
        'preimage_range_union_pw_multi_aff(self, upma)\n\n:param self: :class:`UnionMap`\n:param upma: :class:`UnionPwMultiAff`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upma, UnionPwMultiAff):
            raise IslTypeError("upma is not a UnionPwMultiAff")
        if _ctx_data != upma._ctx_data:
            raise Error("mismatched context in upma")
        _copy_upma = upma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_preimage_range_union_pw_multi_aff(_copy_self._release(), _copy_upma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_preimage_range_union_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.preimage_range_union_pw_multi_aff = preimage_range_union_pw_multi_aff

    def reverse(self):
        'reverse(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_reverse(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_reverse failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.reverse = reverse

    def from_domain_and_range(domain, range):
        'from_domain_and_range(domain, range)\n\n:param domain: :class:`UnionSet`\n:param range: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if isinstance(domain, Set):
            domain = UnionSet.from_set(domain)
        if not isinstance(domain, UnionSet):
            raise IslTypeError("domain is not a UnionSet")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        if isinstance(range, BasicSet):
            range = Set.from_basic_set(range)
        if isinstance(range, Set):
            range = UnionSet.from_set(range)
        if not isinstance(range, UnionSet):
            raise IslTypeError("range is not a UnionSet")
        if _ctx_data != range._ctx_data:
            raise Error("mismatched context in range")
        _copy_range = range._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_from_domain_and_range(_copy_domain._release(), _copy_range._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_from_domain_and_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.from_domain_and_range = staticmethod(from_domain_and_range)

    UnionMap._from_domain_and_range_is_static = True

    def detect_equalities(self):
        'detect_equalities(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_detect_equalities(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_detect_equalities failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.detect_equalities = detect_equalities

    def deltas(self):
        'deltas(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_deltas(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_deltas failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.deltas = deltas

    def deltas_map(self):
        'deltas_map(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_deltas_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_deltas_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.deltas_map = deltas_map

    def project_out(self, type, first, n):
        'project_out(self, type, first, n)\n\n:param self: :class:`UnionMap`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_project_out(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_project_out failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.project_out = project_out

    def project_out_all_params(self):
        'project_out_all_params(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_project_out_all_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_project_out_all_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.project_out_all_params = project_out_all_params

    def remove_divs(self):
        'remove_divs(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_remove_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_remove_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.remove_divs = remove_divs

    def bind_range(self, tuple):
        'bind_range(self, tuple)\n\n:param self: :class:`UnionMap`\n:param tuple: :class:`MultiId`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(tuple, MultiId):
            raise IslTypeError("tuple is not a MultiId")
        if _ctx_data != tuple._ctx_data:
            raise Error("mismatched context in tuple")
        _copy_tuple = tuple._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_bind_range(_copy_self._release(), _copy_tuple._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_bind_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.bind_range = bind_range

    def plain_is_empty(self):
        'plain_is_empty(self)\n\n:param self: :class:`UnionMap`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_plain_is_empty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_plain_is_empty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.plain_is_empty = plain_is_empty

    def is_empty(self):
        'is_empty(self)\n\n:param self: :class:`UnionMap`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_is_empty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_is_empty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.is_empty = is_empty

    def is_single_valued(self):
        'is_single_valued(self)\n\n:param self: :class:`UnionMap`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_is_single_valued(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_is_single_valued\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.is_single_valued = is_single_valued

    def plain_is_injective(self):
        'plain_is_injective(self)\n\n:param self: :class:`UnionMap`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_plain_is_injective(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_plain_is_injective\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.plain_is_injective = plain_is_injective

    def is_injective(self):
        'is_injective(self)\n\n:param self: :class:`UnionMap`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_is_injective(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_is_injective\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.is_injective = is_injective

    def is_bijective(self):
        'is_bijective(self)\n\n:param self: :class:`UnionMap`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_is_bijective(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_is_bijective\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.is_bijective = is_bijective

    def is_identity(self):
        'is_identity(self)\n\n:param self: :class:`UnionMap`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_is_identity(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_is_identity\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.is_identity = is_identity

    def is_subset(self, umap2):
        'is_subset(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_is_subset(self.data, umap2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_is_subset\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.is_subset = is_subset

    def is_equal(self, umap2):
        'is_equal(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_is_equal(self.data, umap2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.is_equal = is_equal

    def is_disjoint(self, umap2):
        'is_disjoint(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_is_disjoint(self.data, umap2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_is_disjoint\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.is_disjoint = is_disjoint

    def is_strict_subset(self, umap2):
        'is_strict_subset(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_is_strict_subset(self.data, umap2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_is_strict_subset\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.is_strict_subset = is_strict_subset

    def get_hash(self):
        'get_hash(self)\n\n:param self: :class:`UnionMap`\n:return: uint32_t'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_get_hash(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionMap.get_hash = get_hash

    def n_map(self):
        'n_map(self)\n\n:param self: :class:`UnionMap`\n:return: isl_size'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_n_map(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionMap.n_map = n_map

    def foreach_map(self, fn):
        'foreach_map(self, fn)\n\n:param self: :class:`UnionMap`\n:param fn: callback(map) -> isl_stat\n:return: (nothing)'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(map, user):
            try:
                _py_map = Map(_data=map)
                _result = fn(_py_map)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_map *map,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_foreach_map(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_union_map_foreach_map\" failed: %s" % _get_last_error_str(_ctx_data))
        

    UnionMap.foreach_map = foreach_map

    def get_map_list(self):
        'get_map_list(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`MapList`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_get_map_list(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MapList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_get_map_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.get_map_list = get_map_list

    def every_map(self, test):
        'every_map(self, test)\n\n:param self: :class:`UnionMap`\n:param test: callback(map) -> isl_bool\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_test(map, user):
            try:
                _py_map = Map(_data=map)
                _result = test(_py_map)
                _py_map._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_test = ffi.callback(" isl_bool (*test)( isl_map *map,  void *user)")(_cb_wrapper_test)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_every_map(self.data, _cb_test, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_every_map\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.every_map = every_map

    def remove_map_if(self, fn):
        'remove_map_if(self, fn)\n\n:param self: :class:`UnionMap`\n:param fn: callback(map) -> isl_bool\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(map, user):
            try:
                _py_map = Map(_data=map)
                _result = fn(_py_map)
                _py_map._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_bool (*fn)( isl_map *map,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_remove_map_if(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_remove_map_if failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.remove_map_if = remove_map_if

    def contains(self, space):
        'contains(self, space)\n\n:param self: :class:`UnionMap`\n:param space: :class:`Space`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        
        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        if _ctx_data != space._ctx_data:
            raise Error("mismatched context in space")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_contains(self.data, space.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_contains\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.contains = contains

    def extract_map(self, dim):
        'extract_map(self, dim)\n\n:param self: :class:`UnionMap`\n:param dim: :class:`Space`\n:return: :class:`Map`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        
        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        if _ctx_data != dim._ctx_data:
            raise Error("mismatched context in dim")
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_extract_map(self.data, _copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_extract_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.extract_map = extract_map

    def isa_map(self):
        'isa_map(self)\n\n:param self: :class:`UnionMap`\n:return: bool'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_isa_map(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_map_isa_map\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionMap.isa_map = isa_map

    def sample(self):
        'sample(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`BasicMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_sample(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_sample failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.sample = sample

    def fixed_power_val(self, exp):
        'fixed_power_val(self, exp)\n\n:param self: :class:`UnionMap`\n:param exp: :class:`Val`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(exp, Val):
            if _ctx_data != exp._ctx_data:
                raise Error("mismatched context in exp")
            _val_exp = exp._copy()
        elif isinstance(exp, six.integer_types):
            _cdata_exp = lib.isl_val_int_from_si(
                self._get_ctx_data(), exp)
        
            if _cdata_exp == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_exp = Val(_data=_cdata_exp)
        
        else:
            raise IslTypeError("exp is a %s and cannot "
                "be cast to a Val" % type(exp))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_fixed_power_val(_copy_self._release(), _val_exp._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_fixed_power_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.fixed_power_val = fixed_power_val

    def lex_lt_union_map(self, umap2):
        'lex_lt_union_map(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_lex_lt_union_map(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_lex_lt_union_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.lex_lt_union_map = lex_lt_union_map

    def lex_le_union_map(self, umap2):
        'lex_le_union_map(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_lex_le_union_map(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_lex_le_union_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.lex_le_union_map = lex_le_union_map

    def lex_gt_union_map(self, umap2):
        'lex_gt_union_map(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_lex_gt_union_map(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_lex_gt_union_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.lex_gt_union_map = lex_gt_union_map

    def lex_ge_union_map(self, umap2):
        'lex_ge_union_map(self, umap2)\n\n:param self: :class:`UnionMap`\n:param umap2: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap2, BasicMap):
            umap2 = Map.from_basic_map(umap2)
        if isinstance(umap2, Map):
            umap2 = UnionMap.from_map(umap2)
        if not isinstance(umap2, UnionMap):
            raise IslTypeError("umap2 is not a UnionMap")
        if _ctx_data != umap2._ctx_data:
            raise Error("mismatched context in umap2")
        _copy_umap2 = umap2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_lex_ge_union_map(_copy_self._release(), _copy_umap2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_lex_ge_union_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.lex_ge_union_map = lex_ge_union_map

    def eq_at_multi_union_pw_aff(self, mupa):
        'eq_at_multi_union_pw_aff(self, mupa)\n\n:param self: :class:`UnionMap`\n:param mupa: :class:`MultiUnionPwAff`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mupa, MultiUnionPwAff):
            raise IslTypeError("mupa is not a MultiUnionPwAff")
        if _ctx_data != mupa._ctx_data:
            raise Error("mismatched context in mupa")
        _copy_mupa = mupa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_eq_at_multi_union_pw_aff(_copy_self._release(), _copy_mupa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_eq_at_multi_union_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.eq_at_multi_union_pw_aff = eq_at_multi_union_pw_aff

    def lex_lt_at_multi_union_pw_aff(self, mupa):
        'lex_lt_at_multi_union_pw_aff(self, mupa)\n\n:param self: :class:`UnionMap`\n:param mupa: :class:`MultiUnionPwAff`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mupa, MultiUnionPwAff):
            raise IslTypeError("mupa is not a MultiUnionPwAff")
        if _ctx_data != mupa._ctx_data:
            raise Error("mismatched context in mupa")
        _copy_mupa = mupa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_lex_lt_at_multi_union_pw_aff(_copy_self._release(), _copy_mupa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_lex_lt_at_multi_union_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.lex_lt_at_multi_union_pw_aff = lex_lt_at_multi_union_pw_aff

    def lex_gt_at_multi_union_pw_aff(self, mupa):
        'lex_gt_at_multi_union_pw_aff(self, mupa)\n\n:param self: :class:`UnionMap`\n:param mupa: :class:`MultiUnionPwAff`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mupa, MultiUnionPwAff):
            raise IslTypeError("mupa is not a MultiUnionPwAff")
        if _ctx_data != mupa._ctx_data:
            raise Error("mismatched context in mupa")
        _copy_mupa = mupa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_lex_gt_at_multi_union_pw_aff(_copy_self._release(), _copy_mupa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_lex_gt_at_multi_union_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.lex_gt_at_multi_union_pw_aff = lex_gt_at_multi_union_pw_aff

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`UnionMap`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.read_from_str = staticmethod(read_from_str)

    UnionMap._read_from_str_is_static = True

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`UnionMap`\n:return: string'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    UnionMap.to_str = to_str

    def dump(self):
        'dump(self)\n\n:param self: :class:`UnionMap`\n:return: (nothing)'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_dump(self.data)
        finally:
            pass
        

    UnionMap.dump = dump

    def wrap(self):
        'wrap(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_wrap(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_wrap failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.wrap = wrap

    def zip(self):
        'zip(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_zip(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_zip failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.zip = zip

    def curry(self):
        'curry(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_curry(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_curry failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.curry = curry

    def range_curry(self):
        'range_curry(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_range_curry(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_range_curry failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.range_curry = range_curry

    def uncurry(self):
        'uncurry(self)\n\n:param self: :class:`UnionMap`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_uncurry(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_uncurry failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.uncurry = uncurry

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`UnionMap`\n:param model: :class:`Space`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_map_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionMap.align_params = align_params

    def compute_flow(self, must_source, may_source, schedule):
        'compute_flow(self, must_source, may_source, schedule)\n\n:param self: :class:`UnionMap`\n:param must_source: :class:`UnionMap`\n:param may_source: :class:`UnionMap`\n:param schedule: :class:`UnionMap`\n:return: (int, must_dep (:class:`UnionMap`), may_dep (:class:`UnionMap`), must_no_source (:class:`UnionMap`), may_no_source (:class:`UnionMap`))'

        if isinstance(self, BasicMap):
            self = Map.from_basic_map(self)
        if isinstance(self, Map):
            self = UnionMap.from_map(self)
        if not isinstance(self, UnionMap):
            raise IslTypeError("self is not a UnionMap")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(must_source, BasicMap):
            must_source = Map.from_basic_map(must_source)
        if isinstance(must_source, Map):
            must_source = UnionMap.from_map(must_source)
        if not isinstance(must_source, UnionMap):
            raise IslTypeError("must_source is not a UnionMap")
        if _ctx_data != must_source._ctx_data:
            raise Error("mismatched context in must_source")
        _copy_must_source = must_source._copy()
        
        if isinstance(may_source, BasicMap):
            may_source = Map.from_basic_map(may_source)
        if isinstance(may_source, Map):
            may_source = UnionMap.from_map(may_source)
        if not isinstance(may_source, UnionMap):
            raise IslTypeError("may_source is not a UnionMap")
        if _ctx_data != may_source._ctx_data:
            raise Error("mismatched context in may_source")
        _copy_may_source = may_source._copy()
        
        if isinstance(schedule, BasicMap):
            schedule = Map.from_basic_map(schedule)
        if isinstance(schedule, Map):
            schedule = UnionMap.from_map(schedule)
        if not isinstance(schedule, UnionMap):
            raise IslTypeError("schedule is not a UnionMap")
        if _ctx_data != schedule._ctx_data:
            raise Error("mismatched context in schedule")
        _copy_schedule = schedule._copy()
        
        _retptr_must_dep = ffi.new("isl_union_map **")
        
        _retptr_may_dep = ffi.new("isl_union_map **")
        
        _retptr_must_no_source = ffi.new("isl_union_map **")
        
        _retptr_may_no_source = ffi.new("isl_union_map **")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_map_compute_flow(_copy_self._release(), _copy_must_source._release(), _copy_may_source._release(), _copy_schedule._release(), _retptr_must_dep, _retptr_may_dep, _retptr_must_no_source, _retptr_may_no_source)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _retptr_must_dep == ffi.NULL:
                _ret_must_dep = None
            else:
                _ret_must_dep = UnionMap(_data=_retptr_must_dep[0])
            if _retptr_may_dep == ffi.NULL:
                _ret_may_dep = None
            else:
                _ret_may_dep = UnionMap(_data=_retptr_may_dep[0])
            if _retptr_must_no_source == ffi.NULL:
                _ret_must_no_source = None
            else:
                _ret_must_no_source = UnionMap(_data=_retptr_must_no_source[0])
            if _retptr_may_no_source == ffi.NULL:
                _ret_may_no_source = None
            else:
                _ret_may_no_source = UnionMap(_data=_retptr_may_no_source[0])
            pass
        
        return _result, _ret_must_dep, _ret_may_dep, _ret_must_no_source, _ret_may_no_source

    UnionMap.compute_flow = compute_flow

    # }}}

    # {{{ union_set

    def identity_union_pw_multi_aff(self):
        'identity_union_pw_multi_aff(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionPwMultiAff`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_identity_union_pw_multi_aff(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_identity_union_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.identity_union_pw_multi_aff = identity_union_pw_multi_aff

    def wrapped_domain_map(self):
        'wrapped_domain_map(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_wrapped_domain_map(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_wrapped_domain_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.wrapped_domain_map = wrapped_domain_map

    def identity(self):
        'identity(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_identity(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_identity failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.identity = identity

    def unwrap(self):
        'unwrap(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_unwrap(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_unwrap failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.unwrap = unwrap

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`UnionSet`\n:param model: :class:`Space`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.align_params = align_params

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`UnionSet`\n:param type: :class:`dim_type`\n:return: isl_size'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionSet.dim = dim

    def from_basic_set(bset):
        'from_basic_set(bset)\n\n:param bset: :class:`BasicSet`\n:return: :class:`UnionSet`'

        if not isinstance(bset, BasicSet):
            raise IslTypeError("bset is not a BasicSet")
        _ctx_data = bset._ctx_data
        _copy_bset = bset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_from_basic_set(_copy_bset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_from_basic_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.from_basic_set = staticmethod(from_basic_set)

    UnionSet._from_basic_set_is_static = True

    def from_set(set):
        'from_set(set)\n\n:param set: :class:`Set`\n:return: :class:`UnionSet`'

        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        _ctx_data = set._ctx_data
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_from_set(_copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_from_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.from_set = staticmethod(from_set)

    UnionSet._from_set_is_static = True

    def empty(space):
        'empty(space)\n\n:param space: :class:`Space`\n:return: :class:`UnionSet`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_empty(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_empty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.empty = staticmethod(empty)

    UnionSet._empty_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.copy = copy

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`Context`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.get_ctx = get_ctx

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`Space`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.get_space = get_space

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.reset_user = reset_user

    def universe(self):
        'universe(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_universe(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_universe failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.universe = universe

    def params(self):
        'params(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.params = params

    def detect_equalities(self):
        'detect_equalities(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_detect_equalities(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_detect_equalities failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.detect_equalities = detect_equalities

    def affine_hull(self):
        'affine_hull(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_affine_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_affine_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.affine_hull = affine_hull

    def polyhedral_hull(self):
        'polyhedral_hull(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_polyhedral_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_polyhedral_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.polyhedral_hull = polyhedral_hull

    def remove_redundancies(self):
        'remove_redundancies(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_remove_redundancies(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_remove_redundancies failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.remove_redundancies = remove_redundancies

    def simple_hull(self):
        'simple_hull(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_simple_hull(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_simple_hull failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.simple_hull = simple_hull

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.coalesce = coalesce

    def compute_divs(self):
        'compute_divs(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_compute_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_compute_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.compute_divs = compute_divs

    def lexmin(self):
        'lexmin(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_lexmin(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_lexmin failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.lexmin = lexmin

    def lexmax(self):
        'lexmax(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_lexmax(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_lexmax failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.lexmax = lexmax

    def add_set(self, set):
        'add_set(self, set)\n\n:param self: :class:`UnionSet`\n:param set: :class:`Set`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_add_set(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_add_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.add_set = add_set

    def union(self, uset2):
        'union(self, uset2)\n\n:param self: :class:`UnionSet`\n:param uset2: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset2, BasicSet):
            uset2 = Set.from_basic_set(uset2)
        if isinstance(uset2, Set):
            uset2 = UnionSet.from_set(uset2)
        if not isinstance(uset2, UnionSet):
            raise IslTypeError("uset2 is not a UnionSet")
        if _ctx_data != uset2._ctx_data:
            raise Error("mismatched context in uset2")
        _copy_uset2 = uset2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_union(_copy_self._release(), _copy_uset2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_union failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.union = union

    def subtract(self, uset2):
        'subtract(self, uset2)\n\n:param self: :class:`UnionSet`\n:param uset2: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset2, BasicSet):
            uset2 = Set.from_basic_set(uset2)
        if isinstance(uset2, Set):
            uset2 = UnionSet.from_set(uset2)
        if not isinstance(uset2, UnionSet):
            raise IslTypeError("uset2 is not a UnionSet")
        if _ctx_data != uset2._ctx_data:
            raise Error("mismatched context in uset2")
        _copy_uset2 = uset2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_subtract(_copy_self._release(), _copy_uset2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_subtract failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.subtract = subtract

    def intersect(self, uset2):
        'intersect(self, uset2)\n\n:param self: :class:`UnionSet`\n:param uset2: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset2, BasicSet):
            uset2 = Set.from_basic_set(uset2)
        if isinstance(uset2, Set):
            uset2 = UnionSet.from_set(uset2)
        if not isinstance(uset2, UnionSet):
            raise IslTypeError("uset2 is not a UnionSet")
        if _ctx_data != uset2._ctx_data:
            raise Error("mismatched context in uset2")
        _copy_uset2 = uset2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_intersect(_copy_self._release(), _copy_uset2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_intersect failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.intersect = intersect

    def intersect_params(self, set):
        'intersect_params(self, set)\n\n:param self: :class:`UnionSet`\n:param set: :class:`Set`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_intersect_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.intersect_params = intersect_params

    def product(self, uset2):
        'product(self, uset2)\n\n:param self: :class:`UnionSet`\n:param uset2: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset2, BasicSet):
            uset2 = Set.from_basic_set(uset2)
        if isinstance(uset2, Set):
            uset2 = UnionSet.from_set(uset2)
        if not isinstance(uset2, UnionSet):
            raise IslTypeError("uset2 is not a UnionSet")
        if _ctx_data != uset2._ctx_data:
            raise Error("mismatched context in uset2")
        _copy_uset2 = uset2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_product(_copy_self._release(), _copy_uset2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_product failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.product = product

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`UnionSet`\n:param context: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if isinstance(context, Set):
            context = UnionSet.from_set(context)
        if not isinstance(context, UnionSet):
            raise IslTypeError("context is not a UnionSet")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.gist = gist

    def gist_params(self, set):
        'gist_params(self, set)\n\n:param self: :class:`UnionSet`\n:param set: :class:`Set`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_gist_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.gist_params = gist_params

    def apply(self, umap):
        'apply(self, umap)\n\n:param self: :class:`UnionSet`\n:param umap: :class:`UnionMap`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap, BasicMap):
            umap = Map.from_basic_map(umap)
        if isinstance(umap, Map):
            umap = UnionMap.from_map(umap)
        if not isinstance(umap, UnionMap):
            raise IslTypeError("umap is not a UnionMap")
        if _ctx_data != umap._ctx_data:
            raise Error("mismatched context in umap")
        _copy_umap = umap._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_apply(_copy_self._release(), _copy_umap._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_apply failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.apply = apply

    def preimage_multi_aff(self, ma):
        'preimage_multi_aff(self, ma)\n\n:param self: :class:`UnionSet`\n:param ma: :class:`MultiAff`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(ma, MultiAff):
            raise IslTypeError("ma is not a MultiAff")
        if _ctx_data != ma._ctx_data:
            raise Error("mismatched context in ma")
        _copy_ma = ma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_preimage_multi_aff(_copy_self._release(), _copy_ma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_preimage_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.preimage_multi_aff = preimage_multi_aff

    def preimage_pw_multi_aff(self, pma):
        'preimage_pw_multi_aff(self, pma)\n\n:param self: :class:`UnionSet`\n:param pma: :class:`PwMultiAff`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_preimage_pw_multi_aff(_copy_self._release(), _copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_preimage_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.preimage_pw_multi_aff = preimage_pw_multi_aff

    def preimage_union_pw_multi_aff(self, upma):
        'preimage_union_pw_multi_aff(self, upma)\n\n:param self: :class:`UnionSet`\n:param upma: :class:`UnionPwMultiAff`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upma, UnionPwMultiAff):
            raise IslTypeError("upma is not a UnionPwMultiAff")
        if _ctx_data != upma._ctx_data:
            raise Error("mismatched context in upma")
        _copy_upma = upma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_preimage_union_pw_multi_aff(_copy_self._release(), _copy_upma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_preimage_union_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.preimage_union_pw_multi_aff = preimage_union_pw_multi_aff

    def project_out(self, type, first, n):
        'project_out(self, type, first, n)\n\n:param self: :class:`UnionSet`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_project_out(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_project_out failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.project_out = project_out

    def project_out_all_params(self):
        'project_out_all_params(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_project_out_all_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_project_out_all_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.project_out_all_params = project_out_all_params

    def remove_divs(self):
        'remove_divs(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_remove_divs(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_remove_divs failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.remove_divs = remove_divs

    def is_params(self):
        'is_params(self)\n\n:param self: :class:`UnionSet`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_is_params(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_set_is_params\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionSet.is_params = is_params

    def is_empty(self):
        'is_empty(self)\n\n:param self: :class:`UnionSet`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_is_empty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_set_is_empty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionSet.is_empty = is_empty

    def is_subset(self, uset2):
        'is_subset(self, uset2)\n\n:param self: :class:`UnionSet`\n:param uset2: :class:`UnionSet`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        
        if isinstance(uset2, BasicSet):
            uset2 = Set.from_basic_set(uset2)
        if isinstance(uset2, Set):
            uset2 = UnionSet.from_set(uset2)
        if not isinstance(uset2, UnionSet):
            raise IslTypeError("uset2 is not a UnionSet")
        if _ctx_data != uset2._ctx_data:
            raise Error("mismatched context in uset2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_is_subset(self.data, uset2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_set_is_subset\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionSet.is_subset = is_subset

    def is_equal(self, uset2):
        'is_equal(self, uset2)\n\n:param self: :class:`UnionSet`\n:param uset2: :class:`UnionSet`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        
        if isinstance(uset2, BasicSet):
            uset2 = Set.from_basic_set(uset2)
        if isinstance(uset2, Set):
            uset2 = UnionSet.from_set(uset2)
        if not isinstance(uset2, UnionSet):
            raise IslTypeError("uset2 is not a UnionSet")
        if _ctx_data != uset2._ctx_data:
            raise Error("mismatched context in uset2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_is_equal(self.data, uset2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_set_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionSet.is_equal = is_equal

    def is_disjoint(self, uset2):
        'is_disjoint(self, uset2)\n\n:param self: :class:`UnionSet`\n:param uset2: :class:`UnionSet`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        
        if isinstance(uset2, BasicSet):
            uset2 = Set.from_basic_set(uset2)
        if isinstance(uset2, Set):
            uset2 = UnionSet.from_set(uset2)
        if not isinstance(uset2, UnionSet):
            raise IslTypeError("uset2 is not a UnionSet")
        if _ctx_data != uset2._ctx_data:
            raise Error("mismatched context in uset2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_is_disjoint(self.data, uset2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_set_is_disjoint\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionSet.is_disjoint = is_disjoint

    def is_strict_subset(self, uset2):
        'is_strict_subset(self, uset2)\n\n:param self: :class:`UnionSet`\n:param uset2: :class:`UnionSet`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        
        if isinstance(uset2, BasicSet):
            uset2 = Set.from_basic_set(uset2)
        if isinstance(uset2, Set):
            uset2 = UnionSet.from_set(uset2)
        if not isinstance(uset2, UnionSet):
            raise IslTypeError("uset2 is not a UnionSet")
        if _ctx_data != uset2._ctx_data:
            raise Error("mismatched context in uset2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_is_strict_subset(self.data, uset2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_set_is_strict_subset\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionSet.is_strict_subset = is_strict_subset

    def get_hash(self):
        'get_hash(self)\n\n:param self: :class:`UnionSet`\n:return: uint32_t'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_get_hash(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionSet.get_hash = get_hash

    def n_set(self):
        'n_set(self)\n\n:param self: :class:`UnionSet`\n:return: isl_size'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_n_set(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionSet.n_set = n_set

    def foreach_set(self, fn):
        'foreach_set(self, fn)\n\n:param self: :class:`UnionSet`\n:param fn: callback(set) -> isl_stat\n:return: (nothing)'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(set, user):
            try:
                _py_set = Set(_data=set)
                _result = fn(_py_set)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_set *set,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_foreach_set(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_union_set_foreach_set\" failed: %s" % _get_last_error_str(_ctx_data))
        

    UnionSet.foreach_set = foreach_set

    def every_set(self, test):
        'every_set(self, test)\n\n:param self: :class:`UnionSet`\n:param test: callback(set) -> isl_bool\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_test(set, user):
            try:
                _py_set = Set(_data=set)
                _result = test(_py_set)
                _py_set._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_test = ffi.callback(" isl_bool (*test)( isl_set *set,  void *user)")(_cb_wrapper_test)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_every_set(self.data, _cb_test, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_set_every_set\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionSet.every_set = every_set

    def get_basic_set_list(self):
        'get_basic_set_list(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`BasicSetList`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_get_basic_set_list(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_get_basic_set_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.get_basic_set_list = get_basic_set_list

    def get_set_list(self):
        'get_set_list(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`SetList`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_get_set_list(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else SetList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_get_set_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.get_set_list = get_set_list

    def contains(self, space):
        'contains(self, space)\n\n:param self: :class:`UnionSet`\n:param space: :class:`Space`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        
        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        if _ctx_data != space._ctx_data:
            raise Error("mismatched context in space")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_contains(self.data, space.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_set_contains\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionSet.contains = contains

    def extract_set(self, dim):
        'extract_set(self, dim)\n\n:param self: :class:`UnionSet`\n:param dim: :class:`Space`\n:return: :class:`Set`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        
        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        if _ctx_data != dim._ctx_data:
            raise Error("mismatched context in dim")
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_extract_set(self.data, _copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_extract_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.extract_set = extract_set

    def isa_set(self):
        'isa_set(self)\n\n:param self: :class:`UnionSet`\n:return: bool'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_isa_set(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_set_isa_set\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionSet.isa_set = isa_set

    def foreach_point(self, fn):
        'foreach_point(self, fn)\n\n:param self: :class:`UnionSet`\n:param fn: callback(pnt) -> isl_stat\n:return: (nothing)'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(pnt, user):
            try:
                _py_pnt = Point(_data=pnt)
                _result = fn(_py_pnt)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_point *pnt,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_foreach_point(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_union_set_foreach_point\" failed: %s" % _get_last_error_str(_ctx_data))
        

    UnionSet.foreach_point = foreach_point

    def sample(self):
        'sample(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`BasicSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_sample(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_sample failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.sample = sample

    def sample_point(self):
        'sample_point(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`Point`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_sample_point(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Point(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_sample_point failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.sample_point = sample_point

    def from_point(pnt):
        'from_point(pnt)\n\n:param pnt: :class:`Point`\n:return: :class:`UnionSet`'

        if not isinstance(pnt, Point):
            raise IslTypeError("pnt is not a Point")
        _ctx_data = pnt._ctx_data
        _copy_pnt = pnt._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_from_point(_copy_pnt._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_from_point failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.from_point = staticmethod(from_point)

    UnionSet._from_point_is_static = True

    def lift(self):
        'lift(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_lift(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_lift failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.lift = lift

    def lex_lt_union_set(self, uset2):
        'lex_lt_union_set(self, uset2)\n\n:param self: :class:`UnionSet`\n:param uset2: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset2, BasicSet):
            uset2 = Set.from_basic_set(uset2)
        if isinstance(uset2, Set):
            uset2 = UnionSet.from_set(uset2)
        if not isinstance(uset2, UnionSet):
            raise IslTypeError("uset2 is not a UnionSet")
        if _ctx_data != uset2._ctx_data:
            raise Error("mismatched context in uset2")
        _copy_uset2 = uset2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_lex_lt_union_set(_copy_self._release(), _copy_uset2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_lex_lt_union_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.lex_lt_union_set = lex_lt_union_set

    def lex_le_union_set(self, uset2):
        'lex_le_union_set(self, uset2)\n\n:param self: :class:`UnionSet`\n:param uset2: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset2, BasicSet):
            uset2 = Set.from_basic_set(uset2)
        if isinstance(uset2, Set):
            uset2 = UnionSet.from_set(uset2)
        if not isinstance(uset2, UnionSet):
            raise IslTypeError("uset2 is not a UnionSet")
        if _ctx_data != uset2._ctx_data:
            raise Error("mismatched context in uset2")
        _copy_uset2 = uset2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_lex_le_union_set(_copy_self._release(), _copy_uset2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_lex_le_union_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.lex_le_union_set = lex_le_union_set

    def lex_gt_union_set(self, uset2):
        'lex_gt_union_set(self, uset2)\n\n:param self: :class:`UnionSet`\n:param uset2: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset2, BasicSet):
            uset2 = Set.from_basic_set(uset2)
        if isinstance(uset2, Set):
            uset2 = UnionSet.from_set(uset2)
        if not isinstance(uset2, UnionSet):
            raise IslTypeError("uset2 is not a UnionSet")
        if _ctx_data != uset2._ctx_data:
            raise Error("mismatched context in uset2")
        _copy_uset2 = uset2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_lex_gt_union_set(_copy_self._release(), _copy_uset2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_lex_gt_union_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.lex_gt_union_set = lex_gt_union_set

    def lex_ge_union_set(self, uset2):
        'lex_ge_union_set(self, uset2)\n\n:param self: :class:`UnionSet`\n:param uset2: :class:`UnionSet`\n:return: :class:`UnionMap`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset2, BasicSet):
            uset2 = Set.from_basic_set(uset2)
        if isinstance(uset2, Set):
            uset2 = UnionSet.from_set(uset2)
        if not isinstance(uset2, UnionSet):
            raise IslTypeError("uset2 is not a UnionSet")
        if _ctx_data != uset2._ctx_data:
            raise Error("mismatched context in uset2")
        _copy_uset2 = uset2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_lex_ge_union_set(_copy_self._release(), _copy_uset2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_lex_ge_union_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.lex_ge_union_set = lex_ge_union_set

    def coefficients(self):
        'coefficients(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_coefficients(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_coefficients failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.coefficients = coefficients

    def solutions(self):
        'solutions(self)\n\n:param self: :class:`UnionSet`\n:return: :class:`UnionSet`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_solutions(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_solutions failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.solutions = solutions

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`UnionSet`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.read_from_str = staticmethod(read_from_str)

    UnionSet._read_from_str_is_static = True

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`UnionSet`\n:return: string'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    UnionSet.to_str = to_str

    def dump(self):
        'dump(self)\n\n:param self: :class:`UnionSet`\n:return: (nothing)'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_dump(self.data)
        finally:
            pass
        

    UnionSet.dump = dump

    def compute_schedule(self, validity, proximity):
        'compute_schedule(self, validity, proximity)\n\n:param self: :class:`UnionSet`\n:param validity: :class:`UnionMap`\n:param proximity: :class:`UnionMap`\n:return: :class:`Schedule`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(validity, BasicMap):
            validity = Map.from_basic_map(validity)
        if isinstance(validity, Map):
            validity = UnionMap.from_map(validity)
        if not isinstance(validity, UnionMap):
            raise IslTypeError("validity is not a UnionMap")
        if _ctx_data != validity._ctx_data:
            raise Error("mismatched context in validity")
        _copy_validity = validity._copy()
        
        if isinstance(proximity, BasicMap):
            proximity = Map.from_basic_map(proximity)
        if isinstance(proximity, Map):
            proximity = UnionMap.from_map(proximity)
        if not isinstance(proximity, UnionMap):
            raise IslTypeError("proximity is not a UnionMap")
        if _ctx_data != proximity._ctx_data:
            raise Error("mismatched context in proximity")
        _copy_proximity = proximity._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_compute_schedule(_copy_self._release(), _copy_validity._release(), _copy_proximity._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_compute_schedule failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.compute_schedule = compute_schedule

    def min_multi_union_pw_aff(self, obj):
        'min_multi_union_pw_aff(self, obj)\n\n:param self: :class:`UnionSet`\n:param obj: :class:`MultiUnionPwAff`\n:return: :class:`MultiVal`'

        if isinstance(self, BasicSet):
            self = Set.from_basic_set(self)
        if isinstance(self, Set):
            self = UnionSet.from_set(self)
        if not isinstance(self, UnionSet):
            raise IslTypeError("self is not a UnionSet")
        _ctx_data = self._ctx_data
        
        if not isinstance(obj, MultiUnionPwAff):
            raise IslTypeError("obj is not a MultiUnionPwAff")
        if _ctx_data != obj._ctx_data:
            raise Error("mismatched context in obj")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_set_min_multi_union_pw_aff(self.data, obj.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiVal(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_set_min_multi_union_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionSet.min_multi_union_pw_aff = min_multi_union_pw_aff

    # }}}

    # {{{ point

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Point`\n:return: :class:`Context`'

        if not isinstance(self, Point):
            raise IslTypeError("self is not a Point")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_point_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_point_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Point.get_ctx = get_ctx

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`Point`\n:return: :class:`Space`'

        if not isinstance(self, Point):
            raise IslTypeError("self is not a Point")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_point_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_point_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Point.get_space = get_space

    def zero(space):
        'zero(space)\n\n:param space: :class:`Space`\n:return: :class:`Point`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_point_zero(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Point(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_point_zero failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Point.zero = staticmethod(zero)

    Point._zero_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`Point`\n:return: :class:`Point`'

        if not isinstance(self, Point):
            raise IslTypeError("self is not a Point")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_point_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Point(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_point_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Point.copy = copy

    def get_coordinate_val(self, type, pos):
        'get_coordinate_val(self, type, pos)\n\n:param self: :class:`Point`\n:param type: :class:`dim_type`\n:param pos: :class:`int`\n:return: :class:`Val`'

        if not isinstance(self, Point):
            raise IslTypeError("self is not a Point")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_point_get_coordinate_val(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_point_get_coordinate_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Point.get_coordinate_val = get_coordinate_val

    def set_coordinate_val(self, type, pos, v):
        'set_coordinate_val(self, type, pos, v)\n\n:param self: :class:`Point`\n:param type: :class:`dim_type`\n:param pos: :class:`int`\n:param v: :class:`Val`\n:return: :class:`Point`'

        if not isinstance(self, Point):
            raise IslTypeError("self is not a Point")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_point_set_coordinate_val(_copy_self._release(), type, pos, _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Point(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_point_set_coordinate_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Point.set_coordinate_val = set_coordinate_val

    def add_ui(self, type, pos, val):
        'add_ui(self, type, pos, val)\n\n:param self: :class:`Point`\n:param type: :class:`dim_type`\n:param pos: :class:`int`\n:param val: :class:`unsigned`\n:return: :class:`Point`'

        if not isinstance(self, Point):
            raise IslTypeError("self is not a Point")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_point_add_ui(_copy_self._release(), type, pos, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Point(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_point_add_ui failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Point.add_ui = add_ui

    def sub_ui(self, type, pos, val):
        'sub_ui(self, type, pos, val)\n\n:param self: :class:`Point`\n:param type: :class:`dim_type`\n:param pos: :class:`int`\n:param val: :class:`unsigned`\n:return: :class:`Point`'

        if not isinstance(self, Point):
            raise IslTypeError("self is not a Point")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        # no argument processing for val
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_point_sub_ui(_copy_self._release(), type, pos, val)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Point(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_point_sub_ui failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Point.sub_ui = sub_ui

    def void(space):
        'void(space)\n\n:param space: :class:`Space`\n:return: :class:`Point`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_point_void(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Point(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_point_void failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Point.void = staticmethod(void)

    Point._void_is_static = True

    def is_void(self):
        'is_void(self)\n\n:param self: :class:`Point`\n:return: bool'

        if not isinstance(self, Point):
            raise IslTypeError("self is not a Point")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_point_is_void(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_point_is_void\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Point.is_void = is_void

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`Point`\n:return: string'

        if not isinstance(self, Point):
            raise IslTypeError("self is not a Point")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_point_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Point.to_str = to_str

    def dump(self):
        'dump(self)\n\n:param self: :class:`Point`\n:return: (nothing)'

        if not isinstance(self, Point):
            raise IslTypeError("self is not a Point")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_point_dump(self.data)
        finally:
            pass
        

    Point.dump = dump

    # }}}

    # {{{ vertex

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Vertex`\n:return: :class:`Context`'

        if not isinstance(self, Vertex):
            raise IslTypeError("self is not a Vertex")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vertex_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vertex_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vertex.get_ctx = get_ctx

    def get_id(self):
        'get_id(self)\n\n:param self: :class:`Vertex`\n:return: isl_size'

        if not isinstance(self, Vertex):
            raise IslTypeError("self is not a Vertex")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vertex_get_id(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Vertex.get_id = get_id

    def get_domain(self):
        'get_domain(self)\n\n:param self: :class:`Vertex`\n:return: :class:`BasicSet`'

        if not isinstance(self, Vertex):
            raise IslTypeError("self is not a Vertex")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vertex_get_domain(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vertex_get_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vertex.get_domain = get_domain

    def get_expr(self):
        'get_expr(self)\n\n:param self: :class:`Vertex`\n:return: :class:`MultiAff`'

        if not isinstance(self, Vertex):
            raise IslTypeError("self is not a Vertex")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vertex_get_expr(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vertex_get_expr failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vertex.get_expr = get_expr

    # }}}

    # {{{ cell

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Cell`\n:return: :class:`Context`'

        if not isinstance(self, Cell):
            raise IslTypeError("self is not a Cell")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_cell_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_cell_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Cell.get_ctx = get_ctx

    def get_domain(self):
        'get_domain(self)\n\n:param self: :class:`Cell`\n:return: :class:`BasicSet`'

        if not isinstance(self, Cell):
            raise IslTypeError("self is not a Cell")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_cell_get_domain(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else BasicSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_cell_get_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Cell.get_domain = get_domain

    def foreach_vertex(self, fn):
        'foreach_vertex(self, fn)\n\n:param self: :class:`Cell`\n:param fn: callback(vertex) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, Cell):
            raise IslTypeError("self is not a Cell")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(vertex, user):
            try:
                _py_vertex = Vertex(_data=vertex)
                _result = fn(_py_vertex)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_vertex *vertex,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_cell_foreach_vertex(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_cell_foreach_vertex\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Cell.foreach_vertex = foreach_vertex

    # }}}

    # {{{ vertices

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Vertices`\n:return: :class:`Context`'

        if not isinstance(self, Vertices):
            raise IslTypeError("self is not a Vertices")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vertices_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_vertices_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Vertices.get_ctx = get_ctx

    def get_n_vertices(self):
        'get_n_vertices(self)\n\n:param self: :class:`Vertices`\n:return: isl_size'

        if not isinstance(self, Vertices):
            raise IslTypeError("self is not a Vertices")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vertices_get_n_vertices(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Vertices.get_n_vertices = get_n_vertices

    def foreach_vertex(self, fn):
        'foreach_vertex(self, fn)\n\n:param self: :class:`Vertices`\n:param fn: callback(vertex) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, Vertices):
            raise IslTypeError("self is not a Vertices")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(vertex, user):
            try:
                _py_vertex = Vertex(_data=vertex)
                _result = fn(_py_vertex)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_vertex *vertex,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vertices_foreach_vertex(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_vertices_foreach_vertex\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Vertices.foreach_vertex = foreach_vertex

    def foreach_cell(self, fn):
        'foreach_cell(self, fn)\n\n:param self: :class:`Vertices`\n:param fn: callback(cell) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, Vertices):
            raise IslTypeError("self is not a Vertices")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(cell, user):
            try:
                _py_cell = Cell(_data=cell)
                _result = fn(_py_cell)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_cell *cell,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_vertices_foreach_cell(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_vertices_foreach_cell\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Vertices.foreach_cell = foreach_cell

    # }}}

    # {{{ stride_info

    # }}}

    # {{{ qpolynomial_fold

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`QPolynomialFold`\n:return: :class:`Context`'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_fold_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomialFold.get_ctx = get_ctx

    def get_type(self):
        'get_type(self)\n\n:param self: :class:`QPolynomialFold`\n:return: isl_fold'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_get_type(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    QPolynomialFold.get_type = get_type

    def empty(type, dim):
        'empty(type, dim)\n\n:param type: :class:`fold`\n:param dim: :class:`Space`\n:return: :class:`QPolynomialFold`'

        # no argument processing for type
        
        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        if _ctx_data != dim._ctx_data:
            raise Error("mismatched context in dim")
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_empty(type, _copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_fold_empty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomialFold.empty = staticmethod(empty)

    QPolynomialFold._empty_is_static = True

    def alloc(type, qp):
        'alloc(type, qp)\n\n:param type: :class:`fold`\n:param qp: :class:`QPolynomial`\n:return: :class:`QPolynomialFold`'

        # no argument processing for type
        
        if not isinstance(qp, QPolynomial):
            raise IslTypeError("qp is not a QPolynomial")
        if _ctx_data != qp._ctx_data:
            raise Error("mismatched context in qp")
        _copy_qp = qp._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_alloc(type, _copy_qp._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_fold_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomialFold.alloc = staticmethod(alloc)

    QPolynomialFold._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`QPolynomialFold`\n:return: :class:`QPolynomialFold`'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_fold_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomialFold.copy = copy

    def is_empty(self):
        'is_empty(self)\n\n:param self: :class:`QPolynomialFold`\n:return: int'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_is_empty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    QPolynomialFold.is_empty = is_empty

    def is_nan(self):
        'is_nan(self)\n\n:param self: :class:`QPolynomialFold`\n:return: bool'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_is_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_qpolynomial_fold_is_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    QPolynomialFold.is_nan = is_nan

    def plain_is_equal(self, fold2):
        'plain_is_equal(self, fold2)\n\n:param self: :class:`QPolynomialFold`\n:param fold2: :class:`QPolynomialFold`\n:return: int'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        
        if not isinstance(fold2, QPolynomialFold):
            raise IslTypeError("fold2 is not a QPolynomialFold")
        if _ctx_data != fold2._ctx_data:
            raise Error("mismatched context in fold2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_plain_is_equal(self.data, fold2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    QPolynomialFold.plain_is_equal = plain_is_equal

    def get_domain_space(self):
        'get_domain_space(self)\n\n:param self: :class:`QPolynomialFold`\n:return: :class:`Space`'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_get_domain_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_fold_get_domain_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomialFold.get_domain_space = get_domain_space

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`QPolynomialFold`\n:return: :class:`Space`'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_fold_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomialFold.get_space = get_space

    def fold(self, fold2):
        'fold(self, fold2)\n\n:param self: :class:`QPolynomialFold`\n:param fold2: :class:`QPolynomialFold`\n:return: :class:`QPolynomialFold`'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(fold2, QPolynomialFold):
            raise IslTypeError("fold2 is not a QPolynomialFold")
        if _ctx_data != fold2._ctx_data:
            raise Error("mismatched context in fold2")
        _copy_fold2 = fold2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_fold(_copy_self._release(), _copy_fold2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_fold_fold failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomialFold.fold = fold

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`QPolynomialFold`\n:param v: :class:`Val`\n:return: :class:`QPolynomialFold`'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_fold_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomialFold.scale_val = scale_val

    def scale_down_val(self, v):
        'scale_down_val(self, v)\n\n:param self: :class:`QPolynomialFold`\n:param v: :class:`Val`\n:return: :class:`QPolynomialFold`'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_scale_down_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_fold_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomialFold.scale_down_val = scale_down_val

    def move_dims(self, dst_type, dst_pos, src_type, src_pos, n):
        'move_dims(self, dst_type, dst_pos, src_type, src_pos, n)\n\n:param self: :class:`QPolynomialFold`\n:param dst_type: :class:`dim_type`\n:param dst_pos: :class:`unsigned`\n:param src_type: :class:`dim_type`\n:param src_pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`QPolynomialFold`'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_type
        
        # no argument processing for dst_pos
        
        # no argument processing for src_type
        
        # no argument processing for src_pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_move_dims(_copy_self._release(), dst_type, dst_pos, src_type, src_pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_fold_move_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomialFold.move_dims = move_dims

    def eval(self, pnt):
        'eval(self, pnt)\n\n:param self: :class:`QPolynomialFold`\n:param pnt: :class:`Point`\n:return: :class:`Val`'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pnt, Point):
            raise IslTypeError("pnt is not a Point")
        if _ctx_data != pnt._ctx_data:
            raise Error("mismatched context in pnt")
        _copy_pnt = pnt._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_eval(_copy_self._release(), _copy_pnt._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_fold_eval failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomialFold.eval = eval

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`QPolynomialFold`\n:param context: :class:`Set`\n:return: :class:`QPolynomialFold`'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_fold_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomialFold.gist_params = gist_params

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`QPolynomialFold`\n:param context: :class:`Set`\n:return: :class:`QPolynomialFold`'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_fold_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomialFold.gist = gist

    def foreach_qpolynomial(self, fn):
        'foreach_qpolynomial(self, fn)\n\n:param self: :class:`QPolynomialFold`\n:param fn: callback(qp) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(qp, user):
            try:
                _py_qp = QPolynomial(_data=qp)
                _result = fn(_py_qp)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_qpolynomial *qp,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_foreach_qpolynomial(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_qpolynomial_fold_foreach_qpolynomial\" failed: %s" % _get_last_error_str(_ctx_data))
        

    QPolynomialFold.foreach_qpolynomial = foreach_qpolynomial

    def dump(self):
        'dump(self)\n\n:param self: :class:`QPolynomialFold`\n:return: (nothing)'

        if not isinstance(self, QPolynomialFold):
            raise IslTypeError("self is not a QPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_fold_dump(self.data)
        finally:
            pass
        

    QPolynomialFold.dump = dump

    # }}}

    # {{{ pw_qpolynomial_fold

    def fix_val(self, type, n, v):
        'fix_val(self, type, n, v)\n\n:param self: :class:`PwQPolynomialFold`\n:param type: :class:`dim_type`\n:param n: :class:`unsigned`\n:param v: :class:`Val`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for n
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_fix_val(_copy_self._release(), type, n, _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_fix_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.fix_val = fix_val

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: :class:`Context`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.get_ctx = get_ctx

    def involves_nan(self):
        'involves_nan(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: bool'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_involves_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_qpolynomial_fold_involves_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwQPolynomialFold.involves_nan = involves_nan

    def plain_is_equal(self, pwf2):
        'plain_is_equal(self, pwf2)\n\n:param self: :class:`PwQPolynomialFold`\n:param pwf2: :class:`PwQPolynomialFold`\n:return: bool'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        
        if not isinstance(pwf2, PwQPolynomialFold):
            raise IslTypeError("pwf2 is not a PwQPolynomialFold")
        if _ctx_data != pwf2._ctx_data:
            raise Error("mismatched context in pwf2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_plain_is_equal(self.data, pwf2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_qpolynomial_fold_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwQPolynomialFold.plain_is_equal = plain_is_equal

    def from_pw_qpolynomial(type, pwqp):
        'from_pw_qpolynomial(type, pwqp)\n\n:param type: :class:`fold`\n:param pwqp: :class:`PwQPolynomial`\n:return: :class:`PwQPolynomialFold`'

        # no argument processing for type
        
        if not isinstance(pwqp, PwQPolynomial):
            raise IslTypeError("pwqp is not a PwQPolynomial")
        if _ctx_data != pwqp._ctx_data:
            raise Error("mismatched context in pwqp")
        _copy_pwqp = pwqp._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_from_pw_qpolynomial(type, _copy_pwqp._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_from_pw_qpolynomial failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.from_pw_qpolynomial = staticmethod(from_pw_qpolynomial)

    PwQPolynomialFold._from_pw_qpolynomial_is_static = True

    def alloc(type, set, fold):
        'alloc(type, set, fold)\n\n:param type: :class:`fold`\n:param set: :class:`Set`\n:param fold: :class:`QPolynomialFold`\n:return: :class:`PwQPolynomialFold`'

        # no argument processing for type
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        
        if not isinstance(fold, QPolynomialFold):
            raise IslTypeError("fold is not a QPolynomialFold")
        if _ctx_data != fold._ctx_data:
            raise Error("mismatched context in fold")
        _copy_fold = fold._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_alloc(type, _copy_set._release(), _copy_fold._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.alloc = staticmethod(alloc)

    PwQPolynomialFold._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.copy = copy

    def is_zero(self):
        'is_zero(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: bool'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_is_zero(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_qpolynomial_fold_is_zero\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwQPolynomialFold.is_zero = is_zero

    def get_domain_space(self):
        'get_domain_space(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: :class:`Space`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_get_domain_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_get_domain_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.get_domain_space = get_domain_space

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: :class:`Space`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.get_space = get_space

    def reset_space(self, dim):
        'reset_space(self, dim)\n\n:param self: :class:`PwQPolynomialFold`\n:param dim: :class:`Space`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        if _ctx_data != dim._ctx_data:
            raise Error("mismatched context in dim")
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_reset_space(_copy_self._release(), _copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_reset_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.reset_space = reset_space

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`PwQPolynomialFold`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwQPolynomialFold.dim = dim

    def involves_param_id(self, id):
        'involves_param_id(self, id)\n\n:param self: :class:`PwQPolynomialFold`\n:param id: :class:`Id`\n:return: bool'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_involves_param_id(self.data, id.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_qpolynomial_fold_involves_param_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwQPolynomialFold.involves_param_id = involves_param_id

    def has_equal_space(self, pwf2):
        'has_equal_space(self, pwf2)\n\n:param self: :class:`PwQPolynomialFold`\n:param pwf2: :class:`PwQPolynomialFold`\n:return: bool'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        
        if not isinstance(pwf2, PwQPolynomialFold):
            raise IslTypeError("pwf2 is not a PwQPolynomialFold")
        if _ctx_data != pwf2._ctx_data:
            raise Error("mismatched context in pwf2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_has_equal_space(self.data, pwf2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_qpolynomial_fold_has_equal_space\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwQPolynomialFold.has_equal_space = has_equal_space

    def size(self):
        'size(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: size_t'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_size(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwQPolynomialFold.__len__ = size

    def zero(dim, type):
        'zero(dim, type)\n\n:param dim: :class:`Space`\n:param type: :class:`fold`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_zero(_copy_dim._release(), type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_zero failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.zero = staticmethod(zero)

    PwQPolynomialFold._zero_is_static = True

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`PwQPolynomialFold`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.set_dim_name = set_dim_name

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`PwQPolynomialFold`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwQPolynomialFold.find_dim_by_name = find_dim_by_name

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.reset_user = reset_user

    def domain(self):
        'domain(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: :class:`Set`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.domain = domain

    def intersect_domain(self, set):
        'intersect_domain(self, set)\n\n:param self: :class:`PwQPolynomialFold`\n:param set: :class:`Set`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_intersect_domain(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.intersect_domain = intersect_domain

    def intersect_params(self, set):
        'intersect_params(self, set)\n\n:param self: :class:`PwQPolynomialFold`\n:param set: :class:`Set`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_intersect_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.intersect_params = intersect_params

    def subtract_domain(self, set):
        'subtract_domain(self, set)\n\n:param self: :class:`PwQPolynomialFold`\n:param set: :class:`Set`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_subtract_domain(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_subtract_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.subtract_domain = subtract_domain

    def add(self, pwf2):
        'add(self, pwf2)\n\n:param self: :class:`PwQPolynomialFold`\n:param pwf2: :class:`PwQPolynomialFold`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pwf2, PwQPolynomialFold):
            raise IslTypeError("pwf2 is not a PwQPolynomialFold")
        if _ctx_data != pwf2._ctx_data:
            raise Error("mismatched context in pwf2")
        _copy_pwf2 = pwf2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_add(_copy_self._release(), _copy_pwf2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.add = add

    def fold(self, pwf2):
        'fold(self, pwf2)\n\n:param self: :class:`PwQPolynomialFold`\n:param pwf2: :class:`PwQPolynomialFold`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pwf2, PwQPolynomialFold):
            raise IslTypeError("pwf2 is not a PwQPolynomialFold")
        if _ctx_data != pwf2._ctx_data:
            raise Error("mismatched context in pwf2")
        _copy_pwf2 = pwf2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_fold(_copy_self._release(), _copy_pwf2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_fold failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.fold = fold

    def add_disjoint(self, pwf2):
        'add_disjoint(self, pwf2)\n\n:param self: :class:`PwQPolynomialFold`\n:param pwf2: :class:`PwQPolynomialFold`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pwf2, PwQPolynomialFold):
            raise IslTypeError("pwf2 is not a PwQPolynomialFold")
        if _ctx_data != pwf2._ctx_data:
            raise Error("mismatched context in pwf2")
        _copy_pwf2 = pwf2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_add_disjoint(_copy_self._release(), _copy_pwf2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_add_disjoint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.add_disjoint = add_disjoint

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`PwQPolynomialFold`\n:param v: :class:`Val`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.scale_val = scale_val

    def scale_down_val(self, v):
        'scale_down_val(self, v)\n\n:param self: :class:`PwQPolynomialFold`\n:param v: :class:`Val`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_scale_down_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.scale_down_val = scale_down_val

    def project_domain_on_params(self):
        'project_domain_on_params(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_project_domain_on_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_project_domain_on_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.project_domain_on_params = project_domain_on_params

    def from_range(self):
        'from_range(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_from_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_from_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.from_range = from_range

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`PwQPolynomialFold`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.drop_dims = drop_dims

    def move_dims(self, dst_type, dst_pos, src_type, src_pos, n):
        'move_dims(self, dst_type, dst_pos, src_type, src_pos, n)\n\n:param self: :class:`PwQPolynomialFold`\n:param dst_type: :class:`dim_type`\n:param dst_pos: :class:`unsigned`\n:param src_type: :class:`dim_type`\n:param src_pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_type
        
        # no argument processing for dst_pos
        
        # no argument processing for src_type
        
        # no argument processing for src_pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_move_dims(_copy_self._release(), dst_type, dst_pos, src_type, src_pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_move_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.move_dims = move_dims

    def drop_unused_params(self):
        'drop_unused_params(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_drop_unused_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_drop_unused_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.drop_unused_params = drop_unused_params

    def eval(self, pnt):
        'eval(self, pnt)\n\n:param self: :class:`PwQPolynomialFold`\n:param pnt: :class:`Point`\n:return: :class:`Val`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pnt, Point):
            raise IslTypeError("pnt is not a Point")
        if _ctx_data != pnt._ctx_data:
            raise Error("mismatched context in pnt")
        _copy_pnt = pnt._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_eval(_copy_self._release(), _copy_pnt._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_eval failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.eval = eval

    def n_piece(self):
        'n_piece(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: isl_size'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_n_piece(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwQPolynomialFold.n_piece = n_piece

    def foreach_piece(self, fn):
        'foreach_piece(self, fn)\n\n:param self: :class:`PwQPolynomialFold`\n:param fn: callback(set, fold) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(set, fold, user):
            try:
                _py_set = Set(_data=set)
                _py_fold = QPolynomialFold(_data=fold)
                _result = fn(_py_set, _py_fold)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_set *set,  isl_qpolynomial_fold *fold,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_foreach_piece(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_pw_qpolynomial_fold_foreach_piece\" failed: %s" % _get_last_error_str(_ctx_data))
        

    PwQPolynomialFold.foreach_piece = foreach_piece

    def foreach_lifted_piece(self, fn):
        'foreach_lifted_piece(self, fn)\n\n:param self: :class:`PwQPolynomialFold`\n:param fn: callback(set, fold) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(set, fold, user):
            try:
                _py_set = Set(_data=set)
                _py_fold = QPolynomialFold(_data=fold)
                _result = fn(_py_set, _py_fold)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_set *set,  isl_qpolynomial_fold *fold,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_foreach_lifted_piece(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_pw_qpolynomial_fold_foreach_lifted_piece\" failed: %s" % _get_last_error_str(_ctx_data))
        

    PwQPolynomialFold.foreach_lifted_piece = foreach_lifted_piece

    def dump(self):
        'dump(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: (nothing)'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_dump(self.data)
        finally:
            pass
        

    PwQPolynomialFold.dump = dump

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.coalesce = coalesce

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`PwQPolynomialFold`\n:param context: :class:`Set`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.gist = gist

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`PwQPolynomialFold`\n:param context: :class:`Set`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.gist_params = gist_params

    def max(self):
        'max(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: :class:`Val`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_max(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_max failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.max = max

    def min(self):
        'min(self)\n\n:param self: :class:`PwQPolynomialFold`\n:return: :class:`Val`'

        if not isinstance(self, PwQPolynomialFold):
            raise IslTypeError("self is not a PwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fold_min(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fold_min failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomialFold.min = min

    # }}}

    # {{{ union_pw_qpolynomial_fold

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:return: :class:`Context`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.get_ctx = get_ctx

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionPwQPolynomialFold.dim = dim

    def involves_nan(self):
        'involves_nan(self)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:return: bool'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_involves_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_pw_qpolynomial_fold_involves_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionPwQPolynomialFold.involves_nan = involves_nan

    def plain_is_equal(self, upwf2):
        'plain_is_equal(self, upwf2)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param upwf2: :class:`UnionPwQPolynomialFold`\n:return: bool'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        
        if not isinstance(upwf2, UnionPwQPolynomialFold):
            raise IslTypeError("upwf2 is not a UnionPwQPolynomialFold")
        if _ctx_data != upwf2._ctx_data:
            raise Error("mismatched context in upwf2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_plain_is_equal(self.data, upwf2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_pw_qpolynomial_fold_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionPwQPolynomialFold.plain_is_equal = plain_is_equal

    def from_pw_qpolynomial_fold(pwf):
        'from_pw_qpolynomial_fold(pwf)\n\n:param pwf: :class:`PwQPolynomialFold`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(pwf, PwQPolynomialFold):
            raise IslTypeError("pwf is not a PwQPolynomialFold")
        _ctx_data = pwf._ctx_data
        _copy_pwf = pwf._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_from_pw_qpolynomial_fold(_copy_pwf._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_from_pw_qpolynomial_fold failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.from_pw_qpolynomial_fold = staticmethod(from_pw_qpolynomial_fold)

    UnionPwQPolynomialFold._from_pw_qpolynomial_fold_is_static = True

    def zero(dim, type):
        'zero(dim, type)\n\n:param dim: :class:`Space`\n:param type: :class:`fold`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_zero(_copy_dim._release(), type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_zero failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.zero = staticmethod(zero)

    UnionPwQPolynomialFold._zero_is_static = True

    def fold_pw_qpolynomial_fold(self, pwqp):
        'fold_pw_qpolynomial_fold(self, pwqp)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param pwqp: :class:`PwQPolynomialFold`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pwqp, PwQPolynomialFold):
            raise IslTypeError("pwqp is not a PwQPolynomialFold")
        if _ctx_data != pwqp._ctx_data:
            raise Error("mismatched context in pwqp")
        _copy_pwqp = pwqp._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_fold_pw_qpolynomial_fold(_copy_self._release(), _copy_pwqp._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_fold_pw_qpolynomial_fold failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.fold_pw_qpolynomial_fold = fold_pw_qpolynomial_fold

    def copy(self):
        'copy(self)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.copy = copy

    def fold(self, upwf2):
        'fold(self, upwf2)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param upwf2: :class:`UnionPwQPolynomialFold`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upwf2, UnionPwQPolynomialFold):
            raise IslTypeError("upwf2 is not a UnionPwQPolynomialFold")
        if _ctx_data != upwf2._ctx_data:
            raise Error("mismatched context in upwf2")
        _copy_upwf2 = upwf2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_fold(_copy_self._release(), _copy_upwf2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_fold failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.fold = fold

    def add_union_pw_qpolynomial(self, upwqp):
        'add_union_pw_qpolynomial(self, upwqp)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param upwqp: :class:`UnionPwQPolynomial`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upwqp, UnionPwQPolynomial):
            raise IslTypeError("upwqp is not a UnionPwQPolynomial")
        if _ctx_data != upwqp._ctx_data:
            raise Error("mismatched context in upwqp")
        _copy_upwqp = upwqp._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_add_union_pw_qpolynomial(_copy_self._release(), _copy_upwqp._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_add_union_pw_qpolynomial failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.add_union_pw_qpolynomial = add_union_pw_qpolynomial

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param v: :class:`Val`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.scale_val = scale_val

    def scale_down_val(self, v):
        'scale_down_val(self, v)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param v: :class:`Val`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_scale_down_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.scale_down_val = scale_down_val

    def domain(self):
        'domain(self)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:return: :class:`UnionSet`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.domain = domain

    def intersect_domain(self, uset):
        'intersect_domain(self, uset)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param uset: :class:`UnionSet`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_intersect_domain(_copy_self._release(), _copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.intersect_domain = intersect_domain

    def intersect_params(self, set):
        'intersect_params(self, set)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param set: :class:`Set`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_intersect_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.intersect_params = intersect_params

    def subtract_domain(self, uset):
        'subtract_domain(self, uset)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param uset: :class:`UnionSet`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_subtract_domain(_copy_self._release(), _copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_subtract_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.subtract_domain = subtract_domain

    def get_type(self):
        'get_type(self)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:return: isl_fold'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_get_type(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionPwQPolynomialFold.get_type = get_type

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:return: :class:`Space`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.get_space = get_space

    def get_pw_qpolynomial_fold_list(self):
        'get_pw_qpolynomial_fold_list(self)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:return: :class:`PwQPolynomialFoldList`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_get_pw_qpolynomial_fold_list(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFoldList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_get_pw_qpolynomial_fold_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.get_pw_qpolynomial_fold_list = get_pw_qpolynomial_fold_list

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.set_dim_name = set_dim_name

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionPwQPolynomialFold.find_dim_by_name = find_dim_by_name

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.drop_dims = drop_dims

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.reset_user = reset_user

    def eval(self, pnt):
        'eval(self, pnt)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param pnt: :class:`Point`\n:return: :class:`Val`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pnt, Point):
            raise IslTypeError("pnt is not a Point")
        if _ctx_data != pnt._ctx_data:
            raise Error("mismatched context in pnt")
        _copy_pnt = pnt._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_eval(_copy_self._release(), _copy_pnt._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_eval failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.eval = eval

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.coalesce = coalesce

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param context: :class:`UnionSet`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if isinstance(context, Set):
            context = UnionSet.from_set(context)
        if not isinstance(context, UnionSet):
            raise IslTypeError("context is not a UnionSet")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.gist = gist

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param context: :class:`Set`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.gist_params = gist_params

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param model: :class:`Space`\n:return: :class:`UnionPwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.align_params = align_params

    def n_pw_qpolynomial_fold(self):
        'n_pw_qpolynomial_fold(self)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:return: isl_size'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_n_pw_qpolynomial_fold(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionPwQPolynomialFold.n_pw_qpolynomial_fold = n_pw_qpolynomial_fold

    def foreach_pw_qpolynomial_fold(self, fn):
        'foreach_pw_qpolynomial_fold(self, fn)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param fn: callback(pwf) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(pwf, user):
            try:
                _py_pwf = PwQPolynomialFold(_data=pwf)
                _result = fn(_py_pwf)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_pw_qpolynomial_fold *pwf,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_foreach_pw_qpolynomial_fold(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_union_pw_qpolynomial_fold_foreach_pw_qpolynomial_fold\" failed: %s" % _get_last_error_str(_ctx_data))
        

    UnionPwQPolynomialFold.foreach_pw_qpolynomial_fold = foreach_pw_qpolynomial_fold

    def extract_pw_qpolynomial_fold(self, dim):
        'extract_pw_qpolynomial_fold(self, dim)\n\n:param self: :class:`UnionPwQPolynomialFold`\n:param dim: :class:`Space`\n:return: :class:`PwQPolynomialFold`'

        if not isinstance(self, UnionPwQPolynomialFold):
            raise IslTypeError("self is not a UnionPwQPolynomialFold")
        _ctx_data = self._ctx_data
        
        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        if _ctx_data != dim._ctx_data:
            raise Error("mismatched context in dim")
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_fold_extract_pw_qpolynomial_fold(self.data, _copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialFold(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_fold_extract_pw_qpolynomial_fold failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomialFold.extract_pw_qpolynomial_fold = extract_pw_qpolynomial_fold

    # }}}

    # {{{ union_pw_qpolynomial

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`UnionPwQPolynomial`\n:return: :class:`Context`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.get_ctx = get_ctx

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`UnionPwQPolynomial`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionPwQPolynomial.dim = dim

    def involves_nan(self):
        'involves_nan(self)\n\n:param self: :class:`UnionPwQPolynomial`\n:return: bool'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_involves_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_pw_qpolynomial_involves_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionPwQPolynomial.involves_nan = involves_nan

    def plain_is_equal(self, upwqp2):
        'plain_is_equal(self, upwqp2)\n\n:param self: :class:`UnionPwQPolynomial`\n:param upwqp2: :class:`UnionPwQPolynomial`\n:return: bool'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        
        if not isinstance(upwqp2, UnionPwQPolynomial):
            raise IslTypeError("upwqp2 is not a UnionPwQPolynomial")
        if _ctx_data != upwqp2._ctx_data:
            raise Error("mismatched context in upwqp2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_plain_is_equal(self.data, upwqp2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_union_pw_qpolynomial_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    UnionPwQPolynomial.plain_is_equal = plain_is_equal

    def from_pw_qpolynomial(pwqp):
        'from_pw_qpolynomial(pwqp)\n\n:param pwqp: :class:`PwQPolynomial`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(pwqp, PwQPolynomial):
            raise IslTypeError("pwqp is not a PwQPolynomial")
        _ctx_data = pwqp._ctx_data
        _copy_pwqp = pwqp._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_from_pw_qpolynomial(_copy_pwqp._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_from_pw_qpolynomial failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.from_pw_qpolynomial = staticmethod(from_pw_qpolynomial)

    UnionPwQPolynomial._from_pw_qpolynomial_is_static = True

    def zero(dim):
        'zero(dim)\n\n:param dim: :class:`Space`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_zero(_copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_zero failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.zero = staticmethod(zero)

    UnionPwQPolynomial._zero_is_static = True

    def add_pw_qpolynomial(self, pwqp):
        'add_pw_qpolynomial(self, pwqp)\n\n:param self: :class:`UnionPwQPolynomial`\n:param pwqp: :class:`PwQPolynomial`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pwqp, PwQPolynomial):
            raise IslTypeError("pwqp is not a PwQPolynomial")
        if _ctx_data != pwqp._ctx_data:
            raise Error("mismatched context in pwqp")
        _copy_pwqp = pwqp._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_add_pw_qpolynomial(_copy_self._release(), _copy_pwqp._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_add_pw_qpolynomial failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.add_pw_qpolynomial = add_pw_qpolynomial

    def copy(self):
        'copy(self)\n\n:param self: :class:`UnionPwQPolynomial`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.copy = copy

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.read_from_str = staticmethod(read_from_str)

    UnionPwQPolynomial._read_from_str_is_static = True

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`UnionPwQPolynomial`\n:return: string'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    UnionPwQPolynomial.to_str = to_str

    def neg(self):
        'neg(self)\n\n:param self: :class:`UnionPwQPolynomial`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.neg = neg

    def add(self, upwqp2):
        'add(self, upwqp2)\n\n:param self: :class:`UnionPwQPolynomial`\n:param upwqp2: :class:`UnionPwQPolynomial`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upwqp2, UnionPwQPolynomial):
            raise IslTypeError("upwqp2 is not a UnionPwQPolynomial")
        if _ctx_data != upwqp2._ctx_data:
            raise Error("mismatched context in upwqp2")
        _copy_upwqp2 = upwqp2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_add(_copy_self._release(), _copy_upwqp2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.add = add

    def sub(self, upwqp2):
        'sub(self, upwqp2)\n\n:param self: :class:`UnionPwQPolynomial`\n:param upwqp2: :class:`UnionPwQPolynomial`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upwqp2, UnionPwQPolynomial):
            raise IslTypeError("upwqp2 is not a UnionPwQPolynomial")
        if _ctx_data != upwqp2._ctx_data:
            raise Error("mismatched context in upwqp2")
        _copy_upwqp2 = upwqp2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_sub(_copy_self._release(), _copy_upwqp2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.sub = sub

    def mul(self, upwqp2):
        'mul(self, upwqp2)\n\n:param self: :class:`UnionPwQPolynomial`\n:param upwqp2: :class:`UnionPwQPolynomial`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upwqp2, UnionPwQPolynomial):
            raise IslTypeError("upwqp2 is not a UnionPwQPolynomial")
        if _ctx_data != upwqp2._ctx_data:
            raise Error("mismatched context in upwqp2")
        _copy_upwqp2 = upwqp2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_mul(_copy_self._release(), _copy_upwqp2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_mul failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.mul = mul

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`UnionPwQPolynomial`\n:param v: :class:`Val`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.scale_val = scale_val

    def scale_down_val(self, v):
        'scale_down_val(self, v)\n\n:param self: :class:`UnionPwQPolynomial`\n:param v: :class:`Val`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_scale_down_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.scale_down_val = scale_down_val

    def domain(self):
        'domain(self)\n\n:param self: :class:`UnionPwQPolynomial`\n:return: :class:`UnionSet`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.domain = domain

    def intersect_domain(self, uset):
        'intersect_domain(self, uset)\n\n:param self: :class:`UnionPwQPolynomial`\n:param uset: :class:`UnionSet`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_intersect_domain(_copy_self._release(), _copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.intersect_domain = intersect_domain

    def intersect_params(self, set):
        'intersect_params(self, set)\n\n:param self: :class:`UnionPwQPolynomial`\n:param set: :class:`Set`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_intersect_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.intersect_params = intersect_params

    def subtract_domain(self, uset):
        'subtract_domain(self, uset)\n\n:param self: :class:`UnionPwQPolynomial`\n:param uset: :class:`UnionSet`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(uset, BasicSet):
            uset = Set.from_basic_set(uset)
        if isinstance(uset, Set):
            uset = UnionSet.from_set(uset)
        if not isinstance(uset, UnionSet):
            raise IslTypeError("uset is not a UnionSet")
        if _ctx_data != uset._ctx_data:
            raise Error("mismatched context in uset")
        _copy_uset = uset._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_subtract_domain(_copy_self._release(), _copy_uset._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_subtract_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.subtract_domain = subtract_domain

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`UnionPwQPolynomial`\n:return: :class:`Space`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.get_space = get_space

    def get_pw_qpolynomial_list(self):
        'get_pw_qpolynomial_list(self)\n\n:param self: :class:`UnionPwQPolynomial`\n:return: :class:`PwQPolynomialList`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_get_pw_qpolynomial_list(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomialList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_get_pw_qpolynomial_list failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.get_pw_qpolynomial_list = get_pw_qpolynomial_list

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`UnionPwQPolynomial`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.set_dim_name = set_dim_name

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`UnionPwQPolynomial`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionPwQPolynomial.find_dim_by_name = find_dim_by_name

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`UnionPwQPolynomial`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.drop_dims = drop_dims

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`UnionPwQPolynomial`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.reset_user = reset_user

    def eval(self, pnt):
        'eval(self, pnt)\n\n:param self: :class:`UnionPwQPolynomial`\n:param pnt: :class:`Point`\n:return: :class:`Val`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pnt, Point):
            raise IslTypeError("pnt is not a Point")
        if _ctx_data != pnt._ctx_data:
            raise Error("mismatched context in pnt")
        _copy_pnt = pnt._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_eval(_copy_self._release(), _copy_pnt._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_eval failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.eval = eval

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`UnionPwQPolynomial`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.coalesce = coalesce

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`UnionPwQPolynomial`\n:param context: :class:`UnionSet`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if isinstance(context, Set):
            context = UnionSet.from_set(context)
        if not isinstance(context, UnionSet):
            raise IslTypeError("context is not a UnionSet")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.gist = gist

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`UnionPwQPolynomial`\n:param context: :class:`Set`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.gist_params = gist_params

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`UnionPwQPolynomial`\n:param model: :class:`Space`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.align_params = align_params

    def n_pw_qpolynomial(self):
        'n_pw_qpolynomial(self)\n\n:param self: :class:`UnionPwQPolynomial`\n:return: isl_size'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_n_pw_qpolynomial(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    UnionPwQPolynomial.n_pw_qpolynomial = n_pw_qpolynomial

    def foreach_pw_qpolynomial(self, fn):
        'foreach_pw_qpolynomial(self, fn)\n\n:param self: :class:`UnionPwQPolynomial`\n:param fn: callback(pwqp) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(pwqp, user):
            try:
                _py_pwqp = PwQPolynomial(_data=pwqp)
                _result = fn(_py_pwqp)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_pw_qpolynomial *pwqp,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_foreach_pw_qpolynomial(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_union_pw_qpolynomial_foreach_pw_qpolynomial\" failed: %s" % _get_last_error_str(_ctx_data))
        

    UnionPwQPolynomial.foreach_pw_qpolynomial = foreach_pw_qpolynomial

    def extract_pw_qpolynomial(self, dim):
        'extract_pw_qpolynomial(self, dim)\n\n:param self: :class:`UnionPwQPolynomial`\n:param dim: :class:`Space`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        
        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        if _ctx_data != dim._ctx_data:
            raise Error("mismatched context in dim")
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_extract_pw_qpolynomial(self.data, _copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_extract_pw_qpolynomial failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.extract_pw_qpolynomial = extract_pw_qpolynomial

    def to_polynomial(self, sign):
        'to_polynomial(self, sign)\n\n:param self: :class:`UnionPwQPolynomial`\n:param sign: :class:`int`\n:return: :class:`UnionPwQPolynomial`'

        if not isinstance(self, UnionPwQPolynomial):
            raise IslTypeError("self is not a UnionPwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for sign
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_pw_qpolynomial_to_polynomial(_copy_self._release(), sign)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_pw_qpolynomial_to_polynomial failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionPwQPolynomial.to_polynomial = to_polynomial

    # }}}

    # {{{ qpolynomial

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`QPolynomial`\n:return: :class:`Context`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.get_ctx = get_ctx

    def get_domain_space(self):
        'get_domain_space(self)\n\n:param self: :class:`QPolynomial`\n:return: :class:`Space`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_get_domain_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_get_domain_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.get_domain_space = get_domain_space

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`QPolynomial`\n:return: :class:`Space`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.get_space = get_space

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`QPolynomial`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    QPolynomial.dim = dim

    def involves_dims(self, type, first, n):
        'involves_dims(self, type, first, n)\n\n:param self: :class:`QPolynomial`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: bool'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_involves_dims(self.data, type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_qpolynomial_involves_dims\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    QPolynomial.involves_dims = involves_dims

    def get_constant_val(self):
        'get_constant_val(self)\n\n:param self: :class:`QPolynomial`\n:return: :class:`Val`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_get_constant_val(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_get_constant_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.get_constant_val = get_constant_val

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`QPolynomial`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.set_dim_name = set_dim_name

    def zero_on_domain(domain):
        'zero_on_domain(domain)\n\n:param domain: :class:`Space`\n:return: :class:`QPolynomial`'

        if not isinstance(domain, Space):
            raise IslTypeError("domain is not a Space")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_zero_on_domain(_copy_domain._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_zero_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.zero_on_domain = staticmethod(zero_on_domain)

    QPolynomial._zero_on_domain_is_static = True

    def one_on_domain(domain):
        'one_on_domain(domain)\n\n:param domain: :class:`Space`\n:return: :class:`QPolynomial`'

        if not isinstance(domain, Space):
            raise IslTypeError("domain is not a Space")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_one_on_domain(_copy_domain._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_one_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.one_on_domain = staticmethod(one_on_domain)

    QPolynomial._one_on_domain_is_static = True

    def infty_on_domain(domain):
        'infty_on_domain(domain)\n\n:param domain: :class:`Space`\n:return: :class:`QPolynomial`'

        if not isinstance(domain, Space):
            raise IslTypeError("domain is not a Space")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_infty_on_domain(_copy_domain._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_infty_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.infty_on_domain = staticmethod(infty_on_domain)

    QPolynomial._infty_on_domain_is_static = True

    def neginfty_on_domain(domain):
        'neginfty_on_domain(domain)\n\n:param domain: :class:`Space`\n:return: :class:`QPolynomial`'

        if not isinstance(domain, Space):
            raise IslTypeError("domain is not a Space")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_neginfty_on_domain(_copy_domain._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_neginfty_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.neginfty_on_domain = staticmethod(neginfty_on_domain)

    QPolynomial._neginfty_on_domain_is_static = True

    def nan_on_domain(domain):
        'nan_on_domain(domain)\n\n:param domain: :class:`Space`\n:return: :class:`QPolynomial`'

        if not isinstance(domain, Space):
            raise IslTypeError("domain is not a Space")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_nan_on_domain(_copy_domain._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_nan_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.nan_on_domain = staticmethod(nan_on_domain)

    QPolynomial._nan_on_domain_is_static = True

    def val_on_domain(space, val):
        'val_on_domain(space, val)\n\n:param space: :class:`Space`\n:param val: :class:`Val`\n:return: :class:`QPolynomial`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        
        if isinstance(val, Val):
            if _ctx_data != val._ctx_data:
                raise Error("mismatched context in val")
            _val_val = val._copy()
        elif isinstance(val, six.integer_types):
            _cdata_val = lib.isl_val_int_from_si(
                space._get_ctx_data(), val)
        
            if _cdata_val == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_val = Val(_data=_cdata_val)
        
        else:
            raise IslTypeError("val is a %s and cannot "
                "be cast to a Val" % type(val))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_val_on_domain(_copy_space._release(), _val_val._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_val_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.val_on_domain = staticmethod(val_on_domain)

    QPolynomial._val_on_domain_is_static = True

    def var_on_domain(domain, type, pos):
        'var_on_domain(domain, type, pos)\n\n:param domain: :class:`Space`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`QPolynomial`'

        if not isinstance(domain, Space):
            raise IslTypeError("domain is not a Space")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_var_on_domain(_copy_domain._release(), type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_var_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.var_on_domain = staticmethod(var_on_domain)

    QPolynomial._var_on_domain_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`QPolynomial`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.copy = copy

    def plain_is_equal(self, qp2):
        'plain_is_equal(self, qp2)\n\n:param self: :class:`QPolynomial`\n:param qp2: :class:`QPolynomial`\n:return: bool'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        
        if not isinstance(qp2, QPolynomial):
            raise IslTypeError("qp2 is not a QPolynomial")
        if _ctx_data != qp2._ctx_data:
            raise Error("mismatched context in qp2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_plain_is_equal(self.data, qp2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_qpolynomial_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    QPolynomial.plain_is_equal = plain_is_equal

    def is_zero(self):
        'is_zero(self)\n\n:param self: :class:`QPolynomial`\n:return: bool'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_is_zero(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_qpolynomial_is_zero\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    QPolynomial.is_zero = is_zero

    def is_nan(self):
        'is_nan(self)\n\n:param self: :class:`QPolynomial`\n:return: bool'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_is_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_qpolynomial_is_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    QPolynomial.is_nan = is_nan

    def is_infty(self):
        'is_infty(self)\n\n:param self: :class:`QPolynomial`\n:return: bool'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_is_infty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_qpolynomial_is_infty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    QPolynomial.is_infty = is_infty

    def is_neginfty(self):
        'is_neginfty(self)\n\n:param self: :class:`QPolynomial`\n:return: bool'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_is_neginfty(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_qpolynomial_is_neginfty\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    QPolynomial.is_neginfty = is_neginfty

    def sgn(self):
        'sgn(self)\n\n:param self: :class:`QPolynomial`\n:return: int'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_sgn(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    QPolynomial.sgn = sgn

    def neg(self):
        'neg(self)\n\n:param self: :class:`QPolynomial`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.neg = neg

    def add(self, qp2):
        'add(self, qp2)\n\n:param self: :class:`QPolynomial`\n:param qp2: :class:`QPolynomial`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(qp2, QPolynomial):
            raise IslTypeError("qp2 is not a QPolynomial")
        if _ctx_data != qp2._ctx_data:
            raise Error("mismatched context in qp2")
        _copy_qp2 = qp2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_add(_copy_self._release(), _copy_qp2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.add = add

    def sub(self, qp2):
        'sub(self, qp2)\n\n:param self: :class:`QPolynomial`\n:param qp2: :class:`QPolynomial`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(qp2, QPolynomial):
            raise IslTypeError("qp2 is not a QPolynomial")
        if _ctx_data != qp2._ctx_data:
            raise Error("mismatched context in qp2")
        _copy_qp2 = qp2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_sub(_copy_self._release(), _copy_qp2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.sub = sub

    def mul(self, qp2):
        'mul(self, qp2)\n\n:param self: :class:`QPolynomial`\n:param qp2: :class:`QPolynomial`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(qp2, QPolynomial):
            raise IslTypeError("qp2 is not a QPolynomial")
        if _ctx_data != qp2._ctx_data:
            raise Error("mismatched context in qp2")
        _copy_qp2 = qp2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_mul(_copy_self._release(), _copy_qp2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_mul failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.mul = mul

    def pow(self, power):
        'pow(self, power)\n\n:param self: :class:`QPolynomial`\n:param power: :class:`unsigned`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for power
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_pow(_copy_self._release(), power)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_pow failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.pow = pow

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`QPolynomial`\n:param v: :class:`Val`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.scale_val = scale_val

    def scale_down_val(self, v):
        'scale_down_val(self, v)\n\n:param self: :class:`QPolynomial`\n:param v: :class:`Val`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_scale_down_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.scale_down_val = scale_down_val

    def insert_dims(self, type, first, n):
        'insert_dims(self, type, first, n)\n\n:param self: :class:`QPolynomial`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_insert_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_insert_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.insert_dims = insert_dims

    def add_dims(self, type, n):
        'add_dims(self, type, n)\n\n:param self: :class:`QPolynomial`\n:param type: :class:`dim_type`\n:param n: :class:`unsigned`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_add_dims(_copy_self._release(), type, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_add_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.add_dims = add_dims

    def move_dims(self, dst_type, dst_pos, src_type, src_pos, n):
        'move_dims(self, dst_type, dst_pos, src_type, src_pos, n)\n\n:param self: :class:`QPolynomial`\n:param dst_type: :class:`dim_type`\n:param dst_pos: :class:`unsigned`\n:param src_type: :class:`dim_type`\n:param src_pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_type
        
        # no argument processing for dst_pos
        
        # no argument processing for src_type
        
        # no argument processing for src_pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_move_dims(_copy_self._release(), dst_type, dst_pos, src_type, src_pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_move_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.move_dims = move_dims

    def project_domain_on_params(self):
        'project_domain_on_params(self)\n\n:param self: :class:`QPolynomial`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_project_domain_on_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_project_domain_on_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.project_domain_on_params = project_domain_on_params

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`QPolynomial`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.drop_dims = drop_dims

    def as_polynomial_on_domain(self, bset, fn):
        'as_polynomial_on_domain(self, bset, fn)\n\n:param self: :class:`QPolynomial`\n:param bset: :class:`BasicSet`\n:param fn: callback(bset, poly) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        
        if not isinstance(bset, BasicSet):
            raise IslTypeError("bset is not a BasicSet")
        if _ctx_data != bset._ctx_data:
            raise Error("mismatched context in bset")
        
        def _cb_wrapper_fn(bset, poly, user):
            try:
                _py_bset = BasicSet(_data=bset)
                _py_poly = QPolynomial(_data=poly)
                _result = fn(_py_bset, _py_poly)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_basic_set *bset,  isl_qpolynomial *poly,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_as_polynomial_on_domain(self.data, bset.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_qpolynomial_as_polynomial_on_domain\" failed: %s" % _get_last_error_str(_ctx_data))
        

    QPolynomial.as_polynomial_on_domain = as_polynomial_on_domain

    def homogenize(self):
        'homogenize(self)\n\n:param self: :class:`QPolynomial`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_homogenize(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_homogenize failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.homogenize = homogenize

    def align_params(self, model):
        'align_params(self, model)\n\n:param self: :class:`QPolynomial`\n:param model: :class:`Space`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(model, Space):
            raise IslTypeError("model is not a Space")
        if _ctx_data != model._ctx_data:
            raise Error("mismatched context in model")
        _copy_model = model._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_align_params(_copy_self._release(), _copy_model._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.align_params = align_params

    def foreach_term(self, fn):
        'foreach_term(self, fn)\n\n:param self: :class:`QPolynomial`\n:param fn: callback(term) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(term, user):
            try:
                _py_term = Term(_data=term)
                _result = fn(_py_term)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_term *term,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_foreach_term(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_qpolynomial_foreach_term\" failed: %s" % _get_last_error_str(_ctx_data))
        

    QPolynomial.foreach_term = foreach_term

    def eval(self, pnt):
        'eval(self, pnt)\n\n:param self: :class:`QPolynomial`\n:param pnt: :class:`Point`\n:return: :class:`Val`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pnt, Point):
            raise IslTypeError("pnt is not a Point")
        if _ctx_data != pnt._ctx_data:
            raise Error("mismatched context in pnt")
        _copy_pnt = pnt._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_eval(_copy_self._release(), _copy_pnt._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_eval failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.eval = eval

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`QPolynomial`\n:param context: :class:`Set`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.gist_params = gist_params

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`QPolynomial`\n:param context: :class:`Set`\n:return: :class:`QPolynomial`'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.gist = gist

    def from_constraint(c, type, pos):
        'from_constraint(c, type, pos)\n\n:param c: :class:`Constraint`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: :class:`QPolynomial`'

        if not isinstance(c, Constraint):
            raise IslTypeError("c is not a Constraint")
        _ctx_data = c._ctx_data
        _copy_c = c._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_from_constraint(_copy_c._release(), type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_from_constraint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.from_constraint = staticmethod(from_constraint)

    QPolynomial._from_constraint_is_static = True

    def from_term(term):
        'from_term(term)\n\n:param term: :class:`Term`\n:return: :class:`QPolynomial`'

        if not isinstance(term, Term):
            raise IslTypeError("term is not a Term")
        _ctx_data = term._ctx_data
        _copy_term = term._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_from_term(_copy_term._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_from_term failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.from_term = staticmethod(from_term)

    QPolynomial._from_term_is_static = True

    def from_aff(aff):
        'from_aff(aff)\n\n:param aff: :class:`Aff`\n:return: :class:`QPolynomial`'

        if not isinstance(aff, Aff):
            raise IslTypeError("aff is not a Aff")
        _ctx_data = aff._ctx_data
        _copy_aff = aff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_from_aff(_copy_aff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else QPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_qpolynomial_from_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    QPolynomial.from_aff = staticmethod(from_aff)

    QPolynomial._from_aff_is_static = True

    def dump(self):
        'dump(self)\n\n:param self: :class:`QPolynomial`\n:return: (nothing)'

        if not isinstance(self, QPolynomial):
            raise IslTypeError("self is not a QPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_qpolynomial_dump(self.data)
        finally:
            pass
        

    QPolynomial.dump = dump

    # }}}

    # {{{ pw_qpolynomial

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`PwQPolynomial`\n:return: :class:`Context`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.get_ctx = get_ctx

    def involves_nan(self):
        'involves_nan(self)\n\n:param self: :class:`PwQPolynomial`\n:return: bool'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_involves_nan(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_qpolynomial_involves_nan\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwQPolynomial.involves_nan = involves_nan

    def plain_is_equal(self, pwqp2):
        'plain_is_equal(self, pwqp2)\n\n:param self: :class:`PwQPolynomial`\n:param pwqp2: :class:`PwQPolynomial`\n:return: bool'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        
        if not isinstance(pwqp2, PwQPolynomial):
            raise IslTypeError("pwqp2 is not a PwQPolynomial")
        if _ctx_data != pwqp2._ctx_data:
            raise Error("mismatched context in pwqp2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_plain_is_equal(self.data, pwqp2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_qpolynomial_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwQPolynomial.plain_is_equal = plain_is_equal

    def zero(dim):
        'zero(dim)\n\n:param dim: :class:`Space`\n:return: :class:`PwQPolynomial`'

        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        _ctx_data = dim._ctx_data
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_zero(_copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_zero failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.zero = staticmethod(zero)

    PwQPolynomial._zero_is_static = True

    def alloc(set, qp):
        'alloc(set, qp)\n\n:param set: :class:`Set`\n:param qp: :class:`QPolynomial`\n:return: :class:`PwQPolynomial`'

        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        _ctx_data = set._ctx_data
        _copy_set = set._copy()
        
        if not isinstance(qp, QPolynomial):
            raise IslTypeError("qp is not a QPolynomial")
        if _ctx_data != qp._ctx_data:
            raise Error("mismatched context in qp")
        _copy_qp = qp._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_alloc(_copy_set._release(), _copy_qp._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.alloc = staticmethod(alloc)

    PwQPolynomial._alloc_is_static = True

    def from_qpolynomial(qp):
        'from_qpolynomial(qp)\n\n:param qp: :class:`QPolynomial`\n:return: :class:`PwQPolynomial`'

        if not isinstance(qp, QPolynomial):
            raise IslTypeError("qp is not a QPolynomial")
        _ctx_data = qp._ctx_data
        _copy_qp = qp._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_from_qpolynomial(_copy_qp._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_from_qpolynomial failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.from_qpolynomial = staticmethod(from_qpolynomial)

    PwQPolynomial._from_qpolynomial_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`PwQPolynomial`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.copy = copy

    def is_zero(self):
        'is_zero(self)\n\n:param self: :class:`PwQPolynomial`\n:return: bool'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_is_zero(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_qpolynomial_is_zero\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwQPolynomial.is_zero = is_zero

    def get_domain_space(self):
        'get_domain_space(self)\n\n:param self: :class:`PwQPolynomial`\n:return: :class:`Space`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_get_domain_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_get_domain_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.get_domain_space = get_domain_space

    def get_space(self):
        'get_space(self)\n\n:param self: :class:`PwQPolynomial`\n:return: :class:`Space`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.get_space = get_space

    def reset_domain_space(self, dim):
        'reset_domain_space(self, dim)\n\n:param self: :class:`PwQPolynomial`\n:param dim: :class:`Space`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(dim, Space):
            raise IslTypeError("dim is not a Space")
        if _ctx_data != dim._ctx_data:
            raise Error("mismatched context in dim")
        _copy_dim = dim._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_reset_domain_space(_copy_self._release(), _copy_dim._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_reset_domain_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.reset_domain_space = reset_domain_space

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`PwQPolynomial`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwQPolynomial.dim = dim

    def involves_param_id(self, id):
        'involves_param_id(self, id)\n\n:param self: :class:`PwQPolynomial`\n:param id: :class:`Id`\n:return: bool'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        
        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        if _ctx_data != id._ctx_data:
            raise Error("mismatched context in id")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_involves_param_id(self.data, id.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_qpolynomial_involves_param_id\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwQPolynomial.involves_param_id = involves_param_id

    def involves_dims(self, type, first, n):
        'involves_dims(self, type, first, n)\n\n:param self: :class:`PwQPolynomial`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: bool'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_involves_dims(self.data, type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_qpolynomial_involves_dims\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwQPolynomial.involves_dims = involves_dims

    def has_equal_space(self, pwqp2):
        'has_equal_space(self, pwqp2)\n\n:param self: :class:`PwQPolynomial`\n:param pwqp2: :class:`PwQPolynomial`\n:return: bool'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        
        if not isinstance(pwqp2, PwQPolynomial):
            raise IslTypeError("pwqp2 is not a PwQPolynomial")
        if _ctx_data != pwqp2._ctx_data:
            raise Error("mismatched context in pwqp2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_has_equal_space(self.data, pwqp2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_pw_qpolynomial_has_equal_space\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    PwQPolynomial.has_equal_space = has_equal_space

    def set_dim_name(self, type, pos, s):
        'set_dim_name(self, type, pos, s)\n\n:param self: :class:`PwQPolynomial`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:param s: string\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for pos
        
        _cstr_s = ffi.new("char[]", s.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_set_dim_name(_copy_self._release(), type, pos, _cstr_s)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_set_dim_name failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.set_dim_name = set_dim_name

    def find_dim_by_name(self, type, name):
        'find_dim_by_name(self, type, name)\n\n:param self: :class:`PwQPolynomial`\n:param type: :class:`dim_type`\n:param name: string\n:return: int'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        _cstr_name = ffi.new("char[]", name.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_find_dim_by_name(self.data, type, _cstr_name)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwQPolynomial.find_dim_by_name = find_dim_by_name

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`PwQPolynomial`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.reset_user = reset_user

    def domain(self):
        'domain(self)\n\n:param self: :class:`PwQPolynomial`\n:return: :class:`Set`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_domain(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.domain = domain

    def intersect_domain(self, set):
        'intersect_domain(self, set)\n\n:param self: :class:`PwQPolynomial`\n:param set: :class:`Set`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_intersect_domain(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.intersect_domain = intersect_domain

    def intersect_params(self, set):
        'intersect_params(self, set)\n\n:param self: :class:`PwQPolynomial`\n:param set: :class:`Set`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_intersect_params(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_intersect_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.intersect_params = intersect_params

    def subtract_domain(self, set):
        'subtract_domain(self, set)\n\n:param self: :class:`PwQPolynomial`\n:param set: :class:`Set`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_subtract_domain(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_subtract_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.subtract_domain = subtract_domain

    def project_domain_on_params(self):
        'project_domain_on_params(self)\n\n:param self: :class:`PwQPolynomial`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_project_domain_on_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_project_domain_on_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.project_domain_on_params = project_domain_on_params

    def from_range(self):
        'from_range(self)\n\n:param self: :class:`PwQPolynomial`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_from_range(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_from_range failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.from_range = from_range

    def drop_dims(self, type, first, n):
        'drop_dims(self, type, first, n)\n\n:param self: :class:`PwQPolynomial`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_drop_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_drop_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.drop_dims = drop_dims

    def split_dims(self, type, first, n):
        'split_dims(self, type, first, n)\n\n:param self: :class:`PwQPolynomial`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_split_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_split_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.split_dims = split_dims

    def drop_unused_params(self):
        'drop_unused_params(self)\n\n:param self: :class:`PwQPolynomial`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_drop_unused_params(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_drop_unused_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.drop_unused_params = drop_unused_params

    def add(self, pwqp2):
        'add(self, pwqp2)\n\n:param self: :class:`PwQPolynomial`\n:param pwqp2: :class:`PwQPolynomial`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pwqp2, PwQPolynomial):
            raise IslTypeError("pwqp2 is not a PwQPolynomial")
        if _ctx_data != pwqp2._ctx_data:
            raise Error("mismatched context in pwqp2")
        _copy_pwqp2 = pwqp2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_add(_copy_self._release(), _copy_pwqp2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.add = add

    def sub(self, pwqp2):
        'sub(self, pwqp2)\n\n:param self: :class:`PwQPolynomial`\n:param pwqp2: :class:`PwQPolynomial`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pwqp2, PwQPolynomial):
            raise IslTypeError("pwqp2 is not a PwQPolynomial")
        if _ctx_data != pwqp2._ctx_data:
            raise Error("mismatched context in pwqp2")
        _copy_pwqp2 = pwqp2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_sub(_copy_self._release(), _copy_pwqp2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.sub = sub

    def add_disjoint(self, pwqp2):
        'add_disjoint(self, pwqp2)\n\n:param self: :class:`PwQPolynomial`\n:param pwqp2: :class:`PwQPolynomial`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pwqp2, PwQPolynomial):
            raise IslTypeError("pwqp2 is not a PwQPolynomial")
        if _ctx_data != pwqp2._ctx_data:
            raise Error("mismatched context in pwqp2")
        _copy_pwqp2 = pwqp2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_add_disjoint(_copy_self._release(), _copy_pwqp2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_add_disjoint failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.add_disjoint = add_disjoint

    def neg(self):
        'neg(self)\n\n:param self: :class:`PwQPolynomial`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.neg = neg

    def mul(self, pwqp2):
        'mul(self, pwqp2)\n\n:param self: :class:`PwQPolynomial`\n:param pwqp2: :class:`PwQPolynomial`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pwqp2, PwQPolynomial):
            raise IslTypeError("pwqp2 is not a PwQPolynomial")
        if _ctx_data != pwqp2._ctx_data:
            raise Error("mismatched context in pwqp2")
        _copy_pwqp2 = pwqp2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_mul(_copy_self._release(), _copy_pwqp2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_mul failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.mul = mul

    def scale_val(self, v):
        'scale_val(self, v)\n\n:param self: :class:`PwQPolynomial`\n:param v: :class:`Val`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_scale_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_scale_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.scale_val = scale_val

    def scale_down_val(self, v):
        'scale_down_val(self, v)\n\n:param self: :class:`PwQPolynomial`\n:param v: :class:`Val`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_scale_down_val(_copy_self._release(), _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_scale_down_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.scale_down_val = scale_down_val

    def pow(self, exponent):
        'pow(self, exponent)\n\n:param self: :class:`PwQPolynomial`\n:param exponent: :class:`unsigned`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for exponent
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_pow(_copy_self._release(), exponent)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_pow failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.pow = pow

    def insert_dims(self, type, first, n):
        'insert_dims(self, type, first, n)\n\n:param self: :class:`PwQPolynomial`\n:param type: :class:`dim_type`\n:param first: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for first
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_insert_dims(_copy_self._release(), type, first, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_insert_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.insert_dims = insert_dims

    def add_dims(self, type, n):
        'add_dims(self, type, n)\n\n:param self: :class:`PwQPolynomial`\n:param type: :class:`dim_type`\n:param n: :class:`unsigned`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_add_dims(_copy_self._release(), type, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_add_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.add_dims = add_dims

    def move_dims(self, dst_type, dst_pos, src_type, src_pos, n):
        'move_dims(self, dst_type, dst_pos, src_type, src_pos, n)\n\n:param self: :class:`PwQPolynomial`\n:param dst_type: :class:`dim_type`\n:param dst_pos: :class:`unsigned`\n:param src_type: :class:`dim_type`\n:param src_pos: :class:`unsigned`\n:param n: :class:`unsigned`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for dst_type
        
        # no argument processing for dst_pos
        
        # no argument processing for src_type
        
        # no argument processing for src_pos
        
        # no argument processing for n
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_move_dims(_copy_self._release(), dst_type, dst_pos, src_type, src_pos, n)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_move_dims failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.move_dims = move_dims

    def fix_val(self, type, n, v):
        'fix_val(self, type, n, v)\n\n:param self: :class:`PwQPolynomial`\n:param type: :class:`dim_type`\n:param n: :class:`unsigned`\n:param v: :class:`Val`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for type
        
        # no argument processing for n
        
        if isinstance(v, Val):
            if _ctx_data != v._ctx_data:
                raise Error("mismatched context in v")
            _val_v = v._copy()
        elif isinstance(v, six.integer_types):
            _cdata_v = lib.isl_val_int_from_si(
                self._get_ctx_data(), v)
        
            if _cdata_v == ffi.NULL:
                raise Error("isl_val_int_from_si failed")
        
            _val_v = Val(_data=_cdata_v)
        
        else:
            raise IslTypeError("v is a %s and cannot "
                "be cast to a Val" % type(v))
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_fix_val(_copy_self._release(), type, n, _val_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_fix_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.fix_val = fix_val

    def eval(self, pnt):
        'eval(self, pnt)\n\n:param self: :class:`PwQPolynomial`\n:param pnt: :class:`Point`\n:return: :class:`Val`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(pnt, Point):
            raise IslTypeError("pnt is not a Point")
        if _ctx_data != pnt._ctx_data:
            raise Error("mismatched context in pnt")
        _copy_pnt = pnt._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_eval(_copy_self._release(), _copy_pnt._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_eval failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.eval = eval

    def max(self):
        'max(self)\n\n:param self: :class:`PwQPolynomial`\n:return: :class:`Val`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_max(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_max failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.max = max

    def min(self):
        'min(self)\n\n:param self: :class:`PwQPolynomial`\n:return: :class:`Val`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_min(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_min failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.min = min

    def n_piece(self):
        'n_piece(self)\n\n:param self: :class:`PwQPolynomial`\n:return: isl_size'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_n_piece(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    PwQPolynomial.n_piece = n_piece

    def foreach_piece(self, fn):
        'foreach_piece(self, fn)\n\n:param self: :class:`PwQPolynomial`\n:param fn: callback(set, qp) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(set, qp, user):
            try:
                _py_set = Set(_data=set)
                _py_qp = QPolynomial(_data=qp)
                _result = fn(_py_set, _py_qp)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_set *set,  isl_qpolynomial *qp,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_foreach_piece(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_pw_qpolynomial_foreach_piece\" failed: %s" % _get_last_error_str(_ctx_data))
        

    PwQPolynomial.foreach_piece = foreach_piece

    def foreach_lifted_piece(self, fn):
        'foreach_lifted_piece(self, fn)\n\n:param self: :class:`PwQPolynomial`\n:param fn: callback(set, qp) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(set, qp, user):
            try:
                _py_set = Set(_data=set)
                _py_qp = QPolynomial(_data=qp)
                _result = fn(_py_set, _py_qp)
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_set *set,  isl_qpolynomial *qp,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_foreach_lifted_piece(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_pw_qpolynomial_foreach_lifted_piece\" failed: %s" % _get_last_error_str(_ctx_data))
        

    PwQPolynomial.foreach_lifted_piece = foreach_lifted_piece

    def from_pw_aff(pwaff):
        'from_pw_aff(pwaff)\n\n:param pwaff: :class:`PwAff`\n:return: :class:`PwQPolynomial`'

        if isinstance(pwaff, Aff):
            pwaff = PwAff.from_aff(pwaff)
        if not isinstance(pwaff, PwAff):
            raise IslTypeError("pwaff is not a PwAff")
        _ctx_data = pwaff._ctx_data
        _copy_pwaff = pwaff._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_from_pw_aff(_copy_pwaff._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_from_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.from_pw_aff = staticmethod(from_pw_aff)

    PwQPolynomial._from_pw_aff_is_static = True

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`PwQPolynomial`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.read_from_str = staticmethod(read_from_str)

    PwQPolynomial._read_from_str_is_static = True

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`PwQPolynomial`\n:return: string'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    PwQPolynomial.to_str = to_str

    def dump(self):
        'dump(self)\n\n:param self: :class:`PwQPolynomial`\n:return: (nothing)'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_dump(self.data)
        finally:
            pass
        

    PwQPolynomial.dump = dump

    def coalesce(self):
        'coalesce(self)\n\n:param self: :class:`PwQPolynomial`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_coalesce(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_coalesce failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.coalesce = coalesce

    def gist(self, context):
        'gist(self, context)\n\n:param self: :class:`PwQPolynomial`\n:param context: :class:`Set`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_gist(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_gist failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.gist = gist

    def gist_params(self, context):
        'gist_params(self, context)\n\n:param self: :class:`PwQPolynomial`\n:param context: :class:`Set`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_gist_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_gist_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.gist_params = gist_params

    def split_periods(self, max_periods):
        'split_periods(self, max_periods)\n\n:param self: :class:`PwQPolynomial`\n:param max_periods: :class:`int`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for max_periods
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_split_periods(_copy_self._release(), max_periods)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_split_periods failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.split_periods = split_periods

    def to_polynomial(self, sign):
        'to_polynomial(self, sign)\n\n:param self: :class:`PwQPolynomial`\n:param sign: :class:`int`\n:return: :class:`PwQPolynomial`'

        if not isinstance(self, PwQPolynomial):
            raise IslTypeError("self is not a PwQPolynomial")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for sign
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_pw_qpolynomial_to_polynomial(_copy_self._release(), sign)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else PwQPolynomial(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_pw_qpolynomial_to_polynomial failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    PwQPolynomial.to_polynomial = to_polynomial

    # }}}

    # {{{ term

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Term`\n:return: :class:`Context`'

        if not isinstance(self, Term):
            raise IslTypeError("self is not a Term")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_term_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_term_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Term.get_ctx = get_ctx

    def copy(self):
        'copy(self)\n\n:param self: :class:`Term`\n:return: :class:`Term`'

        if not isinstance(self, Term):
            raise IslTypeError("self is not a Term")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_term_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Term(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_term_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Term.copy = copy

    def dim(self, type):
        'dim(self, type)\n\n:param self: :class:`Term`\n:param type: :class:`dim_type`\n:return: isl_size'

        if not isinstance(self, Term):
            raise IslTypeError("self is not a Term")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_term_dim(self.data, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Term.dim = dim

    def get_coefficient_val(self):
        'get_coefficient_val(self)\n\n:param self: :class:`Term`\n:return: :class:`Val`'

        if not isinstance(self, Term):
            raise IslTypeError("self is not a Term")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_term_get_coefficient_val(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_term_get_coefficient_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Term.get_coefficient_val = get_coefficient_val

    def get_exp(self, type, pos):
        'get_exp(self, type, pos)\n\n:param self: :class:`Term`\n:param type: :class:`dim_type`\n:param pos: :class:`unsigned`\n:return: isl_size'

        if not isinstance(self, Term):
            raise IslTypeError("self is not a Term")
        _ctx_data = self._ctx_data
        
        # no argument processing for type
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_term_get_exp(self.data, type, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    Term.get_exp = get_exp

    def get_div(self, pos):
        'get_div(self, pos)\n\n:param self: :class:`Term`\n:param pos: :class:`unsigned`\n:return: :class:`Aff`'

        if not isinstance(self, Term):
            raise IslTypeError("self is not a Term")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_term_get_div(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Aff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_term_get_div failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Term.get_div = get_div

    # }}}

    # {{{ band

    # }}}

    # {{{ schedule_constraints

    def copy(self):
        'copy(self)\n\n:param self: :class:`ScheduleConstraints`\n:return: :class:`ScheduleConstraints`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleConstraints(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.copy = copy

    def on_domain(domain):
        'on_domain(domain)\n\n:param domain: :class:`UnionSet`\n:return: :class:`ScheduleConstraints`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if isinstance(domain, Set):
            domain = UnionSet.from_set(domain)
        if not isinstance(domain, UnionSet):
            raise IslTypeError("domain is not a UnionSet")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_on_domain(_copy_domain._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleConstraints(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_on_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.on_domain = staticmethod(on_domain)

    ScheduleConstraints._on_domain_is_static = True

    def set_context(self, context):
        'set_context(self, context)\n\n:param self: :class:`ScheduleConstraints`\n:param context: :class:`Set`\n:return: :class:`ScheduleConstraints`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_set_context(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleConstraints(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_set_context failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.set_context = set_context

    def set_validity(self, validity):
        'set_validity(self, validity)\n\n:param self: :class:`ScheduleConstraints`\n:param validity: :class:`UnionMap`\n:return: :class:`ScheduleConstraints`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(validity, BasicMap):
            validity = Map.from_basic_map(validity)
        if isinstance(validity, Map):
            validity = UnionMap.from_map(validity)
        if not isinstance(validity, UnionMap):
            raise IslTypeError("validity is not a UnionMap")
        if _ctx_data != validity._ctx_data:
            raise Error("mismatched context in validity")
        _copy_validity = validity._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_set_validity(_copy_self._release(), _copy_validity._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleConstraints(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_set_validity failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.set_validity = set_validity

    def set_coincidence(self, coincidence):
        'set_coincidence(self, coincidence)\n\n:param self: :class:`ScheduleConstraints`\n:param coincidence: :class:`UnionMap`\n:return: :class:`ScheduleConstraints`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(coincidence, BasicMap):
            coincidence = Map.from_basic_map(coincidence)
        if isinstance(coincidence, Map):
            coincidence = UnionMap.from_map(coincidence)
        if not isinstance(coincidence, UnionMap):
            raise IslTypeError("coincidence is not a UnionMap")
        if _ctx_data != coincidence._ctx_data:
            raise Error("mismatched context in coincidence")
        _copy_coincidence = coincidence._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_set_coincidence(_copy_self._release(), _copy_coincidence._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleConstraints(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_set_coincidence failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.set_coincidence = set_coincidence

    def set_proximity(self, proximity):
        'set_proximity(self, proximity)\n\n:param self: :class:`ScheduleConstraints`\n:param proximity: :class:`UnionMap`\n:return: :class:`ScheduleConstraints`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(proximity, BasicMap):
            proximity = Map.from_basic_map(proximity)
        if isinstance(proximity, Map):
            proximity = UnionMap.from_map(proximity)
        if not isinstance(proximity, UnionMap):
            raise IslTypeError("proximity is not a UnionMap")
        if _ctx_data != proximity._ctx_data:
            raise Error("mismatched context in proximity")
        _copy_proximity = proximity._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_set_proximity(_copy_self._release(), _copy_proximity._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleConstraints(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_set_proximity failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.set_proximity = set_proximity

    def set_conditional_validity(self, condition, validity):
        'set_conditional_validity(self, condition, validity)\n\n:param self: :class:`ScheduleConstraints`\n:param condition: :class:`UnionMap`\n:param validity: :class:`UnionMap`\n:return: :class:`ScheduleConstraints`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(condition, BasicMap):
            condition = Map.from_basic_map(condition)
        if isinstance(condition, Map):
            condition = UnionMap.from_map(condition)
        if not isinstance(condition, UnionMap):
            raise IslTypeError("condition is not a UnionMap")
        if _ctx_data != condition._ctx_data:
            raise Error("mismatched context in condition")
        _copy_condition = condition._copy()
        
        if isinstance(validity, BasicMap):
            validity = Map.from_basic_map(validity)
        if isinstance(validity, Map):
            validity = UnionMap.from_map(validity)
        if not isinstance(validity, UnionMap):
            raise IslTypeError("validity is not a UnionMap")
        if _ctx_data != validity._ctx_data:
            raise Error("mismatched context in validity")
        _copy_validity = validity._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_set_conditional_validity(_copy_self._release(), _copy_condition._release(), _copy_validity._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleConstraints(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_set_conditional_validity failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.set_conditional_validity = set_conditional_validity

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`ScheduleConstraints`\n:return: :class:`Context`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.get_ctx = get_ctx

    def get_domain(self):
        'get_domain(self)\n\n:param self: :class:`ScheduleConstraints`\n:return: :class:`UnionSet`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_get_domain(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_get_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.get_domain = get_domain

    def get_context(self):
        'get_context(self)\n\n:param self: :class:`ScheduleConstraints`\n:return: :class:`Set`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_get_context(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_get_context failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.get_context = get_context

    def get_validity(self):
        'get_validity(self)\n\n:param self: :class:`ScheduleConstraints`\n:return: :class:`UnionMap`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_get_validity(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_get_validity failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.get_validity = get_validity

    def get_coincidence(self):
        'get_coincidence(self)\n\n:param self: :class:`ScheduleConstraints`\n:return: :class:`UnionMap`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_get_coincidence(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_get_coincidence failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.get_coincidence = get_coincidence

    def get_proximity(self):
        'get_proximity(self)\n\n:param self: :class:`ScheduleConstraints`\n:return: :class:`UnionMap`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_get_proximity(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_get_proximity failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.get_proximity = get_proximity

    def get_conditional_validity(self):
        'get_conditional_validity(self)\n\n:param self: :class:`ScheduleConstraints`\n:return: :class:`UnionMap`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_get_conditional_validity(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_get_conditional_validity failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.get_conditional_validity = get_conditional_validity

    def get_conditional_validity_condition(self):
        'get_conditional_validity_condition(self)\n\n:param self: :class:`ScheduleConstraints`\n:return: :class:`UnionMap`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_get_conditional_validity_condition(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_get_conditional_validity_condition failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.get_conditional_validity_condition = get_conditional_validity_condition

    def apply(self, umap):
        'apply(self, umap)\n\n:param self: :class:`ScheduleConstraints`\n:param umap: :class:`UnionMap`\n:return: :class:`ScheduleConstraints`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(umap, BasicMap):
            umap = Map.from_basic_map(umap)
        if isinstance(umap, Map):
            umap = UnionMap.from_map(umap)
        if not isinstance(umap, UnionMap):
            raise IslTypeError("umap is not a UnionMap")
        if _ctx_data != umap._ctx_data:
            raise Error("mismatched context in umap")
        _copy_umap = umap._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_apply(_copy_self._release(), _copy_umap._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleConstraints(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_apply failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.apply = apply

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`ScheduleConstraints`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleConstraints(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.read_from_str = staticmethod(read_from_str)

    ScheduleConstraints._read_from_str_is_static = True

    def dump(self):
        'dump(self)\n\n:param self: :class:`ScheduleConstraints`\n:return: (nothing)'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_dump(self.data)
        finally:
            pass
        

    ScheduleConstraints.dump = dump

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`ScheduleConstraints`\n:return: string'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    ScheduleConstraints.to_str = to_str

    def compute_schedule(self):
        'compute_schedule(self)\n\n:param self: :class:`ScheduleConstraints`\n:return: :class:`Schedule`'

        if not isinstance(self, ScheduleConstraints):
            raise IslTypeError("self is not a ScheduleConstraints")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_constraints_compute_schedule(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_constraints_compute_schedule failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleConstraints.compute_schedule = compute_schedule

    # }}}

    # {{{ schedule_node

    def from_domain(domain):
        'from_domain(domain)\n\n:param domain: :class:`UnionSet`\n:return: :class:`ScheduleNode`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if isinstance(domain, Set):
            domain = UnionSet.from_set(domain)
        if not isinstance(domain, UnionSet):
            raise IslTypeError("domain is not a UnionSet")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_from_domain(_copy_domain._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_from_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.from_domain = staticmethod(from_domain)

    ScheduleNode._from_domain_is_static = True

    def from_extension(extension):
        'from_extension(extension)\n\n:param extension: :class:`UnionMap`\n:return: :class:`ScheduleNode`'

        if isinstance(extension, BasicMap):
            extension = Map.from_basic_map(extension)
        if isinstance(extension, Map):
            extension = UnionMap.from_map(extension)
        if not isinstance(extension, UnionMap):
            raise IslTypeError("extension is not a UnionMap")
        _ctx_data = extension._ctx_data
        _copy_extension = extension._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_from_extension(_copy_extension._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_from_extension failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.from_extension = staticmethod(from_extension)

    ScheduleNode._from_extension_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.copy = copy

    def is_equal(self, node2):
        'is_equal(self, node2)\n\n:param self: :class:`ScheduleNode`\n:param node2: :class:`ScheduleNode`\n:return: bool'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        
        if not isinstance(node2, ScheduleNode):
            raise IslTypeError("node2 is not a ScheduleNode")
        if _ctx_data != node2._ctx_data:
            raise Error("mismatched context in node2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_is_equal(self.data, node2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_schedule_node_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    ScheduleNode.is_equal = is_equal

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`Context`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.get_ctx = get_ctx

    def get_type(self):
        'get_type(self)\n\n:param self: :class:`ScheduleNode`\n:return: isl_schedule_node_type'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_type(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    ScheduleNode.get_type = get_type

    def get_parent_type(self):
        'get_parent_type(self)\n\n:param self: :class:`ScheduleNode`\n:return: isl_schedule_node_type'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_parent_type(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    ScheduleNode.get_parent_type = get_parent_type

    def get_schedule(self):
        'get_schedule(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`Schedule`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_schedule(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_get_schedule failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.get_schedule = get_schedule

    def foreach_descendant_top_down(self, fn):
        'foreach_descendant_top_down(self, fn)\n\n:param self: :class:`ScheduleNode`\n:param fn: callback(node) -> isl_bool\n:return: (nothing)'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(node, user):
            try:
                _py_node = ScheduleNode(_data=node)
                _result = fn(_py_node)
                _py_node._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_bool (*fn)( isl_schedule_node *node,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_foreach_descendant_top_down(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_schedule_node_foreach_descendant_top_down\" failed: %s" % _get_last_error_str(_ctx_data))
        

    ScheduleNode.foreach_descendant_top_down = foreach_descendant_top_down

    def every_descendant(self, test):
        'every_descendant(self, test)\n\n:param self: :class:`ScheduleNode`\n:param test: callback(node) -> isl_bool\n:return: bool'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_test(node, user):
            try:
                _py_node = ScheduleNode(_data=node)
                _result = test(_py_node)
                _py_node._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_test = ffi.callback(" isl_bool (*test)( isl_schedule_node *node,  void *user)")(_cb_wrapper_test)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_every_descendant(self.data, _cb_test, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_schedule_node_every_descendant\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    ScheduleNode.every_descendant = every_descendant

    def foreach_ancestor_top_down(self, fn):
        'foreach_ancestor_top_down(self, fn)\n\n:param self: :class:`ScheduleNode`\n:param fn: callback(node) -> isl_stat\n:return: (nothing)'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(node, user):
            try:
                _py_node = ScheduleNode(_data=node)
                _result = fn(_py_node)
                _py_node._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_schedule_node *node,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_foreach_ancestor_top_down(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_schedule_node_foreach_ancestor_top_down\" failed: %s" % _get_last_error_str(_ctx_data))
        

    ScheduleNode.foreach_ancestor_top_down = foreach_ancestor_top_down

    def map_descendant_bottom_up(self, fn):
        'map_descendant_bottom_up(self, fn)\n\n:param self: :class:`ScheduleNode`\n:param fn: callback(node) -> isl_schedule_node\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(node, user):
            try:
                _py_node = ScheduleNode(_data=node)
                _result = fn(_py_node)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, ScheduleNode):
                    raise IslTypeError("return value is not a ScheduleNode")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_schedule_node *(*fn)( isl_schedule_node *node,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_map_descendant_bottom_up(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_map_descendant_bottom_up failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.map_descendant_bottom_up = map_descendant_bottom_up

    def get_tree_depth(self):
        'get_tree_depth(self)\n\n:param self: :class:`ScheduleNode`\n:return: isl_size'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_tree_depth(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    ScheduleNode.get_tree_depth = get_tree_depth

    def has_parent(self):
        'has_parent(self)\n\n:param self: :class:`ScheduleNode`\n:return: bool'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_has_parent(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_schedule_node_has_parent\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    ScheduleNode.has_parent = has_parent

    def has_children(self):
        'has_children(self)\n\n:param self: :class:`ScheduleNode`\n:return: bool'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_has_children(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_schedule_node_has_children\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    ScheduleNode.has_children = has_children

    def has_previous_sibling(self):
        'has_previous_sibling(self)\n\n:param self: :class:`ScheduleNode`\n:return: bool'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_has_previous_sibling(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_schedule_node_has_previous_sibling\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    ScheduleNode.has_previous_sibling = has_previous_sibling

    def has_next_sibling(self):
        'has_next_sibling(self)\n\n:param self: :class:`ScheduleNode`\n:return: bool'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_has_next_sibling(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_schedule_node_has_next_sibling\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    ScheduleNode.has_next_sibling = has_next_sibling

    def n_children(self):
        'n_children(self)\n\n:param self: :class:`ScheduleNode`\n:return: isl_size'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_n_children(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    ScheduleNode.n_children = n_children

    def get_child_position(self):
        'get_child_position(self)\n\n:param self: :class:`ScheduleNode`\n:return: isl_size'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_child_position(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    ScheduleNode.get_child_position = get_child_position

    def get_ancestor_child_position(self, ancestor):
        'get_ancestor_child_position(self, ancestor)\n\n:param self: :class:`ScheduleNode`\n:param ancestor: :class:`ScheduleNode`\n:return: isl_size'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        
        if not isinstance(ancestor, ScheduleNode):
            raise IslTypeError("ancestor is not a ScheduleNode")
        if _ctx_data != ancestor._ctx_data:
            raise Error("mismatched context in ancestor")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_ancestor_child_position(self.data, ancestor.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    ScheduleNode.get_ancestor_child_position = get_ancestor_child_position

    def get_child(self, pos):
        'get_child(self, pos)\n\n:param self: :class:`ScheduleNode`\n:param pos: :class:`int`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_child(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_get_child failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.get_child = get_child

    def get_shared_ancestor(self, node2):
        'get_shared_ancestor(self, node2)\n\n:param self: :class:`ScheduleNode`\n:param node2: :class:`ScheduleNode`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        
        if not isinstance(node2, ScheduleNode):
            raise IslTypeError("node2 is not a ScheduleNode")
        if _ctx_data != node2._ctx_data:
            raise Error("mismatched context in node2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_shared_ancestor(self.data, node2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_get_shared_ancestor failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.get_shared_ancestor = get_shared_ancestor

    def root(self):
        'root(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_root(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_root failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.root = root

    def parent(self):
        'parent(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_parent(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_parent failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.parent = parent

    def ancestor(self, generation):
        'ancestor(self, generation)\n\n:param self: :class:`ScheduleNode`\n:param generation: :class:`int`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for generation
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_ancestor(_copy_self._release(), generation)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_ancestor failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.ancestor = ancestor

    def child(self, pos):
        'child(self, pos)\n\n:param self: :class:`ScheduleNode`\n:param pos: :class:`int`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_child(_copy_self._release(), pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_child failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.child = child

    def first_child(self):
        'first_child(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_first_child(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_first_child failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.first_child = first_child

    def previous_sibling(self):
        'previous_sibling(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_previous_sibling(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_previous_sibling failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.previous_sibling = previous_sibling

    def next_sibling(self):
        'next_sibling(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_next_sibling(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_next_sibling failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.next_sibling = next_sibling

    def is_subtree_anchored(self):
        'is_subtree_anchored(self)\n\n:param self: :class:`ScheduleNode`\n:return: bool'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_is_subtree_anchored(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_schedule_node_is_subtree_anchored\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    ScheduleNode.is_subtree_anchored = is_subtree_anchored

    def group(self, group_id):
        'group(self, group_id)\n\n:param self: :class:`ScheduleNode`\n:param group_id: :class:`Id`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(group_id, Id):
            raise IslTypeError("group_id is not a Id")
        if _ctx_data != group_id._ctx_data:
            raise Error("mismatched context in group_id")
        _copy_group_id = group_id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_group(_copy_self._release(), _copy_group_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_group failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.group = group

    def sequence_splice_child(self, pos):
        'sequence_splice_child(self, pos)\n\n:param self: :class:`ScheduleNode`\n:param pos: :class:`int`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_sequence_splice_child(_copy_self._release(), pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_sequence_splice_child failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.sequence_splice_child = sequence_splice_child

    def band_get_space(self):
        'band_get_space(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`Space`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_get_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_get_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_get_space = band_get_space

    def band_get_partial_schedule(self):
        'band_get_partial_schedule(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_get_partial_schedule(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_get_partial_schedule failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_get_partial_schedule = band_get_partial_schedule

    def band_get_partial_schedule_union_map(self):
        'band_get_partial_schedule_union_map(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionMap`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_get_partial_schedule_union_map(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_get_partial_schedule_union_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_get_partial_schedule_union_map = band_get_partial_schedule_union_map

    def band_member_get_ast_loop_type(self, pos):
        'band_member_get_ast_loop_type(self, pos)\n\n:param self: :class:`ScheduleNode`\n:param pos: :class:`int`\n:return: isl_ast_loop_type'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_member_get_ast_loop_type(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    ScheduleNode.band_member_get_ast_loop_type = band_member_get_ast_loop_type

    def band_member_set_ast_loop_type(self, pos, type):
        'band_member_set_ast_loop_type(self, pos, type)\n\n:param self: :class:`ScheduleNode`\n:param pos: :class:`int`\n:param type: :class:`ast_loop_type`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_member_set_ast_loop_type(_copy_self._release(), pos, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_member_set_ast_loop_type failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_member_set_ast_loop_type = band_member_set_ast_loop_type

    def band_member_get_isolate_ast_loop_type(self, pos):
        'band_member_get_isolate_ast_loop_type(self, pos)\n\n:param self: :class:`ScheduleNode`\n:param pos: :class:`int`\n:return: isl_ast_loop_type'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_member_get_isolate_ast_loop_type(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    ScheduleNode.band_member_get_isolate_ast_loop_type = band_member_get_isolate_ast_loop_type

    def band_member_set_isolate_ast_loop_type(self, pos, type):
        'band_member_set_isolate_ast_loop_type(self, pos, type)\n\n:param self: :class:`ScheduleNode`\n:param pos: :class:`int`\n:param type: :class:`ast_loop_type`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        # no argument processing for type
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_member_set_isolate_ast_loop_type(_copy_self._release(), pos, type)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_member_set_isolate_ast_loop_type failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_member_set_isolate_ast_loop_type = band_member_set_isolate_ast_loop_type

    def band_get_ast_build_options(self):
        'band_get_ast_build_options(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionSet`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_get_ast_build_options(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_get_ast_build_options failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_get_ast_build_options = band_get_ast_build_options

    def band_set_ast_build_options(self, options):
        'band_set_ast_build_options(self, options)\n\n:param self: :class:`ScheduleNode`\n:param options: :class:`UnionSet`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(options, BasicSet):
            options = Set.from_basic_set(options)
        if isinstance(options, Set):
            options = UnionSet.from_set(options)
        if not isinstance(options, UnionSet):
            raise IslTypeError("options is not a UnionSet")
        if _ctx_data != options._ctx_data:
            raise Error("mismatched context in options")
        _copy_options = options._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_set_ast_build_options(_copy_self._release(), _copy_options._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_set_ast_build_options failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_set_ast_build_options = band_set_ast_build_options

    def band_get_ast_isolate_option(self):
        'band_get_ast_isolate_option(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`Set`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_get_ast_isolate_option(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_get_ast_isolate_option failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_get_ast_isolate_option = band_get_ast_isolate_option

    def band_n_member(self):
        'band_n_member(self)\n\n:param self: :class:`ScheduleNode`\n:return: isl_size'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_n_member(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    ScheduleNode.band_n_member = band_n_member

    def band_member_get_coincident(self, pos):
        'band_member_get_coincident(self, pos)\n\n:param self: :class:`ScheduleNode`\n:param pos: :class:`int`\n:return: bool'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_member_get_coincident(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_schedule_node_band_member_get_coincident\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    ScheduleNode.band_member_get_coincident = band_member_get_coincident

    def band_member_set_coincident(self, pos, coincident):
        'band_member_set_coincident(self, pos, coincident)\n\n:param self: :class:`ScheduleNode`\n:param pos: :class:`int`\n:param coincident: :class:`int`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        # no argument processing for coincident
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_member_set_coincident(_copy_self._release(), pos, coincident)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_member_set_coincident failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_member_set_coincident = band_member_set_coincident

    def band_get_permutable(self):
        'band_get_permutable(self)\n\n:param self: :class:`ScheduleNode`\n:return: bool'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_get_permutable(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_schedule_node_band_get_permutable\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    ScheduleNode.band_get_permutable = band_get_permutable

    def band_set_permutable(self, permutable):
        'band_set_permutable(self, permutable)\n\n:param self: :class:`ScheduleNode`\n:param permutable: :class:`int`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for permutable
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_set_permutable(_copy_self._release(), permutable)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_set_permutable failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_set_permutable = band_set_permutable

    def band_scale(self, mv):
        'band_scale(self, mv)\n\n:param self: :class:`ScheduleNode`\n:param mv: :class:`MultiVal`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_scale(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_scale failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_scale = band_scale

    def band_scale_down(self, mv):
        'band_scale_down(self, mv)\n\n:param self: :class:`ScheduleNode`\n:param mv: :class:`MultiVal`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_scale_down(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_scale_down failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_scale_down = band_scale_down

    def band_mod(self, mv):
        'band_mod(self, mv)\n\n:param self: :class:`ScheduleNode`\n:param mv: :class:`MultiVal`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mv, MultiVal):
            raise IslTypeError("mv is not a MultiVal")
        if _ctx_data != mv._ctx_data:
            raise Error("mismatched context in mv")
        _copy_mv = mv._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_mod(_copy_self._release(), _copy_mv._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_mod failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_mod = band_mod

    def band_shift(self, shift):
        'band_shift(self, shift)\n\n:param self: :class:`ScheduleNode`\n:param shift: :class:`MultiUnionPwAff`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(shift, MultiUnionPwAff):
            raise IslTypeError("shift is not a MultiUnionPwAff")
        if _ctx_data != shift._ctx_data:
            raise Error("mismatched context in shift")
        _copy_shift = shift._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_shift(_copy_self._release(), _copy_shift._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_shift failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_shift = band_shift

    def band_tile(self, sizes):
        'band_tile(self, sizes)\n\n:param self: :class:`ScheduleNode`\n:param sizes: :class:`MultiVal`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(sizes, MultiVal):
            raise IslTypeError("sizes is not a MultiVal")
        if _ctx_data != sizes._ctx_data:
            raise Error("mismatched context in sizes")
        _copy_sizes = sizes._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_tile(_copy_self._release(), _copy_sizes._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_tile failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_tile = band_tile

    def band_sink(self):
        'band_sink(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_sink(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_sink failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_sink = band_sink

    def band_split(self, pos):
        'band_split(self, pos)\n\n:param self: :class:`ScheduleNode`\n:param pos: :class:`int`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_band_split(_copy_self._release(), pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_band_split failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.band_split = band_split

    def context_get_context(self):
        'context_get_context(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`Set`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_context_get_context(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_context_get_context failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.context_get_context = context_get_context

    def domain_get_domain(self):
        'domain_get_domain(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionSet`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_domain_get_domain(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_domain_get_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.domain_get_domain = domain_get_domain

    def expansion_get_expansion(self):
        'expansion_get_expansion(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionMap`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_expansion_get_expansion(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_expansion_get_expansion failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.expansion_get_expansion = expansion_get_expansion

    def expansion_get_contraction(self):
        'expansion_get_contraction(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_expansion_get_contraction(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_expansion_get_contraction failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.expansion_get_contraction = expansion_get_contraction

    def extension_get_extension(self):
        'extension_get_extension(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionMap`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_extension_get_extension(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_extension_get_extension failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.extension_get_extension = extension_get_extension

    def filter_get_filter(self):
        'filter_get_filter(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionSet`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_filter_get_filter(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_filter_get_filter failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.filter_get_filter = filter_get_filter

    def guard_get_guard(self):
        'guard_get_guard(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`Set`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_guard_get_guard(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Set(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_guard_get_guard failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.guard_get_guard = guard_get_guard

    def mark_get_id(self):
        'mark_get_id(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`Id`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_mark_get_id(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_mark_get_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.mark_get_id = mark_get_id

    def get_schedule_depth(self):
        'get_schedule_depth(self)\n\n:param self: :class:`ScheduleNode`\n:return: isl_size'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_schedule_depth(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    ScheduleNode.get_schedule_depth = get_schedule_depth

    def get_domain(self):
        'get_domain(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionSet`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_domain(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_get_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.get_domain = get_domain

    def get_universe_domain(self):
        'get_universe_domain(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionSet`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_universe_domain(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_get_universe_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.get_universe_domain = get_universe_domain

    def get_prefix_schedule_multi_union_pw_aff(self):
        'get_prefix_schedule_multi_union_pw_aff(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`MultiUnionPwAff`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_prefix_schedule_multi_union_pw_aff(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else MultiUnionPwAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_get_prefix_schedule_multi_union_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.get_prefix_schedule_multi_union_pw_aff = get_prefix_schedule_multi_union_pw_aff

    def get_prefix_schedule_union_pw_multi_aff(self):
        'get_prefix_schedule_union_pw_multi_aff(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_prefix_schedule_union_pw_multi_aff(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_get_prefix_schedule_union_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.get_prefix_schedule_union_pw_multi_aff = get_prefix_schedule_union_pw_multi_aff

    def get_prefix_schedule_union_map(self):
        'get_prefix_schedule_union_map(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionMap`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_prefix_schedule_union_map(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_get_prefix_schedule_union_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.get_prefix_schedule_union_map = get_prefix_schedule_union_map

    def get_prefix_schedule_relation(self):
        'get_prefix_schedule_relation(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionMap`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_prefix_schedule_relation(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_get_prefix_schedule_relation failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.get_prefix_schedule_relation = get_prefix_schedule_relation

    def get_subtree_schedule_union_map(self):
        'get_subtree_schedule_union_map(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionMap`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_subtree_schedule_union_map(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_get_subtree_schedule_union_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.get_subtree_schedule_union_map = get_subtree_schedule_union_map

    def get_subtree_expansion(self):
        'get_subtree_expansion(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionMap`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_subtree_expansion(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_get_subtree_expansion failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.get_subtree_expansion = get_subtree_expansion

    def get_subtree_contraction(self):
        'get_subtree_contraction(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`UnionPwMultiAff`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_get_subtree_contraction(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionPwMultiAff(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_get_subtree_contraction failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.get_subtree_contraction = get_subtree_contraction

    def insert_context(self, context):
        'insert_context(self, context)\n\n:param self: :class:`ScheduleNode`\n:param context: :class:`Set`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_insert_context(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_insert_context failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.insert_context = insert_context

    def insert_partial_schedule(self, schedule):
        'insert_partial_schedule(self, schedule)\n\n:param self: :class:`ScheduleNode`\n:param schedule: :class:`MultiUnionPwAff`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(schedule, MultiUnionPwAff):
            raise IslTypeError("schedule is not a MultiUnionPwAff")
        if _ctx_data != schedule._ctx_data:
            raise Error("mismatched context in schedule")
        _copy_schedule = schedule._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_insert_partial_schedule(_copy_self._release(), _copy_schedule._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_insert_partial_schedule failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.insert_partial_schedule = insert_partial_schedule

    def insert_filter(self, filter):
        'insert_filter(self, filter)\n\n:param self: :class:`ScheduleNode`\n:param filter: :class:`UnionSet`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(filter, BasicSet):
            filter = Set.from_basic_set(filter)
        if isinstance(filter, Set):
            filter = UnionSet.from_set(filter)
        if not isinstance(filter, UnionSet):
            raise IslTypeError("filter is not a UnionSet")
        if _ctx_data != filter._ctx_data:
            raise Error("mismatched context in filter")
        _copy_filter = filter._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_insert_filter(_copy_self._release(), _copy_filter._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_insert_filter failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.insert_filter = insert_filter

    def insert_guard(self, context):
        'insert_guard(self, context)\n\n:param self: :class:`ScheduleNode`\n:param context: :class:`Set`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_insert_guard(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_insert_guard failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.insert_guard = insert_guard

    def insert_mark(self, mark):
        'insert_mark(self, mark)\n\n:param self: :class:`ScheduleNode`\n:param mark: :class:`Id`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(mark, Id):
            raise IslTypeError("mark is not a Id")
        if _ctx_data != mark._ctx_data:
            raise Error("mismatched context in mark")
        _copy_mark = mark._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_insert_mark(_copy_self._release(), _copy_mark._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_insert_mark failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.insert_mark = insert_mark

    def insert_sequence(self, filters):
        'insert_sequence(self, filters)\n\n:param self: :class:`ScheduleNode`\n:param filters: :class:`UnionSetList`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(filters, UnionSetList):
            raise IslTypeError("filters is not a UnionSetList")
        if _ctx_data != filters._ctx_data:
            raise Error("mismatched context in filters")
        _copy_filters = filters._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_insert_sequence(_copy_self._release(), _copy_filters._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_insert_sequence failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.insert_sequence = insert_sequence

    def insert_set(self, filters):
        'insert_set(self, filters)\n\n:param self: :class:`ScheduleNode`\n:param filters: :class:`UnionSetList`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(filters, UnionSetList):
            raise IslTypeError("filters is not a UnionSetList")
        if _ctx_data != filters._ctx_data:
            raise Error("mismatched context in filters")
        _copy_filters = filters._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_insert_set(_copy_self._release(), _copy_filters._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_insert_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.insert_set = insert_set

    def cut(self):
        'cut(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_cut(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_cut failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.cut = cut

    def delete(self):
        'delete(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_delete(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_delete failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.delete = delete

    def order_before(self, filter):
        'order_before(self, filter)\n\n:param self: :class:`ScheduleNode`\n:param filter: :class:`UnionSet`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(filter, BasicSet):
            filter = Set.from_basic_set(filter)
        if isinstance(filter, Set):
            filter = UnionSet.from_set(filter)
        if not isinstance(filter, UnionSet):
            raise IslTypeError("filter is not a UnionSet")
        if _ctx_data != filter._ctx_data:
            raise Error("mismatched context in filter")
        _copy_filter = filter._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_order_before(_copy_self._release(), _copy_filter._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_order_before failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.order_before = order_before

    def order_after(self, filter):
        'order_after(self, filter)\n\n:param self: :class:`ScheduleNode`\n:param filter: :class:`UnionSet`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(filter, BasicSet):
            filter = Set.from_basic_set(filter)
        if isinstance(filter, Set):
            filter = UnionSet.from_set(filter)
        if not isinstance(filter, UnionSet):
            raise IslTypeError("filter is not a UnionSet")
        if _ctx_data != filter._ctx_data:
            raise Error("mismatched context in filter")
        _copy_filter = filter._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_order_after(_copy_self._release(), _copy_filter._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_order_after failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.order_after = order_after

    def graft_before(self, graft):
        'graft_before(self, graft)\n\n:param self: :class:`ScheduleNode`\n:param graft: :class:`ScheduleNode`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(graft, ScheduleNode):
            raise IslTypeError("graft is not a ScheduleNode")
        if _ctx_data != graft._ctx_data:
            raise Error("mismatched context in graft")
        _copy_graft = graft._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_graft_before(_copy_self._release(), _copy_graft._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_graft_before failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.graft_before = graft_before

    def graft_after(self, graft):
        'graft_after(self, graft)\n\n:param self: :class:`ScheduleNode`\n:param graft: :class:`ScheduleNode`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(graft, ScheduleNode):
            raise IslTypeError("graft is not a ScheduleNode")
        if _ctx_data != graft._ctx_data:
            raise Error("mismatched context in graft")
        _copy_graft = graft._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_graft_after(_copy_self._release(), _copy_graft._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_graft_after failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.graft_after = graft_after

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`ScheduleNode`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.reset_user = reset_user

    def align_params(self, space):
        'align_params(self, space)\n\n:param self: :class:`ScheduleNode`\n:param space: :class:`Space`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        if _ctx_data != space._ctx_data:
            raise Error("mismatched context in space")
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_align_params(_copy_self._release(), _copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_node_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    ScheduleNode.align_params = align_params

    def dump(self):
        'dump(self)\n\n:param self: :class:`ScheduleNode`\n:return: (nothing)'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_dump(self.data)
        finally:
            pass
        

    ScheduleNode.dump = dump

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`ScheduleNode`\n:return: string'

        if not isinstance(self, ScheduleNode):
            raise IslTypeError("self is not a ScheduleNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_node_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    ScheduleNode.to_str = to_str

    # }}}

    # {{{ schedule

    def empty(space):
        'empty(space)\n\n:param space: :class:`Space`\n:return: :class:`Schedule`'

        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        _ctx_data = space._ctx_data
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_empty(_copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_empty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.empty = staticmethod(empty)

    Schedule._empty_is_static = True

    def from_domain(domain):
        'from_domain(domain)\n\n:param domain: :class:`UnionSet`\n:return: :class:`Schedule`'

        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if isinstance(domain, Set):
            domain = UnionSet.from_set(domain)
        if not isinstance(domain, UnionSet):
            raise IslTypeError("domain is not a UnionSet")
        _ctx_data = domain._ctx_data
        _copy_domain = domain._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_from_domain(_copy_domain._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_from_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.from_domain = staticmethod(from_domain)

    Schedule._from_domain_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`Schedule`\n:return: :class:`Schedule`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.copy = copy

    def get_map(self):
        'get_map(self)\n\n:param self: :class:`Schedule`\n:return: :class:`UnionMap`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_get_map(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_get_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.get_map = get_map

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Schedule`\n:return: :class:`Context`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.get_ctx = get_ctx

    def plain_is_equal(self, schedule2):
        'plain_is_equal(self, schedule2)\n\n:param self: :class:`Schedule`\n:param schedule2: :class:`Schedule`\n:return: bool'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        
        if not isinstance(schedule2, Schedule):
            raise IslTypeError("schedule2 is not a Schedule")
        if _ctx_data != schedule2._ctx_data:
            raise Error("mismatched context in schedule2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_plain_is_equal(self.data, schedule2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_schedule_plain_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    Schedule.plain_is_equal = plain_is_equal

    def get_root(self):
        'get_root(self)\n\n:param self: :class:`Schedule`\n:return: :class:`ScheduleNode`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_get_root(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else ScheduleNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_get_root failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.get_root = get_root

    def get_domain(self):
        'get_domain(self)\n\n:param self: :class:`Schedule`\n:return: :class:`UnionSet`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_get_domain(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionSet(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_get_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.get_domain = get_domain

    def foreach_schedule_node_top_down(self, fn):
        'foreach_schedule_node_top_down(self, fn)\n\n:param self: :class:`Schedule`\n:param fn: callback(node) -> isl_bool\n:return: (nothing)'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(node, user):
            try:
                _py_node = ScheduleNode(_data=node)
                _result = fn(_py_node)
                _py_node._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_bool (*fn)( isl_schedule_node *node,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_foreach_schedule_node_top_down(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_schedule_foreach_schedule_node_top_down\" failed: %s" % _get_last_error_str(_ctx_data))
        

    Schedule.foreach_schedule_node_top_down = foreach_schedule_node_top_down

    def map_schedule_node_bottom_up(self, fn):
        'map_schedule_node_bottom_up(self, fn)\n\n:param self: :class:`Schedule`\n:param fn: callback(node) -> isl_schedule_node\n:return: :class:`Schedule`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(node, user):
            try:
                _py_node = ScheduleNode(_data=node)
                _result = fn(_py_node)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, ScheduleNode):
                    raise IslTypeError("return value is not a ScheduleNode")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_schedule_node *(*fn)( isl_schedule_node *node,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_map_schedule_node_bottom_up(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_map_schedule_node_bottom_up failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.map_schedule_node_bottom_up = map_schedule_node_bottom_up

    def insert_context(self, context):
        'insert_context(self, context)\n\n:param self: :class:`Schedule`\n:param context: :class:`Set`\n:return: :class:`Schedule`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_insert_context(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_insert_context failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.insert_context = insert_context

    def insert_partial_schedule(self, partial):
        'insert_partial_schedule(self, partial)\n\n:param self: :class:`Schedule`\n:param partial: :class:`MultiUnionPwAff`\n:return: :class:`Schedule`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(partial, MultiUnionPwAff):
            raise IslTypeError("partial is not a MultiUnionPwAff")
        if _ctx_data != partial._ctx_data:
            raise Error("mismatched context in partial")
        _copy_partial = partial._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_insert_partial_schedule(_copy_self._release(), _copy_partial._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_insert_partial_schedule failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.insert_partial_schedule = insert_partial_schedule

    def insert_guard(self, guard):
        'insert_guard(self, guard)\n\n:param self: :class:`Schedule`\n:param guard: :class:`Set`\n:return: :class:`Schedule`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(guard, BasicSet):
            guard = Set.from_basic_set(guard)
        if not isinstance(guard, Set):
            raise IslTypeError("guard is not a Set")
        if _ctx_data != guard._ctx_data:
            raise Error("mismatched context in guard")
        _copy_guard = guard._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_insert_guard(_copy_self._release(), _copy_guard._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_insert_guard failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.insert_guard = insert_guard

    def sequence(self, schedule2):
        'sequence(self, schedule2)\n\n:param self: :class:`Schedule`\n:param schedule2: :class:`Schedule`\n:return: :class:`Schedule`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(schedule2, Schedule):
            raise IslTypeError("schedule2 is not a Schedule")
        if _ctx_data != schedule2._ctx_data:
            raise Error("mismatched context in schedule2")
        _copy_schedule2 = schedule2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_sequence(_copy_self._release(), _copy_schedule2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_sequence failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.sequence = sequence

    def set(self, schedule2):
        'set(self, schedule2)\n\n:param self: :class:`Schedule`\n:param schedule2: :class:`Schedule`\n:return: :class:`Schedule`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(schedule2, Schedule):
            raise IslTypeError("schedule2 is not a Schedule")
        if _ctx_data != schedule2._ctx_data:
            raise Error("mismatched context in schedule2")
        _copy_schedule2 = schedule2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_set(_copy_self._release(), _copy_schedule2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.set = set

    def intersect_domain(self, domain):
        'intersect_domain(self, domain)\n\n:param self: :class:`Schedule`\n:param domain: :class:`UnionSet`\n:return: :class:`Schedule`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(domain, BasicSet):
            domain = Set.from_basic_set(domain)
        if isinstance(domain, Set):
            domain = UnionSet.from_set(domain)
        if not isinstance(domain, UnionSet):
            raise IslTypeError("domain is not a UnionSet")
        if _ctx_data != domain._ctx_data:
            raise Error("mismatched context in domain")
        _copy_domain = domain._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_intersect_domain(_copy_self._release(), _copy_domain._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_intersect_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.intersect_domain = intersect_domain

    def gist_domain_params(self, context):
        'gist_domain_params(self, context)\n\n:param self: :class:`Schedule`\n:param context: :class:`Set`\n:return: :class:`Schedule`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(context, BasicSet):
            context = Set.from_basic_set(context)
        if not isinstance(context, Set):
            raise IslTypeError("context is not a Set")
        if _ctx_data != context._ctx_data:
            raise Error("mismatched context in context")
        _copy_context = context._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_gist_domain_params(_copy_self._release(), _copy_context._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_gist_domain_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.gist_domain_params = gist_domain_params

    def reset_user(self):
        'reset_user(self)\n\n:param self: :class:`Schedule`\n:return: :class:`Schedule`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_reset_user(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_reset_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.reset_user = reset_user

    def align_params(self, space):
        'align_params(self, space)\n\n:param self: :class:`Schedule`\n:param space: :class:`Space`\n:return: :class:`Schedule`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(space, Space):
            raise IslTypeError("space is not a Space")
        if _ctx_data != space._ctx_data:
            raise Error("mismatched context in space")
        _copy_space = space._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_align_params(_copy_self._release(), _copy_space._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_align_params failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.align_params = align_params

    def pullback_union_pw_multi_aff(self, upma):
        'pullback_union_pw_multi_aff(self, upma)\n\n:param self: :class:`Schedule`\n:param upma: :class:`UnionPwMultiAff`\n:return: :class:`Schedule`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(upma, UnionPwMultiAff):
            raise IslTypeError("upma is not a UnionPwMultiAff")
        if _ctx_data != upma._ctx_data:
            raise Error("mismatched context in upma")
        _copy_upma = upma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_pullback_union_pw_multi_aff(_copy_self._release(), _copy_upma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_pullback_union_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.pullback_union_pw_multi_aff = pullback_union_pw_multi_aff

    def expand(self, contraction, expansion):
        'expand(self, contraction, expansion)\n\n:param self: :class:`Schedule`\n:param contraction: :class:`UnionPwMultiAff`\n:param expansion: :class:`Schedule`\n:return: :class:`Schedule`'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(contraction, UnionPwMultiAff):
            raise IslTypeError("contraction is not a UnionPwMultiAff")
        if _ctx_data != contraction._ctx_data:
            raise Error("mismatched context in contraction")
        _copy_contraction = contraction._copy()
        
        if not isinstance(expansion, Schedule):
            raise IslTypeError("expansion is not a Schedule")
        if _ctx_data != expansion._ctx_data:
            raise Error("mismatched context in expansion")
        _copy_expansion = expansion._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_expand(_copy_self._release(), _copy_contraction._release(), _copy_expansion._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_expand failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.expand = expand

    def read_from_str(ctx, str):
        'read_from_str(ctx, str)\n\n:param ctx: :class:`Context`\n:param str: string\n:return: :class:`Schedule`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        
        _cstr_str = ffi.new("char[]", str.encode())
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_read_from_str(ctx.data, _cstr_str)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Schedule(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_schedule_read_from_str failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Schedule.read_from_str = staticmethod(read_from_str)

    Schedule._read_from_str_is_static = True

    def dump(self):
        'dump(self)\n\n:param self: :class:`Schedule`\n:return: (nothing)'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_dump(self.data)
        finally:
            pass
        

    Schedule.dump = dump

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`Schedule`\n:return: string'

        if not isinstance(self, Schedule):
            raise IslTypeError("self is not a Schedule")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_schedule_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    Schedule.to_str = to_str

    # }}}

    # {{{ access_info

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`AccessInfo`\n:return: :class:`Context`'

        if not isinstance(self, AccessInfo):
            raise IslTypeError("self is not a AccessInfo")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_access_info_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_access_info_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AccessInfo.get_ctx = get_ctx

    def compute_flow(self):
        'compute_flow(self)\n\n:param self: :class:`AccessInfo` (mutated in-place)\n:return: :class:`Flow`'

        if not isinstance(self, AccessInfo):
            raise IslTypeError("self is not a AccessInfo")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_access_info_compute_flow(self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Flow(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_access_info_compute_flow failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AccessInfo.compute_flow = compute_flow

    # }}}

    # {{{ flow

    def get_no_source(self, must):
        'get_no_source(self, must)\n\n:param self: :class:`Flow`\n:param must: :class:`int`\n:return: :class:`Map`'

        if not isinstance(self, Flow):
            raise IslTypeError("self is not a Flow")
        _ctx_data = self._ctx_data
        
        # no argument processing for must
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_flow_get_no_source(self.data, must)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Map(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_flow_get_no_source failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Flow.get_no_source = get_no_source

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Flow`\n:return: :class:`Context`'

        if not isinstance(self, Flow):
            raise IslTypeError("self is not a Flow")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_flow_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_flow_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Flow.get_ctx = get_ctx

    # }}}

    # {{{ restriction

    def empty(source_map):
        'empty(source_map)\n\n:param source_map: :class:`Map`\n:return: :class:`Restriction`'

        if isinstance(source_map, BasicMap):
            source_map = Map.from_basic_map(source_map)
        if not isinstance(source_map, Map):
            raise IslTypeError("source_map is not a Map")
        _ctx_data = source_map._ctx_data
        _copy_source_map = source_map._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_restriction_empty(_copy_source_map._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Restriction(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_restriction_empty failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Restriction.empty = staticmethod(empty)

    Restriction._empty_is_static = True

    def none(source_map):
        'none(source_map)\n\n:param source_map: :class:`Map`\n:return: :class:`Restriction`'

        if isinstance(source_map, BasicMap):
            source_map = Map.from_basic_map(source_map)
        if not isinstance(source_map, Map):
            raise IslTypeError("source_map is not a Map")
        _ctx_data = source_map._ctx_data
        _copy_source_map = source_map._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_restriction_none(_copy_source_map._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Restriction(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_restriction_none failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Restriction.none = staticmethod(none)

    Restriction._none_is_static = True

    def input(source_restr, sink_restr):
        'input(source_restr, sink_restr)\n\n:param source_restr: :class:`Set`\n:param sink_restr: :class:`Set`\n:return: :class:`Restriction`'

        if isinstance(source_restr, BasicSet):
            source_restr = Set.from_basic_set(source_restr)
        if not isinstance(source_restr, Set):
            raise IslTypeError("source_restr is not a Set")
        _ctx_data = source_restr._ctx_data
        _copy_source_restr = source_restr._copy()
        
        if isinstance(sink_restr, BasicSet):
            sink_restr = Set.from_basic_set(sink_restr)
        if not isinstance(sink_restr, Set):
            raise IslTypeError("sink_restr is not a Set")
        if _ctx_data != sink_restr._ctx_data:
            raise Error("mismatched context in sink_restr")
        _copy_sink_restr = sink_restr._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_restriction_input(_copy_source_restr._release(), _copy_sink_restr._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Restriction(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_restriction_input failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Restriction.input = staticmethod(input)

    Restriction._input_is_static = True

    def output(source_restr):
        'output(source_restr)\n\n:param source_restr: :class:`Set`\n:return: :class:`Restriction`'

        if isinstance(source_restr, BasicSet):
            source_restr = Set.from_basic_set(source_restr)
        if not isinstance(source_restr, Set):
            raise IslTypeError("source_restr is not a Set")
        _ctx_data = source_restr._ctx_data
        _copy_source_restr = source_restr._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_restriction_output(_copy_source_restr._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Restriction(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_restriction_output failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Restriction.output = staticmethod(output)

    Restriction._output_is_static = True

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`Restriction`\n:return: :class:`Context`'

        if not isinstance(self, Restriction):
            raise IslTypeError("self is not a Restriction")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_restriction_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_restriction_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    Restriction.get_ctx = get_ctx

    # }}}

    # {{{ union_access_info

    def from_sink(sink):
        'from_sink(sink)\n\n:param sink: :class:`UnionMap`\n:return: :class:`UnionAccessInfo`'

        if isinstance(sink, BasicMap):
            sink = Map.from_basic_map(sink)
        if isinstance(sink, Map):
            sink = UnionMap.from_map(sink)
        if not isinstance(sink, UnionMap):
            raise IslTypeError("sink is not a UnionMap")
        _ctx_data = sink._ctx_data
        _copy_sink = sink._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_access_info_from_sink(_copy_sink._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionAccessInfo(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_access_info_from_sink failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionAccessInfo.from_sink = staticmethod(from_sink)

    UnionAccessInfo._from_sink_is_static = True

    def set_must_source(self, must_source):
        'set_must_source(self, must_source)\n\n:param self: :class:`UnionAccessInfo`\n:param must_source: :class:`UnionMap`\n:return: :class:`UnionAccessInfo`'

        if not isinstance(self, UnionAccessInfo):
            raise IslTypeError("self is not a UnionAccessInfo")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(must_source, BasicMap):
            must_source = Map.from_basic_map(must_source)
        if isinstance(must_source, Map):
            must_source = UnionMap.from_map(must_source)
        if not isinstance(must_source, UnionMap):
            raise IslTypeError("must_source is not a UnionMap")
        if _ctx_data != must_source._ctx_data:
            raise Error("mismatched context in must_source")
        _copy_must_source = must_source._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_access_info_set_must_source(_copy_self._release(), _copy_must_source._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionAccessInfo(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_access_info_set_must_source failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionAccessInfo.set_must_source = set_must_source

    def set_may_source(self, may_source):
        'set_may_source(self, may_source)\n\n:param self: :class:`UnionAccessInfo`\n:param may_source: :class:`UnionMap`\n:return: :class:`UnionAccessInfo`'

        if not isinstance(self, UnionAccessInfo):
            raise IslTypeError("self is not a UnionAccessInfo")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(may_source, BasicMap):
            may_source = Map.from_basic_map(may_source)
        if isinstance(may_source, Map):
            may_source = UnionMap.from_map(may_source)
        if not isinstance(may_source, UnionMap):
            raise IslTypeError("may_source is not a UnionMap")
        if _ctx_data != may_source._ctx_data:
            raise Error("mismatched context in may_source")
        _copy_may_source = may_source._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_access_info_set_may_source(_copy_self._release(), _copy_may_source._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionAccessInfo(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_access_info_set_may_source failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionAccessInfo.set_may_source = set_may_source

    def set_kill(self, kill):
        'set_kill(self, kill)\n\n:param self: :class:`UnionAccessInfo`\n:param kill: :class:`UnionMap`\n:return: :class:`UnionAccessInfo`'

        if not isinstance(self, UnionAccessInfo):
            raise IslTypeError("self is not a UnionAccessInfo")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(kill, BasicMap):
            kill = Map.from_basic_map(kill)
        if isinstance(kill, Map):
            kill = UnionMap.from_map(kill)
        if not isinstance(kill, UnionMap):
            raise IslTypeError("kill is not a UnionMap")
        if _ctx_data != kill._ctx_data:
            raise Error("mismatched context in kill")
        _copy_kill = kill._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_access_info_set_kill(_copy_self._release(), _copy_kill._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionAccessInfo(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_access_info_set_kill failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionAccessInfo.set_kill = set_kill

    def set_schedule(self, schedule):
        'set_schedule(self, schedule)\n\n:param self: :class:`UnionAccessInfo`\n:param schedule: :class:`Schedule`\n:return: :class:`UnionAccessInfo`'

        if not isinstance(self, UnionAccessInfo):
            raise IslTypeError("self is not a UnionAccessInfo")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(schedule, Schedule):
            raise IslTypeError("schedule is not a Schedule")
        if _ctx_data != schedule._ctx_data:
            raise Error("mismatched context in schedule")
        _copy_schedule = schedule._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_access_info_set_schedule(_copy_self._release(), _copy_schedule._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionAccessInfo(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_access_info_set_schedule failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionAccessInfo.set_schedule = set_schedule

    def set_schedule_map(self, schedule_map):
        'set_schedule_map(self, schedule_map)\n\n:param self: :class:`UnionAccessInfo`\n:param schedule_map: :class:`UnionMap`\n:return: :class:`UnionAccessInfo`'

        if not isinstance(self, UnionAccessInfo):
            raise IslTypeError("self is not a UnionAccessInfo")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(schedule_map, BasicMap):
            schedule_map = Map.from_basic_map(schedule_map)
        if isinstance(schedule_map, Map):
            schedule_map = UnionMap.from_map(schedule_map)
        if not isinstance(schedule_map, UnionMap):
            raise IslTypeError("schedule_map is not a UnionMap")
        if _ctx_data != schedule_map._ctx_data:
            raise Error("mismatched context in schedule_map")
        _copy_schedule_map = schedule_map._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_access_info_set_schedule_map(_copy_self._release(), _copy_schedule_map._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionAccessInfo(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_access_info_set_schedule_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionAccessInfo.set_schedule_map = set_schedule_map

    def copy(self):
        'copy(self)\n\n:param self: :class:`UnionAccessInfo`\n:return: :class:`UnionAccessInfo`'

        if not isinstance(self, UnionAccessInfo):
            raise IslTypeError("self is not a UnionAccessInfo")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_access_info_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionAccessInfo(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_access_info_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionAccessInfo.copy = copy

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`UnionAccessInfo`\n:return: :class:`Context`'

        if not isinstance(self, UnionAccessInfo):
            raise IslTypeError("self is not a UnionAccessInfo")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_access_info_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_access_info_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionAccessInfo.get_ctx = get_ctx

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`UnionAccessInfo`\n:return: string'

        if not isinstance(self, UnionAccessInfo):
            raise IslTypeError("self is not a UnionAccessInfo")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_access_info_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    UnionAccessInfo.to_str = to_str

    def compute_flow(self):
        'compute_flow(self)\n\n:param self: :class:`UnionAccessInfo`\n:return: :class:`UnionFlow`'

        if not isinstance(self, UnionAccessInfo):
            raise IslTypeError("self is not a UnionAccessInfo")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_access_info_compute_flow(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionFlow(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_access_info_compute_flow failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionAccessInfo.compute_flow = compute_flow

    # }}}

    # {{{ union_flow

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`UnionFlow`\n:return: :class:`Context`'

        if not isinstance(self, UnionFlow):
            raise IslTypeError("self is not a UnionFlow")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_flow_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_flow_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionFlow.get_ctx = get_ctx

    def copy(self):
        'copy(self)\n\n:param self: :class:`UnionFlow`\n:return: :class:`UnionFlow`'

        if not isinstance(self, UnionFlow):
            raise IslTypeError("self is not a UnionFlow")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_flow_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionFlow(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_flow_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionFlow.copy = copy

    def get_must_dependence(self):
        'get_must_dependence(self)\n\n:param self: :class:`UnionFlow`\n:return: :class:`UnionMap`'

        if not isinstance(self, UnionFlow):
            raise IslTypeError("self is not a UnionFlow")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_flow_get_must_dependence(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_flow_get_must_dependence failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionFlow.get_must_dependence = get_must_dependence

    def get_may_dependence(self):
        'get_may_dependence(self)\n\n:param self: :class:`UnionFlow`\n:return: :class:`UnionMap`'

        if not isinstance(self, UnionFlow):
            raise IslTypeError("self is not a UnionFlow")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_flow_get_may_dependence(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_flow_get_may_dependence failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionFlow.get_may_dependence = get_may_dependence

    def get_full_must_dependence(self):
        'get_full_must_dependence(self)\n\n:param self: :class:`UnionFlow`\n:return: :class:`UnionMap`'

        if not isinstance(self, UnionFlow):
            raise IslTypeError("self is not a UnionFlow")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_flow_get_full_must_dependence(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_flow_get_full_must_dependence failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionFlow.get_full_must_dependence = get_full_must_dependence

    def get_full_may_dependence(self):
        'get_full_may_dependence(self)\n\n:param self: :class:`UnionFlow`\n:return: :class:`UnionMap`'

        if not isinstance(self, UnionFlow):
            raise IslTypeError("self is not a UnionFlow")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_flow_get_full_may_dependence(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_flow_get_full_may_dependence failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionFlow.get_full_may_dependence = get_full_may_dependence

    def get_must_no_source(self):
        'get_must_no_source(self)\n\n:param self: :class:`UnionFlow`\n:return: :class:`UnionMap`'

        if not isinstance(self, UnionFlow):
            raise IslTypeError("self is not a UnionFlow")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_flow_get_must_no_source(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_flow_get_must_no_source failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionFlow.get_must_no_source = get_must_no_source

    def get_may_no_source(self):
        'get_may_no_source(self)\n\n:param self: :class:`UnionFlow`\n:return: :class:`UnionMap`'

        if not isinstance(self, UnionFlow):
            raise IslTypeError("self is not a UnionFlow")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_flow_get_may_no_source(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_union_flow_get_may_no_source failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    UnionFlow.get_may_no_source = get_may_no_source

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`UnionFlow`\n:return: string'

        if not isinstance(self, UnionFlow):
            raise IslTypeError("self is not a UnionFlow")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_union_flow_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    UnionFlow.to_str = to_str

    # }}}

    # {{{ ast_expr

    def from_val(v):
        'from_val(v)\n\n:param v: :class:`Val`\n:return: :class:`AstExpr`'

        if not isinstance(v, Val):
            raise IslTypeError("v is not a Val")
        _ctx_data = v._ctx_data
        _copy_v = v._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_from_val(_copy_v._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_from_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.from_val = staticmethod(from_val)

    AstExpr._from_val_is_static = True

    def from_id(id):
        'from_id(id)\n\n:param id: :class:`Id`\n:return: :class:`AstExpr`'

        if not isinstance(id, Id):
            raise IslTypeError("id is not a Id")
        _ctx_data = id._ctx_data
        _copy_id = id._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_from_id(_copy_id._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_from_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.from_id = staticmethod(from_id)

    AstExpr._from_id_is_static = True

    def neg(self):
        'neg(self)\n\n:param self: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_neg(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_neg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.neg = neg

    def add(self, expr2):
        'add(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_add(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_add failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.add = add

    def sub(self, expr2):
        'sub(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_sub(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_sub failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.sub = sub

    def mul(self, expr2):
        'mul(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_mul(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_mul failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.mul = mul

    def div(self, expr2):
        'div(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_div(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_div failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.div = div

    def pdiv_q(self, expr2):
        'pdiv_q(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_pdiv_q(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_pdiv_q failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.pdiv_q = pdiv_q

    def pdiv_r(self, expr2):
        'pdiv_r(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_pdiv_r(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_pdiv_r failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.pdiv_r = pdiv_r

    def and_(self, expr2):
        'and_(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_and(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_and failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.and_ = and_

    def and_then(self, expr2):
        'and_then(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_and_then(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_and_then failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.and_then = and_then

    def or_(self, expr2):
        'or_(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_or(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_or failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.or_ = or_

    def or_else(self, expr2):
        'or_else(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_or_else(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_or_else failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.or_else = or_else

    def le(self, expr2):
        'le(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_le(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_le failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.le = le

    def lt(self, expr2):
        'lt(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_lt(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_lt failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.lt = lt

    def ge(self, expr2):
        'ge(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_ge(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_ge failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.ge = ge

    def gt(self, expr2):
        'gt(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_gt(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_gt failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.gt = gt

    def eq(self, expr2):
        'eq(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        _copy_expr2 = expr2._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_eq(_copy_self._release(), _copy_expr2._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_eq failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.eq = eq

    def access(self, indices):
        'access(self, indices)\n\n:param self: :class:`AstExpr`\n:param indices: :class:`AstExprList`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(indices, AstExprList):
            raise IslTypeError("indices is not a AstExprList")
        if _ctx_data != indices._ctx_data:
            raise Error("mismatched context in indices")
        _copy_indices = indices._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_access(_copy_self._release(), _copy_indices._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_access failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.access = access

    def call(self, arguments):
        'call(self, arguments)\n\n:param self: :class:`AstExpr`\n:param arguments: :class:`AstExprList`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(arguments, AstExprList):
            raise IslTypeError("arguments is not a AstExprList")
        if _ctx_data != arguments._ctx_data:
            raise Error("mismatched context in arguments")
        _copy_arguments = arguments._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_call(_copy_self._release(), _copy_arguments._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_call failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.call = call

    def address_of(self):
        'address_of(self)\n\n:param self: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_address_of(_copy_self._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_address_of failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.address_of = address_of

    def copy(self):
        'copy(self)\n\n:param self: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.copy = copy

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`AstExpr`\n:return: :class:`Context`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.get_ctx = get_ctx

    def get_type(self):
        'get_type(self)\n\n:param self: :class:`AstExpr`\n:return: isl_ast_expr_type'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_get_type(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    AstExpr.get_type = get_type

    def int_get_val(self):
        'int_get_val(self)\n\n:param self: :class:`AstExpr`\n:return: :class:`Val`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_int_get_val(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_int_get_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.int_get_val = int_get_val

    def get_val(self):
        'get_val(self)\n\n:param self: :class:`AstExpr`\n:return: :class:`Val`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_get_val(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Val(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_get_val failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.get_val = get_val

    def id_get_id(self):
        'id_get_id(self)\n\n:param self: :class:`AstExpr`\n:return: :class:`Id`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_id_get_id(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_id_get_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.id_get_id = id_get_id

    def get_id(self):
        'get_id(self)\n\n:param self: :class:`AstExpr`\n:return: :class:`Id`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_get_id(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_get_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.get_id = get_id

    def op_get_n_arg(self):
        'op_get_n_arg(self)\n\n:param self: :class:`AstExpr`\n:return: isl_size'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_op_get_n_arg(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    AstExpr.op_get_n_arg = op_get_n_arg

    def get_op_n_arg(self):
        'get_op_n_arg(self)\n\n:param self: :class:`AstExpr`\n:return: isl_size'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_get_op_n_arg(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    AstExpr.get_op_n_arg = get_op_n_arg

    def op_get_arg(self, pos):
        'op_get_arg(self, pos)\n\n:param self: :class:`AstExpr`\n:param pos: :class:`int`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_op_get_arg(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_op_get_arg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.op_get_arg = op_get_arg

    def get_op_arg(self, pos):
        'get_op_arg(self, pos)\n\n:param self: :class:`AstExpr`\n:param pos: :class:`int`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        
        # no argument processing for pos
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_get_op_arg(self.data, pos)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_get_op_arg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.get_op_arg = get_op_arg

    def set_op_arg(self, pos, arg):
        'set_op_arg(self, pos, arg)\n\n:param self: :class:`AstExpr`\n:param pos: :class:`int`\n:param arg: :class:`AstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        # no argument processing for pos
        
        if not isinstance(arg, AstExpr):
            raise IslTypeError("arg is not a AstExpr")
        if _ctx_data != arg._ctx_data:
            raise Error("mismatched context in arg")
        _copy_arg = arg._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_set_op_arg(_copy_self._release(), pos, _copy_arg._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_set_op_arg failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.set_op_arg = set_op_arg

    def is_equal(self, expr2):
        'is_equal(self, expr2)\n\n:param self: :class:`AstExpr`\n:param expr2: :class:`AstExpr`\n:return: bool'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        
        if not isinstance(expr2, AstExpr):
            raise IslTypeError("expr2 is not a AstExpr")
        if _ctx_data != expr2._ctx_data:
            raise Error("mismatched context in expr2")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_is_equal(self.data, expr2.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_ast_expr_is_equal\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    AstExpr.is_equal = is_equal

    def substitute_ids(self, id2expr):
        'substitute_ids(self, id2expr)\n\n:param self: :class:`AstExpr`\n:param id2expr: :class:`IdToAstExpr`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(id2expr, IdToAstExpr):
            raise IslTypeError("id2expr is not a IdToAstExpr")
        if _ctx_data != id2expr._ctx_data:
            raise Error("mismatched context in id2expr")
        _copy_id2expr = id2expr._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_substitute_ids(_copy_self._release(), _copy_id2expr._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_substitute_ids failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.substitute_ids = substitute_ids

    def dump(self):
        'dump(self)\n\n:param self: :class:`AstExpr`\n:return: (nothing)'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_dump(self.data)
        finally:
            pass
        

    AstExpr.dump = dump

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`AstExpr`\n:return: string'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    AstExpr.to_str = to_str

    def to_C_str(self):
        'to_C_str(self)\n\n:param self: :class:`AstExpr`\n:return: string'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_to_C_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    AstExpr.to_C_str = to_C_str

    def print_macros(self, p):
        'print_macros(self, p)\n\n:param self: :class:`AstExpr`\n:param p: :class:`Printer` (mutated in-place)\n:return: :class:`Printer`'

        if not isinstance(self, AstExpr):
            raise IslTypeError("self is not a AstExpr")
        _ctx_data = self._ctx_data
        
        if not isinstance(p, Printer):
            raise IslTypeError("p is not a Printer")
        if _ctx_data != p._ctx_data:
            raise Error("mismatched context in p")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_expr_print_macros(self.data, p._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Printer(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_expr_print_macros failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstExpr.print_macros = print_macros

    # }}}

    # {{{ ast_node

    def alloc_user(expr):
        'alloc_user(expr)\n\n:param expr: :class:`AstExpr`\n:return: :class:`AstNode`'

        if not isinstance(expr, AstExpr):
            raise IslTypeError("expr is not a AstExpr")
        _ctx_data = expr._ctx_data
        _copy_expr = expr._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_alloc_user(_copy_expr._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_alloc_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.alloc_user = staticmethod(alloc_user)

    AstNode._alloc_user_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstNode`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.copy = copy

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`AstNode`\n:return: :class:`Context`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.get_ctx = get_ctx

    def get_type(self):
        'get_type(self)\n\n:param self: :class:`AstNode`\n:return: isl_ast_node_type'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_get_type(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        
        return _result

    AstNode.get_type = get_type

    def set_annotation(self, annotation):
        'set_annotation(self, annotation)\n\n:param self: :class:`AstNode`\n:param annotation: :class:`Id`\n:return: :class:`AstNode`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(annotation, Id):
            raise IslTypeError("annotation is not a Id")
        if _ctx_data != annotation._ctx_data:
            raise Error("mismatched context in annotation")
        _copy_annotation = annotation._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_set_annotation(_copy_self._release(), _copy_annotation._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_set_annotation failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.set_annotation = set_annotation

    def get_annotation(self):
        'get_annotation(self)\n\n:param self: :class:`AstNode`\n:return: :class:`Id`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_get_annotation(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_get_annotation failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.get_annotation = get_annotation

    def for_get_iterator(self):
        'for_get_iterator(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_for_get_iterator(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_for_get_iterator failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.for_get_iterator = for_get_iterator

    def for_get_init(self):
        'for_get_init(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_for_get_init(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_for_get_init failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.for_get_init = for_get_init

    def for_get_cond(self):
        'for_get_cond(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_for_get_cond(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_for_get_cond failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.for_get_cond = for_get_cond

    def for_get_inc(self):
        'for_get_inc(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_for_get_inc(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_for_get_inc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.for_get_inc = for_get_inc

    def for_get_body(self):
        'for_get_body(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstNode`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_for_get_body(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_for_get_body failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.for_get_body = for_get_body

    def for_is_degenerate(self):
        'for_is_degenerate(self)\n\n:param self: :class:`AstNode`\n:return: bool'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_for_is_degenerate(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_ast_node_for_is_degenerate\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    AstNode.for_is_degenerate = for_is_degenerate

    def if_get_cond(self):
        'if_get_cond(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_if_get_cond(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_if_get_cond failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.if_get_cond = if_get_cond

    def if_get_then_node(self):
        'if_get_then_node(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstNode`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_if_get_then_node(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_if_get_then_node failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.if_get_then_node = if_get_then_node

    def if_get_then(self):
        'if_get_then(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstNode`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_if_get_then(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_if_get_then failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.if_get_then = if_get_then

    def if_has_else_node(self):
        'if_has_else_node(self)\n\n:param self: :class:`AstNode`\n:return: bool'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_if_has_else_node(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_ast_node_if_has_else_node\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    AstNode.if_has_else_node = if_has_else_node

    def if_has_else(self):
        'if_has_else(self)\n\n:param self: :class:`AstNode`\n:return: bool'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_if_has_else(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_bool_error:
            raise Error("call to \"isl_ast_node_if_has_else\" failed: %s" % _get_last_error_str(_ctx_data))
        
        return _result == lib.isl_bool_true

    AstNode.if_has_else = if_has_else

    def if_get_else_node(self):
        'if_get_else_node(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstNode`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_if_get_else_node(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_if_get_else_node failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.if_get_else_node = if_get_else_node

    def if_get_else(self):
        'if_get_else(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstNode`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_if_get_else(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_if_get_else failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.if_get_else = if_get_else

    def block_get_children(self):
        'block_get_children(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstNodeList`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_block_get_children(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNodeList(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_block_get_children failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.block_get_children = block_get_children

    def mark_get_id(self):
        'mark_get_id(self)\n\n:param self: :class:`AstNode`\n:return: :class:`Id`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_mark_get_id(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Id(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_mark_get_id failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.mark_get_id = mark_get_id

    def mark_get_node(self):
        'mark_get_node(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstNode`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_mark_get_node(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_mark_get_node failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.mark_get_node = mark_get_node

    def user_get_expr(self):
        'user_get_expr(self)\n\n:param self: :class:`AstNode`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_user_get_expr(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_user_get_expr failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.user_get_expr = user_get_expr

    def foreach_descendant_top_down(self, fn):
        'foreach_descendant_top_down(self, fn)\n\n:param self: :class:`AstNode`\n:param fn: callback(node) -> isl_bool\n:return: (nothing)'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        
        def _cb_wrapper_fn(node, user):
            try:
                _py_node = AstNode(_data=node)
                _result = fn(_py_node)
                _py_node._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_bool (*fn)( isl_ast_node *node,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_foreach_descendant_top_down(self.data, _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            pass
        if _result == lib.isl_stat_error:
            raise Error("call to \"isl_ast_node_foreach_descendant_top_down\" failed: %s" % _get_last_error_str(_ctx_data))
        

    AstNode.foreach_descendant_top_down = foreach_descendant_top_down

    def dump(self):
        'dump(self)\n\n:param self: :class:`AstNode`\n:return: (nothing)'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_dump(self.data)
        finally:
            pass
        

    AstNode.dump = dump

    def to_str(self):
        'to_str(self)\n\n:param self: :class:`AstNode`\n:return: string'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_to_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    AstNode.to_str = to_str

    def print_macros(self, p):
        'print_macros(self, p)\n\n:param self: :class:`AstNode`\n:param p: :class:`Printer` (mutated in-place)\n:return: :class:`Printer`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        
        if not isinstance(p, Printer):
            raise IslTypeError("p is not a Printer")
        if _ctx_data != p._ctx_data:
            raise Error("mismatched context in p")
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_print_macros(self.data, p._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Printer(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_print_macros failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.print_macros = print_macros

    def print_(self, p, options):
        'print_(self, p, options)\n\n:param self: :class:`AstNode`\n:param p: :class:`Printer` (mutated in-place)\n:param options: :class:`AstPrintOptions`\n:return: :class:`Printer`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        
        if not isinstance(p, Printer):
            raise IslTypeError("p is not a Printer")
        if _ctx_data != p._ctx_data:
            raise Error("mismatched context in p")
        
        if not isinstance(options, AstPrintOptions):
            raise IslTypeError("options is not a AstPrintOptions")
        if _ctx_data != options._ctx_data:
            raise Error("mismatched context in options")
        _copy_options = options._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_print(self.data, p._release(), _copy_options._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Printer(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_print failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.print_ = print_

    def for_print(self, p, options):
        'for_print(self, p, options)\n\n:param self: :class:`AstNode`\n:param p: :class:`Printer` (mutated in-place)\n:param options: :class:`AstPrintOptions`\n:return: :class:`Printer`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        
        if not isinstance(p, Printer):
            raise IslTypeError("p is not a Printer")
        if _ctx_data != p._ctx_data:
            raise Error("mismatched context in p")
        
        if not isinstance(options, AstPrintOptions):
            raise IslTypeError("options is not a AstPrintOptions")
        if _ctx_data != options._ctx_data:
            raise Error("mismatched context in options")
        _copy_options = options._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_for_print(self.data, p._release(), _copy_options._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Printer(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_for_print failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.for_print = for_print

    def if_print(self, p, options):
        'if_print(self, p, options)\n\n:param self: :class:`AstNode`\n:param p: :class:`Printer` (mutated in-place)\n:param options: :class:`AstPrintOptions`\n:return: :class:`Printer`'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        
        if not isinstance(p, Printer):
            raise IslTypeError("p is not a Printer")
        if _ctx_data != p._ctx_data:
            raise Error("mismatched context in p")
        
        if not isinstance(options, AstPrintOptions):
            raise IslTypeError("options is not a AstPrintOptions")
        if _ctx_data != options._ctx_data:
            raise Error("mismatched context in options")
        _copy_options = options._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_if_print(self.data, p._release(), _copy_options._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Printer(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_node_if_print failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstNode.if_print = if_print

    def to_C_str(self):
        'to_C_str(self)\n\n:param self: :class:`AstNode`\n:return: string'

        if not isinstance(self, AstNode):
            raise IslTypeError("self is not a AstNode")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_node_to_C_str(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            if _result != ffi.NULL:
                _str_ret = ffi.string(_result)
            else:
                _str_ret = None
            libc.free(_result)
            pass
        if _PY3 and _str_ret is not None:
            _str_ret = _str_ret.decode()
        
        return _str_ret

    AstNode.to_C_str = to_C_str

    # }}}

    # {{{ ast_print_options

    def alloc(ctx):
        'alloc(ctx)\n\n:param ctx: :class:`Context`\n:return: :class:`AstPrintOptions`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_print_options_alloc(ctx.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstPrintOptions(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_print_options_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstPrintOptions.alloc = staticmethod(alloc)

    AstPrintOptions._alloc_is_static = True

    def copy(self):
        'copy(self)\n\n:param self: :class:`AstPrintOptions`\n:return: :class:`AstPrintOptions`'

        if not isinstance(self, AstPrintOptions):
            raise IslTypeError("self is not a AstPrintOptions")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_print_options_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstPrintOptions(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_print_options_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstPrintOptions.copy = copy

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`AstPrintOptions`\n:return: :class:`Context`'

        if not isinstance(self, AstPrintOptions):
            raise IslTypeError("self is not a AstPrintOptions")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_print_options_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_print_options_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstPrintOptions.get_ctx = get_ctx

    def set_print_user(self, print_user):
        'set_print_user(self, print_user)\n\n:param self: :class:`AstPrintOptions`\n:param print_user: callback(p, options, node) -> isl_printer\n:return: (:class:`AstPrintOptions`, :class:`ffi_callback_handle`)'

        if not isinstance(self, AstPrintOptions):
            raise IslTypeError("self is not a AstPrintOptions")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_print_user(p, options, node, user):
            try:
                _py_p = Printer(_data=p)
                _py_options = AstPrintOptions(_data=options)
                _py_node = AstNode(_data=node)
                _result = print_user(_py_p, _py_options, _py_node)
                _py_node._release()
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, Printer):
                    raise IslTypeError("return value is not a Printer")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_print_user = ffi.callback(" isl_printer *(*print_user)( isl_printer *p,  isl_ast_print_options *options,  isl_ast_node *node,  void *user)")(_cb_wrapper_print_user)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_print_options_set_print_user(_copy_self._release(), _cb_print_user, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstPrintOptions(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_print_options_set_print_user failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _cb_print_user

    AstPrintOptions.set_print_user = set_print_user

    def set_print_for(self, print_for):
        'set_print_for(self, print_for)\n\n:param self: :class:`AstPrintOptions`\n:param print_for: callback(p, options, node) -> isl_printer\n:return: (:class:`AstPrintOptions`, :class:`ffi_callback_handle`)'

        if not isinstance(self, AstPrintOptions):
            raise IslTypeError("self is not a AstPrintOptions")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_print_for(p, options, node, user):
            try:
                _py_p = Printer(_data=p)
                _py_options = AstPrintOptions(_data=options)
                _py_node = AstNode(_data=node)
                _result = print_for(_py_p, _py_options, _py_node)
                _py_node._release()
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, Printer):
                    raise IslTypeError("return value is not a Printer")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_print_for = ffi.callback(" isl_printer *(*print_for)( isl_printer *p,  isl_ast_print_options *options,  isl_ast_node *node,  void *user)")(_cb_wrapper_print_for)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_print_options_set_print_for(_copy_self._release(), _cb_print_for, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstPrintOptions(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_print_options_set_print_for failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _cb_print_for

    AstPrintOptions.set_print_for = set_print_for

    # }}}

    # {{{ ast_build

    def get_ctx(self):
        'get_ctx(self)\n\n:param self: :class:`AstBuild`\n:return: :class:`Context`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_get_ctx(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Context(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_get_ctx failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.get_ctx = get_ctx

    def alloc(ctx):
        'alloc(ctx)\n\n:param ctx: :class:`Context`\n:return: :class:`AstBuild`'

        if not isinstance(ctx, Context):
            raise IslTypeError("ctx is not a Context")
        _ctx_data = ctx._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_alloc(ctx.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstBuild(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_alloc failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.alloc = staticmethod(alloc)

    AstBuild._alloc_is_static = True

    def from_context(set):
        'from_context(set)\n\n:param set: :class:`Set`\n:return: :class:`AstBuild`'

        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        _ctx_data = set._ctx_data
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_from_context(_copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstBuild(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_from_context failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.from_context = staticmethod(from_context)

    AstBuild._from_context_is_static = True

    def get_schedule_space(self):
        'get_schedule_space(self)\n\n:param self: :class:`AstBuild`\n:return: :class:`Space`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_get_schedule_space(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else Space(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_get_schedule_space failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.get_schedule_space = get_schedule_space

    def get_schedule(self):
        'get_schedule(self)\n\n:param self: :class:`AstBuild`\n:return: :class:`UnionMap`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_get_schedule(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else UnionMap(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_get_schedule failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.get_schedule = get_schedule

    def restrict(self, set):
        'restrict(self, set)\n\n:param self: :class:`AstBuild`\n:param set: :class:`Set`\n:return: :class:`AstBuild`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_restrict(_copy_self._release(), _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstBuild(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_restrict failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.restrict = restrict

    def copy(self):
        'copy(self)\n\n:param self: :class:`AstBuild`\n:return: :class:`AstBuild`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_copy(self.data)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstBuild(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_copy failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.copy = copy

    def set_options(self, options):
        'set_options(self, options)\n\n:param self: :class:`AstBuild`\n:param options: :class:`UnionMap`\n:return: :class:`AstBuild`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if isinstance(options, BasicMap):
            options = Map.from_basic_map(options)
        if isinstance(options, Map):
            options = UnionMap.from_map(options)
        if not isinstance(options, UnionMap):
            raise IslTypeError("options is not a UnionMap")
        if _ctx_data != options._ctx_data:
            raise Error("mismatched context in options")
        _copy_options = options._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_set_options(_copy_self._release(), _copy_options._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstBuild(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_set_options failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.set_options = set_options

    def set_iterators(self, iterators):
        'set_iterators(self, iterators)\n\n:param self: :class:`AstBuild`\n:param iterators: :class:`IdList`\n:return: :class:`AstBuild`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        if not isinstance(iterators, IdList):
            raise IslTypeError("iterators is not a IdList")
        if _ctx_data != iterators._ctx_data:
            raise Error("mismatched context in iterators")
        _copy_iterators = iterators._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_set_iterators(_copy_self._release(), _copy_iterators._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstBuild(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_set_iterators failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.set_iterators = set_iterators

    def set_at_each_domain(self, fn):
        'set_at_each_domain(self, fn)\n\n:param self: :class:`AstBuild`\n:param fn: callback(node, build) -> isl_ast_node\n:return: (:class:`AstBuild`, :class:`ffi_callback_handle`)'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(node, build, user):
            try:
                _py_node = AstNode(_data=node)
                _py_build = AstBuild(_data=build)
                _result = fn(_py_node, _py_build)
                _py_build._release()
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, AstNode):
                    raise IslTypeError("return value is not a AstNode")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_ast_node *(*fn)( isl_ast_node *node,  isl_ast_build *build,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_set_at_each_domain(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstBuild(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_set_at_each_domain failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _cb_fn

    AstBuild.set_at_each_domain = set_at_each_domain

    def set_before_each_for(self, fn):
        'set_before_each_for(self, fn)\n\n:param self: :class:`AstBuild`\n:param fn: callback(build) -> isl_id\n:return: (:class:`AstBuild`, :class:`ffi_callback_handle`)'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(build, user):
            try:
                _py_build = AstBuild(_data=build)
                _result = fn(_py_build)
                _py_build._release()
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, Id):
                    raise IslTypeError("return value is not a Id")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_id *(*fn)( isl_ast_build *build,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_set_before_each_for(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstBuild(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_set_before_each_for failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _cb_fn

    AstBuild.set_before_each_for = set_before_each_for

    def set_after_each_for(self, fn):
        'set_after_each_for(self, fn)\n\n:param self: :class:`AstBuild`\n:param fn: callback(node, build) -> isl_ast_node\n:return: (:class:`AstBuild`, :class:`ffi_callback_handle`)'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(node, build, user):
            try:
                _py_node = AstNode(_data=node)
                _py_build = AstBuild(_data=build)
                _result = fn(_py_node, _py_build)
                _py_build._release()
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, AstNode):
                    raise IslTypeError("return value is not a AstNode")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_ast_node *(*fn)( isl_ast_node *node,  isl_ast_build *build,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_set_after_each_for(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstBuild(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_set_after_each_for failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _cb_fn

    AstBuild.set_after_each_for = set_after_each_for

    def set_before_each_mark(self, fn):
        'set_before_each_mark(self, fn)\n\n:param self: :class:`AstBuild`\n:param fn: callback(mark, build) -> isl_stat\n:return: (:class:`AstBuild`, :class:`ffi_callback_handle`)'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(mark, build, user):
            try:
                _py_mark = Id(_data=mark)
                _py_build = AstBuild(_data=build)
                _result = fn(_py_mark, _py_build)
                _py_mark._release()
                _py_build._release()
                if _result is None:
                    _result = lib.isl_stat_ok
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return lib.isl_stat_error
        
        _cb_fn = ffi.callback(" isl_stat (*fn)( isl_id *mark,  isl_ast_build *build,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_set_before_each_mark(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstBuild(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_set_before_each_mark failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _cb_fn

    AstBuild.set_before_each_mark = set_before_each_mark

    def set_after_each_mark(self, fn):
        'set_after_each_mark(self, fn)\n\n:param self: :class:`AstBuild`\n:param fn: callback(node, build) -> isl_ast_node\n:return: (:class:`AstBuild`, :class:`ffi_callback_handle`)'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(node, build, user):
            try:
                _py_node = AstNode(_data=node)
                _py_build = AstBuild(_data=build)
                _result = fn(_py_node, _py_build)
                _py_build._release()
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, AstNode):
                    raise IslTypeError("return value is not a AstNode")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_ast_node *(*fn)( isl_ast_node *node,  isl_ast_build *build,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_set_after_each_mark(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstBuild(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_set_after_each_mark failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _cb_fn

    AstBuild.set_after_each_mark = set_after_each_mark

    def set_create_leaf(self, fn):
        'set_create_leaf(self, fn)\n\n:param self: :class:`AstBuild`\n:param fn: callback(build) -> isl_ast_node\n:return: (:class:`AstBuild`, :class:`ffi_callback_handle`)'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        _copy_self = self._copy()
        
        def _cb_wrapper_fn(build, user):
            try:
                _py_build = AstBuild(_data=build)
                _result = fn(_py_build)
                if _result is None:
                    _result = ffi.NULL
                elif not isinstance(_result, AstNode):
                    raise IslTypeError("return value is not a AstNode")
                else:
                    _result = _result._release()
                return _result
            except Exception as e:
                import sys
                sys.stderr.write("[WARNING] An exception occurred "
                    "in a callback function."
                    "This exception was ignored.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_exc()
            
                return ffi.NULL
        
        _cb_fn = ffi.callback(" isl_ast_node *(*fn)( isl_ast_build *build,  void *user)")(_cb_wrapper_fn)
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_set_create_leaf(_copy_self._release(), _cb_fn, ffi.NULL)
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstBuild(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_set_create_leaf failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result, _cb_fn

    AstBuild.set_create_leaf = set_create_leaf

    def expr_from_set(self, set):
        'expr_from_set(self, set)\n\n:param self: :class:`AstBuild`\n:param set: :class:`Set`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        
        if isinstance(set, BasicSet):
            set = Set.from_basic_set(set)
        if not isinstance(set, Set):
            raise IslTypeError("set is not a Set")
        if _ctx_data != set._ctx_data:
            raise Error("mismatched context in set")
        _copy_set = set._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_expr_from_set(self.data, _copy_set._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_expr_from_set failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.expr_from_set = expr_from_set

    def expr_from_pw_aff(self, pa):
        'expr_from_pw_aff(self, pa)\n\n:param self: :class:`AstBuild`\n:param pa: :class:`PwAff`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        
        if isinstance(pa, Aff):
            pa = PwAff.from_aff(pa)
        if not isinstance(pa, PwAff):
            raise IslTypeError("pa is not a PwAff")
        if _ctx_data != pa._ctx_data:
            raise Error("mismatched context in pa")
        _copy_pa = pa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_expr_from_pw_aff(self.data, _copy_pa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_expr_from_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.expr_from_pw_aff = expr_from_pw_aff

    def access_from_pw_multi_aff(self, pma):
        'access_from_pw_multi_aff(self, pma)\n\n:param self: :class:`AstBuild`\n:param pma: :class:`PwMultiAff`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_access_from_pw_multi_aff(self.data, _copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_access_from_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.access_from_pw_multi_aff = access_from_pw_multi_aff

    def access_from_multi_pw_aff(self, mpa):
        'access_from_multi_pw_aff(self, mpa)\n\n:param self: :class:`AstBuild`\n:param mpa: :class:`MultiPwAff`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        
        if not isinstance(mpa, MultiPwAff):
            raise IslTypeError("mpa is not a MultiPwAff")
        if _ctx_data != mpa._ctx_data:
            raise Error("mismatched context in mpa")
        _copy_mpa = mpa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_access_from_multi_pw_aff(self.data, _copy_mpa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_access_from_multi_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.access_from_multi_pw_aff = access_from_multi_pw_aff

    def call_from_pw_multi_aff(self, pma):
        'call_from_pw_multi_aff(self, pma)\n\n:param self: :class:`AstBuild`\n:param pma: :class:`PwMultiAff`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        
        if not isinstance(pma, PwMultiAff):
            raise IslTypeError("pma is not a PwMultiAff")
        if _ctx_data != pma._ctx_data:
            raise Error("mismatched context in pma")
        _copy_pma = pma._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_call_from_pw_multi_aff(self.data, _copy_pma._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_call_from_pw_multi_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.call_from_pw_multi_aff = call_from_pw_multi_aff

    def call_from_multi_pw_aff(self, mpa):
        'call_from_multi_pw_aff(self, mpa)\n\n:param self: :class:`AstBuild`\n:param mpa: :class:`MultiPwAff`\n:return: :class:`AstExpr`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        
        if not isinstance(mpa, MultiPwAff):
            raise IslTypeError("mpa is not a MultiPwAff")
        if _ctx_data != mpa._ctx_data:
            raise Error("mismatched context in mpa")
        _copy_mpa = mpa._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_call_from_multi_pw_aff(self.data, _copy_mpa._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstExpr(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_call_from_multi_pw_aff failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.call_from_multi_pw_aff = call_from_multi_pw_aff

    def node_from_schedule(self, schedule):
        'node_from_schedule(self, schedule)\n\n:param self: :class:`AstBuild`\n:param schedule: :class:`Schedule`\n:return: :class:`AstNode`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        
        if not isinstance(schedule, Schedule):
            raise IslTypeError("schedule is not a Schedule")
        if _ctx_data != schedule._ctx_data:
            raise Error("mismatched context in schedule")
        _copy_schedule = schedule._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_node_from_schedule(self.data, _copy_schedule._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_node_from_schedule failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.node_from_schedule = node_from_schedule

    def node_from_schedule_map(self, schedule):
        'node_from_schedule_map(self, schedule)\n\n:param self: :class:`AstBuild`\n:param schedule: :class:`UnionMap`\n:return: :class:`AstNode`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        
        if isinstance(schedule, BasicMap):
            schedule = Map.from_basic_map(schedule)
        if isinstance(schedule, Map):
            schedule = UnionMap.from_map(schedule)
        if not isinstance(schedule, UnionMap):
            raise IslTypeError("schedule is not a UnionMap")
        if _ctx_data != schedule._ctx_data:
            raise Error("mismatched context in schedule")
        _copy_schedule = schedule._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_node_from_schedule_map(self.data, _copy_schedule._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_node_from_schedule_map failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.node_from_schedule_map = node_from_schedule_map

    def ast_from_schedule(self, schedule):
        'ast_from_schedule(self, schedule)\n\n:param self: :class:`AstBuild`\n:param schedule: :class:`UnionMap`\n:return: :class:`AstNode`'

        if not isinstance(self, AstBuild):
            raise IslTypeError("self is not a AstBuild")
        _ctx_data = self._ctx_data
        
        if isinstance(schedule, BasicMap):
            schedule = Map.from_basic_map(schedule)
        if isinstance(schedule, Map):
            schedule = UnionMap.from_map(schedule)
        if not isinstance(schedule, UnionMap):
            raise IslTypeError("schedule is not a UnionMap")
        if _ctx_data != schedule._ctx_data:
            raise Error("mismatched context in schedule")
        _copy_schedule = schedule._copy()
        

        try:
            _result = None
            with DelayedKeyboardInterrupt():
                _result = lib.isl_ast_build_ast_from_schedule(self.data, _copy_schedule._release())
        finally:
            if _result is None:
                # This should never happen.
                sys.stderr.write("*** islpy was interrupted while collecting "
                    "a result. "
                    "System state is inconsistent as a result, will print "
                    "traceback and abort.\n")
                sys.stderr.flush()
                import traceback
                traceback.print_stack()
                import os
                os._exit(-1)
            _result = None if (_result == ffi.NULL or _result is None) else AstNode(_data=_result)
            pass
        if _result is None:
            raise Error("call to isl_ast_build_ast_from_schedule failed: %s"
                % _get_last_error_str(_ctx_data))
        
        return _result

    AstBuild.ast_from_schedule = ast_from_schedule

    # }}}


# }}}

_add_methods()

# vim: fdm=marker
