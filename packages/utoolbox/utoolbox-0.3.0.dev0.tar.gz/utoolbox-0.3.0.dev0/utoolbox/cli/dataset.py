"""
Dataset management command-line utility.
"""
import logging
import os

import click
import coloredlogs
import ffmpeg
import imageio

import numpy as np

from utoolbox.data import MicroManagerDataset, SPIMDataset
import utoolbox.data.dataset.mm.error as mm_error
import utoolbox.data.dataset.spim.error as spim_error
from utoolbox.data.datastore import FolderDatastore
from utoolbox.transform.projections import Orthogonal

logging.getLogger("tifffile").setLevel(logging.ERROR)
logger = logging.getLogger(__name__)


@click.group()
@click.option("-v", "--verbose", count=True)
@click.pass_context
def main(ctx, verbose):
    if verbose == 0:
        verbose = "WARNING"
    elif verbose == 1:
        verbose = "INFO"
    else:
        verbose = "DEBUG"
    coloredlogs.install(
        level=verbose, fmt="%(asctime)s %(levelname)s %(message)s", datefmt="%H:%M:%S"
    )


@main.command("analyze", short_help="analyze provided data directory")
@click.argument("root", type=click.Path(exists=True))
@click.pass_context
def analyze(ctx, root):
    def _try_dataset_flavors(root):
        try:
            return SPIMDataset(root, refactor=False)
        except spim_error.SettingsNotFoundError:
            logger.info("not generated by SPIM")

        try:
            return MicroManagerDataset(root)
        except mm_error.NoMetadataInTileFolderError:
            logger.info("not generated by Micro-Manager")

        raise RuntimeError("unable to determine dataset flavor")

    ds = _try_dataset_flavors(root)
    print(ds.metadata)

@main.command("preview", short_help="generate preview")
@click.argument("root", type=click.Path(exists=True))
@click.option("--shrink", type=int, default=1)
# @click.option("--format", type=click.Choice(["mp4", "tif"]))
@click.pass_context
def preview(ctx, root, shrink):
    ds = FolderDatastore(
        root, read_func=imageio.volread, pattern="*5a_ch0_*", extensions=["tif"]
    )
    # dummy read
    ny, nx = next(iter(ds.values())).max(axis=0).shape

    # expand path
    root = os.path.abspath(root)
    parent, basename = os.path.dirname(root), os.path.basename(root)
    out_path = os.path.join(parent, "{}.mp4".format(basename))

    # invoke ffmpeg
    ffmpeg_process = (
        ffmpeg.input(
            "pipe:", format="rawvideo", pix_fmt="gray", s="{}x{}".format(nx, ny)
        )
        .output(out_path, pix_fmt="gray")
        .overwrite_output()
        .run_async(pipe_stdin=True)
    )

    u8_max = np.iinfo(np.uint8).max
    for key, im in ds.items():
        logger.info(key)

        with Orthogonal(np.asarray(im)) as data_ortho:
            data = data_ortho.xy

        # in
        data = data.astype(np.float32)

        # normalize
        m, M = data.min(), data.max()
        data = (data - m) / (M - m)
        data *= u8_max

        print(data.dtype)

        # out
        data = data.astype(np.uint8)

        ffmpeg_process.stdin.write(data.tobytes())

    ffmpeg_process.stdin.close()
    ffmpeg_process.wait()


if __name__ == "__main__":
    main(obj={})
