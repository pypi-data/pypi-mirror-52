# coding: utf-8

"""
    Budgea API Documentation

    see https://www.budget-insight.com/budgea-api  # noqa: E501

    OpenAPI spec version: 2.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from budgea.api_client import ApiClient


class BanksApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def account_types_get(self, **kwargs):  # noqa: E501
        """Get account types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.account_types_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: AccountTypesList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.account_types_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.account_types_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def account_types_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get account types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.account_types_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: AccountTypesList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method account_types_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/account_types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountTypesList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def account_types_id_account_type_get(self, id_account_type, **kwargs):  # noqa: E501
        """Get an account type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.account_types_id_account_type_get(id_account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_account_type: (required)
        :param str expand:
        :return: AccountType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.account_types_id_account_type_get_with_http_info(id_account_type, **kwargs)  # noqa: E501
        else:
            (data) = self.account_types_id_account_type_get_with_http_info(id_account_type, **kwargs)  # noqa: E501
            return data

    def account_types_id_account_type_get_with_http_info(self, id_account_type, **kwargs):  # noqa: E501
        """Get an account type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.account_types_id_account_type_get_with_http_info(id_account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_account_type: (required)
        :param str expand:
        :return: AccountType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_account_type', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method account_types_id_account_type_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_account_type' is set
        if ('id_account_type' not in local_var_params or
                local_var_params['id_account_type'] is None):
            raise ValueError("Missing the required parameter `id_account_type` when calling `account_types_id_account_type_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_account_type' in local_var_params:
            path_params['id_account_type'] = local_var_params['id_account_type']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/account_types/{id_account_type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def banks_categories_id_category_delete(self, id_category, **kwargs):  # noqa: E501
        """Delete the supplied category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_categories_id_category_delete(id_category, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_category: (required)
        :param str expand:
        :return: ConnectorCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.banks_categories_id_category_delete_with_http_info(id_category, **kwargs)  # noqa: E501
        else:
            (data) = self.banks_categories_id_category_delete_with_http_info(id_category, **kwargs)  # noqa: E501
            return data

    def banks_categories_id_category_delete_with_http_info(self, id_category, **kwargs):  # noqa: E501
        """Delete the supplied category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_categories_id_category_delete_with_http_info(id_category, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_category: (required)
        :param str expand:
        :return: ConnectorCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_category', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method banks_categories_id_category_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_category' is set
        if ('id_category' not in local_var_params or
                local_var_params['id_category'] is None):
            raise ValueError("Missing the required parameter `id_category` when calling `banks_categories_id_category_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_category' in local_var_params:
            path_params['id_category'] = local_var_params['id_category']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/banks/categories/{id_category}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorCategory',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def banks_categories_id_category_post(self, id_category, unknown_base_type, **kwargs):  # noqa: E501
        """Edit a bank categories  # noqa: E501

        Edit the name for the supplied category.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_categories_id_category_post(id_category, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_category: (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: ConnectorCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.banks_categories_id_category_post_with_http_info(id_category, unknown_base_type, **kwargs)  # noqa: E501
        else:
            (data) = self.banks_categories_id_category_post_with_http_info(id_category, unknown_base_type, **kwargs)  # noqa: E501
            return data

    def banks_categories_id_category_post_with_http_info(self, id_category, unknown_base_type, **kwargs):  # noqa: E501
        """Edit a bank categories  # noqa: E501

        Edit the name for the supplied category.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_categories_id_category_post_with_http_info(id_category, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_category: (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: ConnectorCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_category', 'unknown_base_type', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method banks_categories_id_category_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_category' is set
        if ('id_category' not in local_var_params or
                local_var_params['id_category'] is None):
            raise ValueError("Missing the required parameter `id_category` when calling `banks_categories_id_category_post`")  # noqa: E501
        # verify the required parameter 'unknown_base_type' is set
        if ('unknown_base_type' not in local_var_params or
                local_var_params['unknown_base_type'] is None):
            raise ValueError("Missing the required parameter `unknown_base_type` when calling `banks_categories_id_category_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_category' in local_var_params:
            path_params['id_category'] = local_var_params['id_category']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/banks/categories/{id_category}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorCategory',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def banks_categories_post(self, unknown_base_type, **kwargs):  # noqa: E501
        """Create bank categories  # noqa: E501

        It requires the name of the category to be created<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_categories_post(unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: ConnectorCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.banks_categories_post_with_http_info(unknown_base_type, **kwargs)  # noqa: E501
        else:
            (data) = self.banks_categories_post_with_http_info(unknown_base_type, **kwargs)  # noqa: E501
            return data

    def banks_categories_post_with_http_info(self, unknown_base_type, **kwargs):  # noqa: E501
        """Create bank categories  # noqa: E501

        It requires the name of the category to be created<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_categories_post_with_http_info(unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: ConnectorCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['unknown_base_type', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method banks_categories_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'unknown_base_type' is set
        if ('unknown_base_type' not in local_var_params or
                local_var_params['unknown_base_type'] is None):
            raise ValueError("Missing the required parameter `unknown_base_type` when calling `banks_categories_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/banks/categories', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorCategory',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def banks_get(self, **kwargs):  # noqa: E501
        """Get list of connectors  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.banks_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.banks_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def banks_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get list of connectors  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method banks_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/banks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def banks_id_connector_connections_get(self, id_connector, **kwargs):  # noqa: E501
        """Get a subset of id_connection with the largest diversity of account  # noqa: E501

        By default, it selects a set of 3 connections.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_id_connector_connections_get(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param int range: the length of the connection subset
        :param int type: to target a specific account type which will be
        :param int occurrences: require at least N accounts of the targeted
        :param str expand:
        :return: ConnectionsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.banks_id_connector_connections_get_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.banks_id_connector_connections_get_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def banks_id_connector_connections_get_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Get a subset of id_connection with the largest diversity of account  # noqa: E501

        By default, it selects a set of 3 connections.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_id_connector_connections_get_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param int range: the length of the connection subset
        :param int type: to target a specific account type which will be
        :param int occurrences: require at least N accounts of the targeted
        :param str expand:
        :return: ConnectionsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'range', 'type', 'occurrences', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method banks_id_connector_connections_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `banks_id_connector_connections_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'range' in local_var_params:
            query_params.append(('range', local_var_params['range']))  # noqa: E501
        if 'type' in local_var_params:
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'occurrences' in local_var_params:
            query_params.append(('occurrences', local_var_params['occurrences']))  # noqa: E501
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/banks/{id_connector}/connections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectionsList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def banks_id_connector_logos_get(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_id_connector_logos_get(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.banks_id_connector_logos_get_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.banks_id_connector_logos_get_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def banks_id_connector_logos_get_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_id_connector_logos_get_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method banks_id_connector_logos_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `banks_id_connector_logos_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/banks/{id_connector}/logos', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorLogosList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def banks_id_connector_logos_main_get(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_id_connector_logos_main_get(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.banks_id_connector_logos_main_get_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.banks_id_connector_logos_main_get_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def banks_id_connector_logos_main_get_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_id_connector_logos_main_get_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method banks_id_connector_logos_main_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `banks_id_connector_logos_main_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/banks/{id_connector}/logos/main', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorLogosList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def banks_id_connector_logos_thumbnail_get(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_id_connector_logos_thumbnail_get(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.banks_id_connector_logos_thumbnail_get_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.banks_id_connector_logos_thumbnail_get_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def banks_id_connector_logos_thumbnail_get_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.banks_id_connector_logos_thumbnail_get_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method banks_id_connector_logos_thumbnail_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `banks_id_connector_logos_thumbnail_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/banks/{id_connector}/logos/thumbnail', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorLogosList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def categories_get(self, **kwargs):  # noqa: E501
        """Get all categories  # noqa: E501

        Ressource to get all existing categories<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.categories_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: CategoriesList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.categories_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.categories_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def categories_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all categories  # noqa: E501

        Ressource to get all existing categories<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.categories_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: CategoriesList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method categories_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CategoriesList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def categories_keywords_id_keyword_delete(self, id_keyword, **kwargs):  # noqa: E501
        """Delete a particular key-value pair on a transaction.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.categories_keywords_id_keyword_delete(id_keyword, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_keyword: (required)
        :param str expand:
        :return: Keyword
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.categories_keywords_id_keyword_delete_with_http_info(id_keyword, **kwargs)  # noqa: E501
        else:
            (data) = self.categories_keywords_id_keyword_delete_with_http_info(id_keyword, **kwargs)  # noqa: E501
            return data

    def categories_keywords_id_keyword_delete_with_http_info(self, id_keyword, **kwargs):  # noqa: E501
        """Delete a particular key-value pair on a transaction.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.categories_keywords_id_keyword_delete_with_http_info(id_keyword, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_keyword: (required)
        :param str expand:
        :return: Keyword
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_keyword', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method categories_keywords_id_keyword_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_keyword' is set
        if ('id_keyword' not in local_var_params or
                local_var_params['id_keyword'] is None):
            raise ValueError("Missing the required parameter `id_keyword` when calling `categories_keywords_id_keyword_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_keyword' in local_var_params:
            path_params['id_keyword'] = local_var_params['id_keyword']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/categories/keywords/{id_keyword}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Keyword',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def categories_keywords_post(self, **kwargs):  # noqa: E501
        """Add a new keyword associated with a category in the database.  # noqa: E501

        If the keyword already exists the keyword is not added. Used for the categorization of transactions.<br><br>Form params: - id_category (integer): a reference towards the category associated with the keyword - keyword (string): the searched keyword - income (bool): 1 if the associated category represents an income else 0 - priority (integer): sets the priority for the keyword, used when categorizing<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.categories_keywords_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: Keyword
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.categories_keywords_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.categories_keywords_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def categories_keywords_post_with_http_info(self, **kwargs):  # noqa: E501
        """Add a new keyword associated with a category in the database.  # noqa: E501

        If the keyword already exists the keyword is not added. Used for the categorization of transactions.<br><br>Form params: - id_category (integer): a reference towards the category associated with the keyword - keyword (string): the searched keyword - income (bool): 1 if the associated category represents an income else 0 - priority (integer): sets the priority for the keyword, used when categorizing<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.categories_keywords_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: Keyword
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method categories_keywords_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/categories/keywords', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Keyword',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def categorize_post(self, unknown_base_type, **kwargs):  # noqa: E501
        """categorize transactions without storing them  # noqa: E501

        It requires an array of transaction dictionaries. Any fields of transactions that are not required will be kept in the response. The response contains the list of transactions with two more fields: id_category and state (it indicates how the transaction has been categorized)<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.categorize_post(unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.categorize_post_with_http_info(unknown_base_type, **kwargs)  # noqa: E501
        else:
            (data) = self.categorize_post_with_http_info(unknown_base_type, **kwargs)  # noqa: E501
            return data

    def categorize_post_with_http_info(self, unknown_base_type, **kwargs):  # noqa: E501
        """categorize transactions without storing them  # noqa: E501

        It requires an array of transaction dictionaries. Any fields of transactions that are not required will be kept in the response. The response contains the list of transactions with two more fields: id_category and state (it indicates how the transaction has been categorized)<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.categorize_post_with_http_info(unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['unknown_base_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method categorize_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'unknown_base_type' is set
        if ('unknown_base_type' not in local_var_params or
                local_var_params['unknown_base_type'] is None):
            raise ValueError("Missing the required parameter `unknown_base_type` when calling `categorize_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'failed', 'total', 'transactions'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/categorize', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def connections_get(self, **kwargs):  # noqa: E501
        """Get connections without a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connections_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: ConnectionsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.connections_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.connections_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def connections_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get connections without a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connections_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: ConnectionsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connections_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/connections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectionsList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def connectors_get(self, **kwargs):  # noqa: E501
        """Get list of connectors  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.connectors_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.connectors_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def connectors_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get list of connectors  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connectors_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/connectors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def connectors_id_connector_logos_get(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_get(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.connectors_id_connector_logos_get_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.connectors_id_connector_logos_get_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def connectors_id_connector_logos_get_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_get_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connectors_id_connector_logos_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `connectors_id_connector_logos_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/connectors/{id_connector}/logos', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorLogosList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def connectors_id_connector_logos_id_logo_delete(self, id_connector, id_logo, **kwargs):  # noqa: E501
        """Delete a single Logo object.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_id_logo_delete(id_connector, id_logo, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param int id_logo: (required)
        :param str expand:
        :return: ConnectorLogo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.connectors_id_connector_logos_id_logo_delete_with_http_info(id_connector, id_logo, **kwargs)  # noqa: E501
        else:
            (data) = self.connectors_id_connector_logos_id_logo_delete_with_http_info(id_connector, id_logo, **kwargs)  # noqa: E501
            return data

    def connectors_id_connector_logos_id_logo_delete_with_http_info(self, id_connector, id_logo, **kwargs):  # noqa: E501
        """Delete a single Logo object.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_id_logo_delete_with_http_info(id_connector, id_logo, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param int id_logo: (required)
        :param str expand:
        :return: ConnectorLogo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'id_logo', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connectors_id_connector_logos_id_logo_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `connectors_id_connector_logos_id_logo_delete`")  # noqa: E501
        # verify the required parameter 'id_logo' is set
        if ('id_logo' not in local_var_params or
                local_var_params['id_logo'] is None):
            raise ValueError("Missing the required parameter `id_logo` when calling `connectors_id_connector_logos_id_logo_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501
        if 'id_logo' in local_var_params:
            path_params['id_logo'] = local_var_params['id_logo']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/connectors/{id_connector}/logos/{id_logo}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorLogo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def connectors_id_connector_logos_id_logo_put(self, id_connector, id_logo, **kwargs):  # noqa: E501
        """Create or Update a connector Logo.  # noqa: E501

        This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_id_logo_put(id_connector, id_logo, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param int id_logo: (required)
        :param str expand:
        :return: ConnectorLogo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.connectors_id_connector_logos_id_logo_put_with_http_info(id_connector, id_logo, **kwargs)  # noqa: E501
        else:
            (data) = self.connectors_id_connector_logos_id_logo_put_with_http_info(id_connector, id_logo, **kwargs)  # noqa: E501
            return data

    def connectors_id_connector_logos_id_logo_put_with_http_info(self, id_connector, id_logo, **kwargs):  # noqa: E501
        """Create or Update a connector Logo.  # noqa: E501

        This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_id_logo_put_with_http_info(id_connector, id_logo, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param int id_logo: (required)
        :param str expand:
        :return: ConnectorLogo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'id_logo', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connectors_id_connector_logos_id_logo_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `connectors_id_connector_logos_id_logo_put`")  # noqa: E501
        # verify the required parameter 'id_logo' is set
        if ('id_logo' not in local_var_params or
                local_var_params['id_logo'] is None):
            raise ValueError("Missing the required parameter `id_logo` when calling `connectors_id_connector_logos_id_logo_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501
        if 'id_logo' in local_var_params:
            path_params['id_logo'] = local_var_params['id_logo']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/connectors/{id_connector}/logos/{id_logo}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorLogo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def connectors_id_connector_logos_main_get(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_main_get(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.connectors_id_connector_logos_main_get_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.connectors_id_connector_logos_main_get_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def connectors_id_connector_logos_main_get_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_main_get_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connectors_id_connector_logos_main_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `connectors_id_connector_logos_main_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/connectors/{id_connector}/logos/main', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorLogosList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def connectors_id_connector_logos_post(self, id_connector, **kwargs):  # noqa: E501
        """Create a connector Logo  # noqa: E501

        This endpoint creates a connector logo. You can either pass a file to as a parameter to insert and link it with the connector or pass an id_file to link a connector with an existing file. Will fail if the file is already linked with that connector.<br><br>Form params: - id_file (integer): The id of the file to link with that connector. - img (string): Path to the image to link with that connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_post(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.connectors_id_connector_logos_post_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.connectors_id_connector_logos_post_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def connectors_id_connector_logos_post_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Create a connector Logo  # noqa: E501

        This endpoint creates a connector logo. You can either pass a file to as a parameter to insert and link it with the connector or pass an id_file to link a connector with an existing file. Will fail if the file is already linked with that connector.<br><br>Form params: - id_file (integer): The id of the file to link with that connector. - img (string): Path to the image to link with that connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_post_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connectors_id_connector_logos_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `connectors_id_connector_logos_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/connectors/{id_connector}/logos', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorLogo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def connectors_id_connector_logos_put(self, id_connector, **kwargs):  # noqa: E501
        """Create or Update a connector Logo  # noqa: E501

        This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_put(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.connectors_id_connector_logos_put_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.connectors_id_connector_logos_put_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def connectors_id_connector_logos_put_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Create or Update a connector Logo  # noqa: E501

        This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_put_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connectors_id_connector_logos_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `connectors_id_connector_logos_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/connectors/{id_connector}/logos', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorLogo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def connectors_id_connector_logos_thumbnail_get(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_thumbnail_get(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.connectors_id_connector_logos_thumbnail_get_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.connectors_id_connector_logos_thumbnail_get_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def connectors_id_connector_logos_thumbnail_get_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_logos_thumbnail_get_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connectors_id_connector_logos_thumbnail_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `connectors_id_connector_logos_thumbnail_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/connectors/{id_connector}/logos/thumbnail', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorLogosList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def connectors_id_connector_put(self, id_connector, **kwargs):  # noqa: E501
        """Edit the provided connector  # noqa: E501

        <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_put(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Connector
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.connectors_id_connector_put_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.connectors_id_connector_put_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def connectors_id_connector_put_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Edit the provided connector  # noqa: E501

        <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_id_connector_put_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Connector
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'expand', 'unknown_base_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connectors_id_connector_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `connectors_id_connector_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'beta', 'capabilities', 'categories', 'charged', 'code', 'color', 'hidden', 'id', 'name', 'slug', 'sync_frequency'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/connectors/{id_connector}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Connector',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def connectors_post(self, unknown_base_type, **kwargs):  # noqa: E501
        """Request a new connector  # noqa: E501

        Send a request to add a new connector<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_post(unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Connector
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.connectors_post_with_http_info(unknown_base_type, **kwargs)  # noqa: E501
        else:
            (data) = self.connectors_post_with_http_info(unknown_base_type, **kwargs)  # noqa: E501
            return data

    def connectors_post_with_http_info(self, unknown_base_type, **kwargs):  # noqa: E501
        """Request a new connector  # noqa: E501

        Send a request to add a new connector<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connectors_post_with_http_info(unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Connector
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['unknown_base_type', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connectors_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'unknown_base_type' is set
        if ('unknown_base_type' not in local_var_params or
                local_var_params['unknown_base_type'] is None):
            raise ValueError("Missing the required parameter `unknown_base_type` when calling `connectors_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/connectors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Connector',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def invoicing_get(self, **kwargs):  # noqa: E501
        """Get number of accounts, connections and users synced.  # noqa: E501

        Get number of accounts, connections and users synced between two dates for the given period.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.invoicing_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param date min_date: minimal date
        :param date max_date: maximum date
        :param str period: period to group logs
        :param str all: get full ids list instead of numbers
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.invoicing_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.invoicing_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def invoicing_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get number of accounts, connections and users synced.  # noqa: E501

        Get number of accounts, connections and users synced between two dates for the given period.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.invoicing_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param date min_date: minimal date
        :param date max_date: maximum date
        :param str period: period to group logs
        :param str all: get full ids list instead of numbers
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['min_date', 'max_date', 'period', 'all']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method invoicing_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'min_date' in local_var_params:
            query_params.append(('min_date', local_var_params['min_date']))  # noqa: E501
        if 'max_date' in local_var_params:
            query_params.append(('max_date', local_var_params['max_date']))  # noqa: E501
        if 'period' in local_var_params:
            query_params.append(('period', local_var_params['period']))  # noqa: E501
        if 'all' in local_var_params:
            query_params.append(('all', local_var_params['all']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/invoicing', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def logs_get(self, **kwargs):  # noqa: E501
        """Get connection logs  # noqa: E501

        Get logs about connections.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal date
        :param date max_date: maximum date
        :param int state: state of user
        :param str period: period to group logs
        :param int id_user: ID of a user
        :param int id_connection: ID of a connection
        :param int id_connector: ID of a connector
        :param bool charged: consider only logs for charged connectors
        :param str expand:
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.logs_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.logs_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def logs_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get connection logs  # noqa: E501

        Get logs about connections.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal date
        :param date max_date: maximum date
        :param int state: state of user
        :param str period: period to group logs
        :param int id_user: ID of a user
        :param int id_connection: ID of a connection
        :param int id_connector: ID of a connector
        :param bool charged: consider only logs for charged connectors
        :param str expand:
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['limit', 'offset', 'min_date', 'max_date', 'state', 'period', 'id_user', 'id_connection', 'id_connector', 'charged', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in local_var_params:
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'min_date' in local_var_params:
            query_params.append(('min_date', local_var_params['min_date']))  # noqa: E501
        if 'max_date' in local_var_params:
            query_params.append(('max_date', local_var_params['max_date']))  # noqa: E501
        if 'state' in local_var_params:
            query_params.append(('state', local_var_params['state']))  # noqa: E501
        if 'period' in local_var_params:
            query_params.append(('period', local_var_params['period']))  # noqa: E501
        if 'id_user' in local_var_params:
            query_params.append(('id_user', local_var_params['id_user']))  # noqa: E501
        if 'id_connection' in local_var_params:
            query_params.append(('id_connection', local_var_params['id_connection']))  # noqa: E501
        if 'id_connector' in local_var_params:
            query_params.append(('id_connector', local_var_params['id_connector']))  # noqa: E501
        if 'charged' in local_var_params:
            query_params.append(('charged', local_var_params['charged']))  # noqa: E501
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def providers_get(self, **kwargs):  # noqa: E501
        """Get list of connectors  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.providers_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.providers_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.providers_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def providers_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get list of connectors  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.providers_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand:
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/providers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def providers_id_connector_connections_get(self, id_connector, **kwargs):  # noqa: E501
        """Get a random subset of provider's id_connection  # noqa: E501

        By default, it selects a set of 3 connections.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.providers_id_connector_connections_get(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param int range: the length of the connection subset
        :param str expand:
        :return: ConnectionsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.providers_id_connector_connections_get_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.providers_id_connector_connections_get_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def providers_id_connector_connections_get_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Get a random subset of provider's id_connection  # noqa: E501

        By default, it selects a set of 3 connections.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.providers_id_connector_connections_get_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param int range: the length of the connection subset
        :param str expand:
        :return: ConnectionsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'range', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_id_connector_connections_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `providers_id_connector_connections_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'range' in local_var_params:
            query_params.append(('range', local_var_params['range']))  # noqa: E501
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/providers/{id_connector}/connections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectionsList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def providers_id_connector_logos_get(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.providers_id_connector_logos_get(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.providers_id_connector_logos_get_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.providers_id_connector_logos_get_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def providers_id_connector_logos_get_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.providers_id_connector_logos_get_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_id_connector_logos_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `providers_id_connector_logos_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/providers/{id_connector}/logos', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorLogosList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def providers_id_connector_logos_main_get(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.providers_id_connector_logos_main_get(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.providers_id_connector_logos_main_get_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.providers_id_connector_logos_main_get_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def providers_id_connector_logos_main_get_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.providers_id_connector_logos_main_get_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_id_connector_logos_main_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `providers_id_connector_logos_main_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/providers/{id_connector}/logos/main', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorLogosList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def providers_id_connector_logos_thumbnail_get(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.providers_id_connector_logos_thumbnail_get(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.providers_id_connector_logos_thumbnail_get_with_http_info(id_connector, **kwargs)  # noqa: E501
        else:
            (data) = self.providers_id_connector_logos_thumbnail_get_with_http_info(id_connector, **kwargs)  # noqa: E501
            return data

    def providers_id_connector_logos_thumbnail_get_with_http_info(self, id_connector, **kwargs):  # noqa: E501
        """Get all links to the files associated with this connector.  # noqa: E501

        This endpoint returns all links to files associated with this connector.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.providers_id_connector_logos_thumbnail_get_with_http_info(id_connector, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_connector: (required)
        :param str expand:
        :return: ConnectorLogosList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_connector', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_id_connector_logos_thumbnail_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_connector' is set
        if ('id_connector' not in local_var_params or
                local_var_params['id_connector'] is None):
            raise ValueError("Missing the required parameter `id_connector` when calling `providers_id_connector_logos_thumbnail_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_connector' in local_var_params:
            path_params['id_connector'] = local_var_params['id_connector']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/providers/{id_connector}/logos/thumbnail', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorLogosList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_account_types_get(self, id_user, **kwargs):  # noqa: E501
        """Get account types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_account_types_get(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: AccountTypesList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_account_types_get_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_account_types_get_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_account_types_get_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Get account types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_account_types_get_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: AccountTypesList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_account_types_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_account_types_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/account_types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountTypesList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_account_types_id_account_type_get(self, id_user, id_account_type, **kwargs):  # noqa: E501
        """Get an account type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_account_types_id_account_type_get(id_user, id_account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account_type: (required)
        :param str expand:
        :return: AccountType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_account_types_id_account_type_get_with_http_info(id_user, id_account_type, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_account_types_id_account_type_get_with_http_info(id_user, id_account_type, **kwargs)  # noqa: E501
            return data

    def users_id_user_account_types_id_account_type_get_with_http_info(self, id_user, id_account_type, **kwargs):  # noqa: E501
        """Get an account type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_account_types_id_account_type_get_with_http_info(id_user, id_account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account_type: (required)
        :param str expand:
        :return: AccountType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account_type', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_account_types_id_account_type_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_account_types_id_account_type_get`")  # noqa: E501
        # verify the required parameter 'id_account_type' is set
        if ('id_account_type' not in local_var_params or
                local_var_params['id_account_type'] is None):
            raise ValueError("Missing the required parameter `id_account_type` when calling `users_id_user_account_types_id_account_type_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account_type' in local_var_params:
            path_params['id_account_type'] = local_var_params['id_account_type']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/account_types/{id_account_type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_delete(self, id_user, **kwargs):  # noqa: E501
        """Delete all accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_delete(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_delete_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_delete_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_delete_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Delete all accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_delete_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_get(self, id_user, **kwargs):  # noqa: E501
        """Get accounts list.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_get(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_get_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_get_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_get_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Get accounts list.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_get_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_categories_get(self, id_user, id_account, **kwargs):  # noqa: E501
        """Get the category  # noqa: E501

        Ressource to get categories for the user's transactions<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_categories_get(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_categories_get_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_categories_get_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_categories_get_with_http_info(self, id_user, id_account, **kwargs):  # noqa: E501
        """Get the category  # noqa: E501

        Ressource to get categories for the user's transactions<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_categories_get_with_http_info(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_categories_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_categories_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_categories_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_delete(self, id_user, id_account, **kwargs):  # noqa: E501
        """Delete an account.  # noqa: E501

        It deletes a specific account.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_delete(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_delete_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_delete_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_delete_with_http_info(self, id_user, id_account, **kwargs):  # noqa: E501
        """Delete an account.  # noqa: E501

        It deletes a specific account.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_delete_with_http_info(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_delete`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_delta_get(self, id_user, id_account, **kwargs):  # noqa: E501
        """Get deltas of accounts  # noqa: E501

        Get account delta between sums of transactions and difference of account balance for the given period.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_delta_get(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param date min_date: minimal date
        :param date max_date: maximum date
        :param str period: period to group logs
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_delta_get_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_delta_get_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_delta_get_with_http_info(self, id_user, id_account, **kwargs):  # noqa: E501
        """Get deltas of accounts  # noqa: E501

        Get account delta between sums of transactions and difference of account balance for the given period.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_delta_get_with_http_info(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param date min_date: minimal date
        :param date max_date: maximum date
        :param str period: period to group logs
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'min_date', 'max_date', 'period']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_delta_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_delta_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_delta_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'min_date' in local_var_params:
            query_params.append(('min_date', local_var_params['min_date']))  # noqa: E501
        if 'max_date' in local_var_params:
            query_params.append(('max_date', local_var_params['max_date']))  # noqa: E501
        if 'period' in local_var_params:
            query_params.append(('period', local_var_params['period']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/delta', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_logs_get(self, id_user, id_account, **kwargs):  # noqa: E501
        """Get accounts logs.  # noqa: E501

        Get logs of account.<br><br>By default, it selects logs for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_logs_get(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal (inclusive) date
        :param date max_date: maximum (inclusive) date
        :param str expand:
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_logs_get_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_logs_get_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_logs_get_with_http_info(self, id_user, id_account, **kwargs):  # noqa: E501
        """Get accounts logs.  # noqa: E501

        Get logs of account.<br><br>By default, it selects logs for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_logs_get_with_http_info(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal (inclusive) date
        :param date max_date: maximum (inclusive) date
        :param str expand:
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'limit', 'offset', 'min_date', 'max_date', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_logs_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params:
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'min_date' in local_var_params:
            query_params.append(('min_date', local_var_params['min_date']))  # noqa: E501
        if 'max_date' in local_var_params:
            query_params.append(('max_date', local_var_params['max_date']))  # noqa: E501
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20025',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_put(self, id_user, id_account, **kwargs):  # noqa: E501
        """Update an account  # noqa: E501

        It updates a specific account<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_put(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_put_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_put_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_put_with_http_info(self, id_user, id_account, **kwargs):  # noqa: E501
        """Update an account  # noqa: E501

        It updates a specific account<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_put_with_http_info(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'expand', 'unknown_base_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_put`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_transactions_delete(self, id_user, id_account, **kwargs):  # noqa: E501
        """Delete transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_delete(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_transactions_delete_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_transactions_delete_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_transactions_delete_with_http_info(self, id_user, id_account, **kwargs):  # noqa: E501
        """Delete transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_delete_with_http_info(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_transactions_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_transactions_delete`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_transactions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/transactions', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transaction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_transactions_get(self, id_user, id_account, **kwargs):  # noqa: E501
        """Get transactions  # noqa: E501

        Get list of transactions.<br><br>By default, it selects transactions for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_get(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal (inclusive) date
        :param date max_date: maximum (inclusive) date
        :param bool income: filter on income or expenditures
        :param bool deleted: display only deleted transactions
        :param bool all: display all transactions, including deleted ones
        :param datetime last_update: get only transactions updated after the specified datetime
        :param str wording: filter transactions containing the given string
        :param float min_value: minimal (inclusive) value
        :param float max_value: maximum (inclusive) value
        :param str search: search in labels, dates, values and categories
        :param str value: \"XX|-XX\" or \"XX\"
        :param str expand:
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_transactions_get_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_transactions_get_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_transactions_get_with_http_info(self, id_user, id_account, **kwargs):  # noqa: E501
        """Get transactions  # noqa: E501

        Get list of transactions.<br><br>By default, it selects transactions for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_get_with_http_info(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal (inclusive) date
        :param date max_date: maximum (inclusive) date
        :param bool income: filter on income or expenditures
        :param bool deleted: display only deleted transactions
        :param bool all: display all transactions, including deleted ones
        :param datetime last_update: get only transactions updated after the specified datetime
        :param str wording: filter transactions containing the given string
        :param float min_value: minimal (inclusive) value
        :param float max_value: maximum (inclusive) value
        :param str search: search in labels, dates, values and categories
        :param str value: \"XX|-XX\" or \"XX\"
        :param str expand:
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'limit', 'offset', 'min_date', 'max_date', 'income', 'deleted', 'all', 'last_update', 'wording', 'min_value', 'max_value', 'search', 'value', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_transactions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_transactions_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_transactions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params:
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'min_date' in local_var_params:
            query_params.append(('min_date', local_var_params['min_date']))  # noqa: E501
        if 'max_date' in local_var_params:
            query_params.append(('max_date', local_var_params['max_date']))  # noqa: E501
        if 'income' in local_var_params:
            query_params.append(('income', local_var_params['income']))  # noqa: E501
        if 'deleted' in local_var_params:
            query_params.append(('deleted', local_var_params['deleted']))  # noqa: E501
        if 'all' in local_var_params:
            query_params.append(('all', local_var_params['all']))  # noqa: E501
        if 'last_update' in local_var_params:
            query_params.append(('last_update', local_var_params['last_update']))  # noqa: E501
        if 'wording' in local_var_params:
            query_params.append(('wording', local_var_params['wording']))  # noqa: E501
        if 'min_value' in local_var_params:
            query_params.append(('min_value', local_var_params['min_value']))  # noqa: E501
        if 'max_value' in local_var_params:
            query_params.append(('max_value', local_var_params['max_value']))  # noqa: E501
        if 'search' in local_var_params:
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'value' in local_var_params:
            query_params.append(('value', local_var_params['value']))  # noqa: E501
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/transactions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20029',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_transactions_id_transaction_informations_delete(self, id_user, id_account, id_transaction, **kwargs):  # noqa: E501
        """Delete all arbitrary key-value pairs of a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_id_transaction_informations_delete(id_user, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_transactions_id_transaction_informations_delete_with_http_info(id_user, id_account, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_transactions_id_transaction_informations_delete_with_http_info(id_user, id_account, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_transactions_id_transaction_informations_delete_with_http_info(self, id_user, id_account, id_transaction, **kwargs):  # noqa: E501
        """Delete all arbitrary key-value pairs of a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_id_transaction_informations_delete_with_http_info(id_user, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'id_transaction', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_transactions_id_transaction_informations_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_delete`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_delete`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/transactions/{id_transaction}/informations', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_transactions_id_transaction_informations_get(self, id_user, id_account, id_transaction, **kwargs):  # noqa: E501
        """List all arbitrary key-value pairs on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_id_transaction_informations_get(id_user, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_transactions_id_transaction_informations_get_with_http_info(id_user, id_account, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_transactions_id_transaction_informations_get_with_http_info(id_user, id_account, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_transactions_id_transaction_informations_get_with_http_info(self, id_user, id_account, id_transaction, **kwargs):  # noqa: E501
        """List all arbitrary key-value pairs on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_id_transaction_informations_get_with_http_info(id_user, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'id_transaction', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_transactions_id_transaction_informations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_get`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/transactions/{id_transaction}/informations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20031',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_delete(self, id_user, id_account, id_transaction, id_information, **kwargs):  # noqa: E501
        """Delete a particular key-value pair on a transaction.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_delete(id_user, id_account, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_delete_with_http_info(id_user, id_account, id_transaction, id_information, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_delete_with_http_info(id_user, id_account, id_transaction, id_information, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_delete_with_http_info(self, id_user, id_account, id_transaction, id_information, **kwargs):  # noqa: E501
        """Delete a particular key-value pair on a transaction.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_delete_with_http_info(id_user, id_account, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'id_transaction', 'id_information', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501
        # verify the required parameter 'id_information' is set
        if ('id_information' not in local_var_params or
                local_var_params['id_information'] is None):
            raise ValueError("Missing the required parameter `id_information` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501
        if 'id_information' in local_var_params:
            path_params['id_information'] = local_var_params['id_information']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/transactions/{id_transaction}/informations/{id_information}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_get(self, id_user, id_account, id_transaction, id_information, **kwargs):  # noqa: E501
        """Get a particular arbitrary key-value pair on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_get(id_user, id_account, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_get_with_http_info(id_user, id_account, id_transaction, id_information, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_get_with_http_info(id_user, id_account, id_transaction, id_information, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_get_with_http_info(self, id_user, id_account, id_transaction, id_information, **kwargs):  # noqa: E501
        """Get a particular arbitrary key-value pair on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_get_with_http_info(id_user, id_account, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'id_transaction', 'id_information', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_get`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_get`")  # noqa: E501
        # verify the required parameter 'id_information' is set
        if ('id_information' not in local_var_params or
                local_var_params['id_information'] is None):
            raise ValueError("Missing the required parameter `id_information` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_id_information_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501
        if 'id_information' in local_var_params:
            path_params['id_information'] = local_var_params['id_information']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/transactions/{id_transaction}/informations/{id_information}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_transactions_id_transaction_informations_put(self, id_user, id_account, id_transaction, **kwargs):  # noqa: E501
        """Add or edit transaction arbitrary key-value pairs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_id_transaction_informations_put(id_user, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_transactions_id_transaction_informations_put_with_http_info(id_user, id_account, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_transactions_id_transaction_informations_put_with_http_info(id_user, id_account, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_transactions_id_transaction_informations_put_with_http_info(self, id_user, id_account, id_transaction, **kwargs):  # noqa: E501
        """Add or edit transaction arbitrary key-value pairs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_id_transaction_informations_put_with_http_info(id_user, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'id_transaction', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_transactions_id_transaction_informations_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_put`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_put`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_accounts_id_account_transactions_id_transaction_informations_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/transactions/{id_transaction}/informations', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_transactions_id_transaction_put(self, id_user, id_account, id_transaction, **kwargs):  # noqa: E501
        """Edit a transaction meta-data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_id_transaction_put(id_user, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_transactions_id_transaction_put_with_http_info(id_user, id_account, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_transactions_id_transaction_put_with_http_info(id_user, id_account, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_transactions_id_transaction_put_with_http_info(self, id_user, id_account, id_transaction, **kwargs):  # noqa: E501
        """Edit a transaction meta-data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_id_transaction_put_with_http_info(id_user, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'id_transaction', 'expand', 'unknown_base_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_transactions_id_transaction_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_transactions_id_transaction_put`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_transactions_id_transaction_put`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_accounts_id_account_transactions_id_transaction_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/transactions/{id_transaction}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transaction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_transactions_post(self, id_user, id_account, unknown_base_type, **kwargs):  # noqa: E501
        """Create transactions  # noqa: E501

        Create transactions for the supplied account or the account whose id is given with form parameters. It requires an array of transaction dictionaries.<br><br><br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_post(id_user, id_account, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_transactions_post_with_http_info(id_user, id_account, unknown_base_type, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_transactions_post_with_http_info(id_user, id_account, unknown_base_type, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_transactions_post_with_http_info(self, id_user, id_account, unknown_base_type, **kwargs):  # noqa: E501
        """Create transactions  # noqa: E501

        Create transactions for the supplied account or the account whose id is given with form parameters. It requires an array of transaction dictionaries.<br><br><br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactions_post_with_http_info(id_user, id_account, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'unknown_base_type', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_transactions_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_transactions_post`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_transactions_post`")  # noqa: E501
        # verify the required parameter 'unknown_base_type' is set
        if ('unknown_base_type' not in local_var_params or
                local_var_params['unknown_base_type'] is None):
            raise ValueError("Missing the required parameter `unknown_base_type` when calling `users_id_user_accounts_id_account_transactions_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/transactions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transaction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_transactionsclusters_get(self, id_user, id_account, **kwargs):  # noqa: E501
        """Get clustered transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactionsclusters_get(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param str expand:
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_transactionsclusters_get_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_transactionsclusters_get_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_transactionsclusters_get_with_http_info(self, id_user, id_account, **kwargs):  # noqa: E501
        """Get clustered transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactionsclusters_get_with_http_info(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param str expand:
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_transactionsclusters_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_transactionsclusters_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_transactionsclusters_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/transactionsclusters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20032',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_delete(self, id_user, id_account, id_transactionscluster, **kwargs):  # noqa: E501
        """Delete a clustered transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_delete(id_user, id_account, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_delete_with_http_info(id_user, id_account, id_transactionscluster, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_delete_with_http_info(id_user, id_account, id_transactionscluster, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_delete_with_http_info(self, id_user, id_account, id_transactionscluster, **kwargs):  # noqa: E501
        """Delete a clustered transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_delete_with_http_info(id_user, id_account, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'id_transactionscluster', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_delete`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_delete`")  # noqa: E501
        # verify the required parameter 'id_transactionscluster' is set
        if ('id_transactionscluster' not in local_var_params or
                local_var_params['id_transactionscluster'] is None):
            raise ValueError("Missing the required parameter `id_transactionscluster` when calling `users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transactionscluster' in local_var_params:
            path_params['id_transactionscluster'] = local_var_params['id_transactionscluster']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionsCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_put(self, id_user, id_account, id_transactionscluster, **kwargs):  # noqa: E501
        """Edit a clustered transaction  # noqa: E501

        Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_put(id_user, id_account, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_put_with_http_info(id_user, id_account, id_transactionscluster, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_put_with_http_info(id_user, id_account, id_transactionscluster, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_put_with_http_info(self, id_user, id_account, id_transactionscluster, **kwargs):  # noqa: E501
        """Edit a clustered transaction  # noqa: E501

        Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_put_with_http_info(id_user, id_account, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'id_transactionscluster', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_put`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_put`")  # noqa: E501
        # verify the required parameter 'id_transactionscluster' is set
        if ('id_transactionscluster' not in local_var_params or
                local_var_params['id_transactionscluster'] is None):
            raise ValueError("Missing the required parameter `id_transactionscluster` when calling `users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transactionscluster' in local_var_params:
            path_params['id_transactionscluster'] = local_var_params['id_transactionscluster']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionsCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_id_account_transactionsclusters_post(self, id_user, id_account, **kwargs):  # noqa: E501
        """Create clustered transaction  # noqa: E501

        Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactionsclusters_post(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_id_account_transactionsclusters_post_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_id_account_transactionsclusters_post_with_http_info(id_user, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_id_account_transactionsclusters_post_with_http_info(self, id_user, id_account, **kwargs):  # noqa: E501
        """Create clustered transaction  # noqa: E501

        Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_id_account_transactionsclusters_post_with_http_info(id_user, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_account: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_account', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_id_account_transactionsclusters_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_id_account_transactionsclusters_post`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_accounts_id_account_transactionsclusters_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts/{id_account}/transactionsclusters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionsCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_post(self, id_user, unknown_base_type, **kwargs):  # noqa: E501
        """Create an account  # noqa: E501

        This endpoint creates an account related to a connection or not.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_post(id_user, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_post_with_http_info(id_user, unknown_base_type, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_post_with_http_info(id_user, unknown_base_type, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_post_with_http_info(self, id_user, unknown_base_type, **kwargs):  # noqa: E501
        """Create an account  # noqa: E501

        This endpoint creates an account related to a connection or not.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_post_with_http_info(id_user, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'unknown_base_type', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_post`")  # noqa: E501
        # verify the required parameter 'unknown_base_type' is set
        if ('unknown_base_type' not in local_var_params or
                local_var_params['unknown_base_type'] is None):
            raise ValueError("Missing the required parameter `unknown_base_type` when calling `users_id_user_accounts_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_accounts_put(self, id_user, **kwargs):  # noqa: E501
        """Update many accounts at once  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_put(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_accounts_put_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_accounts_put_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_accounts_put_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Update many accounts at once  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_accounts_put_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_accounts_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_accounts_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/accounts', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_alerts_get(self, id_user, **kwargs):  # noqa: E501
        """Get alerts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_alerts_get(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: InlineResponse20033
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_alerts_get_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_alerts_get_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_alerts_get_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Get alerts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_alerts_get_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: InlineResponse20033
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_alerts_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_alerts_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20033',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_categories_full_get(self, id_user, **kwargs):  # noqa: E501
        """Get the category  # noqa: E501

        Ressource to get categories<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_categories_full_get(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: InlineResponse20034
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_categories_full_get_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_categories_full_get_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_categories_full_get_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Get the category  # noqa: E501

        Ressource to get categories<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_categories_full_get_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: InlineResponse20034
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_categories_full_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_categories_full_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/categories/full', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20034',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_categories_full_id_full_delete(self, id_user, id_full, **kwargs):  # noqa: E501
        """Delete a user-created transaction category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_categories_full_id_full_delete(id_user, id_full, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_full: (required)
        :param str expand:
        :return: Category
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_categories_full_id_full_delete_with_http_info(id_user, id_full, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_categories_full_id_full_delete_with_http_info(id_user, id_full, **kwargs)  # noqa: E501
            return data

    def users_id_user_categories_full_id_full_delete_with_http_info(self, id_user, id_full, **kwargs):  # noqa: E501
        """Delete a user-created transaction category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_categories_full_id_full_delete_with_http_info(id_user, id_full, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_full: (required)
        :param str expand:
        :return: Category
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_full', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_categories_full_id_full_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_categories_full_id_full_delete`")  # noqa: E501
        # verify the required parameter 'id_full' is set
        if ('id_full' not in local_var_params or
                local_var_params['id_full'] is None):
            raise ValueError("Missing the required parameter `id_full` when calling `users_id_user_categories_full_id_full_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_full' in local_var_params:
            path_params['id_full'] = local_var_params['id_full']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/categories/full/{id_full}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Category',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_categories_full_id_full_put(self, id_user, id_full, **kwargs):  # noqa: E501
        """Modify a user-created category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_categories_full_id_full_put(id_user, id_full, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_full: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Category
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_categories_full_id_full_put_with_http_info(id_user, id_full, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_categories_full_id_full_put_with_http_info(id_user, id_full, **kwargs)  # noqa: E501
            return data

    def users_id_user_categories_full_id_full_put_with_http_info(self, id_user, id_full, **kwargs):  # noqa: E501
        """Modify a user-created category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_categories_full_id_full_put_with_http_info(id_user, id_full, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_full: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Category
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_full', 'expand', 'unknown_base_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_categories_full_id_full_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_categories_full_id_full_put`")  # noqa: E501
        # verify the required parameter 'id_full' is set
        if ('id_full' not in local_var_params or
                local_var_params['id_full'] is None):
            raise ValueError("Missing the required parameter `id_full` when calling `users_id_user_categories_full_id_full_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_full' in local_var_params:
            path_params['id_full'] = local_var_params['id_full']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/categories/full/{id_full}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Category',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_categories_full_post(self, id_user, **kwargs):  # noqa: E501
        """Create a new transaction category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_categories_full_post(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Category
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_categories_full_post_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_categories_full_post_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_categories_full_post_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Create a new transaction category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_categories_full_post_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Category
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'expand', 'unknown_base_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_categories_full_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_categories_full_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/categories/full', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Category',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_categories_get(self, id_user, **kwargs):  # noqa: E501
        """Get the category  # noqa: E501

        Ressource to get categories for the user's transactions<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_categories_get(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_categories_get_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_categories_get_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_categories_get_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Get the category  # noqa: E501

        Ressource to get categories for the user's transactions<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_categories_get_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_categories_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_categories_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_delete(self, id_user, **kwargs):  # noqa: E501
        """Delete all connections  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_delete(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_delete_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_delete_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_delete_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Delete all connections  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_delete_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Connection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_get(self, id_user, **kwargs):  # noqa: E501
        """Get connections  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_get(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: ConnectionsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_get_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_get_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_get_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Get connections  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_get_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: ConnectionsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectionsList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_delete(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Delete all accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_delete(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_delete_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_delete_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_delete_with_http_info(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Delete all accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_delete_with_http_info(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_delete`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_get(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Get accounts list.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_get(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_get_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_get_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_get_with_http_info(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Get accounts list.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_get_with_http_info(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_categories_get(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Get the category  # noqa: E501

        Ressource to get categories for the user's transactions<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_categories_get(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_categories_get_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_categories_get_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_categories_get_with_http_info(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Get the category  # noqa: E501

        Ressource to get categories for the user's transactions<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_categories_get_with_http_info(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_categories_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_categories_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_categories_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_categories_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_delete(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Delete an account.  # noqa: E501

        It deletes a specific account.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_delete(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_delete_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_delete_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_delete_with_http_info(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Delete an account.  # noqa: E501

        It deletes a specific account.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_delete_with_http_info(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_delete`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_delete`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_delta_get(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Get deltas of accounts  # noqa: E501

        Get account delta between sums of transactions and difference of account balance for the given period.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_delta_get(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param date min_date: minimal date
        :param date max_date: maximum date
        :param str period: period to group logs
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_delta_get_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_delta_get_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_delta_get_with_http_info(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Get deltas of accounts  # noqa: E501

        Get account delta between sums of transactions and difference of account balance for the given period.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_delta_get_with_http_info(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param date min_date: minimal date
        :param date max_date: maximum date
        :param str period: period to group logs
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'min_date', 'max_date', 'period']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_delta_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_delta_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_delta_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_delta_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'min_date' in local_var_params:
            query_params.append(('min_date', local_var_params['min_date']))  # noqa: E501
        if 'max_date' in local_var_params:
            query_params.append(('max_date', local_var_params['max_date']))  # noqa: E501
        if 'period' in local_var_params:
            query_params.append(('period', local_var_params['period']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/delta', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_logs_get(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Get accounts logs.  # noqa: E501

        Get logs of account.<br><br>By default, it selects logs for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_logs_get(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal (inclusive) date
        :param date max_date: maximum (inclusive) date
        :param str expand:
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_logs_get_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_logs_get_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_logs_get_with_http_info(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Get accounts logs.  # noqa: E501

        Get logs of account.<br><br>By default, it selects logs for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_logs_get_with_http_info(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal (inclusive) date
        :param date max_date: maximum (inclusive) date
        :param str expand:
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'limit', 'offset', 'min_date', 'max_date', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_logs_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_logs_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params:
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'min_date' in local_var_params:
            query_params.append(('min_date', local_var_params['min_date']))  # noqa: E501
        if 'max_date' in local_var_params:
            query_params.append(('max_date', local_var_params['max_date']))  # noqa: E501
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20025',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_put(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Update an account  # noqa: E501

        It updates a specific account<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_put(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_put_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_put_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_put_with_http_info(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Update an account  # noqa: E501

        It updates a specific account<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_put_with_http_info(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'expand', 'unknown_base_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_put`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_put`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_transactions_delete(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Delete transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_delete(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_transactions_delete_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_transactions_delete_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_transactions_delete_with_http_info(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Delete transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_delete_with_http_info(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_transactions_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_delete`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_delete`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transaction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_transactions_get(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Get transactions  # noqa: E501

        Get list of transactions.<br><br>By default, it selects transactions for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_get(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal (inclusive) date
        :param date max_date: maximum (inclusive) date
        :param bool income: filter on income or expenditures
        :param bool deleted: display only deleted transactions
        :param bool all: display all transactions, including deleted ones
        :param datetime last_update: get only transactions updated after the specified datetime
        :param str wording: filter transactions containing the given string
        :param float min_value: minimal (inclusive) value
        :param float max_value: maximum (inclusive) value
        :param str search: search in labels, dates, values and categories
        :param str value: \"XX|-XX\" or \"XX\"
        :param str expand:
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_transactions_get_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_transactions_get_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_transactions_get_with_http_info(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Get transactions  # noqa: E501

        Get list of transactions.<br><br>By default, it selects transactions for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_get_with_http_info(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal (inclusive) date
        :param date max_date: maximum (inclusive) date
        :param bool income: filter on income or expenditures
        :param bool deleted: display only deleted transactions
        :param bool all: display all transactions, including deleted ones
        :param datetime last_update: get only transactions updated after the specified datetime
        :param str wording: filter transactions containing the given string
        :param float min_value: minimal (inclusive) value
        :param float max_value: maximum (inclusive) value
        :param str search: search in labels, dates, values and categories
        :param str value: \"XX|-XX\" or \"XX\"
        :param str expand:
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'limit', 'offset', 'min_date', 'max_date', 'income', 'deleted', 'all', 'last_update', 'wording', 'min_value', 'max_value', 'search', 'value', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_transactions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params:
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'min_date' in local_var_params:
            query_params.append(('min_date', local_var_params['min_date']))  # noqa: E501
        if 'max_date' in local_var_params:
            query_params.append(('max_date', local_var_params['max_date']))  # noqa: E501
        if 'income' in local_var_params:
            query_params.append(('income', local_var_params['income']))  # noqa: E501
        if 'deleted' in local_var_params:
            query_params.append(('deleted', local_var_params['deleted']))  # noqa: E501
        if 'all' in local_var_params:
            query_params.append(('all', local_var_params['all']))  # noqa: E501
        if 'last_update' in local_var_params:
            query_params.append(('last_update', local_var_params['last_update']))  # noqa: E501
        if 'wording' in local_var_params:
            query_params.append(('wording', local_var_params['wording']))  # noqa: E501
        if 'min_value' in local_var_params:
            query_params.append(('min_value', local_var_params['min_value']))  # noqa: E501
        if 'max_value' in local_var_params:
            query_params.append(('max_value', local_var_params['max_value']))  # noqa: E501
        if 'search' in local_var_params:
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'value' in local_var_params:
            query_params.append(('value', local_var_params['value']))  # noqa: E501
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20029',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_delete(self, id_user, id_connection, id_account, id_transaction, **kwargs):  # noqa: E501
        """Delete all arbitrary key-value pairs of a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_delete(id_user, id_connection, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_delete_with_http_info(id_user, id_connection, id_account, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_delete_with_http_info(id_user, id_connection, id_account, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_delete_with_http_info(self, id_user, id_connection, id_account, id_transaction, **kwargs):  # noqa: E501
        """Delete all arbitrary key-value pairs of a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_delete_with_http_info(id_user, id_connection, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'id_transaction', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_delete`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_delete`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_delete`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_get(self, id_user, id_connection, id_account, id_transaction, **kwargs):  # noqa: E501
        """List all arbitrary key-value pairs on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_get(id_user, id_connection, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_get_with_http_info(id_user, id_connection, id_account, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_get_with_http_info(id_user, id_connection, id_account, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_get_with_http_info(self, id_user, id_connection, id_account, id_transaction, **kwargs):  # noqa: E501
        """List all arbitrary key-value pairs on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_get_with_http_info(id_user, id_connection, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'id_transaction', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_get`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20031',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_delete(self, id_user, id_connection, id_account, id_transaction, id_information, **kwargs):  # noqa: E501
        """Delete a particular key-value pair on a transaction.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_delete(id_user, id_connection, id_account, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_delete_with_http_info(id_user, id_connection, id_account, id_transaction, id_information, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_delete_with_http_info(id_user, id_connection, id_account, id_transaction, id_information, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_delete_with_http_info(self, id_user, id_connection, id_account, id_transaction, id_information, **kwargs):  # noqa: E501
        """Delete a particular key-value pair on a transaction.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_delete_with_http_info(id_user, id_connection, id_account, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'id_transaction', 'id_information', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501
        # verify the required parameter 'id_information' is set
        if ('id_information' not in local_var_params or
                local_var_params['id_information'] is None):
            raise ValueError("Missing the required parameter `id_information` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501
        if 'id_information' in local_var_params:
            path_params['id_information'] = local_var_params['id_information']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations/{id_information}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_get(self, id_user, id_connection, id_account, id_transaction, id_information, **kwargs):  # noqa: E501
        """Get a particular arbitrary key-value pair on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_get(id_user, id_connection, id_account, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_get_with_http_info(id_user, id_connection, id_account, id_transaction, id_information, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_get_with_http_info(id_user, id_connection, id_account, id_transaction, id_information, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_get_with_http_info(self, id_user, id_connection, id_account, id_transaction, id_information, **kwargs):  # noqa: E501
        """Get a particular arbitrary key-value pair on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_get_with_http_info(id_user, id_connection, id_account, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'id_transaction', 'id_information', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_get`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_get`")  # noqa: E501
        # verify the required parameter 'id_information' is set
        if ('id_information' not in local_var_params or
                local_var_params['id_information'] is None):
            raise ValueError("Missing the required parameter `id_information` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501
        if 'id_information' in local_var_params:
            path_params['id_information'] = local_var_params['id_information']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations/{id_information}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_put(self, id_user, id_connection, id_account, id_transaction, **kwargs):  # noqa: E501
        """Add or edit transaction arbitrary key-value pairs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_put(id_user, id_connection, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_put_with_http_info(id_user, id_connection, id_account, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_put_with_http_info(id_user, id_connection, id_account, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_put_with_http_info(self, id_user, id_connection, id_account, id_transaction, **kwargs):  # noqa: E501
        """Add or edit transaction arbitrary key-value pairs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_put_with_http_info(id_user, id_connection, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'id_transaction', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_put`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_put`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_put`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_put(self, id_user, id_connection, id_account, id_transaction, **kwargs):  # noqa: E501
        """Edit a transaction meta-data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_put(id_user, id_connection, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_put_with_http_info(id_user, id_connection, id_account, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_put_with_http_info(id_user, id_connection, id_account, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_put_with_http_info(self, id_user, id_connection, id_account, id_transaction, **kwargs):  # noqa: E501
        """Edit a transaction meta-data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_put_with_http_info(id_user, id_connection, id_account, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transaction: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'id_transaction', 'expand', 'unknown_base_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_put`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_put`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_put`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transaction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_transactions_post(self, id_user, id_connection, id_account, unknown_base_type, **kwargs):  # noqa: E501
        """Create transactions  # noqa: E501

        Create transactions for the supplied account or the account whose id is given with form parameters. It requires an array of transaction dictionaries.<br><br><br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_post(id_user, id_connection, id_account, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_transactions_post_with_http_info(id_user, id_connection, id_account, unknown_base_type, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_transactions_post_with_http_info(id_user, id_connection, id_account, unknown_base_type, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_transactions_post_with_http_info(self, id_user, id_connection, id_account, unknown_base_type, **kwargs):  # noqa: E501
        """Create transactions  # noqa: E501

        Create transactions for the supplied account or the account whose id is given with form parameters. It requires an array of transaction dictionaries.<br><br><br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactions_post_with_http_info(id_user, id_connection, id_account, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'unknown_base_type', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_transactions_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_post`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_post`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_post`")  # noqa: E501
        # verify the required parameter 'unknown_base_type' is set
        if ('unknown_base_type' not in local_var_params or
                local_var_params['unknown_base_type'] is None):
            raise ValueError("Missing the required parameter `unknown_base_type` when calling `users_id_user_connections_id_connection_accounts_id_account_transactions_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transaction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_get(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Get clustered transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_get(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param str expand:
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_get_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_get_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_get_with_http_info(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Get clustered transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_get_with_http_info(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param str expand:
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_get`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20032',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_delete(self, id_user, id_connection, id_account, id_transactionscluster, **kwargs):  # noqa: E501
        """Delete a clustered transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_delete(id_user, id_connection, id_account, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_delete_with_http_info(id_user, id_connection, id_account, id_transactionscluster, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_delete_with_http_info(id_user, id_connection, id_account, id_transactionscluster, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_delete_with_http_info(self, id_user, id_connection, id_account, id_transactionscluster, **kwargs):  # noqa: E501
        """Delete a clustered transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_delete_with_http_info(id_user, id_connection, id_account, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'id_transactionscluster', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_delete`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_delete`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_delete`")  # noqa: E501
        # verify the required parameter 'id_transactionscluster' is set
        if ('id_transactionscluster' not in local_var_params or
                local_var_params['id_transactionscluster'] is None):
            raise ValueError("Missing the required parameter `id_transactionscluster` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transactionscluster' in local_var_params:
            path_params['id_transactionscluster'] = local_var_params['id_transactionscluster']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionsCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_put(self, id_user, id_connection, id_account, id_transactionscluster, **kwargs):  # noqa: E501
        """Edit a clustered transaction  # noqa: E501

        Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_put(id_user, id_connection, id_account, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_put_with_http_info(id_user, id_connection, id_account, id_transactionscluster, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_put_with_http_info(id_user, id_connection, id_account, id_transactionscluster, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_put_with_http_info(self, id_user, id_connection, id_account, id_transactionscluster, **kwargs):  # noqa: E501
        """Edit a clustered transaction  # noqa: E501

        Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_put_with_http_info(id_user, id_connection, id_account, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'id_transactionscluster', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_put`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_put`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_put`")  # noqa: E501
        # verify the required parameter 'id_transactionscluster' is set
        if ('id_transactionscluster' not in local_var_params or
                local_var_params['id_transactionscluster'] is None):
            raise ValueError("Missing the required parameter `id_transactionscluster` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501
        if 'id_transactionscluster' in local_var_params:
            path_params['id_transactionscluster'] = local_var_params['id_transactionscluster']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionsCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_post(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Create clustered transaction  # noqa: E501

        Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_post(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_post_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_post_with_http_info(id_user, id_connection, id_account, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_post_with_http_info(self, id_user, id_connection, id_account, **kwargs):  # noqa: E501
        """Create clustered transaction  # noqa: E501

        Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_post_with_http_info(id_user, id_connection, id_account, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_account: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_account', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_post`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_post`")  # noqa: E501
        # verify the required parameter 'id_account' is set
        if ('id_account' not in local_var_params or
                local_var_params['id_account'] is None):
            raise ValueError("Missing the required parameter `id_account` when calling `users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_account' in local_var_params:
            path_params['id_account'] = local_var_params['id_account']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionsCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_post(self, id_user, id_connection, unknown_base_type, **kwargs):  # noqa: E501
        """Create an account  # noqa: E501

        This endpoint creates an account related to a connection or not.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_post(id_user, id_connection, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_post_with_http_info(id_user, id_connection, unknown_base_type, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_post_with_http_info(id_user, id_connection, unknown_base_type, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_post_with_http_info(self, id_user, id_connection, unknown_base_type, **kwargs):  # noqa: E501
        """Create an account  # noqa: E501

        This endpoint creates an account related to a connection or not.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_post_with_http_info(id_user, id_connection, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'unknown_base_type', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_post`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_post`")  # noqa: E501
        # verify the required parameter 'unknown_base_type' is set
        if ('unknown_base_type' not in local_var_params or
                local_var_params['unknown_base_type'] is None):
            raise ValueError("Missing the required parameter `unknown_base_type` when calling `users_id_user_connections_id_connection_accounts_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_accounts_put(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Update many accounts at once  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_put(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_accounts_put_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_accounts_put_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_accounts_put_with_http_info(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Update many accounts at once  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_accounts_put_with_http_info(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_accounts_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_accounts_put`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_accounts_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/accounts', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_delete(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Delete a connection.  # noqa: E501

        This endpoint deletes a connection and all related accounts and transactions.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_delete(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_delete_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_delete_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_delete_with_http_info(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Delete a connection.  # noqa: E501

        This endpoint deletes a connection and all related accounts and transactions.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_delete_with_http_info(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_delete`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Connection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_informations_get(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Get connection additionnal informations  # noqa: E501

        <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_informations_get(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: ConnectionsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_informations_get_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_informations_get_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_informations_get_with_http_info(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Get connection additionnal informations  # noqa: E501

        <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_informations_get_with_http_info(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: ConnectionsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_informations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_informations_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_informations_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'compagny', 'owner'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/informations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectionsList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_logs_get(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Get connection logs  # noqa: E501

        Get logs about connections.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_logs_get(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal date
        :param date max_date: maximum date
        :param int state: state of user
        :param str period: period to group logs
        :param int id_user2: ID of a user
        :param int id_connection2: ID of a connection
        :param int id_connector: ID of a connector
        :param bool charged: consider only logs for charged connectors
        :param str expand:
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_logs_get_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_logs_get_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_logs_get_with_http_info(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Get connection logs  # noqa: E501

        Get logs about connections.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_logs_get_with_http_info(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal date
        :param date max_date: maximum date
        :param int state: state of user
        :param str period: period to group logs
        :param int id_user2: ID of a user
        :param int id_connection2: ID of a connection
        :param int id_connector: ID of a connector
        :param bool charged: consider only logs for charged connectors
        :param str expand:
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'limit', 'offset', 'min_date', 'max_date', 'state', 'period', 'id_user2', 'id_connection2', 'id_connector', 'charged', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_logs_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params:
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'min_date' in local_var_params:
            query_params.append(('min_date', local_var_params['min_date']))  # noqa: E501
        if 'max_date' in local_var_params:
            query_params.append(('max_date', local_var_params['max_date']))  # noqa: E501
        if 'state' in local_var_params:
            query_params.append(('state', local_var_params['state']))  # noqa: E501
        if 'period' in local_var_params:
            query_params.append(('period', local_var_params['period']))  # noqa: E501
        if 'id_user2' in local_var_params:
            query_params.append(('id_user', local_var_params['id_user2']))  # noqa: E501
        if 'id_connection2' in local_var_params:
            query_params.append(('id_connection', local_var_params['id_connection2']))  # noqa: E501
        if 'id_connector' in local_var_params:
            query_params.append(('id_connector', local_var_params['id_connector']))  # noqa: E501
        if 'charged' in local_var_params:
            query_params.append(('charged', local_var_params['charged']))  # noqa: E501
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_post(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Update a connection.  # noqa: E501

        Give new parameters to change on the configuration of this connection (for example \"password\").<br><br>It tests connection to website, and if it fails, a 400 response is given with the error code \"wrongpass\" or \"websiteUnavailable\".<br><br>You can also supply meta-parameters on connection, like 'active' or 'expire'.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_post(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_post_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_post_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_post_with_http_info(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Update a connection.  # noqa: E501

        Give new parameters to change on the configuration of this connection (for example \"password\").<br><br>It tests connection to website, and if it fails, a 400 response is given with the error code \"wrongpass\" or \"websiteUnavailable\".<br><br>You can also supply meta-parameters on connection, like 'active' or 'expire'.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_post_with_http_info(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'expand', 'unknown_base_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_post`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Connection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_put(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Force synchronisation of a connection.  # noqa: E501

        We suggest to pass parameter expand=accounts[transactions] to get all *new* and *updated* transactions.<br><br>Query params: - expand (string): fields to expand - last_update (dateTime): if supplied, get transactions inserted since this date<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_put(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_put_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_put_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_put_with_http_info(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Force synchronisation of a connection.  # noqa: E501

        We suggest to pass parameter expand=accounts[transactions] to get all *new* and *updated* transactions.<br><br>Query params: - expand (string): fields to expand - last_update (dateTime): if supplied, get transactions inserted since this date<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_put_with_http_info(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_put`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Connection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_transactions_delete(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Delete transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_delete(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_transactions_delete_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_transactions_delete_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_transactions_delete_with_http_info(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Delete transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_delete_with_http_info(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_transactions_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_transactions_delete`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_transactions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/transactions', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transaction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_transactions_get(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Get transactions  # noqa: E501

        Get list of transactions.<br><br>By default, it selects transactions for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_get(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal (inclusive) date
        :param date max_date: maximum (inclusive) date
        :param bool income: filter on income or expenditures
        :param bool deleted: display only deleted transactions
        :param bool all: display all transactions, including deleted ones
        :param datetime last_update: get only transactions updated after the specified datetime
        :param str wording: filter transactions containing the given string
        :param float min_value: minimal (inclusive) value
        :param float max_value: maximum (inclusive) value
        :param str search: search in labels, dates, values and categories
        :param str value: \"XX|-XX\" or \"XX\"
        :param str expand:
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_transactions_get_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_transactions_get_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_transactions_get_with_http_info(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Get transactions  # noqa: E501

        Get list of transactions.<br><br>By default, it selects transactions for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_get_with_http_info(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal (inclusive) date
        :param date max_date: maximum (inclusive) date
        :param bool income: filter on income or expenditures
        :param bool deleted: display only deleted transactions
        :param bool all: display all transactions, including deleted ones
        :param datetime last_update: get only transactions updated after the specified datetime
        :param str wording: filter transactions containing the given string
        :param float min_value: minimal (inclusive) value
        :param float max_value: maximum (inclusive) value
        :param str search: search in labels, dates, values and categories
        :param str value: \"XX|-XX\" or \"XX\"
        :param str expand:
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'limit', 'offset', 'min_date', 'max_date', 'income', 'deleted', 'all', 'last_update', 'wording', 'min_value', 'max_value', 'search', 'value', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_transactions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_transactions_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_transactions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params:
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'min_date' in local_var_params:
            query_params.append(('min_date', local_var_params['min_date']))  # noqa: E501
        if 'max_date' in local_var_params:
            query_params.append(('max_date', local_var_params['max_date']))  # noqa: E501
        if 'income' in local_var_params:
            query_params.append(('income', local_var_params['income']))  # noqa: E501
        if 'deleted' in local_var_params:
            query_params.append(('deleted', local_var_params['deleted']))  # noqa: E501
        if 'all' in local_var_params:
            query_params.append(('all', local_var_params['all']))  # noqa: E501
        if 'last_update' in local_var_params:
            query_params.append(('last_update', local_var_params['last_update']))  # noqa: E501
        if 'wording' in local_var_params:
            query_params.append(('wording', local_var_params['wording']))  # noqa: E501
        if 'min_value' in local_var_params:
            query_params.append(('min_value', local_var_params['min_value']))  # noqa: E501
        if 'max_value' in local_var_params:
            query_params.append(('max_value', local_var_params['max_value']))  # noqa: E501
        if 'search' in local_var_params:
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'value' in local_var_params:
            query_params.append(('value', local_var_params['value']))  # noqa: E501
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/transactions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20029',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_transactions_id_transaction_informations_delete(self, id_user, id_connection, id_transaction, **kwargs):  # noqa: E501
        """Delete all arbitrary key-value pairs of a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_id_transaction_informations_delete(id_user, id_connection, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_transactions_id_transaction_informations_delete_with_http_info(id_user, id_connection, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_transactions_id_transaction_informations_delete_with_http_info(id_user, id_connection, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_transactions_id_transaction_informations_delete_with_http_info(self, id_user, id_connection, id_transaction, **kwargs):  # noqa: E501
        """Delete all arbitrary key-value pairs of a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_id_transaction_informations_delete_with_http_info(id_user, id_connection, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_transaction', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_transactions_id_transaction_informations_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_delete`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_delete`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/transactions/{id_transaction}/informations', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_transactions_id_transaction_informations_get(self, id_user, id_connection, id_transaction, **kwargs):  # noqa: E501
        """List all arbitrary key-value pairs on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_id_transaction_informations_get(id_user, id_connection, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_transactions_id_transaction_informations_get_with_http_info(id_user, id_connection, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_transactions_id_transaction_informations_get_with_http_info(id_user, id_connection, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_transactions_id_transaction_informations_get_with_http_info(self, id_user, id_connection, id_transaction, **kwargs):  # noqa: E501
        """List all arbitrary key-value pairs on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_id_transaction_informations_get_with_http_info(id_user, id_connection, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_transaction', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_transactions_id_transaction_informations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_get`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/transactions/{id_transaction}/informations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20031',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_delete(self, id_user, id_connection, id_transaction, id_information, **kwargs):  # noqa: E501
        """Delete a particular key-value pair on a transaction.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_delete(id_user, id_connection, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_delete_with_http_info(id_user, id_connection, id_transaction, id_information, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_delete_with_http_info(id_user, id_connection, id_transaction, id_information, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_delete_with_http_info(self, id_user, id_connection, id_transaction, id_information, **kwargs):  # noqa: E501
        """Delete a particular key-value pair on a transaction.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_delete_with_http_info(id_user, id_connection, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_transaction', 'id_information', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501
        # verify the required parameter 'id_information' is set
        if ('id_information' not in local_var_params or
                local_var_params['id_information'] is None):
            raise ValueError("Missing the required parameter `id_information` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501
        if 'id_information' in local_var_params:
            path_params['id_information'] = local_var_params['id_information']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/transactions/{id_transaction}/informations/{id_information}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_get(self, id_user, id_connection, id_transaction, id_information, **kwargs):  # noqa: E501
        """Get a particular arbitrary key-value pair on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_get(id_user, id_connection, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_get_with_http_info(id_user, id_connection, id_transaction, id_information, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_get_with_http_info(id_user, id_connection, id_transaction, id_information, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_get_with_http_info(self, id_user, id_connection, id_transaction, id_information, **kwargs):  # noqa: E501
        """Get a particular arbitrary key-value pair on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_get_with_http_info(id_user, id_connection, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_transaction', 'id_information', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_get`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_get`")  # noqa: E501
        # verify the required parameter 'id_information' is set
        if ('id_information' not in local_var_params or
                local_var_params['id_information'] is None):
            raise ValueError("Missing the required parameter `id_information` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_id_information_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501
        if 'id_information' in local_var_params:
            path_params['id_information'] = local_var_params['id_information']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/transactions/{id_transaction}/informations/{id_information}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_transactions_id_transaction_informations_put(self, id_user, id_connection, id_transaction, **kwargs):  # noqa: E501
        """Add or edit transaction arbitrary key-value pairs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_id_transaction_informations_put(id_user, id_connection, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_transactions_id_transaction_informations_put_with_http_info(id_user, id_connection, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_transactions_id_transaction_informations_put_with_http_info(id_user, id_connection, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_transactions_id_transaction_informations_put_with_http_info(self, id_user, id_connection, id_transaction, **kwargs):  # noqa: E501
        """Add or edit transaction arbitrary key-value pairs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_id_transaction_informations_put_with_http_info(id_user, id_connection, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_transaction', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_transactions_id_transaction_informations_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_put`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_put`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_connections_id_connection_transactions_id_transaction_informations_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/transactions/{id_transaction}/informations', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_transactions_id_transaction_put(self, id_user, id_connection, id_transaction, **kwargs):  # noqa: E501
        """Edit a transaction meta-data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_id_transaction_put(id_user, id_connection, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transaction: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_transactions_id_transaction_put_with_http_info(id_user, id_connection, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_transactions_id_transaction_put_with_http_info(id_user, id_connection, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_transactions_id_transaction_put_with_http_info(self, id_user, id_connection, id_transaction, **kwargs):  # noqa: E501
        """Edit a transaction meta-data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_id_transaction_put_with_http_info(id_user, id_connection, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transaction: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_transaction', 'expand', 'unknown_base_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_transactions_id_transaction_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_transactions_id_transaction_put`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_transactions_id_transaction_put`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_connections_id_connection_transactions_id_transaction_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/transactions/{id_transaction}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transaction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_transactions_post(self, id_user, id_connection, unknown_base_type, **kwargs):  # noqa: E501
        """Create transactions  # noqa: E501

        Create transactions for the supplied account or the account whose id is given with form parameters. It requires an array of transaction dictionaries.<br><br><br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_post(id_user, id_connection, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_transactions_post_with_http_info(id_user, id_connection, unknown_base_type, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_transactions_post_with_http_info(id_user, id_connection, unknown_base_type, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_transactions_post_with_http_info(self, id_user, id_connection, unknown_base_type, **kwargs):  # noqa: E501
        """Create transactions  # noqa: E501

        Create transactions for the supplied account or the account whose id is given with form parameters. It requires an array of transaction dictionaries.<br><br><br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactions_post_with_http_info(id_user, id_connection, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'unknown_base_type', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_transactions_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_transactions_post`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_transactions_post`")  # noqa: E501
        # verify the required parameter 'unknown_base_type' is set
        if ('unknown_base_type' not in local_var_params or
                local_var_params['unknown_base_type'] is None):
            raise ValueError("Missing the required parameter `unknown_base_type` when calling `users_id_user_connections_id_connection_transactions_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/transactions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transaction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_transactionsclusters_get(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Get clustered transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactionsclusters_get(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_transactionsclusters_get_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_transactionsclusters_get_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_transactionsclusters_get_with_http_info(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Get clustered transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactionsclusters_get_with_http_info(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_transactionsclusters_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_transactionsclusters_get`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_transactionsclusters_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/transactionsclusters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20032',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_delete(self, id_user, id_connection, id_transactionscluster, **kwargs):  # noqa: E501
        """Delete a clustered transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_delete(id_user, id_connection, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_delete_with_http_info(id_user, id_connection, id_transactionscluster, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_delete_with_http_info(id_user, id_connection, id_transactionscluster, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_delete_with_http_info(self, id_user, id_connection, id_transactionscluster, **kwargs):  # noqa: E501
        """Delete a clustered transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_delete_with_http_info(id_user, id_connection, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_transactionscluster', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_delete`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_delete`")  # noqa: E501
        # verify the required parameter 'id_transactionscluster' is set
        if ('id_transactionscluster' not in local_var_params or
                local_var_params['id_transactionscluster'] is None):
            raise ValueError("Missing the required parameter `id_transactionscluster` when calling `users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_transactionscluster' in local_var_params:
            path_params['id_transactionscluster'] = local_var_params['id_transactionscluster']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/transactionsclusters/{id_transactionscluster}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionsCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_put(self, id_user, id_connection, id_transactionscluster, **kwargs):  # noqa: E501
        """Edit a clustered transaction  # noqa: E501

        Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_put(id_user, id_connection, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_put_with_http_info(id_user, id_connection, id_transactionscluster, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_put_with_http_info(id_user, id_connection, id_transactionscluster, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_put_with_http_info(self, id_user, id_connection, id_transactionscluster, **kwargs):  # noqa: E501
        """Edit a clustered transaction  # noqa: E501

        Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_put_with_http_info(id_user, id_connection, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'id_transactionscluster', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_put`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_put`")  # noqa: E501
        # verify the required parameter 'id_transactionscluster' is set
        if ('id_transactionscluster' not in local_var_params or
                local_var_params['id_transactionscluster'] is None):
            raise ValueError("Missing the required parameter `id_transactionscluster` when calling `users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501
        if 'id_transactionscluster' in local_var_params:
            path_params['id_transactionscluster'] = local_var_params['id_transactionscluster']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/transactionsclusters/{id_transactionscluster}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionsCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_id_connection_transactionsclusters_post(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Create clustered transaction  # noqa: E501

        Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactionsclusters_post(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_id_connection_transactionsclusters_post_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_id_connection_transactionsclusters_post_with_http_info(id_user, id_connection, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_id_connection_transactionsclusters_post_with_http_info(self, id_user, id_connection, **kwargs):  # noqa: E501
        """Create clustered transaction  # noqa: E501

        Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_id_connection_transactionsclusters_post_with_http_info(id_user, id_connection, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_connection: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_connection', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_id_connection_transactionsclusters_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_id_connection_transactionsclusters_post`")  # noqa: E501
        # verify the required parameter 'id_connection' is set
        if ('id_connection' not in local_var_params or
                local_var_params['id_connection'] is None):
            raise ValueError("Missing the required parameter `id_connection` when calling `users_id_user_connections_id_connection_transactionsclusters_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_connection' in local_var_params:
            path_params['id_connection'] = local_var_params['id_connection']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections/{id_connection}/transactionsclusters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionsCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_connections_post(self, id_user, **kwargs):  # noqa: E501
        """Add a new connection.  # noqa: E501

        Create a new connection to a given bank or provider. You have to give all needed parameters (use /banks/ID/fields or /providers/ID/fields to get them).<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_post(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_connections_post_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_connections_post_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_connections_post_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Add a new connection.  # noqa: E501

        Create a new connection to a given bank or provider. You have to give all needed parameters (use /banks/ID/fields or /providers/ID/fields to get them).<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_connections_post_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'expand', 'unknown_base_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_connections_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_connections_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/connections', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Connection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_forecast_get(self, id_user, **kwargs):  # noqa: E501
        """Get forecast  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_forecast_get(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_forecast_get_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_forecast_get_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_forecast_get_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Get forecast  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_forecast_get_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_forecast_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_forecast_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/forecast', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_logs_get(self, id_user, **kwargs):  # noqa: E501
        """Get connection logs  # noqa: E501

        Get logs about connections.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_logs_get(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal date
        :param date max_date: maximum date
        :param int state: state of user
        :param str period: period to group logs
        :param int id_user2: ID of a user
        :param int id_connection: ID of a connection
        :param int id_connector: ID of a connector
        :param bool charged: consider only logs for charged connectors
        :param str expand:
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_logs_get_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_logs_get_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_logs_get_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Get connection logs  # noqa: E501

        Get logs about connections.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_logs_get_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal date
        :param date max_date: maximum date
        :param int state: state of user
        :param str period: period to group logs
        :param int id_user2: ID of a user
        :param int id_connection: ID of a connection
        :param int id_connector: ID of a connector
        :param bool charged: consider only logs for charged connectors
        :param str expand:
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'limit', 'offset', 'min_date', 'max_date', 'state', 'period', 'id_user2', 'id_connection', 'id_connector', 'charged', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params:
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'min_date' in local_var_params:
            query_params.append(('min_date', local_var_params['min_date']))  # noqa: E501
        if 'max_date' in local_var_params:
            query_params.append(('max_date', local_var_params['max_date']))  # noqa: E501
        if 'state' in local_var_params:
            query_params.append(('state', local_var_params['state']))  # noqa: E501
        if 'period' in local_var_params:
            query_params.append(('period', local_var_params['period']))  # noqa: E501
        if 'id_user2' in local_var_params:
            query_params.append(('id_user', local_var_params['id_user2']))  # noqa: E501
        if 'id_connection' in local_var_params:
            query_params.append(('id_connection', local_var_params['id_connection']))  # noqa: E501
        if 'id_connector' in local_var_params:
            query_params.append(('id_connector', local_var_params['id_connector']))  # noqa: E501
        if 'charged' in local_var_params:
            query_params.append(('charged', local_var_params['charged']))  # noqa: E501
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_transactions_delete(self, id_user, **kwargs):  # noqa: E501
        """Delete transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_delete(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_transactions_delete_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_transactions_delete_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_transactions_delete_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Delete transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_delete_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_transactions_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_transactions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/transactions', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transaction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_transactions_get(self, id_user, **kwargs):  # noqa: E501
        """Get transactions  # noqa: E501

        Get list of transactions.<br><br>By default, it selects transactions for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_get(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal (inclusive) date
        :param date max_date: maximum (inclusive) date
        :param bool income: filter on income or expenditures
        :param bool deleted: display only deleted transactions
        :param bool all: display all transactions, including deleted ones
        :param datetime last_update: get only transactions updated after the specified datetime
        :param str wording: filter transactions containing the given string
        :param float min_value: minimal (inclusive) value
        :param float max_value: maximum (inclusive) value
        :param str search: search in labels, dates, values and categories
        :param str value: \"XX|-XX\" or \"XX\"
        :param str expand:
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_transactions_get_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_transactions_get_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_transactions_get_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Get transactions  # noqa: E501

        Get list of transactions.<br><br>By default, it selects transactions for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_get_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int limit: limit number of results
        :param int offset: offset of first result
        :param date min_date: minimal (inclusive) date
        :param date max_date: maximum (inclusive) date
        :param bool income: filter on income or expenditures
        :param bool deleted: display only deleted transactions
        :param bool all: display all transactions, including deleted ones
        :param datetime last_update: get only transactions updated after the specified datetime
        :param str wording: filter transactions containing the given string
        :param float min_value: minimal (inclusive) value
        :param float max_value: maximum (inclusive) value
        :param str search: search in labels, dates, values and categories
        :param str value: \"XX|-XX\" or \"XX\"
        :param str expand:
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'limit', 'offset', 'min_date', 'max_date', 'income', 'deleted', 'all', 'last_update', 'wording', 'min_value', 'max_value', 'search', 'value', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_transactions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_transactions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params:
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'min_date' in local_var_params:
            query_params.append(('min_date', local_var_params['min_date']))  # noqa: E501
        if 'max_date' in local_var_params:
            query_params.append(('max_date', local_var_params['max_date']))  # noqa: E501
        if 'income' in local_var_params:
            query_params.append(('income', local_var_params['income']))  # noqa: E501
        if 'deleted' in local_var_params:
            query_params.append(('deleted', local_var_params['deleted']))  # noqa: E501
        if 'all' in local_var_params:
            query_params.append(('all', local_var_params['all']))  # noqa: E501
        if 'last_update' in local_var_params:
            query_params.append(('last_update', local_var_params['last_update']))  # noqa: E501
        if 'wording' in local_var_params:
            query_params.append(('wording', local_var_params['wording']))  # noqa: E501
        if 'min_value' in local_var_params:
            query_params.append(('min_value', local_var_params['min_value']))  # noqa: E501
        if 'max_value' in local_var_params:
            query_params.append(('max_value', local_var_params['max_value']))  # noqa: E501
        if 'search' in local_var_params:
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'value' in local_var_params:
            query_params.append(('value', local_var_params['value']))  # noqa: E501
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/transactions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20029',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_transactions_id_transaction_informations_delete(self, id_user, id_transaction, **kwargs):  # noqa: E501
        """Delete all arbitrary key-value pairs of a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_id_transaction_informations_delete(id_user, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_transactions_id_transaction_informations_delete_with_http_info(id_user, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_transactions_id_transaction_informations_delete_with_http_info(id_user, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_transactions_id_transaction_informations_delete_with_http_info(self, id_user, id_transaction, **kwargs):  # noqa: E501
        """Delete all arbitrary key-value pairs of a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_id_transaction_informations_delete_with_http_info(id_user, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_transaction', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_transactions_id_transaction_informations_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_transactions_id_transaction_informations_delete`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_transactions_id_transaction_informations_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/transactions/{id_transaction}/informations', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_transactions_id_transaction_informations_get(self, id_user, id_transaction, **kwargs):  # noqa: E501
        """List all arbitrary key-value pairs on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_id_transaction_informations_get(id_user, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_transactions_id_transaction_informations_get_with_http_info(id_user, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_transactions_id_transaction_informations_get_with_http_info(id_user, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_transactions_id_transaction_informations_get_with_http_info(self, id_user, id_transaction, **kwargs):  # noqa: E501
        """List all arbitrary key-value pairs on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_id_transaction_informations_get_with_http_info(id_user, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_transaction', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_transactions_id_transaction_informations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_transactions_id_transaction_informations_get`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_transactions_id_transaction_informations_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/transactions/{id_transaction}/informations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20031',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_transactions_id_transaction_informations_id_information_delete(self, id_user, id_transaction, id_information, **kwargs):  # noqa: E501
        """Delete a particular key-value pair on a transaction.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_id_transaction_informations_id_information_delete(id_user, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_transactions_id_transaction_informations_id_information_delete_with_http_info(id_user, id_transaction, id_information, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_transactions_id_transaction_informations_id_information_delete_with_http_info(id_user, id_transaction, id_information, **kwargs)  # noqa: E501
            return data

    def users_id_user_transactions_id_transaction_informations_id_information_delete_with_http_info(self, id_user, id_transaction, id_information, **kwargs):  # noqa: E501
        """Delete a particular key-value pair on a transaction.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_id_transaction_informations_id_information_delete_with_http_info(id_user, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_transaction', 'id_information', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_transactions_id_transaction_informations_id_information_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501
        # verify the required parameter 'id_information' is set
        if ('id_information' not in local_var_params or
                local_var_params['id_information'] is None):
            raise ValueError("Missing the required parameter `id_information` when calling `users_id_user_transactions_id_transaction_informations_id_information_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501
        if 'id_information' in local_var_params:
            path_params['id_information'] = local_var_params['id_information']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/transactions/{id_transaction}/informations/{id_information}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_transactions_id_transaction_informations_id_information_get(self, id_user, id_transaction, id_information, **kwargs):  # noqa: E501
        """Get a particular arbitrary key-value pair on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_id_transaction_informations_id_information_get(id_user, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_transactions_id_transaction_informations_id_information_get_with_http_info(id_user, id_transaction, id_information, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_transactions_id_transaction_informations_id_information_get_with_http_info(id_user, id_transaction, id_information, **kwargs)  # noqa: E501
            return data

    def users_id_user_transactions_id_transaction_informations_id_information_get_with_http_info(self, id_user, id_transaction, id_information, **kwargs):  # noqa: E501
        """Get a particular arbitrary key-value pair on a transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_id_transaction_informations_id_information_get_with_http_info(id_user, id_transaction, id_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transaction: (required)
        :param int id_information: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_transaction', 'id_information', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_transactions_id_transaction_informations_id_information_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_transactions_id_transaction_informations_id_information_get`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_transactions_id_transaction_informations_id_information_get`")  # noqa: E501
        # verify the required parameter 'id_information' is set
        if ('id_information' not in local_var_params or
                local_var_params['id_information'] is None):
            raise ValueError("Missing the required parameter `id_information` when calling `users_id_user_transactions_id_transaction_informations_id_information_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501
        if 'id_information' in local_var_params:
            path_params['id_information'] = local_var_params['id_information']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/transactions/{id_transaction}/informations/{id_information}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_transactions_id_transaction_informations_put(self, id_user, id_transaction, **kwargs):  # noqa: E501
        """Add or edit transaction arbitrary key-value pairs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_id_transaction_informations_put(id_user, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_transactions_id_transaction_informations_put_with_http_info(id_user, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_transactions_id_transaction_informations_put_with_http_info(id_user, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_transactions_id_transaction_informations_put_with_http_info(self, id_user, id_transaction, **kwargs):  # noqa: E501
        """Add or edit transaction arbitrary key-value pairs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_id_transaction_informations_put_with_http_info(id_user, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transaction: (required)
        :param str expand:
        :return: TransactionInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_transaction', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_transactions_id_transaction_informations_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_transactions_id_transaction_informations_put`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_transactions_id_transaction_informations_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/transactions/{id_transaction}/informations', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_transactions_id_transaction_put(self, id_user, id_transaction, **kwargs):  # noqa: E501
        """Edit a transaction meta-data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_id_transaction_put(id_user, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transaction: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_transactions_id_transaction_put_with_http_info(id_user, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_transactions_id_transaction_put_with_http_info(id_user, id_transaction, **kwargs)  # noqa: E501
            return data

    def users_id_user_transactions_id_transaction_put_with_http_info(self, id_user, id_transaction, **kwargs):  # noqa: E501
        """Edit a transaction meta-data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_id_transaction_put_with_http_info(id_user, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transaction: (required)
        :param str expand:
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_transaction', 'expand', 'unknown_base_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_transactions_id_transaction_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_transactions_id_transaction_put`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in local_var_params or
                local_var_params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `users_id_user_transactions_id_transaction_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_transaction' in local_var_params:
            path_params['id_transaction'] = local_var_params['id_transaction']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/transactions/{id_transaction}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transaction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_transactions_post(self, id_user, unknown_base_type, **kwargs):  # noqa: E501
        """Create transactions  # noqa: E501

        Create transactions for the supplied account or the account whose id is given with form parameters. It requires an array of transaction dictionaries.<br><br><br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_post(id_user, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_transactions_post_with_http_info(id_user, unknown_base_type, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_transactions_post_with_http_info(id_user, unknown_base_type, **kwargs)  # noqa: E501
            return data

    def users_id_user_transactions_post_with_http_info(self, id_user, unknown_base_type, **kwargs):  # noqa: E501
        """Create transactions  # noqa: E501

        Create transactions for the supplied account or the account whose id is given with form parameters. It requires an array of transaction dictionaries.<br><br><br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactions_post_with_http_info(id_user, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: (required)
        :param str expand:
        :return: Transaction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'unknown_base_type', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_transactions_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_transactions_post`")  # noqa: E501
        # verify the required parameter 'unknown_base_type' is set
        if ('unknown_base_type' not in local_var_params or
                local_var_params['unknown_base_type'] is None):
            raise ValueError("Missing the required parameter `unknown_base_type` when calling `users_id_user_transactions_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/transactions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transaction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_transactionsclusters_get(self, id_user, **kwargs):  # noqa: E501
        """Get clustered transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactionsclusters_get(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_transactionsclusters_get_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_transactionsclusters_get_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_transactionsclusters_get_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Get clustered transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactionsclusters_get_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_transactionsclusters_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_transactionsclusters_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/transactionsclusters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20032',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_transactionsclusters_id_transactionscluster_delete(self, id_user, id_transactionscluster, **kwargs):  # noqa: E501
        """Delete a clustered transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactionsclusters_id_transactionscluster_delete(id_user, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_transactionsclusters_id_transactionscluster_delete_with_http_info(id_user, id_transactionscluster, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_transactionsclusters_id_transactionscluster_delete_with_http_info(id_user, id_transactionscluster, **kwargs)  # noqa: E501
            return data

    def users_id_user_transactionsclusters_id_transactionscluster_delete_with_http_info(self, id_user, id_transactionscluster, **kwargs):  # noqa: E501
        """Delete a clustered transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactionsclusters_id_transactionscluster_delete_with_http_info(id_user, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_transactionscluster', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_transactionsclusters_id_transactionscluster_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_transactionsclusters_id_transactionscluster_delete`")  # noqa: E501
        # verify the required parameter 'id_transactionscluster' is set
        if ('id_transactionscluster' not in local_var_params or
                local_var_params['id_transactionscluster'] is None):
            raise ValueError("Missing the required parameter `id_transactionscluster` when calling `users_id_user_transactionsclusters_id_transactionscluster_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_transactionscluster' in local_var_params:
            path_params['id_transactionscluster'] = local_var_params['id_transactionscluster']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/transactionsclusters/{id_transactionscluster}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionsCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_transactionsclusters_id_transactionscluster_put(self, id_user, id_transactionscluster, **kwargs):  # noqa: E501
        """Edit a clustered transaction  # noqa: E501

        Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactionsclusters_id_transactionscluster_put(id_user, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_transactionsclusters_id_transactionscluster_put_with_http_info(id_user, id_transactionscluster, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_transactionsclusters_id_transactionscluster_put_with_http_info(id_user, id_transactionscluster, **kwargs)  # noqa: E501
            return data

    def users_id_user_transactionsclusters_id_transactionscluster_put_with_http_info(self, id_user, id_transactionscluster, **kwargs):  # noqa: E501
        """Edit a clustered transaction  # noqa: E501

        Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactionsclusters_id_transactionscluster_put_with_http_info(id_user, id_transactionscluster, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param int id_transactionscluster: (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'id_transactionscluster', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_transactionsclusters_id_transactionscluster_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_transactionsclusters_id_transactionscluster_put`")  # noqa: E501
        # verify the required parameter 'id_transactionscluster' is set
        if ('id_transactionscluster' not in local_var_params or
                local_var_params['id_transactionscluster'] is None):
            raise ValueError("Missing the required parameter `id_transactionscluster` when calling `users_id_user_transactionsclusters_id_transactionscluster_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501
        if 'id_transactionscluster' in local_var_params:
            path_params['id_transactionscluster'] = local_var_params['id_transactionscluster']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/transactionsclusters/{id_transactionscluster}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionsCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_id_user_transactionsclusters_post(self, id_user, **kwargs):  # noqa: E501
        """Create clustered transaction  # noqa: E501

        Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactionsclusters_post(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_id_user_transactionsclusters_post_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.users_id_user_transactionsclusters_post_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def users_id_user_transactionsclusters_post_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Create clustered transaction  # noqa: E501

        Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_id_user_transactionsclusters_post_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_user: Hint: you can use 'me' or 'all' (required)
        :param str expand:
        :return: TransactionsCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_user', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_id_user_transactionsclusters_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in local_var_params or
                local_var_params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `users_id_user_transactionsclusters_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in local_var_params:
            path_params['id_user'] = local_var_params['id_user']  # noqa: E501

        query_params = []
        if 'expand' in local_var_params:
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id_user}/transactionsclusters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransactionsCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
