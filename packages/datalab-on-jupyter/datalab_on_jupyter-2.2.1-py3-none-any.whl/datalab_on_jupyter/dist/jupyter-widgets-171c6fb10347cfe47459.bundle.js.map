{"version":3,"sources":["webpack:///./node_modules/@nteract/jupyter-widgets/src/index.tsx"],"names":["WidgetDisplay","container","this","current","nextProps","props","data","model_id","channels","createOrUpdateShim","ref","MIMETYPE"],"mappings":"2FAAA,gEAqBO,MAAMA,UAAsB,YAAnC,c,oBAUU,KAAAC,UAAY,cAGpB,oBACOC,KAAKD,UAAUE,QAUtB,wBAQA,sBAAsBC,GAEpB,SACEF,KAAKG,MAAMC,MACXF,EAAUE,KAAKC,WAAaL,KAAKG,MAAMC,KAAKC,WAO1CH,EAAUI,WAAaN,KAAKG,MAAMG,SAQxC,SAGE,OAFAN,KAAKO,qBAGH,2B,oDAEE,uBAAKC,IAAKR,KAAKD,aAQb,uBAhED,EAAAU,SAAW","file":"jupyter-widgets-171c6fb10347cfe47459.bundle.js","sourcesContent":["import * as React from \"react\";\nimport { Subject } from \"rxjs\";\n\n// import { OuterShim } from \"./outer-shim\";\n\ninterface Props {\n  data: { model_id: string };\n  channels: Subject<any>;\n}\n\n/**\n * Component used to render a widget view.\n *\n * Given a kernel and widget model id, this component will render a widget\n * view for the widget model. The widget view and widget models are isolated to\n * a cross domain iframe. Since they have access to the kernel, they are capable\n * of communicating directly with the kernel instance which makes them atypical.\n *\n * Even though it may appear to be pure, since it doesn't have react state, this\n * component's iframe maintains it's own state in communication with the kernel.\n */\nexport class WidgetDisplay extends React.Component<Partial<Props>> {\n  static MIMETYPE = \"application/vnd.jupyter.widget-view+json\";\n\n  // TODO: Uncomment this and related code in a follow-up PR.\n  // The outer shim is responsable for managing the rendered cross domain\n  // iframe, communicating with it, and relaying information to and from the\n  // kernel.\n  // private shim: OuterShim;\n\n  // A reference to the div which we can inject the cross domain widget iframe.\n  private container = React.createRef<HTMLDivElement>();\n\n  /** @override */\n  componentDidMount() {\n    if (!this.container.current) {\n      return;\n    }\n\n    // When the component has mounted, inject the widget iframe.\n    // const view = this.shim.getView();\n    // this.container.current.appendChild(view);\n  }\n\n  /** @override */\n  componentWillUnmount() {\n    // if (this.shim) {\n    //   this.shim.dispose();\n    //   delete this.shim;\n    // }\n  }\n\n  /** @override */\n  shouldComponentUpdate(nextProps: Props): boolean {\n    // Only update if the model_id or kernel_id have changed.\n    if (\n      this.props.data &&\n      nextProps.data.model_id !== this.props.data.model_id\n    ) {\n      return true;\n    }\n\n    // If the channels have changed, we need to make sure that we connect the\n    // shim to the new channels.\n    if (nextProps.channels !== this.props.channels) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /** @override */\n  render() {\n    this.createOrUpdateShim();\n\n    return (\n      <pre>\n        Jupyter-Widgets are not yet supported in nteract.\n        <div ref={this.container} />\n      </pre>\n    );\n  }\n\n  /**\n   * Creates or updates the existing shim to the current model id and kernel.\n   */\n  private createOrUpdateShim() {\n    // if (!this.shim) {\n    //   this.shim = new OuterShim();\n    // }\n    // this.shim.setCommMsgsSubject(this.props.channels);\n    // this.shim.setModelId(this.props.data.model_id);\n  }\n}\n"],"sourceRoot":""}