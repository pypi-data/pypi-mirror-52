# Batch runs - basics

These tests illustrate batch run behavior. We'll use the `batch`
sample project:

    >>> project = Project(sample("projects", "batch"))

A helper to run project ops:

    >>> def run(op, batches=None, label=None, print_trials=False, **flags):
    ...     project.run(
    ...         op,
    ...         flags=flags,
    ...         batch_files=batches,
    ...         label=label,
    ...         print_trials=print_trials,
    ...         simplify_trial_output=True)

We start with no runs:

    >>> project.print_runs()

## Batch runs

A batch run is a run that contains either explicit or implicit batch
specifiers.

Batch runs generate one or more trial runs.

There are two types of implicit batch specifiers:

- Flag list value
- A batch file

A flag list value indicates that the operation should be run each
value in the list. If there is more tha one flag with list values, the
operation is run over the catesian produce of all a possible flag
combinations.

A batch file may contain one or more flag combinations, each of which
is used to run the operation.

If both flag list values and batch files are used, the flag values are
applied to each flag combination in the batch files.

An explicit batch specifier is made using the `--optimizer` flag,
which indicates that the specified optimizer should be used to run the
operation multiple times with the goal of minimizing or maximizing an
operation result.

We'll look at each of these scanarios in the tests that follow.

## Baseline

We'll two operations to illustate various batch runs.

The first is the `say.py` script, which simply prints a specified
message, optionally capitalizing it.

    >>> run("say.py", label="default")
    hello

    >>> run("say.py", msg="hi", label="${msg}")
    hi

    >>> run("say.py", msg="hi", loud=True, label="msg=hi loud=yes")
    HI

And our runs:

    >>> project.print_runs(labels=True)
    say.py  msg=hi loud=yes
    say.py  hi
    say.py  default

Let's delete our runs in preparation for the next section.

    >>> project.delete_runs()
    Deleted 3 run(s)

## Flag list values

A batch is run impicitly whenever a list of values is specified for a
flag.

Let's run `say.py` with a list of one `msg` flag value:

    >>> run("say.py", msg=["hi"])
    Initialized trial (loud=no, msg=hi)
    Running trial: say.py (loud=no, msg=hi)
    hi

Here are the trial runs:

    >>> project.print_runs(flags=True)
    say.py   loud=no msg=hi
    say.py+

Note there are two runs. The first run, listed as `+`, is the batch
operation, which is separate from the trial run. The batch operation
uses the special name `+`.

The batch operation manages the trial runs. Failed batch operations,
for example, can be restarted by restarting the associated runs.

For details on how trial and batch labels are set, see
[run-labels](run-labels.md).

Here are our runs, which include one trial and the batch.

    >>> project.print_runs(labels=True)
    say.py   msg=hi
    say.py+

Let's run `say-with-label` for two runs:

    >>> run("say-with-label", msg=["hi 1", "hi 2"])
    Initialized trial (loud=no, msg='hi 1')
    Running trial: say-with-label (loud=no, msg='hi 1')
    hi 1
    Initialized trial (loud=no, msg='hi 2')
    Running trial: say-with-label (loud=no, msg='hi 2')
    hi 2

    >>> project.print_runs(labels=True)
    say-with-label   msg is 'hi 2'
    say-with-label   msg is 'hi 1'
    say-with-label+
    ...

Let's delete runs in preparation for the next tests:

    >>> project.delete_runs()
    Deleted 5 run(s)

Note that we can preview the trials that will be generated using the
`print_trials` flag:

    >>> run("say.py", msg=["hi"], print_trials=True)
    #  loud  msg
    1  no    hi

Next we'll run `say.py` with two values for `msg`:

    >>> run("say.py", msg=["hello", "hola"])
    Initialized trial (loud=no, msg=hello)
    Running trial: say.py (loud=no, msg=hello)
    hello
    Initialized trial (loud=no, msg=hola)
    Running trial: say.py (loud=no, msg=hola)
    hola

In this case, we have three runs, one for the batch and two for each
trial.

    >>> project.print_runs(flags=True)
    say.py   loud=no msg=hola
    say.py   loud=no msg=hello
    say.py+

Here we we see that two trials are generated by the batch, each with
one of the specified `msg` flag values.

Here's the preview of the same operation:

    >>> run("say.py", msg=["hello", "hola"], print_trials=True)
    #  loud  msg
    1  no    hello
    2  no    hola

Trials are run in order corresponding to the flag value in the
list.

    >>> run("say.py", msg=["c", "a", "b"])
    Initialized trial (loud=no, msg=c)
    Running trial: say.py (loud=no, msg=c)
    c
    Initialized trial (loud=no, msg=a)
    Running trial: say.py (loud=no, msg=a)
    a
    Initialized trial (loud=no, msg=b)
    Running trial: say.py (loud=no, msg=b)
    b

    >>> run("say.py", msg=["c", "a", "b"], print_trials=True)
    #  loud  msg
    1  no    c
    2  no    a
    3  no    b

We can specify other flags along with our batch specifiers:

    >>> run("say.py", msg=["a", "b"], loud=True)
    Initialized trial (loud=yes, msg=a)
    Running trial: say.py (loud=yes, msg=a)
    A
    Initialized trial (loud=yes, msg=b)
    Running trial: say.py (loud=yes, msg=b)
    B

    >>> run("say.py", msg=["a", "b"], loud=True, print_trials=True)
    #  loud  msg
    1  yes   a
    2  yes   b

If we use multiple list values, trials are generated using the
cartesian product of all flag combinations. The order of trials
corresponds to the flag names in ascending order followed by the flag
values as ordered in each flag value list.

    >>> run("say.py", msg=["b", "a"], loud=[False, True])
    Initialized trial (loud=no, msg=b)
    Running trial: say.py (loud=no, msg=b)
    b
    Initialized trial (loud=no, msg=a)
    Running trial: say.py (loud=no, msg=a)
    a
    Initialized trial (loud=yes, msg=b)
    Running trial: say.py (loud=yes, msg=b)
    B
    Initialized trial (loud=yes, msg=a)
    Running trial: say.py (loud=yes, msg=a)
    A

    >>> run("say.py", msg=["b", "a"], loud=[False, True], print_trials=True)
    #  loud  msg
    1  no    b
    2  no    a
    3  yes   b
    4  yes   a

Let's delete our runs in preparation for the next section.

    >>> project.delete_runs()
    Deleted ... run(s)

## Batch files

Batch files are used to explicitly run batches. A batch file contains
one or more flag combinations that are each used to generate a trial
run.

Guild supports three batch file formats:

- YAML
- JSON
- CSV

Let's look at `batch.csv`, which we can use to run a batch:

    >>> cat(join_path(project.cwd, "batch.csv"))
    msg,loud
    hello 1
    hello 2,yes
    hello 3

CSV files must have a header row that defines the flag names separated
by commas. Each subsequent row is a list of flag values, each
corresponding to a flag name and also separate by commas.

In this case we have a batch of three flag combinations.

Let's use the batch file in an operation:

    >>> run("say.py", batches=["batch.csv"])
    Initialized trial (loud=no, msg='hello 1')
    Running trial: say.py (loud=no, msg='hello 1')
    hello 1
    Initialized trial (loud=yes, msg='hello 2')
    Running trial: say.py (loud=yes, msg='hello 2')
    HELLO 2
    Initialized trial (loud=no, msg='hello 3')
    Running trial: say.py (loud=no, msg='hello 3')
    hello 3

    >>> run("say.py", batches=["batch.csv"], print_trials=True)
    #  loud  msg
    1  no    hello 1
    2  yes   hello 2
    3  no    hello 3

Here's what our runs look like after the batch operation:

    >>> project.print_runs(flags=True)
    say.py   loud=no msg='hello 3'
    say.py   loud=yes msg='hello 2'
    say.py   loud=no msg='hello 1'
    say.py+

In cases where we explicitly define flag values, those flag values are
applied only if they are not defined in the batch file - the batch
file takes precedence over flags specified for the operation.

    >>> run("say.py", batches=["batch.csv"], loud=False)
    Initialized trial (loud=no, msg='hello 1')
    Running trial: say.py (loud=no, msg='hello 1')
    hello 1
    Initialized trial (loud=yes, msg='hello 2')
    Running trial: say.py (loud=yes, msg='hello 2')
    HELLO 2
    Initialized trial (loud=no, msg='hello 3')
    Running trial: say.py (loud=no, msg='hello 3')
    hello 3

    >>> run("say.py", batches=["batch.csv"], loud=False, print_trials=True)
    #  loud  msg
    1  no    hello 1
    2  yes   hello 2
    3  no    hello 3

We can additionally specify multiple flag values that are used to
generate additional trials, in cases where the batch file doesn't
specify a flag value.

Here we'll use a list of `loud`, which is applied in cases where
`loud` is not defined in the batch:

    >>> run("say.py", batches=["batch.csv"], loud=[True, False])
    Initialized trial (loud=yes, msg='hello 1')
    Running trial: say.py (loud=yes, msg='hello 1')
    HELLO 1
    Initialized trial (loud=no, msg='hello 1')
    Running trial: say.py (loud=no, msg='hello 1')
    hello 1
    Initialized trial (loud=yes, msg='hello 2')
    Running trial: say.py (loud=yes, msg='hello 2')
    HELLO 2
    Initialized trial (loud=yes, msg='hello 3')
    Running trial: say.py (loud=yes, msg='hello 3')
    HELLO 3
    Initialized trial (loud=no, msg='hello 3')
    Running trial: say.py (loud=no, msg='hello 3')
    hello 3

    >>> run("say.py", batches=["batch.csv"], loud=[True, False],
    ...     print_trials=True)
    #  loud  msg
    1  yes   hello 1
    2  no    hello 1
    3  yes   hello 2
    4  yes   hello 3
    5  no    hello 3

Here's a case that further illustates the point. While we may request
different values for `msg`, the batch file values are used when
specified:

    >>> run("say.py", batches=["batch.csv"], msg=["hello 4", "hello 5"])
    Initialized trial (loud=no, msg='hello 1')
    Running trial: say.py (loud=no, msg='hello 1')
    hello 1
    Initialized trial (loud=yes, msg='hello 2')
    Running trial: say.py (loud=yes, msg='hello 2')
    HELLO 2
    Initialized trial (loud=no, msg='hello 3')
    Running trial: say.py (loud=no, msg='hello 3')
    hello 3

    >>> run("say.py", batches=["batch.csv"], msg=["hello 4", "hello 5"],
    ...     print_trials=True)
    #  loud  msg
    1  no    hello 1
    2  yes   hello 2
    3  no    hello 3

Next we'll look at `batch.yaml`:

    >>> cat(join_path(project.cwd, "batch.yaml"))
    - msg: hello 4
    - msg: hello 5
    - msg: hello 6
      loud: yes

In this case we have three flag batches as well, but with different
values.

Here's our batch using the file:

    >>> run("say.py", batches=["batch.yaml"])
    Initialized trial (loud=no, msg='hello 4')
    Running trial: say.py (loud=no, msg='hello 4')
    hello 4
    Initialized trial (loud=no, msg='hello 5')
    Running trial: say.py (loud=no, msg='hello 5')
    hello 5
    Initialized trial (loud=yes, msg='hello 6')
    Running trial: say.py (loud=yes, msg='hello 6')
    HELLO 6

    >>> run("say.py", batches=["batch.yaml"], print_trials=True)
    #  loud  msg
    1  no    hello 4
    2  no    hello 5
    3  yes   hello 6

We can apply a value for `loud` that will be used when the batch file
doesn't define it:

    >>> run("say.py", batches=["batch.yaml"], loud=True)
    Initialized trial (loud=yes, msg='hello 4')
    Running trial: say.py (loud=yes, msg='hello 4')
    HELLO 4
    Initialized trial (loud=yes, msg='hello 5')
    Running trial: say.py (loud=yes, msg='hello 5')
    HELLO 5
    Initialized trial (loud=yes, msg='hello 6')
    Running trial: say.py (loud=yes, msg='hello 6')
    HELLO 6

    >>> run("say.py", batches=["batch.yaml"], loud=True, print_trials=True)
    #  loud  msg
    1  yes   hello 4
    2  yes   hello 5
    3  yes   hello 6

Next we'll look at JSON formatted batch files.

    >>> cat(join_path(project.cwd, "batch.json"))
    [
      {"msg": "hello 7", "loud": false},
      {"msg": "hello 8", "loud": true},
      {"msg": "hello 9", "loud": true}
    ]

    >>> run("say.py", batches=["batch.json"])
    Initialized trial (loud=no, msg='hello 7')
    Running trial: say.py (loud=no, msg='hello 7')
    hello 7
    Initialized trial (loud=yes, msg='hello 8')
    Running trial: say.py (loud=yes, msg='hello 8')
    HELLO 8
    Initialized trial (loud=yes, msg='hello 9')
    Running trial: say.py (loud=yes, msg='hello 9')
    HELLO 9

    >>> run("say.py", batches=["batch.json"], print_trials=True)
    #  loud  msg
    1  no    hello 7
    2  yes   hello 8
    3  yes   hello 9

Finally, Guild supports multiple batch files, each of which being
applied in the order specified:

    >>> run("say.py", batches=["batch.csv", "batch.yaml", "batch.json"])
    Initialized trial (loud=no, msg='hello 1')
    Running trial: say.py (loud=no, msg='hello 1')
    hello 1
    Initialized trial (loud=yes, msg='hello 2')
    Running trial: say.py (loud=yes, msg='hello 2')
    HELLO 2
    Initialized trial (loud=no, msg='hello 3')
    Running trial: say.py (loud=no, msg='hello 3')
    hello 3
    Initialized trial (loud=no, msg='hello 4')
    Running trial: say.py (loud=no, msg='hello 4')
    hello 4
    Initialized trial (loud=no, msg='hello 5')
    Running trial: say.py (loud=no, msg='hello 5')
    hello 5
    Initialized trial (loud=yes, msg='hello 6')
    Running trial: say.py (loud=yes, msg='hello 6')
    HELLO 6
    Initialized trial (loud=no, msg='hello 7')
    Running trial: say.py (loud=no, msg='hello 7')
    hello 7
    Initialized trial (loud=yes, msg='hello 8')
    Running trial: say.py (loud=yes, msg='hello 8')
    HELLO 8
    Initialized trial (loud=yes, msg='hello 9')
    Running trial: say.py (loud=yes, msg='hello 9')
    HELLO 9

    >>> run("say.py", batches=["batch.csv", "batch.yaml", "batch.json"],
    ...     print_trials=True)
    #  loud  msg
    1  no    hello 1
    2  yes   hello 2
    3  no    hello 3
    4  no    hello 4
    5  no    hello 5
    6  yes   hello 6
    7  no    hello 7
    8  yes   hello 8
    9  yes   hello 9

Unsupported batch files generate an error:

    >>> run("say.py", batches=["batch.unknown"])
    guild: unsupported batch file extension for batch.unknown
    <exit 1>
