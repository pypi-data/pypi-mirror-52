#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Aug  9 14:16:40 2018

@author: asr
"""

import matplotlib.pyplot as plt
import numpy as np
from sklearn import datasets
from sklearn.cluster import KMeans
from sklearn.metrics.pairwise import pairwise_distances
from sklearn.neighbors import NearestNeighbors

from abc import ABC, abstractmethod
from typing import NewType

from .extra import eigenstuff


Matrix = NewType('Matrix', np.ndarray)
IntTuple = NewType('IntTuple', (int, int))


class WTVMeans(ABC):
    """
    WTVMeans is a wide clustering object gathering some whatever-means algorithms like X-Means, G-Means or Dip-Means
    """

    def __init__(self, **kwargs):
        """Constructor
        This object behaves a bit like the clustering objects from sklearn

        Parameters
        ----------
        min_pts: int or float
            The minimum number of points in a cluster (to avoid over clustering). It can etier be an integer (absolute value) or a float between 0 and 1 (ratio of the size of the input observations)
            Default value is 0.10

        **kwargs:
            Extra parameters passed to sklearn.cluster.KMeans
            (see http://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html)
        """

        # Convention for the attributes
        # self.__ARG    private
        # self.ARG_     generated by the object (~results)
        # self.ARG      input parameter

        # minimum numbr of point to consider a cluster
        self.min_pts = kwargs.pop('min_pts', 0.10)

        # extra kmeans arguments
        self._extra_kmeans_args = kwargs

        # general things
        self._data = None
        self.cluster_centers_ = None
        self.labels_ = None
        self.n_clusters_ = 0
        self.n_iter_ = 0

    def is_fitted(self):
        """
        Check if the object has been fitted to data
        """
        return self.n_clusters_ > 0

    def _load(self, X: Matrix):
        """
        Load the data to the object (to perform the fit). It also updates min_pts
        in case it is defined by a ratio (float) and init the single cluster model
        (all the data in the same cluster)

        Parameters
        ----------

        X: numpy.ndarray
            Training instances to cluster, shape=(n_samples, n_features)
        """
        self._data = X
        if isinstance(self.min_pts, float):
            self.min_pts = int(self.min_pts * X.shape[0])

        self.labels_ = np.zeros(X.shape[0])
        self.n_clusters_ = 1
        self.cluster_centers_ = X.mean(axis=0).reshape(1, -1)
        self.n_iter_ = 0

    def _global_kmeans(self, k: int):
        """Perform the main kmeans run
        """
        k_means = KMeans(n_clusters=k,
                         init=self.cluster_centers_,
                         n_init=1,
                         **self._extra_kmeans_args)
        self.labels_ = k_means.fit_predict(self._data)
        self.cluster_centers_ = k_means.cluster_centers_
        self.n_iter_ += k_means.n_iter_

    def _split_kmeans(self, index, init, n_init):
        """Perform a kmeans to split a cluster into two clusters
        """
        k_means = KMeans(2, init=init, n_init=n_init,
                         **self._extra_kmeans_args)
        labels = k_means.fit_predict(self._data[index])
        # add number of iterations
        self.n_iter_ += k_means.n_iter_
        return labels, k_means.cluster_centers_

    @abstractmethod
    def _fit(self):
        """
        Launch the algorithm on the previously loaded data (method _load)
        """
        pass

    def fit(self, X: Matrix):
        """
        Launch the algorithm on the incoming data X

        Parameters
        ----------

        X: numpy.ndarray
            Training instances to cluster, shape=(n_samples, n_features)
        """
        self._load(X)
        self._fit()

    def predict(self, Y: Matrix) -> Matrix:
        """Cluster new point

        Parameters
        ----------

        Y: numpy.ndarray
            new instances to cluster, shape=(n_samples, n_features)
        """
        if self.is_fitted():
            neighbors = NearestNeighbors(1)
            neighbors.fit(self.cluster_centers_)
            return neighbors.kneighbors(Y, return_distance=False).flatten()
        raise RuntimeError("WTVMeans object has not been initialized")

    def fit_predict(self, X: Matrix):
        """
        Fit the algorithm to the data and returns their labels

        Parameters
        ----------

        X: numpy.ndarray
            Training instances to cluster, shape=(n_samples, n_features)
        """
        self.fit(X)
        return self.labels_

    def _split(self, cluster, index=None):
        """
        Perform a random split of the cluster
        """
        if index is None:
            index = (self.labels_ == cluster)
        return self._split_kmeans(index, init='random', n_init=10)

    def _split_center(self, cluster, centers, index=None):
        """
        Perform a split of the cluster based on two inital centers
        (ndarray of shape (2, n_features))
        """
        if index is None:
            index = (self.labels_ == cluster)
        return self._split_kmeans(index, init=centers, n_init=1)

    def _split_pca(self, cluster, index=None):
        """
        Perform a PCA split of the cluster
        """
        if index is None:
            index = (self.labels_ == cluster)

        # retrieve eigenvectors and eigenvalues
        eigenvector, eigenvalue = eigenstuff(
            self._data[self.labels_ == cluster])
        # compute a step vector
        direction = np.sqrt(2 * eigenvalue / np.pi) * eigenvector
        # creates two new centers
        centers = np.vstack((self.cluster_centers_[cluster] + direction,
                             self.cluster_centers_[cluster] - direction))
        return self._split_kmeans(index, init=centers, n_init=1)

    def _accept_split(self, initial_cluster, index, new_labels, new_centers):
        """
        Make the split effective
        """
        # Get the first cluster of the split
        local_index = (new_labels == 0)
        # Re-label them (with the label of the splitted cluster)
        new_labels[local_index] = initial_cluster
        # But we have to assign a new number to the second cluster of the split
        new_labels[~local_index] = self.n_clusters_ + 1
        # Finally we assign everything
        self.labels_[index] = new_labels
        self.cluster_centers_[initial_cluster] = new_centers[0]
        self.cluster_centers_ = np.vstack(
            (self.cluster_centers_, new_centers[1]))
        # increment the number of clusters
        self.n_clusters_ += 1

    def fit_predict_plot(self, X: Matrix, dim: IntTuple = (0, 1)):
        """
        Cluster data and plot the result

        Parameters
        ----------

        X: numpy.ndarray
            Training instances to cluster, shape=(n_samples, n_features)
        dim: tuple(int,int)
            Dimension to plot (two first by default)
        """
        self.fit(X)
        fig = plt.figure()
        axes = fig.add_subplot(111)
        for i in range(self.n_clusters_):
            index = (self.labels_ == i)
            axes.scatter(X[index][:, dim[0]], X[index]
                         [:, dim[1]], label=str(i))
        plt.axis('equal')
        return axes

    def plot(self, dim: IntTuple = (0, 1)):
        """
        Plot clustering results according to the given dimensions

        Parameters
        ----------
        dim: tuple(int,int)
            the two dimension projections
        """
        if self.is_fitted():
            fig = plt.figure()
            axes = fig.add_subplot(111)
            for i in range(self.n_clusters_):
                index = (self.labels_ == i)
                axes.scatter(self._data[index][:, dim[0]],
                             self._data[index][:, dim[1]],
                             label=str(i))
            return axes
        raise RuntimeError("WTVMeans object has not been initialized")
