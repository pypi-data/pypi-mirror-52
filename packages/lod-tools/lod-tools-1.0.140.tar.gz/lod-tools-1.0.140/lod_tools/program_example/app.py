import csv
import json
import numpy as np

# LOD preparations
# Import the LOD library.
from lod import lod
# The object_manager contains every object that has been created in this Scenario so far.
object_manager = lod.get_object_manager()

def main(lod_manager):
    #
    # Get the arguments that were given to this Program.
    #
    # Each element of 'arguments' is a named object that was passed to this Program.
    # If the object is a file, that file can be opened.
    # The parameters selected by the user have been put into a single file in JSON format, so we can just read them out that way.
    # (Note that if your requirements are more complicated, you can use several input files from different sources.
    # For example, if you have two different Options that each require parameters from users, or several files that have been uploaded by the user or generated by other programs)
    arguments = lod.get_program_arguments()
    with open(arguments['user_parameters_file'].file, 'r') as f:
        user_parameters = json.load(f)
        timeseries_as_text = user_parameters['timeseries']
        c = user_parameters['c']
        use_inbuilt_visualization = user_parameters['use_inbuilt_visualization']
    #
    # Try to parse the timeseries entered by the user.
    #
    # If this doesn't work, show the Option again with an error message, then return.
    # The Option we create here is almost identical to the original one that was created by the Rule Demo-a-simple-timeseries-prediction, but we set the default values to what the user entered before.
    #
    # Note that this is not ideal programming:
    # There is redundancy between the Option created by the rule Demo-a-simple-timeseries-rediction and the one created by this program.
    # In this case, that is deliberate: It was necessary to show that an Option can be created both via a Rule and inside a Program.
    try:
        timeseries = [float(a) for a in timeseries_as_text.split(',')]
        if len(timeseries) == 0:
            raise Exception()
    except:
        confidence = 1000
        description = None
        trigger = {}
        display = {
            'must_always_be_shown' : True,
            'parameter_file_name' : 'userParametersFile',
            'message_components' : [
                {
                    "text" : "The timeseries you entered could not be parsed. Please try again."
                },
                {
                    'type' : 'option_parameter_selector',
                    'name' : 'timeseries',
                    'title' : "Timeseries to predict",
                    'description' : "The timeseries, as a string of comma-separated values:",
                    'optional' : False,
                    'value' : {
                        'type' : 'string',
                        'default' : "1.0, 2.0, 3.0",
                    }
                },
                {
                    'type' : 'option_parameter_selector',
                    'name' : 'c',
                    'title' : "Number of elements to predict",
                    'description' : "",
                    'optional' : False,
                    'value' : {
                        'type' : 'int',
                        'min' : 1,
                        'default' : c,
                    }
                },
                {
                    'type' : 'option_parameter_selector',
                    'name' : 'use_inbuilt_visualization',
                    'title' : "Use inbuilt visualization?",
                    'description' : "If selected, the predicted timeseries will be visualized with a simple built-in program. Otherwise it will be left to the Programs of other users to visualize the result (this is not part of the tutorial and may not work!)",
                    'optional' : True,
                    'value' : {
                        'type' : 'bool',
                        'default' : use_inbuilt_visualization,
                    }
                }
            ],
            'buttons' : [
                {
                    'text' : "Perform the prediction",
                    'style' : 'cta',
                }
            ],
        }
        actions = [
            {
                'type' : 'execute_program',
                'program' : "Demo_a_simple_timeseries_prediction",
                'arguments' : {
                    'user_parameters_file' : 'userParametersFile',
                }
            },
        ]
        existing_variables = {}
        new_option = lod.option(confidence, 'demo-a-simple-timeseries-prediction-try-again', description, trigger, display, actions, existing_variables)
        return

    #
    # Make a prediction
    #
    # If this was a real Program, this is where the important parts of your program would go.
    # Since this is just a tutorial, we just use simple linear regression for the prediction.
    xs = list(range(len(timeseries)))
    ys = timeseries
    res = np.polyfit(xs, ys, 1)
    # Predict c more values
    prediction = ys + [a * res[0] + res[1] for a in range(len(ys), len(ys) + c)]

    #
    # Output the result
    #
    if use_inbuilt_visualization:
        # If the user chose the inbuilt visualization, create a simple graph using the graphing library used by Elody,
        # then add a button to download the file as well as a message asking the user to rate the results.
        # ---
        # Create the file that we want to offer for download
        prediction_file = lod.file("prediction.csv")
        with open(prediction_file.file, 'w') as f:
            wr = csv.writer(f, dialect='excel')
            wr.writerow(prediction)
        # Create the plot
        original_series = {
            'color' : 'blue',
            'data' : [[i, a] for i,a in enumerate(timeseries)],
        }
        prediction_series = {
            'color' : 'red',
            'data' : [[i, a] for i,a in enumerate(prediction)][len(timeseries):],
        }
        plot_options = {
            'lines' : {
                'show' : True,
            },
            'points' : {
                'show' : True,
            }
        }
        # Create the Message, and attach both the plot and the file to it.
        # Because scenario_history_title is provided for the downloadable file, the file can still be downloaded after the Scenario has been closed, by visiting the History view of the Scenario.
        message = lod.start_message().\
            add_plot([original_series, prediction_series], options=plot_options).\
            add_downloadable_file("Download the prediction", prediction_file, scenario_history_title="The predicted file").\
            finish()
        # Create a second message to ask the user to rate the prediction.
        program_identifier, program_name, program_version = lod.get_own_program_details()
        lod.start_message().\
            add_text("Rate this Program!").\
            add_request_for_rating(program_identifier, event=None).\
            finish()
        # Create a Tag to change the status message, so the user knows that this Scenario is done.
        lod.tag('!set_status_message', comment="This Scenario is finished. You can still download the result from the History view after closing this window.")
    else:
        # If the user chose not to use the inbuilt visualization, output a file containing the original and the prediction as well as some tags
        # Other Rules, written by other deveopers, can now react to these tags and display the prediction for you.
        # ---
        # Write the original to a properly formatted file in CSV
        original_file = lod.add_output_file("original.csv")
        with open(original_file.file, 'w') as f:
            wr = csv.writer(f, dialect='excel')
            wr.writerow(timeseries)
        # Write the prediction to a properly formatted file in CSV
        prediction_file = lod.add_output_file("prediction.csv")
        with open(prediction_file.file, 'w') as f:
            wr = csv.writer(f, dialect='excel')
            wr.writerow(prediction)
        # Create a simple tag connecting these two files.
        # It is up to others how they want to react to this Tag.
        # Note: If you are already aware of another program that can visualize timeseries the way you need, then it would make sense to create whatever Tag that Program responds to.
        # Since no such program exists yet at the time of this writing, we instead create a made up Symbol which we can react to later.
        # How tasks and requirements for tasks are usually chained together is explained in later sections of the tutorial.
        lod.tag('demo_a_simple_timeseries_prediction_need_visualization', arguments=[original_file, prediction_file])


# Execute the main() function defined above.
# We wrap the whole thing in an lod.manager().
# This ensures that the objects created above (Options, Files, Messages, Tags) are made available to Elody.
#     (The objects are not created immediately, since the program runs in an isolated environment.
#     Instead, they are all given to Elody once the Program has finished running.)
# It also creates log files from any errors or print() statements that occur, which is useful for debugging.
# To inspect these log files, you need to use the lod-executor to run the Programs locally.
with lod.manager(suppress_exceptions_after_logging_them=False, redirect_stdout_to_log=True) as lod_manager:
    main(lod_manager)
