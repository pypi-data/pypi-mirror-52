from itertools import product
from os.path import isdir, abspath, dirname
from typing import Tuple, Union

import numpy as np
import seaborn as sns
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from sklearn.base import TransformerMixin, BaseEstimator
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing.data import StandardScaler


def downproject_2D(projector: TransformerMixin, X: np.ndarray, y: np.array = None,
                   scaler=StandardScaler(), save: str = None, **kwargs) -> np.ndarray:
    """
    Performs a down-projection of the data to 2D using the given estimator and
    generates a scatter-plot of the results.

    :param projector: projection method used
    :param X: data
    :param y: labels, used for coloring projected data points iff not ``None``
    :param scaler: scaler for normalising the data. Data will not be scaled iff ``None``


    :param save: path to save an image; do not save iff ``None``
    :param kwargs: parameters that are used to change the look and feel of the plots generated
    :return: projected data
    """
    if projector is None:
        raise ValueError('Projector must not be None!')
    if X is None:
        raise ValueError('Data points must not be None!')
    if y is None:
        raise ValueError('Class labels must not be None!')

    _verify_input(2, projector, X, y, scaler, save)

    # Ensures 2D projection
    projector.__setattr__('n_components', 2)

    # Scaling and projection
    X_tfd = _scale_and_project(projector, X, scaler)

    fig_num, _ = _generate_figure_2D(projector, X_tfd, y, **kwargs)
    plt.figure(fig_num)

    _handle_save(fig_num, save)

    return X_tfd


def downproject_3D(projector: TransformerMixin, X: np.ndarray, y: np.array = None,
                   scaler=StandardScaler(),
                   save: str = None, **kwargs) -> np.ndarray:
    """
    Performs a down-projection of the data to 3D using the given estimator and generates a scatter-plot of the results.

    :param projector: projection method used
    :param X: data
    :param y: labels, used for coloring projected data points iff not ``None``
    :param scaler: scaler for normalising the data. Data will not be scaled iff ``None``


    :param save: path to save an image; do not save iff ``None``
    :param kwargs: parameters that are used to change the look and feel of the plots generated
    :return: projected data
    """

    _verify_input(3, projector, X, y, scaler, save)

    # Ensures 2D projection
    projector.__setattr__('n_components', 3)

    # Scaling and projection
    X_tfd = _scale_and_project(projector, X, scaler)

    fig_num, _ = _generate_figure_3D(projector, X_tfd, y, **kwargs)
    plt.figure(fig_num)

    _handle_save(fig_num, save)

    return X_tfd


def param_product(parameters: dict) -> list:
    """
    Returns a list of different parameters which can be used as input for any projector passed to downproject_2D.

    For example: \n
    param_product( \n
    {'n_components': (2,), 'max_iter': (75, 125)}
    ) \n
    will yield \n
    [ \n
    {'n_components': 2, 'max_iter': 75}, \n
    {'n_components': 2, 'max_iter': 125} \n
    ] \n
    :param parameters: dict of parameter-value combinations whereas the value for each parameter
    :return: extensive list of parameter value combinations used for down-projection
    """
    return [dict(zip(parameters.keys(), values)) for values in product(*parameters.values())]


def multi_downproject_2D(projector: Union[TransformerMixin, BaseEstimator], parameters: dict,
                         X: np.ndarray, y: np.array = None, scaler=StandardScaler(),
                         save: str = None, **kwargs):
    """
    :param projector: Projections method used
    :param X: the data
    :param y: labels, used for coloring projected data points iff not ``None``
    :param scaler: scaler for normalising the data. Data will not be scaled iff ``None``

    :param save: path to save an image; do not save iff ``None``
    :param parameters: dict of name-tuple combinations used for projector-parameterisation
    :param kwargs: Parameter dict used for customizing the plots generated by downproject_2D
    :return:
    """
    _verify_input(2, projector, X, y, scaler, save)

    product = param_product(parameters)

    grid_cols = 2
    num_plots = len(product)

    if num_plots == 1:
        [projector.__setattr__(name, value) for name, value in product[0].items()]
        downproject_2D(projector, X, y, scaler, save, **kwargs)
        return

    # Prepare Projector
    projector.__setattr__('n_components', 2)

    fig = plt.figure(figsize=kwargs.get('gridsize', (10 * grid_cols, 10 * num_plots / grid_cols)))

    for idx, params in enumerate(product):
        title = _generate_plot_title(projector, params, scaler is not None)
        cur_ax = fig.add_subplot(int((num_plots + 1) / grid_cols), grid_cols, idx + 1,
                                 projection='3d')

        update_params(projector, params)
        X_tfd = _scale_and_project(projector, X, scaler)
        _, _ = _generate_figure_2D(projector, X_tfd, y, cur_ax, title=title, **kwargs)

    _handle_save(fig.number, save)


def multi_downproject_3D(projector: Union[TransformerMixin, BaseEstimator], parameters: dict,
                         X: np.ndarray, y: np.array = None, scaler=StandardScaler(),
                         save: str = None, **kwargs):
    """
    :param projector: Projections method used
    :param X: the data
    :param y: labels, used for coloring projected data points iff not ``None``
    :param scaler: scaler for normalising the data. Data will not be scaled iff ``None``

    :param save: path to save an image; do not save iff ``None``
    :param parameters: dict of name-tuple combinations used for projector-parameterisation
    :param kwargs: Parameter dict used for customizing the plots generated by downproject_2D
    :return:
    """
    _verify_input(3, projector, X, y, scaler, save)

    product = param_product(parameters)

    grid_cols = 2
    num_plots = len(product)

    if num_plots == 1:
        [projector.__setattr__(name, value) for name, value in product[0].items()]
        downproject_3D(projector, X, y, scaler, save, **kwargs)
        return

    # Prepare Projector
    projector.__setattr__('n_components', 3)

    fig = plt.figure(figsize=kwargs.get('gridsize', (10 * grid_cols, 10 * num_plots / grid_cols)))

    for idx, params in enumerate(product):
        title = _generate_plot_title(projector, params, scaler is not None)
        cur_ax = fig.add_subplot(int((num_plots + 1) / grid_cols), grid_cols, idx + 1,
                                 projection='3d')

        update_params(projector, params)
        X_tfd = _scale_and_project(projector, X, scaler)
        _, _ = _generate_figure_3D(projector, X_tfd, y, cur_ax, title=title, **kwargs)

    _handle_save(fig.number, save)


def _scale_and_project(projector: TransformerMixin, X: np.ndarray, scaler) -> np.ndarray:
    if scaler is not None:
        return projector.fit_transform(scaler.fit_transform(X))
    else:
        return projector.fit_transform(X)


def _generate_figure_2D(projector: TransformerMixin, X_tfd: np.ndarray, y: np.array = None,
                        axes=None, **kwargs) -> Tuple[int, plt.Figure]:
    color_vec = _generate_color_vector(y, kwargs.get('color_palette', 'husl'))

    if axes is None:
        fig = plt.figure(figsize=kwargs.get('figsize', (8, 6)), dpi=kwargs.get('dpi', 100))
        axes = fig.gca()

    axes.scatter(X_tfd[:, 0], X_tfd[:, 1], c=color_vec or 'k', marker=kwargs.get('marker', 'o'),
                 alpha=kwargs.get('alpha', 1.0))

    axes.set_title(kwargs.get('title', projector.__repr__()))
    axes.set_xlabel(kwargs.get('xlabel', 'Component 1'))
    axes.set_ylabel(kwargs.get('ylabel', 'Component 2'))

    if 'xticks' in kwargs:
        axes.set_xticks(kwargs.get('xticks'))
    if 'yticks' in kwargs:
        axes.set_yticks(kwargs.get('yticks'))

    figure = plt.gcf()
    return figure.number, figure


def _generate_figure_3D(projector: TransformerMixin, X_tfd: np.ndarray, y: np.array = None,
                        axes=None, **kwargs) -> Tuple[int, plt.Figure]:
    color_vec = _generate_color_vector(y, kwargs.get('color_palette', 'husl'))

    if axes is None:
        fig = plt.figure(figsize=kwargs.get('figsize', (8, 6)), dpi=kwargs.get('dpi', 100))
        axes = Axes3D(fig)

    axes.scatter(X_tfd[:, 0], X_tfd[:, 1], X_tfd[:, 2], c=color_vec or 'k',
                 marker=kwargs.get('marker', 'o'),
                 alpha=kwargs.get('alpha', 1.0))

    axes.set_title(kwargs.get('title', projector.__repr__()))
    axes.set_xlabel(kwargs.get('xlabel', 'Component 1'))
    axes.set_ylabel(kwargs.get('ylabel', 'Component 2'))
    axes.set_zlabel(kwargs.get('zlabel', 'Component 3'))

    if 'xticks' in kwargs:
        axes.set_xticks(kwargs.get('xticks'))
    if 'yticks' in kwargs:
        axes.set_yticks(kwargs.get('yticks'))
    if 'zticks' in kwargs:
        axes.set_zticks(kwargs.get('zticks'))

    figure = plt.gcf()
    return figure.number, figure


def _generate_plot_title(projector: TransformerMixin, parameters: dict, scaled) -> str:
    clazz = projector.__class__.__name__
    params = str(parameters)
    return ': '.join([clazz, "scaled" if scaled else "unscaled", params])


def _generate_color_vector(y: np.array, color_palette: str):
    if y is None:
        return None

    label_encoder = LabelEncoder()
    n_labels = len(np.unique(y))
    colors = sns.color_palette(color_palette, n_labels)
    return [colors[i - 1] for i in label_encoder.fit_transform(y).astype(int)]


def _verify_input(projection: int, projector: TransformerMixin, X: np.ndarray, y: np.array = None,
                  scaler=StandardScaler(), save: str = None):
    if projector is None:
        raise ValueError('Projector cannot be None')

    if np.size(X, 1) < projection:
        raise ValueError(
            f'Cannot perform a {projection}D down-projection with a {np.size(X, 1)}-column matrix X!')

    if len(y) != len(X):
        raise ValueError(f'Number of observations in X is not equal to the number of labels in y! '
                         f'{len(X)} != {len(y)}')

    if y.ndim != 1:
        raise ValueError(
            f'y can only be a 1-dimensional vector and not a matrix of dimension {y.ndim}!')

    if save:
        if not save.endswith(('.jpg', '.png')):
            raise ValueError(f'Only .jpg and .png supported as file extensions for saved plots.')

        save_dir = dirname(abspath(save))
        if not isdir(save_dir):
            raise ValueError(f'Directory: {save_dir} does not exist!')


def _handle_save(fig_num: int, save: str):
    if save:
        plt.savefig(save)
        plt.close(fig_num)
    else:
        plt.show()


def update_params(projector: TransformerMixin, params):
    for name, value in params.items():
        projector.__setattr__(name, value)
