> import re
> from collections import OrderedDict
  
> from graphene.types import Enum, Interface, List, NonNull, Scalar, String, Union
> from graphene.types.field import Field
> from graphene.types.objecttype import ObjectType
> from graphene.relay.connection import PageInfo, Connection, ConnectionOptions
  
> from .types.elastic_meta import Highlight
  
> __all__ = (
>     'ElasticsearchConnection',
> )
  
  
> class ElasticsearchConnectionOptions(ConnectionOptions):
>     node = None
  
  
> class ElasticsearchConnection(Connection):
>     class Meta:
>         abstract = True
  
>     @classmethod
>     def __init_subclass_with_meta__(cls, node=None, name=None, **options):
>         _meta = ElasticsearchConnectionOptions(cls)
          # import ipdb; ipdb.set_trace()
>         assert node, "You have to provide a node in {}.Meta".format(cls.__name__)
>         assert isinstance(node, NonNull) or issubclass(
>             node, (Scalar, Enum, ObjectType, Interface, Union, NonNull)
>         ), ('Received incompatible node "{}" for Connection {}.').format(
>             node, cls.__name__
>         )
  
>         base_name = re.sub("Connection$", "", name or cls.__name__) or node._meta.name
>         if not name:
>             name = "{}Connection".format(base_name)
  
>         edge_class = getattr(cls, "Edge", None)
>         _node = node
  
>         class EdgeBase(object):
>             node = Field(_node, description="The item at the end of the edge")
>             cursor = String(required=True, description="A cursor for use in pagination")
>             highlight = Highlight()
  
>         class EdgeMeta:
>             description = "A Relay edge containing a `{}` and its cursor.".format(
>                 base_name
>             )
  
>         edge_name = "{}Edge".format(base_name)
>         if edge_class:
!             edge_bases = (edge_class, EdgeBase, ObjectType)
>         else:
>             edge_bases = (EdgeBase, ObjectType)
  
>         edge = type(edge_name, edge_bases, {"Meta": EdgeMeta})
  
>         cls.Edge = edge
  
>         options["name"] = name
>         _meta.node = node
>         _meta.fields = OrderedDict(
>             [
>                 (
>                     "page_info",
>                     Field(
>                         PageInfo,
>                         name="pageInfo",
>                         required=True,
>                         description="Pagination data for this connection.",
>                     ),
>                 ),
>                 (
>                     "edges",
>                     Field(
>                         NonNull(List(edge)),
>                         description="Contains the nodes in this connection.",
>                     ),
>                 ),
>             ]
>         )
>         return super(Connection, cls).__init_subclass_with_meta__(
>             _meta=_meta, **options
>         )
